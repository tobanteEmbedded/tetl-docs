<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl::static_set&lt; Key, Capacity, Compare &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tetl
   &#160;<span id="projectnumber">0.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structetl_1_1static__set.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structetl_1_1static__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">etl::static_set&lt; Key, Capacity, Compare &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structetl_1_1static__set.html" title="static_set is an associative container that contains a sorted set of unique objects of type Key....">static_set</a> is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare.  
 <a href="structetl_1_1static__set.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aff79031c8bab2a0e66d4daa73b1f14ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> = typename <a class="el" href="structetl_1_1static__vector.html#add2b76e9faf0a39c1c4916446a1c0b66">storage_type::value_type</a></td></tr>
<tr class="separator:aff79031c8bab2a0e66d4daa73b1f14ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ca773e70e71c4e12b273dccccb55d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> = typename <a class="el" href="structetl_1_1static__vector.html#add2b76e9faf0a39c1c4916446a1c0b66">storage_type::value_type</a></td></tr>
<tr class="separator:a0f6ca773e70e71c4e12b273dccccb55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6ecd554915071945801c3990ea7201"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a> = <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a></td></tr>
<tr class="separator:aab6ecd554915071945801c3990ea7201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d747985144f7f59cc9a113637b449c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a3d747985144f7f59cc9a113637b449c3">difference_type</a> = <a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">ptrdiff_t</a></td></tr>
<tr class="separator:a3d747985144f7f59cc9a113637b449c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c246219cb070da3e5c473bb581f173"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a04c246219cb070da3e5c473bb581f173">key_compare</a> = Compare</td></tr>
<tr class="separator:a04c246219cb070da3e5c473bb581f173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b2c9e5c7ca1a5dba099162a6051410"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a31b2c9e5c7ca1a5dba099162a6051410">value_compare</a> = Compare</td></tr>
<tr class="separator:a31b2c9e5c7ca1a5dba099162a6051410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d45dbda073e8796d27c3228fd06ae7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ac6d45dbda073e8796d27c3228fd06ae7">reference</a> = <a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &amp;</td></tr>
<tr class="separator:ac6d45dbda073e8796d27c3228fd06ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6925e8776edf0262a5da0d4cb0e9f7b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a6925e8776edf0262a5da0d4cb0e9f7b3">const_reference</a> = <a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> const  &amp;</td></tr>
<tr class="separator:a6925e8776edf0262a5da0d4cb0e9f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf232283b038877fdcdab7c8dd2fb16"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#acbf232283b038877fdcdab7c8dd2fb16">pointer</a> = typename <a class="el" href="structetl_1_1static__vector.html#a5a02d4f9b32615b609a3b242582b607d">storage_type::pointer</a></td></tr>
<tr class="separator:acbf232283b038877fdcdab7c8dd2fb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475002803a709eb6702e46898b7972ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a475002803a709eb6702e46898b7972ba">const_pointer</a> = typename <a class="el" href="structetl_1_1static__vector.html#aef5032ee73612add9beaa687e954fc9a">storage_type::const_pointer</a></td></tr>
<tr class="separator:a475002803a709eb6702e46898b7972ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee05afb7bcd196762352083de3e905cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> = typename <a class="el" href="structetl_1_1static__vector.html#a5a02d4f9b32615b609a3b242582b607d">storage_type::pointer</a></td></tr>
<tr class="separator:aee05afb7bcd196762352083de3e905cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838222da9c69c81886ad2860cccb7b00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> = typename <a class="el" href="structetl_1_1static__vector.html#aef5032ee73612add9beaa687e954fc9a">storage_type::const_pointer</a></td></tr>
<tr class="separator:a838222da9c69c81886ad2860cccb7b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4d32661a140e193428e39a42b3f9ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a> = <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> &gt;</td></tr>
<tr class="separator:abb4d32661a140e193428e39a42b3f9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8a5a29cb228f5d09bd65ffa8e5da6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a> = <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> &gt;</td></tr>
<tr class="separator:a8d8a5a29cb228f5d09bd65ffa8e5da6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb3fc92fe2d972684a753d3200f1ed78"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#abb3fc92fe2d972684a753d3200f1ed78">static_set</a> ()=default</td></tr>
<tr class="memdesc:abb3fc92fe2d972684a753d3200f1ed78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty container.  <a href="structetl_1_1static__set.html#abb3fc92fe2d972684a753d3200f1ed78">More...</a><br /></td></tr>
<tr class="separator:abb3fc92fe2d972684a753d3200f1ed78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e91bd77da03139a0bfc2640dd02f5a"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , TETL_REQUIRES_(detail::InputIterator&lt; InputIt &gt;) &gt; </td></tr>
<tr class="memitem:a69e91bd77da03139a0bfc2640dd02f5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a69e91bd77da03139a0bfc2640dd02f5a">static_set</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a69e91bd77da03139a0bfc2640dd02f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, all but the first will be discarded.  <a href="structetl_1_1static__set.html#a69e91bd77da03139a0bfc2640dd02f5a">More...</a><br /></td></tr>
<tr class="separator:a69e91bd77da03139a0bfc2640dd02f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989d9498ab2571a428bafd8809eb7f45"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a989d9498ab2571a428bafd8809eb7f45">static_set</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> const &amp;other)=default</td></tr>
<tr class="separator:a989d9498ab2571a428bafd8809eb7f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87df9ce69aff3495acdf874c3b52816"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ad87df9ce69aff3495acdf874c3b52816">static_set</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;&amp;other) noexcept(noexcept(<a class="el" href="namespaceetl.html#a1b8df3814fc65f04932c2f0d09a56107">move</a>(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="structetl_1_1static__vector.html">storage_type</a> &gt;())))=default</td></tr>
<tr class="separator:ad87df9ce69aff3495acdf874c3b52816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905f23e207ac079a1968727ebda6a988"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a905f23e207ac079a1968727ebda6a988">operator=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> const &amp;other) -&gt; <a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;=default</td></tr>
<tr class="separator:a905f23e207ac079a1968727ebda6a988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0d5d8c652cc02c33fc264bc6b7c6dd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#add0d5d8c652cc02c33fc264bc6b7c6dd">operator=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;&amp;other) noexcept(noexcept(<a class="el" href="namespaceetl.html#a1b8df3814fc65f04932c2f0d09a56107">move</a>(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="structetl_1_1static__vector.html">storage_type</a> &gt;()))) -&gt; <a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;=default</td></tr>
<tr class="separator:add0d5d8c652cc02c33fc264bc6b7c6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa483c782bcd32df37c3f08782b431fe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#afa483c782bcd32df37c3f08782b431fe">begin</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:afa483c782bcd32df37c3f08782b431fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the set.  <a href="structetl_1_1static__set.html#afa483c782bcd32df37c3f08782b431fe">More...</a><br /></td></tr>
<tr class="separator:afa483c782bcd32df37c3f08782b431fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a55bb9aed80d33cd827ad570b74e8c0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a3a55bb9aed80d33cd827ad570b74e8c0">begin</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a3a55bb9aed80d33cd827ad570b74e8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the set.  <a href="structetl_1_1static__set.html#a3a55bb9aed80d33cd827ad570b74e8c0">More...</a><br /></td></tr>
<tr class="separator:a3a55bb9aed80d33cd827ad570b74e8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c640b72530cc3675973a85ebc90de60"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a6c640b72530cc3675973a85ebc90de60">cbegin</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a6c640b72530cc3675973a85ebc90de60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the set.  <a href="structetl_1_1static__set.html#a6c640b72530cc3675973a85ebc90de60">More...</a><br /></td></tr>
<tr class="separator:a6c640b72530cc3675973a85ebc90de60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e84d33eaf9c3c6151a9725229f7cb2c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a3e84d33eaf9c3c6151a9725229f7cb2c">end</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a3e84d33eaf9c3c6151a9725229f7cb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set.  <a href="structetl_1_1static__set.html#a3e84d33eaf9c3c6151a9725229f7cb2c">More...</a><br /></td></tr>
<tr class="separator:a3e84d33eaf9c3c6151a9725229f7cb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c74bb359a7678aab9af9306e468b1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ad9c74bb359a7678aab9af9306e468b1b">end</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:ad9c74bb359a7678aab9af9306e468b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set.  <a href="structetl_1_1static__set.html#ad9c74bb359a7678aab9af9306e468b1b">More...</a><br /></td></tr>
<tr class="separator:ad9c74bb359a7678aab9af9306e468b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce7fad93a11843893b0157604be19f2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a0ce7fad93a11843893b0157604be19f2">cend</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a0ce7fad93a11843893b0157604be19f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set.  <a href="structetl_1_1static__set.html#a0ce7fad93a11843893b0157604be19f2">More...</a><br /></td></tr>
<tr class="separator:a0ce7fad93a11843893b0157604be19f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc31f69f46693accacaff5c41761ded"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#abbc31f69f46693accacaff5c41761ded">rbegin</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a></td></tr>
<tr class="memdesc:abbc31f69f46693accacaff5c41761ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set.  <a href="structetl_1_1static__set.html#abbc31f69f46693accacaff5c41761ded">More...</a><br /></td></tr>
<tr class="separator:abbc31f69f46693accacaff5c41761ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2699787ed6faf0dbf8c74b2e7f069388"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a2699787ed6faf0dbf8c74b2e7f069388">rbegin</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a2699787ed6faf0dbf8c74b2e7f069388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set.  <a href="structetl_1_1static__set.html#a2699787ed6faf0dbf8c74b2e7f069388">More...</a><br /></td></tr>
<tr class="separator:a2699787ed6faf0dbf8c74b2e7f069388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c0ca215eb733d466773fbb8cb0e94b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a75c0ca215eb733d466773fbb8cb0e94b">crbegin</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a75c0ca215eb733d466773fbb8cb0e94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set.  <a href="structetl_1_1static__set.html#a75c0ca215eb733d466773fbb8cb0e94b">More...</a><br /></td></tr>
<tr class="separator:a75c0ca215eb733d466773fbb8cb0e94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaad75e3a3d9f0ce431ea90821a2263"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a1aaad75e3a3d9f0ce431ea90821a2263">rend</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a></td></tr>
<tr class="memdesc:a1aaad75e3a3d9f0ce431ea90821a2263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set.  <a href="structetl_1_1static__set.html#a1aaad75e3a3d9f0ce431ea90821a2263">More...</a><br /></td></tr>
<tr class="separator:a1aaad75e3a3d9f0ce431ea90821a2263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262048839dd74999a35072749fd54de9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a262048839dd74999a35072749fd54de9">rend</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a262048839dd74999a35072749fd54de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set.  <a href="structetl_1_1static__set.html#a262048839dd74999a35072749fd54de9">More...</a><br /></td></tr>
<tr class="separator:a262048839dd74999a35072749fd54de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751298981beec7d3639cfe4709b62e97"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a751298981beec7d3639cfe4709b62e97">crend</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a751298981beec7d3639cfe4709b62e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set.  <a href="structetl_1_1static__set.html#a751298981beec7d3639cfe4709b62e97">More...</a><br /></td></tr>
<tr class="separator:a751298981beec7d3639cfe4709b62e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb565b2a0b1b3b2168d0e461c01d15e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a1eb565b2a0b1b3b2168d0e461c01d15e">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a1eb565b2a0b1b3b2168d0e461c01d15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="structetl_1_1static__set.html#afa483c782bcd32df37c3f08782b431fe" title="Returns an iterator to the first element of the set.">begin()</a> == <a class="el" href="structetl_1_1static__set.html#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>.  <a href="structetl_1_1static__set.html#a1eb565b2a0b1b3b2168d0e461c01d15e">More...</a><br /></td></tr>
<tr class="separator:a1eb565b2a0b1b3b2168d0e461c01d15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5447b2bb33022fd78bd7f6c04eadacb6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a5447b2bb33022fd78bd7f6c04eadacb6">full</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a5447b2bb33022fd78bd7f6c04eadacb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container full, i.e. whether <a class="el" href="structetl_1_1static__set.html#aa43d950ad6ac18738488a5a67976f45e" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a> == Capacity.  <a href="structetl_1_1static__set.html#a5447b2bb33022fd78bd7f6c04eadacb6">More...</a><br /></td></tr>
<tr class="separator:a5447b2bb33022fd78bd7f6c04eadacb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43d950ad6ac18738488a5a67976f45e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#aa43d950ad6ac18738488a5a67976f45e">size</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:aa43d950ad6ac18738488a5a67976f45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. distance(<a class="el" href="structetl_1_1static__set.html#afa483c782bcd32df37c3f08782b431fe" title="Returns an iterator to the first element of the set.">begin()</a>, <a class="el" href="structetl_1_1static__set.html#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>).  <a href="structetl_1_1static__set.html#aa43d950ad6ac18738488a5a67976f45e">More...</a><br /></td></tr>
<tr class="separator:aa43d950ad6ac18738488a5a67976f45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67f246436b96d244f4b9bcd117bacfe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ab67f246436b96d244f4b9bcd117bacfe">max_size</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:ab67f246436b96d244f4b9bcd117bacfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold.  <a href="structetl_1_1static__set.html#ab67f246436b96d244f4b9bcd117bacfe">More...</a><br /></td></tr>
<tr class="separator:ab67f246436b96d244f4b9bcd117bacfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a4e54dd8e4ab7d6261e0289d259af"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a323a4e54dd8e4ab7d6261e0289d259af">clear</a> () noexcept -&gt; void</td></tr>
<tr class="memdesc:a323a4e54dd8e4ab7d6261e0289d259af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="structetl_1_1static__set.html#aa43d950ad6ac18738488a5a67976f45e" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a> returns zero.  <a href="structetl_1_1static__set.html#a323a4e54dd8e4ab7d6261e0289d259af">More...</a><br /></td></tr>
<tr class="separator:a323a4e54dd8e4ab7d6261e0289d259af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6a3dc7cad2305b76d43bf473d3227f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#acb6a3dc7cad2305b76d43bf473d3227f">insert</a> (<a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a>&lt; <a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &gt;, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>, bool &gt;&gt;</td></tr>
<tr class="memdesc:acb6a3dc7cad2305b76d43bf473d3227f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container, if the container doesn't already contain an element with an equivalent key.  <a href="structetl_1_1static__set.html#acb6a3dc7cad2305b76d43bf473d3227f">More...</a><br /></td></tr>
<tr class="separator:acb6a3dc7cad2305b76d43bf473d3227f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44f58948b48006f6a4c169c3c17104f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ac44f58948b48006f6a4c169c3c17104f">insert</a> (<a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> const &amp;value) -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a>&lt; <a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &gt;, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>, bool &gt;&gt;</td></tr>
<tr class="memdesc:ac44f58948b48006f6a4c169c3c17104f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container, if the container doesn't already contain an element with an equivalent key.  <a href="structetl_1_1static__set.html#ac44f58948b48006f6a4c169c3c17104f">More...</a><br /></td></tr>
<tr class="separator:ac44f58948b48006f6a4c169c3c17104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5deb63c47f2c1ecdf3fe3fa841dcd7"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , TETL_REQUIRES_(detail::InputIterator&lt; InputIter &gt;) &gt; </td></tr>
<tr class="memitem:a7f5deb63c47f2c1ecdf3fe3fa841dcd7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a7f5deb63c47f2c1ecdf3fe3fa841dcd7">insert</a> (InputIter first, InputIter last) noexcept(noexcept(insert(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &gt;()))) -&gt; void</td></tr>
<tr class="memdesc:a7f5deb63c47f2c1ecdf3fe3fa841dcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending LWG2844).  <a href="structetl_1_1static__set.html#a7f5deb63c47f2c1ecdf3fe3fa841dcd7">More...</a><br /></td></tr>
<tr class="separator:a7f5deb63c47f2c1ecdf3fe3fa841dcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad679a55634b467caad0ac6a239db5efd"><td class="memTemplParams" colspan="2">template&lt;typename... Args, TETL_REQUIRES_(is_copy_constructible_v&lt; key_type &gt;) &gt; </td></tr>
<tr class="memitem:ad679a55634b467caad0ac6a239db5efd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ad679a55634b467caad0ac6a239db5efd">emplace</a> (Args &amp;&amp;... args) noexcept(noexcept(<a class="el" href="structetl_1_1static__set.html#acb6a3dc7cad2305b76d43bf473d3227f">insert</a>(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &gt;()))) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>, bool &gt;</td></tr>
<tr class="memdesc:ad679a55634b467caad0ac6a239db5efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.  <a href="structetl_1_1static__set.html#ad679a55634b467caad0ac6a239db5efd">More...</a><br /></td></tr>
<tr class="separator:ad679a55634b467caad0ac6a239db5efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f2a9cfe69b9418622c9d3ad2fbe468"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a05f2a9cfe69b9418622c9d3ad2fbe468">erase</a> (<a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> pos) noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a05f2a9cfe69b9418622c9d3ad2fbe468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos.  <a href="structetl_1_1static__set.html#a05f2a9cfe69b9418622c9d3ad2fbe468">More...</a><br /></td></tr>
<tr class="separator:a05f2a9cfe69b9418622c9d3ad2fbe468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3667df326062554b3e36c8f7825e297"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ad3667df326062554b3e36c8f7825e297">erase</a> (<a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> first, <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> last) -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:ad3667df326062554b3e36c8f7825e297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first; last), which must be a valid range in *this.  <a href="structetl_1_1static__set.html#ad3667df326062554b3e36c8f7825e297">More...</a><br /></td></tr>
<tr class="separator:ad3667df326062554b3e36c8f7825e297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3620b27ba365e5995b9a4b832313eb82"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a3620b27ba365e5995b9a4b832313eb82">erase</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:a3620b27ba365e5995b9a4b832313eb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <a href="structetl_1_1static__set.html#a3620b27ba365e5995b9a4b832313eb82">More...</a><br /></td></tr>
<tr class="separator:a3620b27ba365e5995b9a4b832313eb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5274597109dc4339926ad9541bd989"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a0b5274597109dc4339926ad9541bd989">swap</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;other) noexcept(<a class="el" href="namespaceetl.html#a4fe0a7655d7b161139e48f8eb34838ac">is_nothrow_swappable_v</a>&lt; <a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &gt;) -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#ae630f4cbcf30c3c7912d50547711e86d">is_assignable_v</a>&lt; <a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &amp;, <a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &amp;&amp; &gt;, void &gt;</td></tr>
<tr class="memdesc:a0b5274597109dc4339926ad9541bd989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other.  <a href="structetl_1_1static__set.html#a0b5274597109dc4339926ad9541bd989">More...</a><br /></td></tr>
<tr class="separator:a0b5274597109dc4339926ad9541bd989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c49fa4411effa2f4192e4dc6e2a8439"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a9c49fa4411effa2f4192e4dc6e2a8439">count</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:a9c49fa4411effa2f4192e4dc6e2a8439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument, which is either 1 or 0 since this container does not allow duplicates.  <a href="structetl_1_1static__set.html#a9c49fa4411effa2f4192e4dc6e2a8439">More...</a><br /></td></tr>
<tr class="separator:a9c49fa4411effa2f4192e4dc6e2a8439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5d02d453c6db0d287ee65941a845f0"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:a5b5d02d453c6db0d287ee65941a845f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a5b5d02d453c6db0d287ee65941a845f0">count</a> (K const &amp;x) const -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:a5b5d02d453c6db0d287ee65941a845f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the value x.  <a href="structetl_1_1static__set.html#a5b5d02d453c6db0d287ee65941a845f0">More...</a><br /></td></tr>
<tr class="separator:a5b5d02d453c6db0d287ee65941a845f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0f5a4d2bbf9d8e3c02bb4f28999863"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a8e0f5a4d2bbf9d8e3c02bb4f28999863">find</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a8e0f5a4d2bbf9d8e3c02bb4f28999863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="structetl_1_1static__set.html#a8e0f5a4d2bbf9d8e3c02bb4f28999863">More...</a><br /></td></tr>
<tr class="separator:a8e0f5a4d2bbf9d8e3c02bb4f28999863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe34badb2fbda17da8512f03efcab59e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#afe34badb2fbda17da8512f03efcab59e">find</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:afe34badb2fbda17da8512f03efcab59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <a href="structetl_1_1static__set.html#afe34badb2fbda17da8512f03efcab59e">More...</a><br /></td></tr>
<tr class="separator:afe34badb2fbda17da8512f03efcab59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134342287b220f8af15eadc7252704d7"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:a134342287b220f8af15eadc7252704d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a134342287b220f8af15eadc7252704d7">find</a> (K const &amp;x) -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a134342287b220f8af15eadc7252704d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value x.  <a href="structetl_1_1static__set.html#a134342287b220f8af15eadc7252704d7">More...</a><br /></td></tr>
<tr class="separator:a134342287b220f8af15eadc7252704d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad34492fab02757b9b44c42733f45a6e"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:aad34492fab02757b9b44c42733f45a6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#aad34492fab02757b9b44c42733f45a6e">find</a> (K const &amp;x) const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:aad34492fab02757b9b44c42733f45a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value x.  <a href="structetl_1_1static__set.html#aad34492fab02757b9b44c42733f45a6e">More...</a><br /></td></tr>
<tr class="separator:aad34492fab02757b9b44c42733f45a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265586ce4755fc25bb39febca9aa7149"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a265586ce4755fc25bb39febca9aa7149">contains</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a265586ce4755fc25bb39febca9aa7149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equivalent to key in the container.  <a href="structetl_1_1static__set.html#a265586ce4755fc25bb39febca9aa7149">More...</a><br /></td></tr>
<tr class="separator:a265586ce4755fc25bb39febca9aa7149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca7178e7042be4ca8f1704b5000452f"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:a4ca7178e7042be4ca8f1704b5000452f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a4ca7178e7042be4ca8f1704b5000452f">contains</a> (K const &amp;x) const -&gt; bool</td></tr>
<tr class="memdesc:a4ca7178e7042be4ca8f1704b5000452f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value x.  <a href="structetl_1_1static__set.html#a4ca7178e7042be4ca8f1704b5000452f">More...</a><br /></td></tr>
<tr class="separator:a4ca7178e7042be4ca8f1704b5000452f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9e26bacddca06feddd58643c5dfee"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee">lower_bound</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a7ee9e26bacddca06feddd58643c5dfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee">More...</a><br /></td></tr>
<tr class="separator:a7ee9e26bacddca06feddd58643c5dfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978395b6dec16b02c05eb2cd40ade8e7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a978395b6dec16b02c05eb2cd40ade8e7">lower_bound</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a978395b6dec16b02c05eb2cd40ade8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="structetl_1_1static__set.html#a978395b6dec16b02c05eb2cd40ade8e7">More...</a><br /></td></tr>
<tr class="separator:a978395b6dec16b02c05eb2cd40ade8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01b7af48258fc60ddb5036a7ba79a41"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:ae01b7af48258fc60ddb5036a7ba79a41"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ae01b7af48258fc60ddb5036a7ba79a41">lower_bound</a> (K const &amp;key) -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:ae01b7af48258fc60ddb5036a7ba79a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="structetl_1_1static__set.html#ae01b7af48258fc60ddb5036a7ba79a41">More...</a><br /></td></tr>
<tr class="separator:ae01b7af48258fc60ddb5036a7ba79a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1aa212da8e6429a4ecef303f50dd12"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:a6e1aa212da8e6429a4ecef303f50dd12"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a6e1aa212da8e6429a4ecef303f50dd12">lower_bound</a> (K const &amp;key) const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a6e1aa212da8e6429a4ecef303f50dd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <a href="structetl_1_1static__set.html#a6e1aa212da8e6429a4ecef303f50dd12">More...</a><br /></td></tr>
<tr class="separator:a6e1aa212da8e6429a4ecef303f50dd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81a99ca82c2a5eaf1b22997f06874b1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1">upper_bound</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:ae81a99ca82c2a5eaf1b22997f06874b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1">More...</a><br /></td></tr>
<tr class="separator:ae81a99ca82c2a5eaf1b22997f06874b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e9e8291c11bb963ad1279e3d786514"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ae9e9e8291c11bb963ad1279e3d786514">upper_bound</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:ae9e9e8291c11bb963ad1279e3d786514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="structetl_1_1static__set.html#ae9e9e8291c11bb963ad1279e3d786514">More...</a><br /></td></tr>
<tr class="separator:ae9e9e8291c11bb963ad1279e3d786514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c37d24274adc7b41d2c7f0d70bfc8de"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:a2c37d24274adc7b41d2c7f0d70bfc8de"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a2c37d24274adc7b41d2c7f0d70bfc8de">upper_bound</a> (K const &amp;key) -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a2c37d24274adc7b41d2c7f0d70bfc8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="structetl_1_1static__set.html#a2c37d24274adc7b41d2c7f0d70bfc8de">More...</a><br /></td></tr>
<tr class="separator:a2c37d24274adc7b41d2c7f0d70bfc8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be7b7b5470f9351bf437004970a69e6"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:a5be7b7b5470f9351bf437004970a69e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a5be7b7b5470f9351bf437004970a69e6">upper_bound</a> (K const &amp;key) const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a5be7b7b5470f9351bf437004970a69e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <a href="structetl_1_1static__set.html#a5be7b7b5470f9351bf437004970a69e6">More...</a><br /></td></tr>
<tr class="separator:a5be7b7b5470f9351bf437004970a69e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ab8b97c95f0798b4dc08f20721a1a3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ac7ab8b97c95f0798b4dc08f20721a1a3">equal_range</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:ac7ab8b97c95f0798b4dc08f20721a1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.  <a href="structetl_1_1static__set.html#ac7ab8b97c95f0798b4dc08f20721a1a3">More...</a><br /></td></tr>
<tr class="separator:ac7ab8b97c95f0798b4dc08f20721a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3874cfe5b7783a59b6504de83e9f1394"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a3874cfe5b7783a59b6504de83e9f1394">equal_range</a> (<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;key) const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a3874cfe5b7783a59b6504de83e9f1394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.  <a href="structetl_1_1static__set.html#a3874cfe5b7783a59b6504de83e9f1394">More...</a><br /></td></tr>
<tr class="separator:a3874cfe5b7783a59b6504de83e9f1394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa896d91a51fe258f5c267b5d56b6493a"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:aa896d91a51fe258f5c267b5d56b6493a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#aa896d91a51fe258f5c267b5d56b6493a">equal_range</a> (K const &amp;key) -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:aa896d91a51fe258f5c267b5d56b6493a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.  <a href="structetl_1_1static__set.html#aa896d91a51fe258f5c267b5d56b6493a">More...</a><br /></td></tr>
<tr class="separator:aa896d91a51fe258f5c267b5d56b6493a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582511afdb54f538bc9b046c6e352282"><td class="memTemplParams" colspan="2">template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </td></tr>
<tr class="memitem:a582511afdb54f538bc9b046c6e352282"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a582511afdb54f538bc9b046c6e352282">equal_range</a> (K const &amp;key) const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a582511afdb54f538bc9b046c6e352282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.  <a href="structetl_1_1static__set.html#a582511afdb54f538bc9b046c6e352282">More...</a><br /></td></tr>
<tr class="separator:a582511afdb54f538bc9b046c6e352282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06692f007a748a7713515e40afcce7a2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#a06692f007a748a7713515e40afcce7a2">key_comp</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a04c246219cb070da3e5c473bb581f173">key_compare</a></td></tr>
<tr class="memdesc:a06692f007a748a7713515e40afcce7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function object that compares the keys, which is a copy of this container's constructor argument comp. It is the same as value_comp.  <a href="structetl_1_1static__set.html#a06692f007a748a7713515e40afcce7a2">More...</a><br /></td></tr>
<tr class="separator:a06692f007a748a7713515e40afcce7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02207a72f7d4bc72b216525383cb311"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html#ac02207a72f7d4bc72b216525383cb311">value_comp</a> () const noexcept -&gt; <a class="el" href="structetl_1_1static__set.html#a31b2c9e5c7ca1a5dba099162a6051410">value_compare</a></td></tr>
<tr class="memdesc:ac02207a72f7d4bc72b216525383cb311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function object that compares the values. It is the same as key_comp.  <a href="structetl_1_1static__set.html#ac02207a72f7d4bc72b216525383cb311">More...</a><br /></td></tr>
<tr class="separator:ac02207a72f7d4bc72b216525383cb311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, size_t Capacity, typename Compare = less&lt;Key&gt;&gt;<br />
struct etl::static_set&lt; Key, Capacity, Compare &gt;</h3>

<p><a class="el" href="structetl_1_1static__set.html" title="static_set is an associative container that contains a sorted set of unique objects of type Key....">static_set</a> is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="set_8cpp-example.html#_a2">set.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aff79031c8bab2a0e66d4daa73b1f14ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff79031c8bab2a0e66d4daa73b1f14ee">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> =  typename <a class="el" href="structetl_1_1static__vector.html#add2b76e9faf0a39c1c4916446a1c0b66">storage_type::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f6ca773e70e71c4e12b273dccccb55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ca773e70e71c4e12b273dccccb55d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> =  typename <a class="el" href="structetl_1_1static__vector.html#add2b76e9faf0a39c1c4916446a1c0b66">storage_type::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab6ecd554915071945801c3990ea7201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6ecd554915071945801c3990ea7201">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a> =  <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d747985144f7f59cc9a113637b449c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d747985144f7f59cc9a113637b449c3">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#a3d747985144f7f59cc9a113637b449c3">difference_type</a> =  <a class="el" href="namespaceetl.html#a955e0d5a5e84e9e394bf38a95c8ce380">ptrdiff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04c246219cb070da3e5c473bb581f173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c246219cb070da3e5c473bb581f173">&#9670;&nbsp;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#a04c246219cb070da3e5c473bb581f173">key_compare</a> =  Compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31b2c9e5c7ca1a5dba099162a6051410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b2c9e5c7ca1a5dba099162a6051410">&#9670;&nbsp;</a></span>value_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#a31b2c9e5c7ca1a5dba099162a6051410">value_compare</a> =  Compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6d45dbda073e8796d27c3228fd06ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d45dbda073e8796d27c3228fd06ae7">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#ac6d45dbda073e8796d27c3228fd06ae7">reference</a> =  <a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6925e8776edf0262a5da0d4cb0e9f7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6925e8776edf0262a5da0d4cb0e9f7b3">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#a6925e8776edf0262a5da0d4cb0e9f7b3">const_reference</a> =  <a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> const&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbf232283b038877fdcdab7c8dd2fb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf232283b038877fdcdab7c8dd2fb16">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#acbf232283b038877fdcdab7c8dd2fb16">pointer</a> =  typename <a class="el" href="structetl_1_1static__vector.html#a5a02d4f9b32615b609a3b242582b607d">storage_type::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a475002803a709eb6702e46898b7972ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475002803a709eb6702e46898b7972ba">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#a475002803a709eb6702e46898b7972ba">const_pointer</a> =  typename <a class="el" href="structetl_1_1static__vector.html#aef5032ee73612add9beaa687e954fc9a">storage_type::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee05afb7bcd196762352083de3e905cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee05afb7bcd196762352083de3e905cd">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> =  typename <a class="el" href="structetl_1_1static__vector.html#a5a02d4f9b32615b609a3b242582b607d">storage_type::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a838222da9c69c81886ad2860cccb7b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838222da9c69c81886ad2860cccb7b00">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> =  typename <a class="el" href="structetl_1_1static__vector.html#aef5032ee73612add9beaa687e954fc9a">storage_type::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb4d32661a140e193428e39a42b3f9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4d32661a140e193428e39a42b3f9ee">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a> =  <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d8a5a29cb228f5d09bd65ffa8e5da6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a> =  <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb3fc92fe2d972684a753d3200f1ed78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3fc92fe2d972684a753d3200f1ed78">&#9670;&nbsp;</a></span>static_set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html">static_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty container. </p>

</div>
</div>
<a id="a69e91bd77da03139a0bfc2640dd02f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e91bd77da03139a0bfc2640dd02f5a">&#9670;&nbsp;</a></span>static_set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , TETL_REQUIRES_(detail::InputIterator&lt; InputIt &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html">static_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, all but the first will be discarded. </p>

</div>
</div>
<a id="a989d9498ab2571a428bafd8809eb7f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989d9498ab2571a428bafd8809eb7f45">&#9670;&nbsp;</a></span>static_set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html">static_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad87df9ce69aff3495acdf874c3b52816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87df9ce69aff3495acdf874c3b52816">&#9670;&nbsp;</a></span>static_set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::<a class="el" href="structetl_1_1static__set.html">static_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a905f23e207ac079a1968727ebda6a988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905f23e207ac079a1968727ebda6a988">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add0d5d8c652cc02c33fc264bc6b7c6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0d5d8c652cc02c33fc264bc6b7c6dd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa483c782bcd32df37c3f08782b431fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa483c782bcd32df37c3f08782b431fe">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the set. </p>

</div>
</div>
<a id="a3a55bb9aed80d33cd827ad570b74e8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a55bb9aed80d33cd827ad570b74e8c0">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the set. </p>

</div>
</div>
<a id="a6c640b72530cc3675973a85ebc90de60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c640b72530cc3675973a85ebc90de60">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the set. </p>

</div>
</div>
<a id="a3e84d33eaf9c3c6151a9725229f7cb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e84d33eaf9c3c6151a9725229f7cb2c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the set. </p>

</div>
</div>
<a id="ad9c74bb359a7678aab9af9306e468b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c74bb359a7678aab9af9306e468b1b">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the set. </p>

</div>
</div>
<a id="a0ce7fad93a11843893b0157604be19f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce7fad93a11843893b0157604be19f2">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the set. </p>

</div>
</div>
<a id="abbc31f69f46693accacaff5c41761ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc31f69f46693accacaff5c41761ded">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set. </p>

</div>
</div>
<a id="a2699787ed6faf0dbf8c74b2e7f069388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2699787ed6faf0dbf8c74b2e7f069388">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set. </p>

</div>
</div>
<a id="a75c0ca215eb733d466773fbb8cb0e94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c0ca215eb733d466773fbb8cb0e94b">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set. </p>

</div>
</div>
<a id="a1aaad75e3a3d9f0ce431ea90821a2263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaad75e3a3d9f0ce431ea90821a2263">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set. </p>

</div>
</div>
<a id="a262048839dd74999a35072749fd54de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262048839dd74999a35072749fd54de9">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set. </p>

</div>
</div>
<a id="a751298981beec7d3639cfe4709b62e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751298981beec7d3639cfe4709b62e97">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set. </p>

</div>
</div>
<a id="a1eb565b2a0b1b3b2168d0e461c01d15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb565b2a0b1b3b2168d0e461c01d15e">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <a class="el" href="structetl_1_1static__set.html#afa483c782bcd32df37c3f08782b431fe" title="Returns an iterator to the first element of the set.">begin()</a> == <a class="el" href="structetl_1_1static__set.html#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>. </p>

</div>
</div>
<a id="a5447b2bb33022fd78bd7f6c04eadacb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5447b2bb33022fd78bd7f6c04eadacb6">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container full, i.e. whether <a class="el" href="structetl_1_1static__set.html#aa43d950ad6ac18738488a5a67976f45e" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a> == Capacity. </p>

</div>
</div>
<a id="aa43d950ad6ac18738488a5a67976f45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43d950ad6ac18738488a5a67976f45e">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. distance(<a class="el" href="structetl_1_1static__set.html#afa483c782bcd32df37c3f08782b431fe" title="Returns an iterator to the first element of the set.">begin()</a>, <a class="el" href="structetl_1_1static__set.html#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>). </p>

</div>
</div>
<a id="ab67f246436b96d244f4b9bcd117bacfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67f246436b96d244f4b9bcd117bacfe">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold. </p>

</div>
</div>
<a id="a323a4e54dd8e4ab7d6261e0289d259af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323a4e54dd8e4ab7d6261e0289d259af">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. After this call, <a class="el" href="structetl_1_1static__set.html#aa43d950ad6ac18738488a5a67976f45e" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a> returns zero. </p>

</div>
</div>
<a id="acb6a3dc7cad2305b76d43bf473d3227f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6a3dc7cad2305b76d43bf473d3227f">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a>&lt;<a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a>&gt;, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>, bool&gt;&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="set_8cpp-example.html#a3">set.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac44f58948b48006f6a4c169c3c17104f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44f58948b48006f6a4c169c3c17104f">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a>&lt;<a class="el" href="structetl_1_1static__set.html#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a>&gt;, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>, bool&gt;&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>noexcept(noexcept(base_type::insert(move(declval&lt;key_type&gt;())))) breaks GCC 9.3 Ubuntu Focal build </dd></dl>

</div>
</div>
<a id="a7f5deb63c47f2c1ecdf3fe3fa841dcd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5deb63c47f2c1ecdf3fe3fa841dcd7">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIter , TETL_REQUIRES_(detail::InputIterator&lt; InputIter &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending LWG2844). </p>

</div>
</div>
<a id="ad679a55634b467caad0ac6a239db5efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad679a55634b467caad0ac6a239db5efd">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, TETL_REQUIRES_(is_copy_constructible_v&lt; key_type &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>, bool&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. </p>

</div>
</div>
<a id="a05f2a9cfe69b9418622c9d3ad2fbe468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f2a9cfe69b9418622c9d3ad2fbe468">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at pos. </p>
<p><a href="https://en.cppreference.com/w/cpp/container/set/erase">https://en.cppreference.com/w/cpp/container/set/erase</a></p>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="ad3667df326062554b3e36c8f7825e297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3667df326062554b3e36c8f7825e297">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first; last), which must be a valid range in *this. </p>
<p><a href="https://en.cppreference.com/w/cpp/container/set/erase">https://en.cppreference.com/w/cpp/container/set/erase</a></p>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="a3620b27ba365e5995b9a4b832313eb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3620b27ba365e5995b9a4b832313eb82">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<p><a href="https://en.cppreference.com/w/cpp/container/set/erase">https://en.cppreference.com/w/cpp/container/set/erase</a></p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed. </dd></dl>

</div>
</div>
<a id="a0b5274597109dc4339926ad9541bd989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5274597109dc4339926ad9541bd989">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; Key, Capacity, Compare &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#ae630f4cbcf30c3c7912d50547711e86d">is_assignable_v</a>&lt;<a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a>&amp;, <a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a>&amp;&amp;&gt;, void&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. </p>

</div>
</div>
<a id="a9c49fa4411effa2f4192e4dc6e2a8439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c49fa4411effa2f4192e4dc6e2a8439">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the specified argument, which is either 1 or 0 since this container does not allow duplicates. </p>

</div>
</div>
<a id="a5b5d02d453c6db0d287ee65941a845f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5d02d453c6db0d287ee65941a845f0">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::count </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#aab6ecd554915071945801c3990ea7201">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the value x. </p>

</div>
</div>
<a id="a8e0f5a4d2bbf9d8e3c02bb4f28999863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0f5a4d2bbf9d8e3c02bb4f28999863">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end (see <a class="el" href="structetl_1_1static__set.html#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>) iterator is returned. </dd></dl>

</div>
</div>
<a id="afe34badb2fbda17da8512f03efcab59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe34badb2fbda17da8512f03efcab59e">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end (see <a class="el" href="structetl_1_1static__set.html#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>) iterator is returned. </dd></dl>

</div>
</div>
<a id="a134342287b220f8af15eadc7252704d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134342287b220f8af15eadc7252704d7">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value x. </p>

</div>
</div>
<a id="aad34492fab02757b9b44c42733f45a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad34492fab02757b9b44c42733f45a6e">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value x. </p>

</div>
</div>
<a id="a265586ce4755fc25bb39febca9aa7149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265586ce4755fc25bb39febca9aa7149">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key equivalent to key in the container. </p>

</div>
</div>
<a id="a4ca7178e7042be4ca8f1704b5000452f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca7178e7042be4ca8f1704b5000452f">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key that compares equivalent to the value x. </p>

</div>
</div>
<a id="a7ee9e26bacddca06feddd58643c5dfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee9e26bacddca06feddd58643c5dfee">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="a978395b6dec16b02c05eb2cd40ade8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978395b6dec16b02c05eb2cd40ade8e7">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="ae01b7af48258fc60ddb5036a7ba79a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01b7af48258fc60ddb5036a7ba79a41">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="a6e1aa212da8e6429a4ecef303f50dd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1aa212da8e6429a4ecef303f50dd12">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="ae81a99ca82c2a5eaf1b22997f06874b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81a99ca82c2a5eaf1b22997f06874b1">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="ae9e9e8291c11bb963ad1279e3d786514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e9e8291c11bb963ad1279e3d786514">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="a2c37d24274adc7b41d2c7f0d70bfc8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c37d24274adc7b41d2c7f0d70bfc8de">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="a5be7b7b5470f9351bf437004970a69e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be7b7b5470f9351bf437004970a69e6">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="ac7ab8b97c95f0798b4dc08f20721a1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ab8b97c95f0798b4dc08f20721a1a3">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>. </p>

</div>
</div>
<a id="a3874cfe5b7783a59b6504de83e9f1394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3874cfe5b7783a59b6504de83e9f1394">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>. </p>

</div>
</div>
<a id="aa896d91a51fe258f5c267b5d56b6493a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa896d91a51fe258f5c267b5d56b6493a">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__set.html#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>. </p>

</div>
</div>
<a id="a582511afdb54f538bc9b046c6e352282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582511afdb54f538bc9b046c6e352282">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K , TETL_REQUIRES_(detail::is_transparent_v&lt; key_compare &gt;) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="structetl_1_1static__set.html#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="structetl_1_1static__set.html#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>. </p>

</div>
</div>
<a id="a06692f007a748a7713515e40afcce7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06692f007a748a7713515e40afcce7a2">&#9670;&nbsp;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a04c246219cb070da3e5c473bb581f173">key_compare</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function object that compares the keys, which is a copy of this container's constructor argument comp. It is the same as value_comp. </p>
<dl class="section return"><dt>Returns</dt><dd>The key comparison function object. </dd></dl>

</div>
</div>
<a id="ac02207a72f7d4bc72b216525383cb311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02207a72f7d4bc72b216525383cb311">&#9670;&nbsp;</a></span>value_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , size_t Capacity, typename Compare  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; Key, Capacity, Compare &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__set.html#a31b2c9e5c7ca1a5dba099162a6051410">value_compare</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function object that compares the values. It is the same as key_comp. </p>
<dl class="section return"><dt>Returns</dt><dd>The value comparison function object. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>etl/_set/<a class="el" href="static__set_8hpp_source.html">static_set.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="structetl_1_1static__set.html">static_set</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
