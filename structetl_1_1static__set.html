<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl::static_set&lt; Key, Capacity, Compare &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structetl_1_1static__set.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structetl_1_1static__set-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">etl::static_set&lt; Key, Capacity, Compare &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structetl_1_1static__set.html" title="static_set is an associative container that contains a sorted set of unique objects of type Key....">static_set</a> is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="static__set_8hpp_source.html">static_set.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aff79031c8bab2a0e66d4daa73b1f14ee" id="r_aff79031c8bab2a0e66d4daa73b1f14ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#add2b76e9faf0a39c1c4916446a1c0b66">storage_type::value_type</a></td></tr>
<tr class="separator:aff79031c8bab2a0e66d4daa73b1f14ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ca773e70e71c4e12b273dccccb55d" id="r_a0f6ca773e70e71c4e12b273dccccb55d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#add2b76e9faf0a39c1c4916446a1c0b66">storage_type::value_type</a></td></tr>
<tr class="separator:a0f6ca773e70e71c4e12b273dccccb55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6ecd554915071945801c3990ea7201" id="r_aab6ecd554915071945801c3990ea7201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a> = <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a></td></tr>
<tr class="separator:aab6ecd554915071945801c3990ea7201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d747985144f7f59cc9a113637b449c3" id="r_a3d747985144f7f59cc9a113637b449c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d747985144f7f59cc9a113637b449c3">difference_type</a> = <a class="el" href="namespaceetl.html#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a></td></tr>
<tr class="separator:a3d747985144f7f59cc9a113637b449c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c246219cb070da3e5c473bb581f173" id="r_a04c246219cb070da3e5c473bb581f173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a> = <a class="el" href="structetl_1_1static__vector.html">Compare</a></td></tr>
<tr class="separator:a04c246219cb070da3e5c473bb581f173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b2c9e5c7ca1a5dba099162a6051410" id="r_a31b2c9e5c7ca1a5dba099162a6051410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31b2c9e5c7ca1a5dba099162a6051410">value_compare</a> = <a class="el" href="structetl_1_1static__vector.html">Compare</a></td></tr>
<tr class="separator:a31b2c9e5c7ca1a5dba099162a6051410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d45dbda073e8796d27c3228fd06ae7" id="r_ac6d45dbda073e8796d27c3228fd06ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6d45dbda073e8796d27c3228fd06ae7">reference</a> = <a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a>&amp;</td></tr>
<tr class="separator:ac6d45dbda073e8796d27c3228fd06ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6925e8776edf0262a5da0d4cb0e9f7b3" id="r_a6925e8776edf0262a5da0d4cb0e9f7b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6925e8776edf0262a5da0d4cb0e9f7b3">const_reference</a> = <a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;</td></tr>
<tr class="separator:a6925e8776edf0262a5da0d4cb0e9f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf232283b038877fdcdab7c8dd2fb16" id="r_acbf232283b038877fdcdab7c8dd2fb16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbf232283b038877fdcdab7c8dd2fb16">pointer</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#a5a02d4f9b32615b609a3b242582b607d">storage_type::pointer</a></td></tr>
<tr class="separator:acbf232283b038877fdcdab7c8dd2fb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475002803a709eb6702e46898b7972ba" id="r_a475002803a709eb6702e46898b7972ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a475002803a709eb6702e46898b7972ba">const_pointer</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#aef5032ee73612add9beaa687e954fc9a">storage_type::const_pointer</a></td></tr>
<tr class="separator:a475002803a709eb6702e46898b7972ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee05afb7bcd196762352083de3e905cd" id="r_aee05afb7bcd196762352083de3e905cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#a5a02d4f9b32615b609a3b242582b607d">storage_type::pointer</a></td></tr>
<tr class="separator:aee05afb7bcd196762352083de3e905cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838222da9c69c81886ad2860cccb7b00" id="r_a838222da9c69c81886ad2860cccb7b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#aef5032ee73612add9beaa687e954fc9a">storage_type::const_pointer</a></td></tr>
<tr class="separator:a838222da9c69c81886ad2860cccb7b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4d32661a140e193428e39a42b3f9ee" id="r_abb4d32661a140e193428e39a42b3f9ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a> = <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>&gt;</td></tr>
<tr class="separator:abb4d32661a140e193428e39a42b3f9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8a5a29cb228f5d09bd65ffa8e5da6d" id="r_a8d8a5a29cb228f5d09bd65ffa8e5da6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a> = <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>&gt;</td></tr>
<tr class="separator:a8d8a5a29cb228f5d09bd65ffa8e5da6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb3fc92fe2d972684a753d3200f1ed78" id="r_abb3fc92fe2d972684a753d3200f1ed78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb3fc92fe2d972684a753d3200f1ed78">static_set</a> ()=<a class="el" href="structetl_1_1static__vector.html">default</a></td></tr>
<tr class="memdesc:abb3fc92fe2d972684a753d3200f1ed78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty container.  <br /></td></tr>
<tr class="separator:abb3fc92fe2d972684a753d3200f1ed78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c644dad9c0f860bb47662a77102783" id="r_a98c644dad9c0f860bb47662a77102783"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt; <br />
requires (detail::InputIterator&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt</a>&gt;)</td></tr>
<tr class="memitem:a98c644dad9c0f860bb47662a77102783"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a98c644dad9c0f860bb47662a77102783">static_set</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last)</td></tr>
<tr class="memdesc:a98c644dad9c0f860bb47662a77102783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, all but the first will be discarded.  <br /></td></tr>
<tr class="separator:a98c644dad9c0f860bb47662a77102783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989d9498ab2571a428bafd8809eb7f45" id="r_a989d9498ab2571a428bafd8809eb7f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a989d9498ab2571a428bafd8809eb7f45">static_set</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">other</a>)=<a class="el" href="structetl_1_1static__vector.html">default</a></td></tr>
<tr class="separator:a989d9498ab2571a428bafd8809eb7f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7620e086c4afe58ebfc0d8a6b48902cb" id="r_a7620e086c4afe58ebfc0d8a6b48902cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7620e086c4afe58ebfc0d8a6b48902cb">static_set</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">other</a>) noexcept(noexcept(<a class="el" href="__utility_2move_8hpp.html#afb338536d7767b0fd9392f796b908073">TETL_MOVE</a>(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="structetl_1_1static__vector.html">storage_type</a> &gt;())))=<a class="el" href="structetl_1_1static__vector.html">default</a></td></tr>
<tr class="separator:a7620e086c4afe58ebfc0d8a6b48902cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905f23e207ac079a1968727ebda6a988" id="r_a905f23e207ac079a1968727ebda6a988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a905f23e207ac079a1968727ebda6a988">operator=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">other</a>) -&gt; <a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;=<a class="el" href="structetl_1_1static__vector.html">default</a></td></tr>
<tr class="separator:a905f23e207ac079a1968727ebda6a988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94be4d154634f3fb43f7752fd6edb50" id="r_ac94be4d154634f3fb43f7752fd6edb50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac94be4d154634f3fb43f7752fd6edb50">operator=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">other</a>) noexcept(noexcept(<a class="el" href="__utility_2move_8hpp.html#afb338536d7767b0fd9392f796b908073">TETL_MOVE</a>(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="structetl_1_1static__vector.html">storage_type</a> &gt;()))) -&gt; <a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;=<a class="el" href="structetl_1_1static__vector.html">default</a></td></tr>
<tr class="separator:ac94be4d154634f3fb43f7752fd6edb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa483c782bcd32df37c3f08782b431fe" id="r_afa483c782bcd32df37c3f08782b431fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa483c782bcd32df37c3f08782b431fe">begin</a> () noexcept -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:afa483c782bcd32df37c3f08782b431fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the set.  <br /></td></tr>
<tr class="separator:afa483c782bcd32df37c3f08782b431fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a55bb9aed80d33cd827ad570b74e8c0" id="r_a3a55bb9aed80d33cd827ad570b74e8c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a55bb9aed80d33cd827ad570b74e8c0">begin</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a3a55bb9aed80d33cd827ad570b74e8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the set.  <br /></td></tr>
<tr class="separator:a3a55bb9aed80d33cd827ad570b74e8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c640b72530cc3675973a85ebc90de60" id="r_a6c640b72530cc3675973a85ebc90de60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c640b72530cc3675973a85ebc90de60">cbegin</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a6c640b72530cc3675973a85ebc90de60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the set.  <br /></td></tr>
<tr class="separator:a6c640b72530cc3675973a85ebc90de60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e84d33eaf9c3c6151a9725229f7cb2c" id="r_a3e84d33eaf9c3c6151a9725229f7cb2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e84d33eaf9c3c6151a9725229f7cb2c">end</a> () noexcept -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a3e84d33eaf9c3c6151a9725229f7cb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set.  <br /></td></tr>
<tr class="separator:a3e84d33eaf9c3c6151a9725229f7cb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c74bb359a7678aab9af9306e468b1b" id="r_ad9c74bb359a7678aab9af9306e468b1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c74bb359a7678aab9af9306e468b1b">end</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:ad9c74bb359a7678aab9af9306e468b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set.  <br /></td></tr>
<tr class="separator:ad9c74bb359a7678aab9af9306e468b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce7fad93a11843893b0157604be19f2" id="r_a0ce7fad93a11843893b0157604be19f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ce7fad93a11843893b0157604be19f2">cend</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a0ce7fad93a11843893b0157604be19f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set.  <br /></td></tr>
<tr class="separator:a0ce7fad93a11843893b0157604be19f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc31f69f46693accacaff5c41761ded" id="r_abbc31f69f46693accacaff5c41761ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbc31f69f46693accacaff5c41761ded">rbegin</a> () noexcept -&gt; <a class="el" href="#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a></td></tr>
<tr class="memdesc:abbc31f69f46693accacaff5c41761ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set.  <br /></td></tr>
<tr class="separator:abbc31f69f46693accacaff5c41761ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2699787ed6faf0dbf8c74b2e7f069388" id="r_a2699787ed6faf0dbf8c74b2e7f069388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2699787ed6faf0dbf8c74b2e7f069388">rbegin</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a2699787ed6faf0dbf8c74b2e7f069388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set.  <br /></td></tr>
<tr class="separator:a2699787ed6faf0dbf8c74b2e7f069388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c0ca215eb733d466773fbb8cb0e94b" id="r_a75c0ca215eb733d466773fbb8cb0e94b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75c0ca215eb733d466773fbb8cb0e94b">crbegin</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a75c0ca215eb733d466773fbb8cb0e94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set.  <br /></td></tr>
<tr class="separator:a75c0ca215eb733d466773fbb8cb0e94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaad75e3a3d9f0ce431ea90821a2263" id="r_a1aaad75e3a3d9f0ce431ea90821a2263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1aaad75e3a3d9f0ce431ea90821a2263">rend</a> () noexcept -&gt; <a class="el" href="#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a></td></tr>
<tr class="memdesc:a1aaad75e3a3d9f0ce431ea90821a2263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set.  <br /></td></tr>
<tr class="separator:a1aaad75e3a3d9f0ce431ea90821a2263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262048839dd74999a35072749fd54de9" id="r_a262048839dd74999a35072749fd54de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a262048839dd74999a35072749fd54de9">rend</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a262048839dd74999a35072749fd54de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set.  <br /></td></tr>
<tr class="separator:a262048839dd74999a35072749fd54de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751298981beec7d3639cfe4709b62e97" id="r_a751298981beec7d3639cfe4709b62e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a751298981beec7d3639cfe4709b62e97">crend</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a751298981beec7d3639cfe4709b62e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set.  <br /></td></tr>
<tr class="separator:a751298981beec7d3639cfe4709b62e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb565b2a0b1b3b2168d0e461c01d15e" id="r_a1eb565b2a0b1b3b2168d0e461c01d15e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eb565b2a0b1b3b2168d0e461c01d15e">empty</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1eb565b2a0b1b3b2168d0e461c01d15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="#afa483c782bcd32df37c3f08782b431fe" title="Returns an iterator to the first element of the set.">begin()</a> == <a class="el" href="#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>.  <br /></td></tr>
<tr class="separator:a1eb565b2a0b1b3b2168d0e461c01d15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5447b2bb33022fd78bd7f6c04eadacb6" id="r_a5447b2bb33022fd78bd7f6c04eadacb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5447b2bb33022fd78bd7f6c04eadacb6">full</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5447b2bb33022fd78bd7f6c04eadacb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container full, i.e. whether <a class="el" href="#aa43d950ad6ac18738488a5a67976f45e" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a> == Capacity.  <br /></td></tr>
<tr class="separator:a5447b2bb33022fd78bd7f6c04eadacb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43d950ad6ac18738488a5a67976f45e" id="r_aa43d950ad6ac18738488a5a67976f45e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa43d950ad6ac18738488a5a67976f45e">size</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:aa43d950ad6ac18738488a5a67976f45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. distance(<a class="el" href="#afa483c782bcd32df37c3f08782b431fe" title="Returns an iterator to the first element of the set.">begin()</a>, <a class="el" href="#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>).  <br /></td></tr>
<tr class="separator:aa43d950ad6ac18738488a5a67976f45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67f246436b96d244f4b9bcd117bacfe" id="r_ab67f246436b96d244f4b9bcd117bacfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67f246436b96d244f4b9bcd117bacfe">max_size</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:ab67f246436b96d244f4b9bcd117bacfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold.  <br /></td></tr>
<tr class="separator:ab67f246436b96d244f4b9bcd117bacfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a4e54dd8e4ab7d6261e0289d259af" id="r_a323a4e54dd8e4ab7d6261e0289d259af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a323a4e54dd8e4ab7d6261e0289d259af">clear</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a323a4e54dd8e4ab7d6261e0289d259af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="#aa43d950ad6ac18738488a5a67976f45e" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a> returns zero.  <br /></td></tr>
<tr class="separator:a323a4e54dd8e4ab7d6261e0289d259af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5107c22a1ba6ea0108c5a7190f8084" id="r_acd5107c22a1ba6ea0108c5a7190f8084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd5107c22a1ba6ea0108c5a7190f8084">insert</a> (<a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &amp;&amp;value) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a> &gt; <a class="el" href="structetl_1_1static__vector.html">requires</a>(<a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a>&lt; <a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &gt;)</td></tr>
<tr class="memdesc:acd5107c22a1ba6ea0108c5a7190f8084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:acd5107c22a1ba6ea0108c5a7190f8084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b18fe6a9e33baf9b0163bf6948becc" id="r_a83b18fe6a9e33baf9b0163bf6948becc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83b18fe6a9e33baf9b0163bf6948becc">insert</a> (<a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) noexcept(noexcept(insert(<a class="el" href="__utility_2move_8hpp.html#afb338536d7767b0fd9392f796b908073">TETL_MOVE</a>(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &gt;())))) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a> &gt; <a class="el" href="structetl_1_1static__vector.html">requires</a>(<a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a>&lt; <a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &gt;)</td></tr>
<tr class="memdesc:a83b18fe6a9e33baf9b0163bf6948becc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts element into the container, if the container doesn't already contain an element with an equivalent key.  <br /></td></tr>
<tr class="separator:a83b18fe6a9e33baf9b0163bf6948becc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8196f94dd4222493e5bd711d103c879" id="r_ac8196f94dd4222493e5bd711d103c879"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIter</a> &gt; <br />
requires (detail::InputIterator&lt;<a class="el" href="structetl_1_1static__vector.html">InputIter</a>&gt;)</td></tr>
<tr class="memitem:ac8196f94dd4222493e5bd711d103c879"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8196f94dd4222493e5bd711d103c879">insert</a> (<a class="el" href="structetl_1_1static__vector.html">InputIter</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIter</a> last) noexcept(noexcept(insert(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &gt;()))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ac8196f94dd4222493e5bd711d103c879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending LWG2844).  <br /></td></tr>
<tr class="separator:ac8196f94dd4222493e5bd711d103c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0335f2f266a6aa2fd0c58c0d177b0f1" id="r_af0335f2f266a6aa2fd0c58c0d177b0f1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (<a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a>&lt;<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a>&gt;)</td></tr>
<tr class="memitem:af0335f2f266a6aa2fd0c58c0d177b0f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0335f2f266a6aa2fd0c58c0d177b0f1">emplace</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) noexcept(noexcept(<a class="el" href="#acd5107c22a1ba6ea0108c5a7190f8084">insert</a>(<a class="el" href="namespaceetl.html#a27a1a97135d4a41771948063bd8c3a90">declval</a>&lt; <a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &gt;()))) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a> &gt;</td></tr>
<tr class="memdesc:af0335f2f266a6aa2fd0c58c0d177b0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.  <br /></td></tr>
<tr class="separator:af0335f2f266a6aa2fd0c58c0d177b0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f2a9cfe69b9418622c9d3ad2fbe468" id="r_a05f2a9cfe69b9418622c9d3ad2fbe468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05f2a9cfe69b9418622c9d3ad2fbe468">erase</a> (<a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a> <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a05f2a9cfe69b9418622c9d3ad2fbe468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos.  <br /></td></tr>
<tr class="separator:a05f2a9cfe69b9418622c9d3ad2fbe468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3667df326062554b3e36c8f7825e297" id="r_ad3667df326062554b3e36c8f7825e297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3667df326062554b3e36c8f7825e297">erase</a> (<a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a> first, <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a> last) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:ad3667df326062554b3e36c8f7825e297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first; last), which must be a valid range in *this.  <br /></td></tr>
<tr class="separator:ad3667df326062554b3e36c8f7825e297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3620b27ba365e5995b9a4b832313eb82" id="r_a3620b27ba365e5995b9a4b832313eb82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3620b27ba365e5995b9a4b832313eb82">erase</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) noexcept -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:a3620b27ba365e5995b9a4b832313eb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equivalent to key.  <br /></td></tr>
<tr class="separator:a3620b27ba365e5995b9a4b832313eb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a12c2ed506f64cd7b3a37978fde79a8" id="r_a7a12c2ed506f64cd7b3a37978fde79a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a12c2ed506f64cd7b3a37978fde79a8">swap</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;<a class="el" href="structetl_1_1static__vector.html">other</a>) noexcept(<a class="el" href="namespaceetl.html#a4fe0a7655d7b161139e48f8eb34838ac">is_nothrow_swappable_v</a>&lt; <a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &gt;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">requires</a>(<a class="el" href="namespaceetl.html#ae630f4cbcf30c3c7912d50547711e86d">is_assignable_v</a>&lt; <a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &amp;, <a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &amp;&amp; &gt;)</td></tr>
<tr class="memdesc:a7a12c2ed506f64cd7b3a37978fde79a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other.  <br /></td></tr>
<tr class="separator:a7a12c2ed506f64cd7b3a37978fde79a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c49fa4411effa2f4192e4dc6e2a8439" id="r_a9c49fa4411effa2f4192e4dc6e2a8439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c49fa4411effa2f4192e4dc6e2a8439">count</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:a9c49fa4411effa2f4192e4dc6e2a8439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the specified argument, which is either 1 or 0 since this container does not allow duplicates.  <br /></td></tr>
<tr class="separator:a9c49fa4411effa2f4192e4dc6e2a8439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47f639416f87137ba29a72b433d57e" id="r_a2b47f639416f87137ba29a72b433d57e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:a2b47f639416f87137ba29a72b433d57e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b47f639416f87137ba29a72b433d57e">count</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a></td></tr>
<tr class="memdesc:a2b47f639416f87137ba29a72b433d57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that compares equivalent to the value x.  <br /></td></tr>
<tr class="separator:a2b47f639416f87137ba29a72b433d57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0f5a4d2bbf9d8e3c02bb4f28999863" id="r_a8e0f5a4d2bbf9d8e3c02bb4f28999863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e0f5a4d2bbf9d8e3c02bb4f28999863">find</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) noexcept -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a8e0f5a4d2bbf9d8e3c02bb4f28999863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <br /></td></tr>
<tr class="separator:a8e0f5a4d2bbf9d8e3c02bb4f28999863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe34badb2fbda17da8512f03efcab59e" id="r_afe34badb2fbda17da8512f03efcab59e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe34badb2fbda17da8512f03efcab59e">find</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:afe34badb2fbda17da8512f03efcab59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equivalent to key.  <br /></td></tr>
<tr class="separator:afe34badb2fbda17da8512f03efcab59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66429c0fcde3b63ccbf45fac4442534b" id="r_a66429c0fcde3b63ccbf45fac4442534b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:a66429c0fcde3b63ccbf45fac4442534b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66429c0fcde3b63ccbf45fac4442534b">find</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a66429c0fcde3b63ccbf45fac4442534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value x.  <br /></td></tr>
<tr class="separator:a66429c0fcde3b63ccbf45fac4442534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bf76673afbaddc5641579a80fd78c5" id="r_a73bf76673afbaddc5641579a80fd78c5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:a73bf76673afbaddc5641579a80fd78c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73bf76673afbaddc5641579a80fd78c5">find</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a73bf76673afbaddc5641579a80fd78c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key that compares equivalent to the value x.  <br /></td></tr>
<tr class="separator:a73bf76673afbaddc5641579a80fd78c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265586ce4755fc25bb39febca9aa7149" id="r_a265586ce4755fc25bb39febca9aa7149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a265586ce4755fc25bb39febca9aa7149">contains</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a265586ce4755fc25bb39febca9aa7149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equivalent to key in the container.  <br /></td></tr>
<tr class="separator:a265586ce4755fc25bb39febca9aa7149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735722b15c6004ca411841d4b0778c41" id="r_a735722b15c6004ca411841d4b0778c41"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:a735722b15c6004ca411841d4b0778c41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a735722b15c6004ca411841d4b0778c41">contains</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a735722b15c6004ca411841d4b0778c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key that compares equivalent to the value x.  <br /></td></tr>
<tr class="separator:a735722b15c6004ca411841d4b0778c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9e26bacddca06feddd58643c5dfee" id="r_a7ee9e26bacddca06feddd58643c5dfee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee">lower_bound</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a7ee9e26bacddca06feddd58643c5dfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <br /></td></tr>
<tr class="separator:a7ee9e26bacddca06feddd58643c5dfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978395b6dec16b02c05eb2cd40ade8e7" id="r_a978395b6dec16b02c05eb2cd40ade8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a978395b6dec16b02c05eb2cd40ade8e7">lower_bound</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a978395b6dec16b02c05eb2cd40ade8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <br /></td></tr>
<tr class="separator:a978395b6dec16b02c05eb2cd40ade8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23dd621defb5b4c0b961cf2565e7a8f" id="r_ab23dd621defb5b4c0b961cf2565e7a8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:ab23dd621defb5b4c0b961cf2565e7a8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab23dd621defb5b4c0b961cf2565e7a8f">lower_bound</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:ab23dd621defb5b4c0b961cf2565e7a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <br /></td></tr>
<tr class="separator:ab23dd621defb5b4c0b961cf2565e7a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f76a5baed7c73e2bafae7cc60bc5e" id="r_afc2f76a5baed7c73e2bafae7cc60bc5e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:afc2f76a5baed7c73e2bafae7cc60bc5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afc2f76a5baed7c73e2bafae7cc60bc5e">lower_bound</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:afc2f76a5baed7c73e2bafae7cc60bc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key.  <br /></td></tr>
<tr class="separator:afc2f76a5baed7c73e2bafae7cc60bc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81a99ca82c2a5eaf1b22997f06874b1" id="r_ae81a99ca82c2a5eaf1b22997f06874b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1">upper_bound</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:ae81a99ca82c2a5eaf1b22997f06874b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <br /></td></tr>
<tr class="separator:ae81a99ca82c2a5eaf1b22997f06874b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e9e8291c11bb963ad1279e3d786514" id="r_ae9e9e8291c11bb963ad1279e3d786514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9e9e8291c11bb963ad1279e3d786514">upper_bound</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:ae9e9e8291c11bb963ad1279e3d786514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <br /></td></tr>
<tr class="separator:ae9e9e8291c11bb963ad1279e3d786514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a0caaadc981f1df34f667da987d272" id="r_af4a0caaadc981f1df34f667da987d272"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:af4a0caaadc981f1df34f667da987d272"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4a0caaadc981f1df34f667da987d272">upper_bound</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:af4a0caaadc981f1df34f667da987d272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <br /></td></tr>
<tr class="separator:af4a0caaadc981f1df34f667da987d272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7529b8d2b822d00b5b782f6e1d106d43" id="r_a7529b8d2b822d00b5b782f6e1d106d43"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:a7529b8d2b822d00b5b782f6e1d106d43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7529b8d2b822d00b5b782f6e1d106d43">upper_bound</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a7529b8d2b822d00b5b782f6e1d106d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is greater than key.  <br /></td></tr>
<tr class="separator:a7529b8d2b822d00b5b782f6e1d106d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ab8b97c95f0798b4dc08f20721a1a3" id="r_ac7ab8b97c95f0798b4dc08f20721a1a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7ab8b97c95f0798b4dc08f20721a1a3">equal_range</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:ac7ab8b97c95f0798b4dc08f20721a1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.  <br /></td></tr>
<tr class="separator:ac7ab8b97c95f0798b4dc08f20721a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3874cfe5b7783a59b6504de83e9f1394" id="r_a3874cfe5b7783a59b6504de83e9f1394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3874cfe5b7783a59b6504de83e9f1394">equal_range</a> (<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a3874cfe5b7783a59b6504de83e9f1394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.  <br /></td></tr>
<tr class="separator:a3874cfe5b7783a59b6504de83e9f1394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c68b244ef0afa5db1c0065532b80c69" id="r_a2c68b244ef0afa5db1c0065532b80c69"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:a2c68b244ef0afa5db1c0065532b80c69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c68b244ef0afa5db1c0065532b80c69">equal_range</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td></tr>
<tr class="memdesc:a2c68b244ef0afa5db1c0065532b80c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.  <br /></td></tr>
<tr class="separator:a2c68b244ef0afa5db1c0065532b80c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8888d252345465996ff84f231b5e9115" id="r_a8888d252345465996ff84f231b5e9115"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</td></tr>
<tr class="memitem:a8888d252345465996ff84f231b5e9115"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8888d252345465996ff84f231b5e9115">equal_range</a> (<a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">key</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a></td></tr>
<tr class="memdesc:a8888d252345465996ff84f231b5e9115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>.  <br /></td></tr>
<tr class="separator:a8888d252345465996ff84f231b5e9115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06692f007a748a7713515e40afcce7a2" id="r_a06692f007a748a7713515e40afcce7a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06692f007a748a7713515e40afcce7a2">key_comp</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a></td></tr>
<tr class="memdesc:a06692f007a748a7713515e40afcce7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function object that compares the keys, which is a copy of this container's constructor argument comp. It is the same as value_comp.  <br /></td></tr>
<tr class="separator:a06692f007a748a7713515e40afcce7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02207a72f7d4bc72b216525383cb311" id="r_ac02207a72f7d4bc72b216525383cb311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac02207a72f7d4bc72b216525383cb311">value_comp</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a31b2c9e5c7ca1a5dba099162a6051410">value_compare</a></td></tr>
<tr class="memdesc:ac02207a72f7d4bc72b216525383cb311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function object that compares the values. It is the same as key_comp.  <br /></td></tr>
<tr class="separator:ac02207a72f7d4bc72b216525383cb311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> = less&lt;Key&gt;&gt;<br />
struct etl::static_set&lt; Key, Capacity, Compare &gt;</div><p><a class="el" href="structetl_1_1static__set.html" title="static_set is an associative container that contains a sorted set of unique objects of type Key....">static_set</a> is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="set_8cpp-example.html#_a2">set.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aff79031c8bab2a0e66d4daa73b1f14ee" name="aff79031c8bab2a0e66d4daa73b1f14ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff79031c8bab2a0e66d4daa73b1f14ee">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::key_type = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#add2b76e9faf0a39c1c4916446a1c0b66">storage_type::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f6ca773e70e71c4e12b273dccccb55d" name="a0f6ca773e70e71c4e12b273dccccb55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ca773e70e71c4e12b273dccccb55d">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::value_type = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#add2b76e9faf0a39c1c4916446a1c0b66">storage_type::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab6ecd554915071945801c3990ea7201" name="aab6ecd554915071945801c3990ea7201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6ecd554915071945801c3990ea7201">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::size_type = <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d747985144f7f59cc9a113637b449c3" name="a3d747985144f7f59cc9a113637b449c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d747985144f7f59cc9a113637b449c3">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::difference_type = <a class="el" href="namespaceetl.html#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04c246219cb070da3e5c473bb581f173" name="a04c246219cb070da3e5c473bb581f173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c246219cb070da3e5c473bb581f173">&#9670;&#160;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::key_compare = <a class="el" href="structetl_1_1static__vector.html">Compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31b2c9e5c7ca1a5dba099162a6051410" name="a31b2c9e5c7ca1a5dba099162a6051410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b2c9e5c7ca1a5dba099162a6051410">&#9670;&#160;</a></span>value_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::value_compare = <a class="el" href="structetl_1_1static__vector.html">Compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6d45dbda073e8796d27c3228fd06ae7" name="ac6d45dbda073e8796d27c3228fd06ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d45dbda073e8796d27c3228fd06ae7">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::reference = <a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6925e8776edf0262a5da0d4cb0e9f7b3" name="a6925e8776edf0262a5da0d4cb0e9f7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6925e8776edf0262a5da0d4cb0e9f7b3">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::const_reference = <a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbf232283b038877fdcdab7c8dd2fb16" name="acbf232283b038877fdcdab7c8dd2fb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf232283b038877fdcdab7c8dd2fb16">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::pointer = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#a5a02d4f9b32615b609a3b242582b607d">storage_type::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a475002803a709eb6702e46898b7972ba" name="a475002803a709eb6702e46898b7972ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475002803a709eb6702e46898b7972ba">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::const_pointer = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#aef5032ee73612add9beaa687e954fc9a">storage_type::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee05afb7bcd196762352083de3e905cd" name="aee05afb7bcd196762352083de3e905cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee05afb7bcd196762352083de3e905cd">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::iterator = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#a5a02d4f9b32615b609a3b242582b607d">storage_type::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a838222da9c69c81886ad2860cccb7b00" name="a838222da9c69c81886ad2860cccb7b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838222da9c69c81886ad2860cccb7b00">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::const_iterator = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html#aef5032ee73612add9beaa687e954fc9a">storage_type::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb4d32661a140e193428e39a42b3f9ee" name="abb4d32661a140e193428e39a42b3f9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4d32661a140e193428e39a42b3f9ee">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::reverse_iterator = <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d8a5a29cb228f5d09bd65ffa8e5da6d" name="a8d8a5a29cb228f5d09bd65ffa8e5da6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::const_reverse_iterator = <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb3fc92fe2d972684a753d3200f1ed78" name="abb3fc92fe2d972684a753d3200f1ed78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3fc92fe2d972684a753d3200f1ed78">&#9670;&#160;</a></span>static_set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::static_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty container. </p>

</div>
</div>
<a id="a98c644dad9c0f860bb47662a77102783" name="a98c644dad9c0f860bb47662a77102783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c644dad9c0f860bb47662a77102783">&#9670;&#160;</a></span>static_set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt; <br />
requires (detail::InputIterator&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::static_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs with the contents of the range [first, last). If multiple elements in the range have keys that compare equivalent, all but the first will be discarded. </p>

</div>
</div>
<a id="a989d9498ab2571a428bafd8809eb7f45" name="a989d9498ab2571a428bafd8809eb7f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989d9498ab2571a428bafd8809eb7f45">&#9670;&#160;</a></span>static_set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::static_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7620e086c4afe58ebfc0d8a6b48902cb" name="a7620e086c4afe58ebfc0d8a6b48902cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7620e086c4afe58ebfc0d8a6b48902cb">&#9670;&#160;</a></span>static_set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::static_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a905f23e207ac079a1968727ebda6a988" name="a905f23e207ac079a1968727ebda6a988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905f23e207ac079a1968727ebda6a988">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;=<a class="el" href="structetl_1_1static__vector.html">default</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac94be4d154634f3fb43f7752fd6edb50" name="ac94be4d154634f3fb43f7752fd6edb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94be4d154634f3fb43f7752fd6edb50">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__set.html">static_set</a> &amp;=<a class="el" href="structetl_1_1static__vector.html">default</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa483c782bcd32df37c3f08782b431fe" name="afa483c782bcd32df37c3f08782b431fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa483c782bcd32df37c3f08782b431fe">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the set. </p>

</div>
</div>
<a id="a3a55bb9aed80d33cd827ad570b74e8c0" name="a3a55bb9aed80d33cd827ad570b74e8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a55bb9aed80d33cd827ad570b74e8c0">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the set. </p>

</div>
</div>
<a id="a6c640b72530cc3675973a85ebc90de60" name="a6c640b72530cc3675973a85ebc90de60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c640b72530cc3675973a85ebc90de60">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the set. </p>

</div>
</div>
<a id="a3e84d33eaf9c3c6151a9725229f7cb2c" name="a3e84d33eaf9c3c6151a9725229f7cb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e84d33eaf9c3c6151a9725229f7cb2c">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the set. </p>

</div>
</div>
<a id="ad9c74bb359a7678aab9af9306e468b1b" name="ad9c74bb359a7678aab9af9306e468b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c74bb359a7678aab9af9306e468b1b">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the set. </p>

</div>
</div>
<a id="a0ce7fad93a11843893b0157604be19f2" name="a0ce7fad93a11843893b0157604be19f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce7fad93a11843893b0157604be19f2">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the set. </p>

</div>
</div>
<a id="abbc31f69f46693accacaff5c41761ded" name="abbc31f69f46693accacaff5c41761ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc31f69f46693accacaff5c41761ded">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set. </p>

</div>
</div>
<a id="a2699787ed6faf0dbf8c74b2e7f069388" name="a2699787ed6faf0dbf8c74b2e7f069388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2699787ed6faf0dbf8c74b2e7f069388">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set. </p>

</div>
</div>
<a id="a75c0ca215eb733d466773fbb8cb0e94b" name="a75c0ca215eb733d466773fbb8cb0e94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c0ca215eb733d466773fbb8cb0e94b">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed set. It corresponds to the last element of the non-reversed set. </p>

</div>
</div>
<a id="a1aaad75e3a3d9f0ce431ea90821a2263" name="a1aaad75e3a3d9f0ce431ea90821a2263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaad75e3a3d9f0ce431ea90821a2263">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#abb4d32661a140e193428e39a42b3f9ee">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set. </p>

</div>
</div>
<a id="a262048839dd74999a35072749fd54de9" name="a262048839dd74999a35072749fd54de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262048839dd74999a35072749fd54de9">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set. </p>

</div>
</div>
<a id="a751298981beec7d3639cfe4709b62e97" name="a751298981beec7d3639cfe4709b62e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751298981beec7d3639cfe4709b62e97">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a8d8a5a29cb228f5d09bd65ffa8e5da6d">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed set. It corresponds to the element preceding the first element of the non-reversed set. </p>

</div>
</div>
<a id="a1eb565b2a0b1b3b2168d0e461c01d15e" name="a1eb565b2a0b1b3b2168d0e461c01d15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb565b2a0b1b3b2168d0e461c01d15e">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <a class="el" href="#afa483c782bcd32df37c3f08782b431fe" title="Returns an iterator to the first element of the set.">begin()</a> == <a class="el" href="#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>. </p>

</div>
</div>
<a id="a5447b2bb33022fd78bd7f6c04eadacb6" name="a5447b2bb33022fd78bd7f6c04eadacb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5447b2bb33022fd78bd7f6c04eadacb6">&#9670;&#160;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::full </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container full, i.e. whether <a class="el" href="#aa43d950ad6ac18738488a5a67976f45e" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a> == Capacity. </p>

</div>
</div>
<a id="aa43d950ad6ac18738488a5a67976f45e" name="aa43d950ad6ac18738488a5a67976f45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43d950ad6ac18738488a5a67976f45e">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. distance(<a class="el" href="#afa483c782bcd32df37c3f08782b431fe" title="Returns an iterator to the first element of the set.">begin()</a>, <a class="el" href="#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>). </p>

</div>
</div>
<a id="ab67f246436b96d244f4b9bcd117bacfe" name="ab67f246436b96d244f4b9bcd117bacfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67f246436b96d244f4b9bcd117bacfe">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold. </p>

</div>
</div>
<a id="a323a4e54dd8e4ab7d6261e0289d259af" name="a323a4e54dd8e4ab7d6261e0289d259af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323a4e54dd8e4ab7d6261e0289d259af">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. After this call, <a class="el" href="#aa43d950ad6ac18738488a5a67976f45e" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a> returns zero. </p>

</div>
</div>
<a id="acd5107c22a1ba6ea0108c5a7190f8084" name="acd5107c22a1ba6ea0108c5a7190f8084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5107c22a1ba6ea0108c5a7190f8084">&#9670;&#160;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;
        <a class="el" href="structetl_1_1static__vector.html">requires</a>(<a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a>&lt;<a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a>&gt;)
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container, if the container doesn't already contain an element with an equivalent key. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="set_8cpp-example.html#a3">set.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a83b18fe6a9e33baf9b0163bf6948becc" name="a83b18fe6a9e33baf9b0163bf6948becc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b18fe6a9e33baf9b0163bf6948becc">&#9670;&#160;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;
        <a class="el" href="structetl_1_1static__vector.html">requires</a>(<a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a>&lt;<a class="el" href="#a0f6ca773e70e71c4e12b273dccccb55d">value_type</a>&gt;)
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts element into the container, if the container doesn't already contain an element with an equivalent key. </p>

</div>
</div>
<a id="ac8196f94dd4222493e5bd711d103c879" name="ac8196f94dd4222493e5bd711d103c879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8196f94dd4222493e5bd711d103c879">&#9670;&#160;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIter</a> &gt; <br />
requires (detail::InputIterator&lt;<a class="el" href="structetl_1_1static__vector.html">InputIter</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIter</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIter</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first, last). If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending LWG2844). </p>

</div>
</div>
<a id="af0335f2f266a6aa2fd0c58c0d177b0f1" name="af0335f2f266a6aa2fd0c58c0d177b0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0335f2f266a6aa2fd0c58c0d177b0f1">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (<a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a>&lt;<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container. </p>

</div>
</div>
<a id="a05f2a9cfe69b9418622c9d3ad2fbe468" name="a05f2a9cfe69b9418622c9d3ad2fbe468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f2a9cfe69b9418622c9d3ad2fbe468">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at pos. </p>
<p><a href="https://en.cppreference.com/w/cpp/container/set/erase">https://en.cppreference.com/w/cpp/container/set/erase</a></p>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="ad3667df326062554b3e36c8f7825e297" name="ad3667df326062554b3e36c8f7825e297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3667df326062554b3e36c8f7825e297">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first; last), which must be a valid range in *this. </p>
<p><a href="https://en.cppreference.com/w/cpp/container/set/erase">https://en.cppreference.com/w/cpp/container/set/erase</a></p>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="a3620b27ba365e5995b9a4b832313eb82" name="a3620b27ba365e5995b9a4b832313eb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3620b27ba365e5995b9a4b832313eb82">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equivalent to key. </p>
<p><a href="https://en.cppreference.com/w/cpp/container/set/erase">https://en.cppreference.com/w/cpp/container/set/erase</a></p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed. </dd></dl>

</div>
</div>
<a id="a7a12c2ed506f64cd7b3a37978fde79a8" name="a7a12c2ed506f64cd7b3a37978fde79a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a12c2ed506f64cd7b3a37978fde79a8">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
        <a class="el" href="structetl_1_1static__vector.html">requires</a>(<a class="el" href="namespaceetl.html#ae630f4cbcf30c3c7912d50547711e86d">is_assignable_v</a>&lt;<a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a>&amp;, <a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> &amp;&amp;&gt;)
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. </p>

</div>
</div>
<a id="a9c49fa4411effa2f4192e4dc6e2a8439" name="a9c49fa4411effa2f4192e4dc6e2a8439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c49fa4411effa2f4192e4dc6e2a8439">&#9670;&#160;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the specified argument, which is either 1 or 0 since this container does not allow duplicates. </p>

</div>
</div>
<a id="a2b47f639416f87137ba29a72b433d57e" name="a2b47f639416f87137ba29a72b433d57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b47f639416f87137ba29a72b433d57e">&#9670;&#160;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#aab6ecd554915071945801c3990ea7201">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key that compares equivalent to the value x. </p>

</div>
</div>
<a id="a8e0f5a4d2bbf9d8e3c02bb4f28999863" name="a8e0f5a4d2bbf9d8e3c02bb4f28999863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0f5a4d2bbf9d8e3c02bb4f28999863">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end (see <a class="el" href="#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>) iterator is returned. </dd></dl>

</div>
</div>
<a id="afe34badb2fbda17da8512f03efcab59e" name="afe34badb2fbda17da8512f03efcab59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe34badb2fbda17da8512f03efcab59e">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equivalent to key. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to an element with key equivalent to key. If no such element is found, past-the-end (see <a class="el" href="#a3e84d33eaf9c3c6151a9725229f7cb2c" title="Returns an iterator to the element following the last element of the set.">end()</a>) iterator is returned. </dd></dl>

</div>
</div>
<a id="a66429c0fcde3b63ccbf45fac4442534b" name="a66429c0fcde3b63ccbf45fac4442534b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66429c0fcde3b63ccbf45fac4442534b">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value x. </p>

</div>
</div>
<a id="a73bf76673afbaddc5641579a80fd78c5" name="a73bf76673afbaddc5641579a80fd78c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bf76673afbaddc5641579a80fd78c5">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key that compares equivalent to the value x. </p>

</div>
</div>
<a id="a265586ce4755fc25bb39febca9aa7149" name="a265586ce4755fc25bb39febca9aa7149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265586ce4755fc25bb39febca9aa7149">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key equivalent to key in the container. </p>

</div>
</div>
<a id="a735722b15c6004ca411841d4b0778c41" name="a735722b15c6004ca411841d4b0778c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735722b15c6004ca411841d4b0778c41">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key that compares equivalent to the value x. </p>

</div>
</div>
<a id="a7ee9e26bacddca06feddd58643c5dfee" name="a7ee9e26bacddca06feddd58643c5dfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee9e26bacddca06feddd58643c5dfee">&#9670;&#160;</a></span>lower_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="a978395b6dec16b02c05eb2cd40ade8e7" name="a978395b6dec16b02c05eb2cd40ade8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978395b6dec16b02c05eb2cd40ade8e7">&#9670;&#160;</a></span>lower_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="ab23dd621defb5b4c0b961cf2565e7a8f" name="ab23dd621defb5b4c0b961cf2565e7a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23dd621defb5b4c0b961cf2565e7a8f">&#9670;&#160;</a></span>lower_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="afc2f76a5baed7c73e2bafae7cc60bc5e" name="afc2f76a5baed7c73e2bafae7cc60bc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2f76a5baed7c73e2bafae7cc60bc5e">&#9670;&#160;</a></span>lower_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) key. </p>

</div>
</div>
<a id="ae81a99ca82c2a5eaf1b22997f06874b1" name="ae81a99ca82c2a5eaf1b22997f06874b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81a99ca82c2a5eaf1b22997f06874b1">&#9670;&#160;</a></span>upper_bound() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="ae9e9e8291c11bb963ad1279e3d786514" name="ae9e9e8291c11bb963ad1279e3d786514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e9e8291c11bb963ad1279e3d786514">&#9670;&#160;</a></span>upper_bound() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="af4a0caaadc981f1df34f667da987d272" name="af4a0caaadc981f1df34f667da987d272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a0caaadc981f1df34f667da987d272">&#9670;&#160;</a></span>upper_bound() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="a7529b8d2b822d00b5b782f6e1d106d43" name="a7529b8d2b822d00b5b782f6e1d106d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7529b8d2b822d00b5b782f6e1d106d43">&#9670;&#160;</a></span>upper_bound() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is greater than key. </p>

</div>
</div>
<a id="ac7ab8b97c95f0798b4dc08f20721a1a3" name="ac7ab8b97c95f0798b4dc08f20721a1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ab8b97c95f0798b4dc08f20721a1a3">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>. </p>

</div>
</div>
<a id="a3874cfe5b7783a59b6504de83e9f1394" name="a3874cfe5b7783a59b6504de83e9f1394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3874cfe5b7783a59b6504de83e9f1394">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aff79031c8bab2a0e66d4daa73b1f14ee">key_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>. </p>

</div>
</div>
<a id="a2c68b244ef0afa5db1c0065532b80c69" name="a2c68b244ef0afa5db1c0065532b80c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c68b244ef0afa5db1c0065532b80c69">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee05afb7bcd196762352083de3e905cd">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>. </p>

</div>
</div>
<a id="a8888d252345465996ff84f231b5e9115" name="a8888d252345465996ff84f231b5e9115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8888d252345465996ff84f231b5e9115">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">K</a> &gt; <br />
requires (detail::is_transparent_v&lt;<a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">K</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a838222da9c69c81886ad2860cccb7b00">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#a7ee9e26bacddca06feddd58643c5dfee" title="Returns an iterator pointing to the first element that is not less than (i.e. greater or equal to) ke...">lower_bound()</a>, and the second with <a class="el" href="#ae81a99ca82c2a5eaf1b22997f06874b1" title="Returns an iterator pointing to the first element that is greater than key.">upper_bound()</a>. </p>

</div>
</div>
<a id="a06692f007a748a7713515e40afcce7a2" name="a06692f007a748a7713515e40afcce7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06692f007a748a7713515e40afcce7a2">&#9670;&#160;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a04c246219cb070da3e5c473bb581f173">key_compare</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function object that compares the keys, which is a copy of this container's constructor argument comp. It is the same as value_comp. </p>
<dl class="section return"><dt>Returns</dt><dd>The key comparison function object. </dd></dl>

</div>
</div>
<a id="ac02207a72f7d4bc72b216525383cb311" name="ac02207a72f7d4bc72b216525383cb311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02207a72f7d4bc72b216525383cb311">&#9670;&#160;</a></span>value_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a>  = less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__set.html">etl::static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a31b2c9e5c7ca1a5dba099162a6051410">value_compare</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the function object that compares the values. It is the same as key_comp. </p>
<dl class="section return"><dt>Returns</dt><dd>The value comparison function object. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/etl/_set/<a class="el" href="static__set_8hpp_source.html">static_set.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="structetl_1_1static__set.html">static_set</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
