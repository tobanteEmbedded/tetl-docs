<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__algorithm.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">algorithm<div class="ingroups"><a class="el" href="group__algorithms-library.html">Algorithms Library</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Algorithms that operate on ranges  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ranges_1_1in__fun__result.html">in_fun_result&lt; I, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f9b625e56c5ddcc87c1b813687215cd" id="r_ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9f9b625e56c5ddcc87c1b813687215cd">copy</a> (InputIt first, InputIt last, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3807f7eadedf61cbd5fcbed1fd59d087" id="r_ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt1 , typename BidirIt2 &gt; </td></tr>
<tr class="memitem:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3807f7eadedf61cbd5fcbed1fd59d087">copy_backward</a> (BidirIt1 first, BidirIt1 last, BidirIt2 dLast) -&gt; BidirIt2</td></tr>
<tr class="memdesc:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed613dd207fcb8dad486fd471d90af0" id="r_ga0ed613dd207fcb8dad486fd471d90af0"><td class="memTemplParams" colspan="2">template&lt;typename InIt , typename OutIt , typename Pred &gt; </td></tr>
<tr class="memitem:ga0ed613dd207fcb8dad486fd471d90af0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0ed613dd207fcb8dad486fd471d90af0">copy_if</a> (InIt first, InIt last, OutIt dFirst, Pred pred) -&gt; OutIt</td></tr>
<tr class="memdesc:ga0ed613dd207fcb8dad486fd471d90af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:ga0ed613dd207fcb8dad486fd471d90af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae848a2fb9566a7471c52d02d108a87e6" id="r_gae848a2fb9566a7471c52d02d108a87e6"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Size , typename OutputIt &gt; </td></tr>
<tr class="memitem:gae848a2fb9566a7471c52d02d108a87e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae848a2fb9566a7471c52d02d108a87e6">copy_n</a> (InputIt first, Size <a class="el" href="#gacf27092e22460faafdb958cac56c6fec">count</a>, OutputIt result) -&gt; OutputIt</td></tr>
<tr class="memdesc:gae848a2fb9566a7471c52d02d108a87e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <br /></td></tr>
<tr class="separator:gae848a2fb9566a7471c52d02d108a87e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf27092e22460faafdb958cac56c6fec" id="r_gacf27092e22460faafdb958cac56c6fec"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename T &gt; </td></tr>
<tr class="memitem:gacf27092e22460faafdb958cac56c6fec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacf27092e22460faafdb958cac56c6fec">count</a> (InputIt first, InputIt last, T const &amp;value) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIt &gt;::difference_type</td></tr>
<tr class="memdesc:gacf27092e22460faafdb958cac56c6fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value.  <br /></td></tr>
<tr class="separator:gacf27092e22460faafdb958cac56c6fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf36ef6fdcb46c9ad8060d4520016096" id="r_gadf36ef6fdcb46c9ad8060d4520016096"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:gadf36ef6fdcb46c9ad8060d4520016096"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gadf36ef6fdcb46c9ad8060d4520016096">count_if</a> (InputIt first, InputIt last, Predicate p) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIt &gt;::difference_type</td></tr>
<tr class="memdesc:gadf36ef6fdcb46c9ad8060d4520016096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:gadf36ef6fdcb46c9ad8060d4520016096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fb0dac9928f1cf33cc07f069cac971" id="r_ga13fb0dac9928f1cf33cc07f069cac971"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:ga13fb0dac9928f1cf33cc07f069cac971"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga13fb0dac9928f1cf33cc07f069cac971">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2) -&gt; bool</td></tr>
<tr class="separator:ga13fb0dac9928f1cf33cc07f069cac971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb7da13869cc2911d1dd3ebfbc49681" id="r_ga8cb7da13869cc2911d1dd3ebfbc49681"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:ga8cb7da13869cc2911d1dd3ebfbc49681"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8cb7da13869cc2911d1dd3ebfbc49681">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2) -&gt; bool</td></tr>
<tr class="separator:ga8cb7da13869cc2911d1dd3ebfbc49681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79340eb0330b4f112afc47f71e3d844" id="r_gab79340eb0330b4f112afc47f71e3d844"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:gab79340eb0330b4f112afc47f71e3d844"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab79340eb0330b4f112afc47f71e3d844">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Predicate p) -&gt; bool</td></tr>
<tr class="separator:gab79340eb0330b4f112afc47f71e3d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a8919c2c9cca7f4eb38f2199797c37" id="r_gad2a8919c2c9cca7f4eb38f2199797c37"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:gad2a8919c2c9cca7f4eb38f2199797c37"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad2a8919c2c9cca7f4eb38f2199797c37">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:gad2a8919c2c9cca7f4eb38f2199797c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise.  <br /></td></tr>
<tr class="separator:gad2a8919c2c9cca7f4eb38f2199797c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7225526a11c7ee4454afce37e9bfd031" id="r_ga7225526a11c7ee4454afce37e9bfd031"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:ga7225526a11c7ee4454afce37e9bfd031"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7225526a11c7ee4454afce37e9bfd031">equal_range</a> (ForwardIt first, ForwardIt last, T const &amp;value) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="separator:ga7225526a11c7ee4454afce37e9bfd031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0065deb93b945a04f6875db16eba3fd3" id="r_ga0065deb93b945a04f6875db16eba3fd3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ga0065deb93b945a04f6875db16eba3fd3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0065deb93b945a04f6875db16eba3fd3">equal_range</a> (ForwardIt first, ForwardIt last, T const &amp;value, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="memdesc:ga0065deb93b945a04f6875db16eba3fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga0065deb93b945a04f6875db16eba3fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9378dad55c6bc1835467e35f3d096808" id="r_ga9378dad55c6bc1835467e35f3d096808"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:ga9378dad55c6bc1835467e35f3d096808"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9378dad55c6bc1835467e35f3d096808">exchange_sort</a> (RandomIt first, RandomIt last) -&gt; void</td></tr>
<tr class="memdesc:ga9378dad55c6bc1835467e35f3d096808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga9378dad55c6bc1835467e35f3d096808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d64a767f3a1408540f8d99f0da4cf68" id="r_ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4d64a767f3a1408540f8d99f0da4cf68">exchange_sort</a> (RandomIt first, RandomIt last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7166349fd110372de5c865fe5767f97" id="r_gad7166349fd110372de5c865fe5767f97"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:gad7166349fd110372de5c865fe5767f97"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad7166349fd110372de5c865fe5767f97">fill</a> (ForwardIt first, ForwardIt last, T const &amp;value) -&gt; void</td></tr>
<tr class="memdesc:gad7166349fd110372de5c865fe5767f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gad7166349fd110372de5c865fe5767f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae52b4d387889126b64b88ca2150c6ddc" id="r_gae52b4d387889126b64b88ca2150c6ddc"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt , typename Size , typename T &gt; </td></tr>
<tr class="memitem:gae52b4d387889126b64b88ca2150c6ddc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae52b4d387889126b64b88ca2150c6ddc">fill_n</a> (OutputIt first, Size <a class="el" href="#gacf27092e22460faafdb958cac56c6fec">count</a>, T const &amp;value) -&gt; OutputIt</td></tr>
<tr class="memdesc:gae52b4d387889126b64b88ca2150c6ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise.  <br /></td></tr>
<tr class="separator:gae52b4d387889126b64b88ca2150c6ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf123f494fccf3d1e9420928c32915189" id="r_gaf123f494fccf3d1e9420928c32915189"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename T &gt; </td></tr>
<tr class="memitem:gaf123f494fccf3d1e9420928c32915189"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf123f494fccf3d1e9420928c32915189">find</a> (InputIt first, InputIt last, T const &amp;value) noexcept -&gt; InputIt</td></tr>
<tr class="memdesc:gaf123f494fccf3d1e9420928c32915189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element equal to value.  <br /></td></tr>
<tr class="separator:gaf123f494fccf3d1e9420928c32915189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3668f0480d1f8d6976de08b3658eb97e" id="r_ga3668f0480d1f8d6976de08b3658eb97e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:ga3668f0480d1f8d6976de08b3658eb97e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3668f0480d1f8d6976de08b3658eb97e">find_end</a> (ForwardIt1 first, ForwardIt1 last, ForwardIt2 sFirst, ForwardIt2 sLast) -&gt; ForwardIt1</td></tr>
<tr class="separator:ga3668f0480d1f8d6976de08b3658eb97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ba00834faefda2a3d9b112d053f889" id="r_ga99ba00834faefda2a3d9b112d053f889"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:ga99ba00834faefda2a3d9b112d053f889"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga99ba00834faefda2a3d9b112d053f889">find_end</a> (ForwardIt1 first, ForwardIt1 last, ForwardIt2 sFirst, ForwardIt2 sLast, Predicate p) -&gt; ForwardIt1</td></tr>
<tr class="memdesc:ga99ba00834faefda2a3d9b112d053f889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga99ba00834faefda2a3d9b112d053f889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74fd28c3677d3bebf66460a3e492f3c0" id="r_ga74fd28c3677d3bebf66460a3e492f3c0"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga74fd28c3677d3bebf66460a3e492f3c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga74fd28c3677d3bebf66460a3e492f3c0">find_first_of</a> (InputIt first, InputIt last, ForwardIt sFirst, ForwardIt sLast) -&gt; InputIt</td></tr>
<tr class="memdesc:ga74fd28c3677d3bebf66460a3e492f3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast).  <br /></td></tr>
<tr class="separator:ga74fd28c3677d3bebf66460a3e492f3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac49fa522ef832adfa9ebb8c4592ca60" id="r_gaac49fa522ef832adfa9ebb8c4592ca60"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:gaac49fa522ef832adfa9ebb8c4592ca60"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaac49fa522ef832adfa9ebb8c4592ca60">find_first_of</a> (InputIt first, InputIt last, ForwardIt sFirst, ForwardIt sLast, Predicate pred) -&gt; InputIt</td></tr>
<tr class="memdesc:gaac49fa522ef832adfa9ebb8c4592ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred.  <br /></td></tr>
<tr class="separator:gaac49fa522ef832adfa9ebb8c4592ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214a2898fc2820379237f4cc89e3249f" id="r_ga214a2898fc2820379237f4cc89e3249f"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga214a2898fc2820379237f4cc89e3249f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga214a2898fc2820379237f4cc89e3249f">find_if</a> (InputIt first, InputIt last, Predicate pred) noexcept -&gt; InputIt</td></tr>
<tr class="memdesc:ga214a2898fc2820379237f4cc89e3249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate p returns true.  <br /></td></tr>
<tr class="separator:ga214a2898fc2820379237f4cc89e3249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd10eb98eb927ed2e7efb96bbbebac30" id="r_gabd10eb98eb927ed2e7efb96bbbebac30"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:gabd10eb98eb927ed2e7efb96bbbebac30"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabd10eb98eb927ed2e7efb96bbbebac30">find_if_not</a> (InputIt first, InputIt last, Predicate pred) noexcept -&gt; InputIt</td></tr>
<tr class="memdesc:gabd10eb98eb927ed2e7efb96bbbebac30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate q returns false.  <br /></td></tr>
<tr class="separator:gabd10eb98eb927ed2e7efb96bbbebac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14fe21109f4f9d8ce7a3364bb45e9eae" id="r_ga14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename UnaryFunc &gt; </td></tr>
<tr class="memitem:ga14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga14fe21109f4f9d8ce7a3364bb45e9eae">for_each</a> (InputIt first, InputIt last, UnaryFunc f) noexcept -&gt; UnaryFunc</td></tr>
<tr class="memdesc:ga14fe21109f4f9d8ce7a3364bb45e9eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order.  <br /></td></tr>
<tr class="separator:ga14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef3395c26e44857cb21437ffbd285e7" id="r_ga5ef3395c26e44857cb21437ffbd285e7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Size , typename UnaryFunc &gt; </td></tr>
<tr class="memitem:ga5ef3395c26e44857cb21437ffbd285e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5ef3395c26e44857cb21437ffbd285e7">for_each_n</a> (InputIt first, Size n, UnaryFunc f) noexcept -&gt; InputIt</td></tr>
<tr class="memdesc:ga5ef3395c26e44857cb21437ffbd285e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order.  <br /></td></tr>
<tr class="separator:ga5ef3395c26e44857cb21437ffbd285e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379d8ee0b21dfbdc9b0e5e4d7762eb43" id="r_ga379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Generator &gt; </td></tr>
<tr class="memitem:ga379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga379d8ee0b21dfbdc9b0e5e4d7762eb43">generate</a> (ForwardIt first, ForwardIt last, Generator g) -&gt; void</td></tr>
<tr class="memdesc:ga379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns each element in range <code>[first, last)</code> a value generated by the given function object g.  <br /></td></tr>
<tr class="separator:ga379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12543b4f9ab02e90be68988a60f74dbe" id="r_ga12543b4f9ab02e90be68988a60f74dbe"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt , typename SizeT , typename Generator &gt; </td></tr>
<tr class="memitem:ga12543b4f9ab02e90be68988a60f74dbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga12543b4f9ab02e90be68988a60f74dbe">generate_n</a> (OutputIt first, SizeT <a class="el" href="#gacf27092e22460faafdb958cac56c6fec">count</a>, Generator g) -&gt; OutputIt</td></tr>
<tr class="memdesc:ga12543b4f9ab02e90be68988a60f74dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise.  <br /></td></tr>
<tr class="separator:ga12543b4f9ab02e90be68988a60f74dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee8f3605b778d70c05a5697ffae6192" id="r_ga4ee8f3605b778d70c05a5697ffae6192"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:ga4ee8f3605b778d70c05a5697ffae6192"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4ee8f3605b778d70c05a5697ffae6192">gnome_sort</a> (BidirIt first, BidirIt last) -&gt; void</td></tr>
<tr class="memdesc:ga4ee8f3605b778d70c05a5697ffae6192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga4ee8f3605b778d70c05a5697ffae6192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe96d864c89d47ea3902b6fc8826d2b5" id="r_gafe96d864c89d47ea3902b6fc8826d2b5"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename Compare &gt; </td></tr>
<tr class="memitem:gafe96d864c89d47ea3902b6fc8826d2b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafe96d864c89d47ea3902b6fc8826d2b5">gnome_sort</a> (BidirIt first, BidirIt last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:gafe96d864c89d47ea3902b6fc8826d2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:gafe96d864c89d47ea3902b6fc8826d2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d74dfc016d11d54f60ad30618fc276" id="r_gae0d74dfc016d11d54f60ad30618fc276"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:gae0d74dfc016d11d54f60ad30618fc276"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gae0d74dfc016d11d54f60ad30618fc276">includes</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2) -&gt; bool</td></tr>
<tr class="separator:gae0d74dfc016d11d54f60ad30618fc276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0d5db89d1e54d2ccb479a559df46aa" id="r_ga5f0d5db89d1e54d2ccb479a559df46aa"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </td></tr>
<tr class="memitem:ga5f0d5db89d1e54d2ccb479a559df46aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5f0d5db89d1e54d2ccb479a559df46aa">includes</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:ga5f0d5db89d1e54d2ccb479a559df46aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted.  <br /></td></tr>
<tr class="separator:ga5f0d5db89d1e54d2ccb479a559df46aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90ac00af714eca3a603115a96d226d1" id="r_gaf90ac00af714eca3a603115a96d226d1"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename Compare &gt; </td></tr>
<tr class="memitem:gaf90ac00af714eca3a603115a96d226d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf90ac00af714eca3a603115a96d226d1">inplace_merge</a> (BidirIt <a class="el" href="group__iterator.html#gaeb088ae74a2ec53c8c206de329935df4">begin</a>, BidirIt mid, BidirIt <a class="el" href="group__iterator.html#gaa26698de685cc42e99c0c560d05ca93c">end</a>, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:gaf90ac00af714eca3a603115a96d226d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last).  <br /></td></tr>
<tr class="separator:gaf90ac00af714eca3a603115a96d226d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485ce5c1c0690a9616ba899fe2db7a10" id="r_ga485ce5c1c0690a9616ba899fe2db7a10"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:ga485ce5c1c0690a9616ba899fe2db7a10"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga485ce5c1c0690a9616ba899fe2db7a10">inplace_merge</a> (BidirIt first, BidirIt mid, BidirIt last) -&gt; void</td></tr>
<tr class="separator:ga485ce5c1c0690a9616ba899fe2db7a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819f2e196782c8f996a7a6d85853564b" id="r_ga819f2e196782c8f996a7a6d85853564b"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:ga819f2e196782c8f996a7a6d85853564b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga819f2e196782c8f996a7a6d85853564b">insertion_sort</a> (RandomIt first, RandomIt last) -&gt; void</td></tr>
<tr class="separator:ga819f2e196782c8f996a7a6d85853564b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1189f81daa0314d4422781edab8a4e83" id="r_ga1189f81daa0314d4422781edab8a4e83"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga1189f81daa0314d4422781edab8a4e83"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1189f81daa0314d4422781edab8a4e83">insertion_sort</a> (RandomIt first, RandomIt last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:ga1189f81daa0314d4422781edab8a4e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga1189f81daa0314d4422781edab8a4e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3a106198fbf6b07743f082cec761fa" id="r_ga7c3a106198fbf6b07743f082cec761fa"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga7c3a106198fbf6b07743f082cec761fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7c3a106198fbf6b07743f082cec761fa">is_partitioned</a> (InputIt first, InputIt last, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:ga7c3a106198fbf6b07743f082cec761fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty.  <br /></td></tr>
<tr class="separator:ga7c3a106198fbf6b07743f082cec761fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ca70817d9b940ccd963245edb804e7" id="r_gab7ca70817d9b940ccd963245edb804e7"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:gab7ca70817d9b940ccd963245edb804e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab7ca70817d9b940ccd963245edb804e7">is_permutation</a> (ForwardIt1 first, ForwardIt1 last, ForwardIt2 first2) -&gt; bool</td></tr>
<tr class="memdesc:gab7ca70817d9b940ccd963245edb804e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given.  <br /></td></tr>
<tr class="separator:gab7ca70817d9b940ccd963245edb804e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebb0727381b2818e6575c43ad064189" id="r_gacebb0727381b2818e6575c43ad064189"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:gacebb0727381b2818e6575c43ad064189"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacebb0727381b2818e6575c43ad064189">is_permutation</a> (ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2) -&gt; bool</td></tr>
<tr class="separator:gacebb0727381b2818e6575c43ad064189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25741a63c525afca9eaf8054b7122a9" id="r_gaa25741a63c525afca9eaf8054b7122a9"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:gaa25741a63c525afca9eaf8054b7122a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa25741a63c525afca9eaf8054b7122a9">is_sorted</a> (ForwardIt first, ForwardIt last) -&gt; bool</td></tr>
<tr class="memdesc:gaa25741a63c525afca9eaf8054b7122a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:gaa25741a63c525afca9eaf8054b7122a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a1d40ec7a46d94456bc76abf70910c" id="r_gaf0a1d40ec7a46d94456bc76abf70910c"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:gaf0a1d40ec7a46d94456bc76abf70910c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf0a1d40ec7a46d94456bc76abf70910c">is_sorted</a> (ForwardIt first, ForwardIt last, Compare comp) -&gt; bool</td></tr>
<tr class="separator:gaf0a1d40ec7a46d94456bc76abf70910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb2f98e7a5c930b843b813c8885ff0e" id="r_ga1eb2f98e7a5c930b843b813c8885ff0e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga1eb2f98e7a5c930b843b813c8885ff0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1eb2f98e7a5c930b843b813c8885ff0e">is_sorted_until</a> (ForwardIt first, ForwardIt last) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga1eb2f98e7a5c930b843b813c8885ff0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:ga1eb2f98e7a5c930b843b813c8885ff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76ed3932bcae919d183136bb3dcf658" id="r_gaa76ed3932bcae919d183136bb3dcf658"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:gaa76ed3932bcae919d183136bb3dcf658"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa76ed3932bcae919d183136bb3dcf658">is_sorted_until</a> (ForwardIt first, ForwardIt last, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="separator:gaa76ed3932bcae919d183136bb3dcf658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1249aee36691133f6b783a82290f8e" id="r_ga7a1249aee36691133f6b783a82290f8e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:ga7a1249aee36691133f6b783a82290f8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7a1249aee36691133f6b783a82290f8e">iter_swap</a> (ForwardIt1 a, ForwardIt2 b) -&gt; void</td></tr>
<tr class="memdesc:ga7a1249aee36691133f6b783a82290f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of the elements the given iterators are pointing to.  <br /></td></tr>
<tr class="separator:ga7a1249aee36691133f6b783a82290f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbb8794e1a09c00341acc4070284bd3" id="r_ga6bbb8794e1a09c00341acc4070284bd3"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:ga6bbb8794e1a09c00341acc4070284bd3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6bbb8794e1a09c00341acc4070284bd3">lexicographical_compare</a> (InputIt1 f1, InputIt1 l1, InputIt2 f2, InputIt2 l2) -&gt; bool</td></tr>
<tr class="separator:ga6bbb8794e1a09c00341acc4070284bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb90a196cbc728c59a4f2f16a9a9befd" id="r_gacb90a196cbc728c59a4f2f16a9a9befd"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </td></tr>
<tr class="memitem:gacb90a196cbc728c59a4f2f16a9a9befd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacb90a196cbc728c59a4f2f16a9a9befd">lexicographical_compare</a> (InputIt1 f1, InputIt1 l1, InputIt2 f2, InputIt2 l2, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:gacb90a196cbc728c59a4f2f16a9a9befd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>.  <br /></td></tr>
<tr class="separator:gacb90a196cbc728c59a4f2f16a9a9befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef2815c598ddf680df6562ff413fc89" id="r_gaeef2815c598ddf680df6562ff413fc89"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:gaeef2815c598ddf680df6562ff413fc89"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaeef2815c598ddf680df6562ff413fc89">lower_bound</a> (ForwardIt first, ForwardIt last, T const &amp;value) noexcept -&gt; ForwardIt</td></tr>
<tr class="separator:gaeef2815c598ddf680df6562ff413fc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eac84d4e60cc02ce593a33117a79ba3" id="r_ga7eac84d4e60cc02ce593a33117a79ba3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ga7eac84d4e60cc02ce593a33117a79ba3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7eac84d4e60cc02ce593a33117a79ba3">lower_bound</a> (ForwardIt first, ForwardIt last, T const &amp;value, Compare comp) noexcept -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga7eac84d4e60cc02ce593a33117a79ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found.  <br /></td></tr>
<tr class="separator:ga7eac84d4e60cc02ce593a33117a79ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3eca1793f7f38aeb756464984eb194" id="r_ga5f3eca1793f7f38aeb756464984eb194"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga5f3eca1793f7f38aeb756464984eb194"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5f3eca1793f7f38aeb756464984eb194">max</a> (Type const &amp;a, Type const &amp;b) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:ga5f3eca1793f7f38aeb756464984eb194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b.  <br /></td></tr>
<tr class="separator:ga5f3eca1793f7f38aeb756464984eb194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b79e7341165c49fa24ea2d66a761a5" id="r_gab9b79e7341165c49fa24ea2d66a761a5"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:gab9b79e7341165c49fa24ea2d66a761a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab9b79e7341165c49fa24ea2d66a761a5">max</a> (Type const &amp;a, Type const &amp;b, Compare comp) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:gab9b79e7341165c49fa24ea2d66a761a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b, using a compare function.  <br /></td></tr>
<tr class="separator:gab9b79e7341165c49fa24ea2d66a761a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4b38361c7330f3c5996fef40213eed" id="r_ga3b4b38361c7330f3c5996fef40213eed"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga3b4b38361c7330f3c5996fef40213eed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga3b4b38361c7330f3c5996fef40213eed">max_element</a> (ForwardIt first, ForwardIt last) noexcept -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga3b4b38361c7330f3c5996fef40213eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <br /></td></tr>
<tr class="separator:ga3b4b38361c7330f3c5996fef40213eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac847a74164e6c1a692093c156b35eb30" id="r_gac847a74164e6c1a692093c156b35eb30"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:gac847a74164e6c1a692093c156b35eb30"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac847a74164e6c1a692093c156b35eb30">max_element</a> (ForwardIt first, ForwardIt last, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="memdesc:gac847a74164e6c1a692093c156b35eb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <br /></td></tr>
<tr class="separator:gac847a74164e6c1a692093c156b35eb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de3be8fc3e9e834497d00be337e09ea" id="r_ga2de3be8fc3e9e834497d00be337e09ea"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:ga2de3be8fc3e9e834497d00be337e09ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2de3be8fc3e9e834497d00be337e09ea">merge</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="separator:ga2de3be8fc3e9e834497d00be337e09ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390da486f87fc7f5e59fd16cb3015c25" id="r_ga390da486f87fc7f5e59fd16cb3015c25"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga390da486f87fc7f5e59fd16cb3015c25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga390da486f87fc7f5e59fd16cb3015c25">merge</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:ga390da486f87fc7f5e59fd16cb3015c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>.  <br /></td></tr>
<tr class="separator:ga390da486f87fc7f5e59fd16cb3015c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga810b4260b22a58b461be941fa6acb745" id="r_ga810b4260b22a58b461be941fa6acb745"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga810b4260b22a58b461be941fa6acb745"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga810b4260b22a58b461be941fa6acb745">min</a> (Type const &amp;a, Type const &amp;b) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:ga810b4260b22a58b461be941fa6acb745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b.  <br /></td></tr>
<tr class="separator:ga810b4260b22a58b461be941fa6acb745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c60a3adb053935acbf3c8a91a0a035" id="r_ga80c60a3adb053935acbf3c8a91a0a035"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:ga80c60a3adb053935acbf3c8a91a0a035"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga80c60a3adb053935acbf3c8a91a0a035">min</a> (Type const &amp;a, Type const &amp;b, Compare comp) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:ga80c60a3adb053935acbf3c8a91a0a035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b, using a compare function.  <br /></td></tr>
<tr class="separator:ga80c60a3adb053935acbf3c8a91a0a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5571b6aa07c8298071d5e43411200c" id="r_ga4b5571b6aa07c8298071d5e43411200c"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga4b5571b6aa07c8298071d5e43411200c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4b5571b6aa07c8298071d5e43411200c">min_element</a> (ForwardIt first, ForwardIt last) noexcept -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga4b5571b6aa07c8298071d5e43411200c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <br /></td></tr>
<tr class="separator:ga4b5571b6aa07c8298071d5e43411200c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb64c2aeca7185a3fdd03bff27f93f2" id="r_ga4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4fb64c2aeca7185a3fdd03bff27f93f2">min_element</a> (ForwardIt first, ForwardIt last, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga4fb64c2aeca7185a3fdd03bff27f93f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <br /></td></tr>
<tr class="separator:ga4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe7517750d66b576d14d06fd58d74b1" id="r_ga8fe7517750d66b576d14d06fd58d74b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8fe7517750d66b576d14d06fd58d74b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8fe7517750d66b576d14d06fd58d74b1">minmax</a> (T const &amp;a, T const &amp;b) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T const &amp;, T const &amp; &gt;</td></tr>
<tr class="memdesc:ga8fe7517750d66b576d14d06fd58d74b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <br /></td></tr>
<tr class="separator:ga8fe7517750d66b576d14d06fd58d74b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf8c00a7d8e6e8c5eff71f1063fad52" id="r_ga2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ga2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2cf8c00a7d8e6e8c5eff71f1063fad52">minmax</a> (T const &amp;a, T const &amp;b, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T const &amp;, T const &amp; &gt;</td></tr>
<tr class="memdesc:ga2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <br /></td></tr>
<tr class="separator:ga2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ee575bad4a7b0cecd1869f7ecdc942" id="r_ga26ee575bad4a7b0cecd1869f7ecdc942"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga26ee575bad4a7b0cecd1869f7ecdc942"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga26ee575bad4a7b0cecd1869f7ecdc942">minmax_element</a> (ForwardIt first, ForwardIt last) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="memdesc:ga26ee575bad4a7b0cecd1869f7ecdc942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga26ee575bad4a7b0cecd1869f7ecdc942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68fb6c83c244cd496ea25c4f5a9d01f" id="r_gaa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Compare &gt; </td></tr>
<tr class="memitem:gaa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa68fb6c83c244cd496ea25c4f5a9d01f">minmax_element</a> (ForwardIt first, ForwardIt last, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="memdesc:gaa68fb6c83c244cd496ea25c4f5a9d01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gaa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272907f42acd772ea50acaa07ffb12aa" id="r_ga272907f42acd772ea50acaa07ffb12aa"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:ga272907f42acd772ea50acaa07ffb12aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga272907f42acd772ea50acaa07ffb12aa">mismatch</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, Predicate pred) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; InputIt1, InputIt2 &gt;</td></tr>
<tr class="memdesc:ga272907f42acd772ea50acaa07ffb12aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred.  <br /></td></tr>
<tr class="separator:ga272907f42acd772ea50acaa07ffb12aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9060e0931516472a88f4657d835684a9" id="r_ga9060e0931516472a88f4657d835684a9"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:ga9060e0931516472a88f4657d835684a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9060e0931516472a88f4657d835684a9">move</a> (InputIt first, InputIt last, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:ga9060e0931516472a88f4657d835684a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.  <br /></td></tr>
<tr class="separator:ga9060e0931516472a88f4657d835684a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf551d4e71ff0eabb8f92409796fcf33d" id="r_gaf551d4e71ff0eabb8f92409796fcf33d"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt1 , typename BidirIt2 &gt; </td></tr>
<tr class="memitem:gaf551d4e71ff0eabb8f92409796fcf33d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf551d4e71ff0eabb8f92409796fcf33d">move_backward</a> (BidirIt1 first, BidirIt1 last, BidirIt2 destination) -&gt; BidirIt2</td></tr>
<tr class="memdesc:gaf551d4e71ff0eabb8f92409796fcf33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:gaf551d4e71ff0eabb8f92409796fcf33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga816a532bf04d7e7c0a846b930a571a1d" id="r_ga816a532bf04d7e7c0a846b930a571a1d"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga816a532bf04d7e7c0a846b930a571a1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga816a532bf04d7e7c0a846b930a571a1d">none_of</a> (InputIt first, InputIt last, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:ga816a532bf04d7e7c0a846b930a571a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga816a532bf04d7e7c0a846b930a571a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a975e8950c5e7cc4ff7f97638d34a53" id="r_ga8a975e8950c5e7cc4ff7f97638d34a53"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga8a975e8950c5e7cc4ff7f97638d34a53"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8a975e8950c5e7cc4ff7f97638d34a53">nth_element</a> (RandomIt first, RandomIt nth, RandomIt last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:ga8a975e8950c5e7cc4ff7f97638d34a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that:  <br /></td></tr>
<tr class="separator:ga8a975e8950c5e7cc4ff7f97638d34a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae05431e1f03b692ae88a58f8629a057" id="r_gaae05431e1f03b692ae88a58f8629a057"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:gaae05431e1f03b692ae88a58f8629a057"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaae05431e1f03b692ae88a58f8629a057">partial_sort</a> (RandomIt first, RandomIt middle, RandomIt last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:gaae05431e1f03b692ae88a58f8629a057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified.  <br /></td></tr>
<tr class="separator:gaae05431e1f03b692ae88a58f8629a057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58dc6d94b5e29f2351debc8dff607246" id="r_ga58dc6d94b5e29f2351debc8dff607246"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga58dc6d94b5e29f2351debc8dff607246"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga58dc6d94b5e29f2351debc8dff607246">partition</a> (ForwardIt first, ForwardIt last, Predicate p) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga58dc6d94b5e29f2351debc8dff607246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved.  <br /></td></tr>
<tr class="separator:ga58dc6d94b5e29f2351debc8dff607246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac406ce808473104b511907657832cd92" id="r_gac406ce808473104b511907657832cd92"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt1 , typename OutputIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:gac406ce808473104b511907657832cd92"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac406ce808473104b511907657832cd92">partition_copy</a> (InputIt first, InputIt last, OutputIt1 destinationTrue, OutputIt2 destinationFalse, Predicate p) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; OutputIt1, OutputIt2 &gt;</td></tr>
<tr class="memdesc:gac406ce808473104b511907657832cd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false.  <br /></td></tr>
<tr class="separator:gac406ce808473104b511907657832cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59eeccfe79ec5ab27f96d577417ca35a" id="r_ga59eeccfe79ec5ab27f96d577417ca35a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga59eeccfe79ec5ab27f96d577417ca35a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga59eeccfe79ec5ab27f96d577417ca35a">partition_point</a> (ForwardIt first, ForwardIt last, Predicate p) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga59eeccfe79ec5ab27f96d577417ca35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p.  <br /></td></tr>
<tr class="separator:ga59eeccfe79ec5ab27f96d577417ca35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ecba2ecefe71607f67bec456ff072fd" id="r_ga1ecba2ecefe71607f67bec456ff072fd"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:ga1ecba2ecefe71607f67bec456ff072fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1ecba2ecefe71607f67bec456ff072fd">remove</a> (ForwardIt first, ForwardIt last, T const &amp;value) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga1ecba2ecefe71607f67bec456ff072fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <br /></td></tr>
<tr class="separator:ga1ecba2ecefe71607f67bec456ff072fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafdb5717541ddef9974357131dc1d248" id="r_gaafdb5717541ddef9974357131dc1d248"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename T &gt; </td></tr>
<tr class="memitem:gaafdb5717541ddef9974357131dc1d248"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaafdb5717541ddef9974357131dc1d248">remove_copy</a> (InputIt first, InputIt last, OutputIt destination, T const &amp;value) -&gt; OutputIt</td></tr>
<tr class="memdesc:gaafdb5717541ddef9974357131dc1d248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value.  <br /></td></tr>
<tr class="separator:gaafdb5717541ddef9974357131dc1d248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bdbbf4b495def4cb406f6af3ef25882" id="r_ga8bdbbf4b495def4cb406f6af3ef25882"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga8bdbbf4b495def4cb406f6af3ef25882"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8bdbbf4b495def4cb406f6af3ef25882">remove_copy_if</a> (InputIt first, InputIt last, OutputIt destination, Predicate p) -&gt; OutputIt</td></tr>
<tr class="memdesc:ga8bdbbf4b495def4cb406f6af3ef25882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:ga8bdbbf4b495def4cb406f6af3ef25882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22cf73ac58ec2b4dd086be384cbbdd7d" id="r_ga22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga22cf73ac58ec2b4dd086be384cbbdd7d">remove_if</a> (ForwardIt first, ForwardIt last, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga22cf73ac58ec2b4dd086be384cbbdd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <br /></td></tr>
<tr class="separator:ga22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e970687eb65ad36a17922ed1be6764a" id="r_ga7e970687eb65ad36a17922ed1be6764a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:ga7e970687eb65ad36a17922ed1be6764a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7e970687eb65ad36a17922ed1be6764a">replace</a> (ForwardIt first, ForwardIt last, T const &amp;oldValue, T const &amp;newValue) -&gt; void</td></tr>
<tr class="memdesc:ga7e970687eb65ad36a17922ed1be6764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value.  <br /></td></tr>
<tr class="separator:ga7e970687eb65ad36a17922ed1be6764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13040e3fc5925b1bc966782f36635444" id="r_ga13040e3fc5925b1bc966782f36635444"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate , typename T &gt; </td></tr>
<tr class="memitem:ga13040e3fc5925b1bc966782f36635444"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga13040e3fc5925b1bc966782f36635444">replace_if</a> (ForwardIt first, ForwardIt last, Predicate p, T const &amp;newValue) -&gt; void</td></tr>
<tr class="memdesc:ga13040e3fc5925b1bc966782f36635444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:ga13040e3fc5925b1bc966782f36635444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3169a8bd10088a7cf7d65b8aae66bc" id="r_gabf3169a8bd10088a7cf7d65b8aae66bc"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:gabf3169a8bd10088a7cf7d65b8aae66bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabf3169a8bd10088a7cf7d65b8aae66bc">reverse</a> (BidirIt first, BidirIt last) -&gt; void</td></tr>
<tr class="memdesc:gabf3169a8bd10088a7cf7d65b8aae66bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gabf3169a8bd10088a7cf7d65b8aae66bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5067524643b55244e12cb5eed183ddae" id="r_ga5067524643b55244e12cb5eed183ddae"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:ga5067524643b55244e12cb5eed183ddae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5067524643b55244e12cb5eed183ddae">reverse_copy</a> (BidirIt first, BidirIt last, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:ga5067524643b55244e12cb5eed183ddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order.  <br /></td></tr>
<tr class="separator:ga5067524643b55244e12cb5eed183ddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d4db23a06789c303ee8ec693d84129" id="r_ga99d4db23a06789c303ee8ec693d84129"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga99d4db23a06789c303ee8ec693d84129"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga99d4db23a06789c303ee8ec693d84129">rotate</a> (ForwardIt first, ForwardIt nFirst, ForwardIt last) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga99d4db23a06789c303ee8ec693d84129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on a range of elements.  <br /></td></tr>
<tr class="separator:ga99d4db23a06789c303ee8ec693d84129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3ea43eb370058e059c95c0738eb379" id="r_ga8e3ea43eb370058e059c95c0738eb379"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:ga8e3ea43eb370058e059c95c0738eb379"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8e3ea43eb370058e059c95c0738eb379">rotate_copy</a> (ForwardIt first, ForwardIt nFirst, ForwardIt last, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:ga8e3ea43eb370058e059c95c0738eb379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element.  <br /></td></tr>
<tr class="separator:ga8e3ea43eb370058e059c95c0738eb379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6d3457c4b1a845dce8219245bbc31c" id="r_ga2a6d3457c4b1a845dce8219245bbc31c"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga2a6d3457c4b1a845dce8219245bbc31c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2a6d3457c4b1a845dce8219245bbc31c">shift_left</a> (ForwardIt first, ForwardIt const last, typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; ForwardIt &gt;::difference_type n) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga2a6d3457c4b1a845dce8219245bbc31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <br /></td></tr>
<tr class="separator:ga2a6d3457c4b1a845dce8219245bbc31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465e2a36ddbbed9d12ad5403dccbb7b3" id="r_ga465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memTemplParams" colspan="2">template&lt;typename BidiIt &gt; </td></tr>
<tr class="memitem:ga465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga465e2a36ddbbed9d12ad5403dccbb7b3">shift_right</a> (BidiIt first, BidiIt last, typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; BidiIt &gt;::difference_type n) -&gt; BidiIt</td></tr>
<tr class="memdesc:ga465e2a36ddbbed9d12ad5403dccbb7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <br /></td></tr>
<tr class="separator:ga465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0402fada51d792d7500e9a8f196eb649" id="r_ga0402fada51d792d7500e9a8f196eb649"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga0402fada51d792d7500e9a8f196eb649"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0402fada51d792d7500e9a8f196eb649">stable_partition</a> (BidirIt f, BidirIt l, Predicate p) -&gt; BidirIt</td></tr>
<tr class="memdesc:ga0402fada51d792d7500e9a8f196eb649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved.  <br /></td></tr>
<tr class="separator:ga0402fada51d792d7500e9a8f196eb649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8e235b7f1654c13232e768201e17f4a" id="r_gaa8e235b7f1654c13232e768201e17f4a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:gaa8e235b7f1654c13232e768201e17f4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa8e235b7f1654c13232e768201e17f4a">swap_ranges</a> (ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2) -&gt; ForwardIt2</td></tr>
<tr class="memdesc:gaa8e235b7f1654c13232e768201e17f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>.  <br /></td></tr>
<tr class="separator:gaa8e235b7f1654c13232e768201e17f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6643f5ca84c6579040caeeb9079e0c3a" id="r_ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6643f5ca84c6579040caeeb9079e0c3a">adjacent_find</a> (ForwardIt first, ForwardIt last, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf6853a6729fd97ca2688e2ce192273" id="r_ga5bf6853a6729fd97ca2688e2ce192273"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:ga5bf6853a6729fd97ca2688e2ce192273"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5bf6853a6729fd97ca2688e2ce192273">adjacent_find</a> (ForwardIt first, ForwardIt last) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga5bf6853a6729fd97ca2688e2ce192273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga5bf6853a6729fd97ca2688e2ce192273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga068d12997d2db7789f5feeee67ba6632" id="r_ga068d12997d2db7789f5feeee67ba6632"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga068d12997d2db7789f5feeee67ba6632"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga068d12997d2db7789f5feeee67ba6632">all_of</a> (InputIt first, InputIt last, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:ga068d12997d2db7789f5feeee67ba6632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga068d12997d2db7789f5feeee67ba6632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab7423807619552d4187d28ced39b9a" id="r_gaeab7423807619552d4187d28ced39b9a"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:gaeab7423807619552d4187d28ced39b9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaeab7423807619552d4187d28ced39b9a">any_of</a> (InputIt first, InputIt last, Predicate p) -&gt; bool</td></tr>
<tr class="memdesc:gaeab7423807619552d4187d28ced39b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gaeab7423807619552d4187d28ced39b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga518c4f26f6b475c9ba5b742ca6202a05" id="r_ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga518c4f26f6b475c9ba5b742ca6202a05">binary_search</a> (ForwardIt first, ForwardIt last, T const &amp;value, Compare comp) -&gt; bool</td></tr>
<tr class="separator:ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd7d82f1e1253083d060c08049cb64b" id="r_ga5bd7d82f1e1253083d060c08049cb64b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:ga5bd7d82f1e1253083d060c08049cb64b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5bd7d82f1e1253083d060c08049cb64b">binary_search</a> (ForwardIt first, ForwardIt last, T const &amp;value) -&gt; bool</td></tr>
<tr class="separator:ga5bd7d82f1e1253083d060c08049cb64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d3f8f2170e346ec527e33ba981a2ae" id="r_ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga11d3f8f2170e346ec527e33ba981a2ae">bubble_sort</a> (RandomIt first, RandomIt last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aaad8ffc58779f75d6ce3d017dd3cb4" id="r_ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga1aaad8ffc58779f75d6ce3d017dd3cb4">bubble_sort</a> (RandomIt first, RandomIt last) -&gt; void</td></tr>
<tr class="memdesc:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ad3fc1cb6d967df6a52c8e61030f75" id="r_ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga72ad3fc1cb6d967df6a52c8e61030f75">clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi, Compare comp) -&gt; Type const &amp;</td></tr>
<tr class="memdesc:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <br /></td></tr>
<tr class="separator:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e0d6f4937eef794486e125996b6ce1" id="r_gac2e0d6f4937eef794486e125996b6ce1"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gac2e0d6f4937eef794486e125996b6ce1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac2e0d6f4937eef794486e125996b6ce1">clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:gac2e0d6f4937eef794486e125996b6ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <br /></td></tr>
<tr class="separator:gac2e0d6f4937eef794486e125996b6ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d076e41cf7830be44fc5fc1322d9f49" id="r_ga0d076e41cf7830be44fc5fc1322d9f49"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga0d076e41cf7830be44fc5fc1322d9f49"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0d076e41cf7830be44fc5fc1322d9f49">merge_sort</a> (BidirIt first, BidirIt last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:ga0d076e41cf7830be44fc5fc1322d9f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga0d076e41cf7830be44fc5fc1322d9f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e07086e339175ad2433a095b9205e87" id="r_ga9e07086e339175ad2433a095b9205e87"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt &gt; </td></tr>
<tr class="memitem:ga9e07086e339175ad2433a095b9205e87"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9e07086e339175ad2433a095b9205e87">merge_sort</a> (BidirIt first, BidirIt last) -&gt; void</td></tr>
<tr class="memdesc:ga9e07086e339175ad2433a095b9205e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga9e07086e339175ad2433a095b9205e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e" id="r_gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memTemplParams" colspan="2">template&lt;typename FwdIt1 , typename FwdIt2 , typename Predicate &gt; </td></tr>
<tr class="memitem:gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e">search</a> (FwdIt1 first, FwdIt1 last, FwdIt2 sFirst, FwdIt2 sLast, Predicate pred) -&gt; FwdIt1</td></tr>
<tr class="separator:gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd9a9ec8c617610bf30e92fbaa678cd" id="r_ga9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memTemplParams" colspan="2">template&lt;typename FwdIt1 , typename FwdIt2 &gt; </td></tr>
<tr class="memitem:ga9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9fd9a9ec8c617610bf30e92fbaa678cd">search</a> (FwdIt1 first, FwdIt1 last, FwdIt2 sFirst, FwdIt2 sLast) -&gt; FwdIt1</td></tr>
<tr class="separator:ga9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec0297d32d2f51e39c270a715b430d1" id="r_ga8ec0297d32d2f51e39c270a715b430d1"><td class="memTemplParams" colspan="2">template&lt;typename FwdIt , typename Searcher &gt; </td></tr>
<tr class="memitem:ga8ec0297d32d2f51e39c270a715b430d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga8ec0297d32d2f51e39c270a715b430d1">search</a> (FwdIt first, FwdIt last, Searcher const &amp;searcher) -&gt; FwdIt</td></tr>
<tr class="separator:ga8ec0297d32d2f51e39c270a715b430d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b828a0b5a5e92873f178d30c4bb9df" id="r_ga07b828a0b5a5e92873f178d30c4bb9df"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Size , typename ValueT , typename Predicate &gt; </td></tr>
<tr class="memitem:ga07b828a0b5a5e92873f178d30c4bb9df"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga07b828a0b5a5e92873f178d30c4bb9df">search_n</a> (ForwardIt first, ForwardIt last, Size <a class="el" href="#gacf27092e22460faafdb958cac56c6fec">count</a>, ValueT const &amp;value, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga07b828a0b5a5e92873f178d30c4bb9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value.  <br /></td></tr>
<tr class="separator:ga07b828a0b5a5e92873f178d30c4bb9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52038b2431b48b42d039e54647d96493" id="r_ga52038b2431b48b42d039e54647d96493"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Size , typename ValueT &gt; </td></tr>
<tr class="memitem:ga52038b2431b48b42d039e54647d96493"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga52038b2431b48b42d039e54647d96493">search_n</a> (ForwardIt first, ForwardIt last, Size <a class="el" href="#gacf27092e22460faafdb958cac56c6fec">count</a>, ValueT const &amp;value) -&gt; ForwardIt</td></tr>
<tr class="memdesc:ga52038b2431b48b42d039e54647d96493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value.  <br /></td></tr>
<tr class="separator:ga52038b2431b48b42d039e54647d96493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe32b3c3b80a92b66e5d7f118439492e" id="r_gafe32b3c3b80a92b66e5d7f118439492e"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:gafe32b3c3b80a92b66e5d7f118439492e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gafe32b3c3b80a92b66e5d7f118439492e">set_difference</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:gafe32b3c3b80a92b66e5d7f118439492e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same.  <br /></td></tr>
<tr class="separator:gafe32b3c3b80a92b66e5d7f118439492e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf15d37410e2266762deefec2f9552e2" id="r_gabf15d37410e2266762deefec2f9552e2"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:gabf15d37410e2266762deefec2f9552e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gabf15d37410e2266762deefec2f9552e2">set_difference</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:gabf15d37410e2266762deefec2f9552e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same.  <br /></td></tr>
<tr class="separator:gabf15d37410e2266762deefec2f9552e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa483f6d503afb56bafdb6c73eebdd8" id="r_gacfa483f6d503afb56bafdb6c73eebdd8"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:gacfa483f6d503afb56bafdb6c73eebdd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacfa483f6d503afb56bafdb6c73eebdd8">set_intersection</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:gacfa483f6d503afb56bafdb6c73eebdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:gacfa483f6d503afb56bafdb6c73eebdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac046bcca7d511bae026125e54c1f20e7" id="r_gac046bcca7d511bae026125e54c1f20e7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:gac046bcca7d511bae026125e54c1f20e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gac046bcca7d511bae026125e54c1f20e7">set_intersection</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest) -&gt; OutputIt</td></tr>
<tr class="memdesc:gac046bcca7d511bae026125e54c1f20e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:gac046bcca7d511bae026125e54c1f20e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4249908e93f7b1367d3605c52b20a842" id="r_ga4249908e93f7b1367d3605c52b20a842"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga4249908e93f7b1367d3605c52b20a842"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4249908e93f7b1367d3605c52b20a842">set_symmetric_difference</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp) -&gt; OutputIt</td></tr>
<tr class="separator:ga4249908e93f7b1367d3605c52b20a842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c80d1254a7659943993cacc3498dc38" id="r_ga5c80d1254a7659943993cacc3498dc38"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:ga5c80d1254a7659943993cacc3498dc38"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga5c80d1254a7659943993cacc3498dc38">set_symmetric_difference</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest) -&gt; OutputIt</td></tr>
<tr class="separator:ga5c80d1254a7659943993cacc3498dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd656aa427e48301b6fd14503854ff7" id="r_gacfd656aa427e48301b6fd14503854ff7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </td></tr>
<tr class="memitem:gacfd656aa427e48301b6fd14503854ff7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gacfd656aa427e48301b6fd14503854ff7">set_union</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination, Compare comp) -&gt; OutputIt</td></tr>
<tr class="memdesc:gacfd656aa427e48301b6fd14503854ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:gacfd656aa427e48301b6fd14503854ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4135eaec81217633145f410048de3cbe" id="r_ga4135eaec81217633145f410048de3cbe"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </td></tr>
<tr class="memitem:ga4135eaec81217633145f410048de3cbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga4135eaec81217633145f410048de3cbe">set_union</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:ga4135eaec81217633145f410048de3cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:ga4135eaec81217633145f410048de3cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ef221b98a814660142c728ce9bac78" id="r_gad5ef221b98a814660142c728ce9bac78"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:gad5ef221b98a814660142c728ce9bac78"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad5ef221b98a814660142c728ce9bac78">sort</a> (RandomIt first, RandomIt last, Compare comp) -&gt; void</td></tr>
<tr class="separator:gad5ef221b98a814660142c728ce9bac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9823f4c1911f50c9f7ac3b4a8be9f294" id="r_ga9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:ga9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga9823f4c1911f50c9f7ac3b4a8be9f294">sort</a> (RandomIt first, RandomIt last) -&gt; void</td></tr>
<tr class="separator:ga9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555004d15f48a5bb9b71103bcc3e1555" id="r_ga555004d15f48a5bb9b71103bcc3e1555"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:ga555004d15f48a5bb9b71103bcc3e1555"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga555004d15f48a5bb9b71103bcc3e1555">stable_sort</a> (RandomIt first, RandomIt last, Compare comp) -&gt; void</td></tr>
<tr class="separator:ga555004d15f48a5bb9b71103bcc3e1555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57756439702cf72053e29b5c7294d85" id="r_gab57756439702cf72053e29b5c7294d85"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:gab57756439702cf72053e29b5c7294d85"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab57756439702cf72053e29b5c7294d85">stable_sort</a> (RandomIt first, RandomIt last) -&gt; void</td></tr>
<tr class="separator:gab57756439702cf72053e29b5c7294d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d479673068495c0b88dcd93a99dfb57" id="r_ga0d479673068495c0b88dcd93a99dfb57"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename UnaryOp &gt; </td></tr>
<tr class="memitem:ga0d479673068495c0b88dcd93a99dfb57"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga0d479673068495c0b88dcd93a99dfb57">transform</a> (InputIt first, InputIt last, OutputIt dest, UnaryOp op) -&gt; OutputIt</td></tr>
<tr class="separator:ga0d479673068495c0b88dcd93a99dfb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f1eb9069005465b67c5d79eaae8bb9" id="r_gaa4f1eb9069005465b67c5d79eaae8bb9"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename BinaryOp &gt; </td></tr>
<tr class="memitem:gaa4f1eb9069005465b67c5d79eaae8bb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaa4f1eb9069005465b67c5d79eaae8bb9">transform</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt dest, BinaryOp op) -&gt; OutputIt</td></tr>
<tr class="separator:gaa4f1eb9069005465b67c5d79eaae8bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f27339834dd24fea714a4b4ef5b383" id="r_ga99f27339834dd24fea714a4b4ef5b383"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga99f27339834dd24fea714a4b4ef5b383"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga99f27339834dd24fea714a4b4ef5b383">unique</a> (ForwardIt first, ForwardIt last, Predicate pred) -&gt; ForwardIt</td></tr>
<tr class="separator:ga99f27339834dd24fea714a4b4ef5b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf368b8bc471211756f0fd32f9d2c8968" id="r_gaf368b8bc471211756f0fd32f9d2c8968"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:gaf368b8bc471211756f0fd32f9d2c8968"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaf368b8bc471211756f0fd32f9d2c8968">unique</a> (ForwardIt first, ForwardIt last) -&gt; ForwardIt</td></tr>
<tr class="separator:gaf368b8bc471211756f0fd32f9d2c8968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aefae29604dcd0147171f39aa1380be" id="r_ga6aefae29604dcd0147171f39aa1380be"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename Predicate &gt; </td></tr>
<tr class="memitem:ga6aefae29604dcd0147171f39aa1380be"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga6aefae29604dcd0147171f39aa1380be">unique_copy</a> (InputIt first, InputIt last, OutputIt destination, Predicate pred) -&gt; OutputIt</td></tr>
<tr class="separator:ga6aefae29604dcd0147171f39aa1380be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18330134b5b5074b665d9e91c994f5e2" id="r_ga18330134b5b5074b665d9e91c994f5e2"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:ga18330134b5b5074b665d9e91c994f5e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga18330134b5b5074b665d9e91c994f5e2">unique_copy</a> (InputIt first, InputIt last, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="separator:ga18330134b5b5074b665d9e91c994f5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3130ebfc35a09b9488d205269fdac86" id="r_gad3130ebfc35a09b9488d205269fdac86"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:gad3130ebfc35a09b9488d205269fdac86"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gad3130ebfc35a09b9488d205269fdac86">upper_bound</a> (ForwardIt first, ForwardIt last, T const &amp;value, Compare comp) -&gt; ForwardIt</td></tr>
<tr class="separator:gad3130ebfc35a09b9488d205269fdac86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25261717b25b3523e4fdb8d6420183d2" id="r_ga25261717b25b3523e4fdb8d6420183d2"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:ga25261717b25b3523e4fdb8d6420183d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga25261717b25b3523e4fdb8d6420183d2">upper_bound</a> (ForwardIt first, ForwardIt last, T const &amp;value) -&gt; ForwardIt</td></tr>
<tr class="separator:ga25261717b25b3523e4fdb8d6420183d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algorithms that operate on ranges </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5bf6853a6729fd97ca2688e2ce192273" name="ga5bf6853a6729fd97ca2688e2ce192273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bf6853a6729fd97ca2688e2ce192273">&#9670;&#160;</a></span>adjacent_find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto adjacent_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_find">https://en.cppreference.com/w/cpp/algorithm/adjacent_find</a> </p>

</div>
</div>
<a id="ga6643f5ca84c6579040caeeb9079e0c3a" name="ga6643f5ca84c6579040caeeb9079e0c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6643f5ca84c6579040caeeb9079e0c3a">&#9670;&#160;</a></span>adjacent_find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto adjacent_find </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_find">https://en.cppreference.com/w/cpp/algorithm/adjacent_find</a> </p>

</div>
</div>
<a id="ga068d12997d2db7789f5feeee67ba6632" name="ga068d12997d2db7789f5feeee67ba6632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga068d12997d2db7789f5feeee67ba6632">&#9670;&#160;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto all_of </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_8cpp-example.html#a3">array.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaeab7423807619552d4187d28ced39b9a" name="gaeab7423807619552d4187d28ced39b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeab7423807619552d4187d28ced39b9a">&#9670;&#160;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto any_of </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ga5bd7d82f1e1253083d060c08049cb64b" name="ga5bd7d82f1e1253083d060c08049cb64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bd7d82f1e1253083d060c08049cb64b">&#9670;&#160;</a></span>binary_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto binary_search </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a> </p>

</div>
</div>
<a id="ga518c4f26f6b475c9ba5b742ca6202a05" name="ga518c4f26f6b475c9ba5b742ca6202a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga518c4f26f6b475c9ba5b742ca6202a05">&#9670;&#160;</a></span>binary_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto binary_search </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a> </p>

</div>
</div>
<a id="ga1aaad8ffc58779f75d6ce3d017dd3cb4" name="ga1aaad8ffc58779f75d6ce3d017dd3cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aaad8ffc58779f75d6ce3d017dd3cb4">&#9670;&#160;</a></span>bubble_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bubble_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. </p>
<p><a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a></p>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga11d3f8f2170e346ec527e33ba981a2ae" name="ga11d3f8f2170e346ec527e33ba981a2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11d3f8f2170e346ec527e33ba981a2ae">&#9670;&#160;</a></span>bubble_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bubble_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. </p>
<p><a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a></p>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="gac2e0d6f4937eef794486e125996b6ce1" name="gac2e0d6f4937eef794486e125996b6ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e0d6f4937eef794486e125996b6ce1">&#9670;&#160;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto clamp </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>lo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>&#160;) -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values. </p>

</div>
</div>
<a id="ga72ad3fc1cb6d967df6a52c8e61030f75" name="ga72ad3fc1cb6d967df6a52c8e61030f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72ad3fc1cb6d967df6a52c8e61030f75">&#9670;&#160;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto clamp </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>lo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values. </p>

</div>
</div>
<a id="ga9f9b625e56c5ddcc87c1b813687215cd" name="ga9f9b625e56c5ddcc87c1b813687215cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9b625e56c5ddcc87c1b813687215cd">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto copy </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination. </p>
<p>Copies all elements in the range <code>[first, last)</code> starting from first and proceeding to <code>last - 1</code>. The behavior is undefined if destination is within the range <code>[first, last)</code>. In this case, copy_backward may be used instead. </p><dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_8cpp-example.html#a4">array.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga3807f7eadedf61cbd5fcbed1fd59d087" name="ga3807f7eadedf61cbd5fcbed1fd59d087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3807f7eadedf61cbd5fcbed1fd59d087">&#9670;&#160;</a></span>copy_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt1 , typename BidirIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto copy_backward </td>
          <td>(</td>
          <td class="paramtype">BidirIt1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt1</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt2</td>          <td class="paramname"><span class="paramname"><em>dLast</em></span>&#160;) -&gt; BidirIt2
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved. </p>
<p>The behavior is undefined if <code>dLast</code> is within <code>(first, last]</code>. copy must be used instead of copy_backward in that case.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the last element copied. </dd></dl>

</div>
</div>
<a id="ga0ed613dd207fcb8dad486fd471d90af0" name="ga0ed613dd207fcb8dad486fd471d90af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ed613dd207fcb8dad486fd471d90af0">&#9670;&#160;</a></span>copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InIt , typename OutIt , typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto copy_if </td>
          <td>(</td>
          <td class="paramtype">InIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIt</td>          <td class="paramname"><span class="paramname"><em>dFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; OutIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination. </p>
<p>Only copies the elements for which the predicate pred returns true. The relative order of the elements that are copied is preserved. The behavior is undefined if the source and the destination ranges overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>

</div>
</div>
<a id="gae848a2fb9566a7471c52d02d108a87e6" name="gae848a2fb9566a7471c52d02d108a87e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae848a2fb9566a7471c52d02d108a87e6">&#9670;&#160;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Size , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto copy_n </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator in the destination range, pointing past the last element copied if count&gt;0 or result otherwise. </dd></dl>

</div>
</div>
<a id="gacf27092e22460faafdb958cac56c6fec" name="gacf27092e22460faafdb958cac56c6fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf27092e22460faafdb958cac56c6fec">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto count </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;InputIt&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">value</td><td>The value to search for.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a> </p>

</div>
</div>
<a id="gadf36ef6fdcb46c9ad8060d4520016096" name="gadf36ef6fdcb46c9ad8060d4520016096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf36ef6fdcb46c9ad8060d4520016096">&#9670;&#160;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto count_if </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;InputIt&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">p</td><td>Unary predicate which returns true for the required elements.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a> </p>

</div>
</div>
<a id="ga13fb0dac9928f1cf33cc07f069cac971" name="ga13fb0dac9928f1cf33cc07f069cac971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13fb0dac9928f1cf33cc07f069cac971">&#9670;&#160;</a></span>equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8cb7da13869cc2911d1dd3ebfbc49681" name="ga8cb7da13869cc2911d1dd3ebfbc49681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cb7da13869cc2911d1dd3ebfbc49681">&#9670;&#160;</a></span>equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab79340eb0330b4f112afc47f71e3d844" name="gab79340eb0330b4f112afc47f71e3d844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab79340eb0330b4f112afc47f71e3d844">&#9670;&#160;</a></span>equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gad2a8919c2c9cca7f4eb38f2199797c37" name="gad2a8919c2c9cca7f4eb38f2199797c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a8919c2c9cca7f4eb38f2199797c37">&#9670;&#160;</a></span>equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise. </p>

</div>
</div>
<a id="ga7225526a11c7ee4454afce37e9bfd031" name="ga7225526a11c7ee4454afce37e9bfd031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7225526a11c7ee4454afce37e9bfd031">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto equal_range </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;ForwardIt, ForwardIt&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0065deb93b945a04f6875db16eba3fd3" name="ga0065deb93b945a04f6875db16eba3fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0065deb93b945a04f6875db16eba3fd3">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto equal_range </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;ForwardIt, ForwardIt&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a> </p>

</div>
</div>
<a id="ga9378dad55c6bc1835467e35f3d096808" name="ga9378dad55c6bc1835467e35f3d096808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9378dad55c6bc1835467e35f3d096808">&#9670;&#160;</a></span>exchange_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto exchange_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. </p>
<p><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort">https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga4d64a767f3a1408540f8d99f0da4cf68" name="ga4d64a767f3a1408540f8d99f0da4cf68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d64a767f3a1408540f8d99f0da4cf68">&#9670;&#160;</a></span>exchange_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto exchange_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. </p>
<p><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort">https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="gad7166349fd110372de5c865fe5767f97" name="gad7166349fd110372de5c865fe5767f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7166349fd110372de5c865fe5767f97">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value to the elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="gae52b4d387889126b64b88ca2150c6ddc" name="gae52b4d387889126b64b88ca2150c6ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae52b4d387889126b64b88ca2150c6ddc">&#9670;&#160;</a></span>fill_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt , typename Size , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto fill_n </td>
          <td>(</td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator one past the last element assigned if <code>count &gt; 0</code>, <code>first</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaf123f494fccf3d1e9420928c32915189" name="gaf123f494fccf3d1e9420928c32915189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf123f494fccf3d1e9420928c32915189">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto find </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">value</td><td>Value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a2">algorithm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga3668f0480d1f8d6976de08b3658eb97e" name="ga3668f0480d1f8d6976de08b3658eb97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3668f0480d1f8d6976de08b3658eb97e">&#9670;&#160;</a></span>find_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto find_end </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; ForwardIt1
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga99ba00834faefda2a3d9b112d053f889" name="ga99ba00834faefda2a3d9b112d053f889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ba00834faefda2a3d9b112d053f889">&#9670;&#160;</a></span>find_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto find_end </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; ForwardIt1
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for </td></tr>
    <tr><td class="paramname">p</td><td>Binary predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the beginning of last occurrence of the sequence [sFirst, sLast) in range <code>[first, last)</code>. If [sFirst, sLast) is empty or if no such sequence is found, last is returned. </dd></dl>

</div>
</div>
<a id="ga74fd28c3677d3bebf66460a3e492f3c0" name="ga74fd28c3677d3bebf66460a3e492f3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74fd28c3677d3bebf66460a3e492f3c0">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto find_first_of </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of">https://en.cppreference.com/w/cpp/algorithm/find_first_of</a> </p>

</div>
</div>
<a id="gaac49fa522ef832adfa9ebb8c4592ca60" name="gaac49fa522ef832adfa9ebb8c4592ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac49fa522ef832adfa9ebb8c4592ca60">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto find_first_of </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of">https://en.cppreference.com/w/cpp/algorithm/find_first_of</a> </p>

</div>
</div>
<a id="ga214a2898fc2820379237f4cc89e3249f" name="ga214a2898fc2820379237f4cc89e3249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga214a2898fc2820379237f4cc89e3249f">&#9670;&#160;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto find_if </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate p returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Unary predicate which returns true for the required element.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>

</div>
</div>
<a id="gabd10eb98eb927ed2e7efb96bbbebac30" name="gabd10eb98eb927ed2e7efb96bbbebac30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd10eb98eb927ed2e7efb96bbbebac30">&#9670;&#160;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto find_if_not </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate q returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Unary predicate which returns true for the required element.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>

</div>
</div>
<a id="ga14fe21109f4f9d8ce7a3364bb45e9eae" name="ga14fe21109f4f9d8ce7a3364bb45e9eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14fe21109f4f9d8ce7a3364bb45e9eae">&#9670;&#160;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename UnaryFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto for_each </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunc</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; UnaryFunc
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range to apply the function to. </td></tr>
    <tr><td class="paramname">last</td><td>The range to apply the function to. </td></tr>
    <tr><td class="paramname">f</td><td>Function object, to be applied to the result of dereferencing every iterator in the range.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each">https://en.cppreference.com/w/cpp/algorithm/for_each</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="set_8cpp-example.html#a2">set.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga5ef3395c26e44857cb21437ffbd285e7" name="ga5ef3395c26e44857cb21437ffbd285e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ef3395c26e44857cb21437ffbd285e7">&#9670;&#160;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Size , typename UnaryFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto for_each_n </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunc</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to apply the function to. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements to apply the function to. </td></tr>
    <tr><td class="paramname">f</td><td>Function object, to be applied to the result of dereferencing every iterator in the range.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each_n">https://en.cppreference.com/w/cpp/algorithm/for_each_n</a> </p>

</div>
</div>
<a id="ga379d8ee0b21dfbdc9b0e5e4d7762eb43" name="ga379d8ee0b21dfbdc9b0e5e4d7762eb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga379d8ee0b21dfbdc9b0e5e4d7762eb43">&#9670;&#160;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto generate </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns each element in range <code>[first, last)</code> a value generated by the given function object g. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">g</td><td>Generator function object that will be called.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate">https://en.cppreference.com/w/cpp/algorithm/generate</a> </p>

</div>
</div>
<a id="ga12543b4f9ab02e90be68988a60f74dbe" name="ga12543b4f9ab02e90be68988a60f74dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12543b4f9ab02e90be68988a60f74dbe">&#9670;&#160;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt , typename SizeT , typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto generate_n </td>
          <td>(</td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeT</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">count</td><td>Number of the elements to generate. </td></tr>
    <tr><td class="paramname">g</td><td>Generator function object that will be called.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate_n">https://en.cppreference.com/w/cpp/algorithm/generate_n</a> </p>

</div>
</div>
<a id="ga4ee8f3605b778d70c05a5697ffae6192" name="ga4ee8f3605b778d70c05a5697ffae6192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee8f3605b778d70c05a5697ffae6192">&#9670;&#160;</a></span>gnome_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gnome_sort </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. </p>
<p><a href="https://en.wikipedia.org/wiki/Gnome_sort">https://en.wikipedia.org/wiki/Gnome_sort</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="gafe96d864c89d47ea3902b6fc8826d2b5" name="gafe96d864c89d47ea3902b6fc8826d2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe96d864c89d47ea3902b6fc8826d2b5">&#9670;&#160;</a></span>gnome_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto gnome_sort </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. </p>
<p><a href="https://en.wikipedia.org/wiki/Gnome_sort">https://en.wikipedia.org/wiki/Gnome_sort</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="gae0d74dfc016d11d54f60ad30618fc276" name="gae0d74dfc016d11d54f60ad30618fc276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d74dfc016d11d54f60ad30618fc276">&#9670;&#160;</a></span>includes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto includes </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5f0d5db89d1e54d2ccb479a559df46aa" name="ga5f0d5db89d1e54d2ccb479a559df46aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0d5db89d1e54d2ccb479a559df46aa">&#9670;&#160;</a></span>includes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto includes </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted. </p>

</div>
</div>
<a id="gaf90ac00af714eca3a603115a96d226d1" name="gaf90ac00af714eca3a603115a96d226d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90ac00af714eca3a603115a96d226d1">&#9670;&#160;</a></span>inplace_merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto inplace_merge </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>mid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). </p>
<p>A sequence [first, last) is said to be sorted with respect to a comparator comp if for any iterator it pointing to the sequence and any non-negative integer n such that it + n is a valid iterator pointing to an element of the sequence, comp(*(it + n), *it) evaluates to false.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/inplace_merge">https://en.cppreference.com/w/cpp/algorithm/inplace_merge</a> </p>

</div>
</div>
<a id="ga485ce5c1c0690a9616ba899fe2db7a10" name="ga485ce5c1c0690a9616ba899fe2db7a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga485ce5c1c0690a9616ba899fe2db7a10">&#9670;&#160;</a></span>inplace_merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto inplace_merge </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>mid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga819f2e196782c8f996a7a6d85853564b" name="ga819f2e196782c8f996a7a6d85853564b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga819f2e196782c8f996a7a6d85853564b">&#9670;&#160;</a></span>insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto insertion_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga1189f81daa0314d4422781edab8a4e83" name="ga1189f81daa0314d4422781edab8a4e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1189f81daa0314d4422781edab8a4e83">&#9670;&#160;</a></span>insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto insertion_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. </p>
<p><a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a></p>
<dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga7c3a106198fbf6b07743f082cec761fa" name="ga7c3a106198fbf6b07743f082cec761fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c3a106198fbf6b07743f082cec761fa">&#9670;&#160;</a></span>is_partitioned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto is_partitioned </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned">https://en.cppreference.com/w/cpp/algorithm/is_partitioned</a> </p>

</div>
</div>
<a id="gab7ca70817d9b940ccd963245edb804e7" name="gab7ca70817d9b940ccd963245edb804e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ca70817d9b940ccd963245edb804e7">&#9670;&#160;</a></span>is_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto is_permutation </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given. </p>

</div>
</div>
<a id="gacebb0727381b2818e6575c43ad064189" name="gacebb0727381b2818e6575c43ad064189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacebb0727381b2818e6575c43ad064189">&#9670;&#160;</a></span>is_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto is_permutation </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa25741a63c525afca9eaf8054b7122a9" name="gaa25741a63c525afca9eaf8054b7122a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa25741a63c525afca9eaf8054b7122a9">&#9670;&#160;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order. </p>

</div>
</div>
<a id="gaf0a1d40ec7a46d94456bc76abf70910c" name="gaf0a1d40ec7a46d94456bc76abf70910c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a1d40ec7a46d94456bc76abf70910c">&#9670;&#160;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1eb2f98e7a5c930b843b813c8885ff0e" name="ga1eb2f98e7a5c930b843b813c8885ff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eb2f98e7a5c930b843b813c8885ff0e">&#9670;&#160;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order. </p>

</div>
</div>
<a id="gaa76ed3932bcae919d183136bb3dcf658" name="gaa76ed3932bcae919d183136bb3dcf658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa76ed3932bcae919d183136bb3dcf658">&#9670;&#160;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7a1249aee36691133f6b783a82290f8e" name="ga7a1249aee36691133f6b783a82290f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1249aee36691133f6b783a82290f8e">&#9670;&#160;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto iter_swap </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the values of the elements the given iterators are pointing to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Iterators to the elements to swap. </td></tr>
    <tr><td class="paramname">b</td><td>Iterators to the elements to swap.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/iter_swap">https://en.cppreference.com/w/cpp/algorithm/iter_swap</a> </p>

</div>
</div>
<a id="ga6bbb8794e1a09c00341acc4070284bd3" name="ga6bbb8794e1a09c00341acc4070284bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bbb8794e1a09c00341acc4070284bd3">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>l1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>l2</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gacb90a196cbc728c59a4f2f16a9a9befd" name="gacb90a196cbc728c59a4f2f16a9a9befd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb90a196cbc728c59a4f2f16a9a9befd">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>l1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>l2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare</a> </p>

</div>
</div>
<a id="gaeef2815c598ddf680df6562ff413fc89" name="gaeef2815c598ddf680df6562ff413fc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeef2815c598ddf680df6562ff413fc89">&#9670;&#160;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lower_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7eac84d4e60cc02ce593a33117a79ba3" name="ga7eac84d4e60cc02ce593a33117a79ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eac84d4e60cc02ce593a33117a79ba3">&#9670;&#160;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lower_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a> </p>

</div>
</div>
<a id="ga5f3eca1793f7f38aeb756464984eb194" name="ga5f3eca1793f7f38aeb756464984eb194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3eca1793f7f38aeb756464984eb194">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto max </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b. </p>

</div>
</div>
<a id="gab9b79e7341165c49fa24ea2d66a761a5" name="gab9b79e7341165c49fa24ea2d66a761a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b79e7341165c49fa24ea2d66a761a5">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto max </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b, using a compare function. </p>

</div>
</div>
<a id="ga3b4b38361c7330f3c5996fef40213eed" name="ga3b4b38361c7330f3c5996fef40213eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4b38361c7330f3c5996fef40213eed">&#9670;&#160;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="gac847a74164e6c1a692093c156b35eb30" name="gac847a74164e6c1a692093c156b35eb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac847a74164e6c1a692093c156b35eb30">&#9670;&#160;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="ga2de3be8fc3e9e834497d00be337e09ea" name="ga2de3be8fc3e9e834497d00be337e09ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de3be8fc3e9e834497d00be337e09ea">&#9670;&#160;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto merge </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga390da486f87fc7f5e59fd16cb3015c25" name="ga390da486f87fc7f5e59fd16cb3015c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga390da486f87fc7f5e59fd16cb3015c25">&#9670;&#160;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto merge </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>. </p>

</div>
</div>
<a id="ga9e07086e339175ad2433a095b9205e87" name="ga9e07086e339175ad2433a095b9205e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e07086e339175ad2433a095b9205e87">&#9670;&#160;</a></span>merge_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto merge_sort </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. </p>
<p><a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga0d076e41cf7830be44fc5fc1322d9f49" name="ga0d076e41cf7830be44fc5fc1322d9f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d076e41cf7830be44fc5fc1322d9f49">&#9670;&#160;</a></span>merge_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto merge_sort </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. </p>
<p><a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a> </p><dl class="section note"><dt>Note</dt><dd>Non-standard extension </dd></dl>

</div>
</div>
<a id="ga810b4260b22a58b461be941fa6acb745" name="ga810b4260b22a58b461be941fa6acb745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga810b4260b22a58b461be941fa6acb745">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto min </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b. </p>

</div>
</div>
<a id="ga80c60a3adb053935acbf3c8a91a0a035" name="ga80c60a3adb053935acbf3c8a91a0a035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c60a3adb053935acbf3c8a91a0a035">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto min </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b, using a compare function. </p>

</div>
</div>
<a id="ga4b5571b6aa07c8298071d5e43411200c" name="ga4b5571b6aa07c8298071d5e43411200c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b5571b6aa07c8298071d5e43411200c">&#9670;&#160;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="ga4fb64c2aeca7185a3fdd03bff27f93f2" name="ga4fb64c2aeca7185a3fdd03bff27f93f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb64c2aeca7185a3fdd03bff27f93f2">&#9670;&#160;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="ga8fe7517750d66b576d14d06fd58d74b1" name="ga8fe7517750d66b576d14d06fd58d74b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fe7517750d66b576d14d06fd58d74b1">&#9670;&#160;</a></span>minmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto minmax </td>
          <td>(</td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T const&amp;, T const&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest and the greatest of the given values. </p>

</div>
</div>
<a id="ga2cf8c00a7d8e6e8c5eff71f1063fad52" name="ga2cf8c00a7d8e6e8c5eff71f1063fad52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cf8c00a7d8e6e8c5eff71f1063fad52">&#9670;&#160;</a></span>minmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto minmax </td>
          <td>(</td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T const&amp;, T const&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest and the greatest of the given values. </p>

</div>
</div>
<a id="ga26ee575bad4a7b0cecd1869f7ecdc942" name="ga26ee575bad4a7b0cecd1869f7ecdc942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ee575bad4a7b0cecd1869f7ecdc942">&#9670;&#160;</a></span>minmax_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto minmax_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;ForwardIt, ForwardIt&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest and greatest element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="gaa68fb6c83c244cd496ea25c4f5a9d01f" name="gaa68fb6c83c244cd496ea25c4f5a9d01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa68fb6c83c244cd496ea25c4f5a9d01f">&#9670;&#160;</a></span>minmax_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto minmax_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;ForwardIt, ForwardIt&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest and greatest element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ga272907f42acd772ea50acaa07ffb12aa" name="ga272907f42acd772ea50acaa07ffb12aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272907f42acd772ea50acaa07ffb12aa">&#9670;&#160;</a></span>mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;InputIt1, InputIt2&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The first range of the elements. </td></tr>
    <tr><td class="paramname">last1</td><td>The first range of the elements. </td></tr>
    <tr><td class="paramname">first2</td><td>The second range of the elements. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/mismatch">https://en.cppreference.com/w/cpp/algorithm/mismatch</a> </p>

</div>
</div>
<a id="ga9060e0931516472a88f4657d835684a9" name="ga9060e0931516472a88f4657d835684a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9060e0931516472a88f4657d835684a9">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto move </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/move">https://en.cppreference.com/w/cpp/algorithm/move</a></p>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element past the last element moved.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">destination</td><td>The beginning of the destination range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a2">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaf551d4e71ff0eabb8f92409796fcf33d" name="gaf551d4e71ff0eabb8f92409796fcf33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf551d4e71ff0eabb8f92409796fcf33d">&#9670;&#160;</a></span>move_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt1 , typename BidirIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto move_backward </td>
          <td>(</td>
          <td class="paramtype">BidirIt1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt1</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt2</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; BidirIt2
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/move_backward">https://en.cppreference.com/w/cpp/algorithm/move_backward</a></p>
<dl class="section return"><dt>Returns</dt><dd>Iterator in the destination range, pointing at the last element moved.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">destination</td><td>End of the destination range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga816a532bf04d7e7c0a846b930a571a1d" name="ga816a532bf04d7e7c0a846b930a571a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga816a532bf04d7e7c0a846b930a571a1d">&#9670;&#160;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto none_of </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ga8a975e8950c5e7cc4ff7f97638d34a53" name="ga8a975e8950c5e7cc4ff7f97638d34a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a975e8950c5e7cc4ff7f97638d34a53">&#9670;&#160;</a></span>nth_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto nth_element </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>nth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that: </p>
<ul>
<li>The element pointed at by nth is changed to whatever element would occur in that position if <code>[first, last)</code> were sorted.</li>
<li>All of the elements before this new nth element are less than or equal to the elements after the new nth element.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/nth_element">https://en.cppreference.com/w/cpp/algorithm/nth_element</a> </p>

</div>
</div>
<a id="gaae05431e1f03b692ae88a58f8629a057" name="gaae05431e1f03b692ae88a58f8629a057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae05431e1f03b692ae88a58f8629a057">&#9670;&#160;</a></span>partial_sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto partial_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/partial_sort">https://en.cppreference.com/w/cpp/algorithm/partial_sort</a> </p>

</div>
</div>
<a id="ga58dc6d94b5e29f2351debc8dff607246" name="ga58dc6d94b5e29f2351debc8dff607246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58dc6d94b5e29f2351debc8dff607246">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto partition </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved. </p>

</div>
</div>
<a id="gac406ce808473104b511907657832cd92" name="gac406ce808473104b511907657832cd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac406ce808473104b511907657832cd92">&#9670;&#160;</a></span>partition_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt1 , typename OutputIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto partition_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt1</td>          <td class="paramname"><span class="paramname"><em>destinationTrue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt2</td>          <td class="paramname"><span class="paramname"><em>destinationFalse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;OutputIt1, OutputIt2&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false. </p>
<p>The behavior is undefined if the input range overlaps either of the output ranges. </p>

</div>
</div>
<a id="ga59eeccfe79ec5ab27f96d577417ca35a" name="ga59eeccfe79ec5ab27f96d577417ca35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59eeccfe79ec5ab27f96d577417ca35a">&#9670;&#160;</a></span>partition_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto partition_point </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p. </p>

</div>
</div>
<a id="ga1ecba2ecefe71607f67bec456ff072fd" name="ga1ecba2ecefe71607f67bec456ff072fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ecba2ecefe71607f67bec456ff072fd">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto remove </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range. </p>

</div>
</div>
<a id="gaafdb5717541ddef9974357131dc1d248" name="gaafdb5717541ddef9974357131dc1d248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafdb5717541ddef9974357131dc1d248">&#9670;&#160;</a></span>remove_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto remove_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element copied. </dd></dl>

</div>
</div>
<a id="ga8bdbbf4b495def4cb406f6af3ef25882" name="ga8bdbbf4b495def4cb406f6af3ef25882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bdbbf4b495def4cb406f6af3ef25882">&#9670;&#160;</a></span>remove_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element copied. </dd></dl>

</div>
</div>
<a id="ga22cf73ac58ec2b4dd086be384cbbdd7d" name="ga22cf73ac58ec2b4dd086be384cbbdd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22cf73ac58ec2b4dd086be384cbbdd7d">&#9670;&#160;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto remove_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range. </p>

</div>
</div>
<a id="ga7e970687eb65ad36a17922ed1be6764a" name="ga7e970687eb65ad36a17922ed1be6764a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e970687eb65ad36a17922ed1be6764a">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto replace </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>oldValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value. </p>

</div>
</div>
<a id="ga13040e3fc5925b1bc966782f36635444" name="ga13040e3fc5925b1bc966782f36635444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13040e3fc5925b1bc966782f36635444">&#9670;&#160;</a></span>replace_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto replace_if </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true. </p>

</div>
</div>
<a id="gabf3169a8bd10088a7cf7d65b8aae66bc" name="gabf3169a8bd10088a7cf7d65b8aae66bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf3169a8bd10088a7cf7d65b8aae66bc">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto reverse </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ga5067524643b55244e12cb5eed183ddae" name="ga5067524643b55244e12cb5eed183ddae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5067524643b55244e12cb5eed183ddae">&#9670;&#160;</a></span>reverse_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto reverse_copy </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order. </p>
<p>If the source and destination ranges (that is, <code>[first, last)</code> and [d_first, d_first+(last-first)) respectively) overlap, the behavior is undefined. </p>

</div>
</div>
<a id="ga99d4db23a06789c303ee8ec693d84129" name="ga99d4db23a06789c303ee8ec693d84129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99d4db23a06789c303ee8ec693d84129">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rotate </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>nFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotation on a range of elements. </p>
<p>Specifically, rotate swaps the elements in the range [first, last) in such a way that the element n_first becomes the first element of the new range and n_first - 1 becomes the last element. A precondition of this function is that [first, n_first) and [n_first, last) are valid ranges. </p>

</div>
</div>
<a id="ga8e3ea43eb370058e059c95c0738eb379" name="ga8e3ea43eb370058e059c95c0738eb379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e3ea43eb370058e059c95c0738eb379">&#9670;&#160;</a></span>rotate_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rotate_copy </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>nFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element. </p>

</div>
</div>
<a id="ga8ec0297d32d2f51e39c270a715b430d1" name="ga8ec0297d32d2f51e39c270a715b430d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ec0297d32d2f51e39c270a715b430d1">&#9670;&#160;</a></span>search() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIt , typename Searcher &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto search </td>
          <td>(</td>
          <td class="paramtype">FwdIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Searcher const &amp;</td>          <td class="paramname"><span class="paramname"><em>searcher</em></span>&#160;) -&gt; FwdIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/search">https://en.cppreference.com/w/cpp/algorithm/search</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fd9a9ec8c617610bf30e92fbaa678cd" name="ga9fd9a9ec8c617610bf30e92fbaa678cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fd9a9ec8c617610bf30e92fbaa678cd">&#9670;&#160;</a></span>search() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIt1 , typename FwdIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto search </td>
          <td>(</td>
          <td class="paramtype">FwdIt1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt1</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt2</td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt2</td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; FwdIt1
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/search">https://en.cppreference.com/w/cpp/algorithm/search</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e" name="gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e">&#9670;&#160;</a></span>search() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIt1 , typename FwdIt2 , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto search </td>
          <td>(</td>
          <td class="paramtype">FwdIt1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt1</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt2</td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIt2</td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; FwdIt1
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/search">https://en.cppreference.com/w/cpp/algorithm/search</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52038b2431b48b42d039e54647d96493" name="ga52038b2431b48b42d039e54647d96493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52038b2431b48b42d039e54647d96493">&#9670;&#160;</a></span>search_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Size , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto search_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value. </p>

</div>
</div>
<a id="ga07b828a0b5a5e92873f178d30c4bb9df" name="ga07b828a0b5a5e92873f178d30c4bb9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b828a0b5a5e92873f178d30c4bb9df">&#9670;&#160;</a></span>search_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Size , typename ValueT , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto search_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value. </p>

</div>
</div>
<a id="gabf15d37410e2266762deefec2f9552e2" name="gabf15d37410e2266762deefec2f9552e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf15d37410e2266762deefec2f9552e2">&#9670;&#160;</a></span>set_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same. </p>

</div>
</div>
<a id="gafe32b3c3b80a92b66e5d7f118439492e" name="gafe32b3c3b80a92b66e5d7f118439492e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe32b3c3b80a92b66e5d7f118439492e">&#9670;&#160;</a></span>set_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same. </p>

</div>
</div>
<a id="gac046bcca7d511bae026125e54c1f20e7" name="gac046bcca7d511bae026125e54c1f20e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac046bcca7d511bae026125e54c1f20e7">&#9670;&#160;</a></span>set_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="gacfa483f6d503afb56bafdb6c73eebdd8" name="gacfa483f6d503afb56bafdb6c73eebdd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfa483f6d503afb56bafdb6c73eebdd8">&#9670;&#160;</a></span>set_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="ga5c80d1254a7659943993cacc3498dc38" name="ga5c80d1254a7659943993cacc3498dc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c80d1254a7659943993cacc3498dc38">&#9670;&#160;</a></span>set_symmetric_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at destination. The resulting range is also sorted. </p>

</div>
</div>
<a id="ga4249908e93f7b1367d3605c52b20a842" name="ga4249908e93f7b1367d3605c52b20a842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4249908e93f7b1367d3605c52b20a842">&#9670;&#160;</a></span>set_symmetric_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at destination. The resulting range is also sorted. </p>

</div>
</div>
<a id="ga4135eaec81217633145f410048de3cbe" name="ga4135eaec81217633145f410048de3cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4135eaec81217633145f410048de3cbe">&#9670;&#160;</a></span>set_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_union </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="gacfd656aa427e48301b6fd14503854ff7" name="gacfd656aa427e48301b6fd14503854ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfd656aa427e48301b6fd14503854ff7">&#9670;&#160;</a></span>set_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto set_union </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="ga2a6d3457c4b1a845dce8219245bbc31c" name="ga2a6d3457c4b1a845dce8219245bbc31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a6d3457c4b1a845dce8219245bbc31c">&#9670;&#160;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto shift_left </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt const</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; ForwardIt &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the elements in the range [first, last) by n positions. </p>
<p>Shifts the elements towards the beginning of the range. If n == 0 or n &gt;= last - first, there are no effects. If n &lt; 0, the behavior is undefined. Otherwise, for every integer i in [0, last - first - n), moves the element originally at position first + n + i to position first + i. The moves are performed in increasing order of i starting from 0. </p>

</div>
</div>
<a id="ga465e2a36ddbbed9d12ad5403dccbb7b3" name="ga465e2a36ddbbed9d12ad5403dccbb7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga465e2a36ddbbed9d12ad5403dccbb7b3">&#9670;&#160;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidiIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto shift_right </td>
          <td>(</td>
          <td class="paramtype">BidiIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidiIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; BidiIt &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; BidiIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the elements in the range [first, last) by n positions. </p>
<p>Shifts the elements towards the end of the range. If n &lt;= 0 or n &gt;= last - first, there are no effects. Otherwise, for every integer i in [0, last - first - n), moves the element originally at position first + i to position first + n + i.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/shift">https://en.cppreference.com/w/cpp/algorithm/shift</a></p>
<dl class="section note"><dt>Note</dt><dd>The standard specifies that this algorithm should also work with legacy forward iterators. I don't know how to implement that without dynamic memory, so forward iterators are not supported. </dd></dl>

</div>
</div>
<a id="ga9823f4c1911f50c9f7ac3b4a8be9f294" name="ga9823f4c1911f50c9f7ac3b4a8be9f294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9823f4c1911f50c9f7ac3b4a8be9f294">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is not guaranteed to be preserved.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a> </p>

</div>
</div>
<a id="gad5ef221b98a814660142c728ce9bac78" name="gad5ef221b98a814660142c728ce9bac78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5ef221b98a814660142c728ce9bac78">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is not guaranteed to be preserved.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a> </p>

</div>
</div>
<a id="ga0402fada51d792d7500e9a8f196eb649" name="ga0402fada51d792d7500e9a8f196eb649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0402fada51d792d7500e9a8f196eb649">&#9670;&#160;</a></span>stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stable_partition </td>
          <td>(</td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; BidirIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved. </p>

</div>
</div>
<a id="gab57756439702cf72053e29b5c7294d85" name="gab57756439702cf72053e29b5c7294d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57756439702cf72053e29b5c7294d85">&#9670;&#160;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stable_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved. Elements are compared using the given comparison function comp.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a> </p>

</div>
</div>
<a id="ga555004d15f48a5bb9b71103bcc3e1555" name="ga555004d15f48a5bb9b71103bcc3e1555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555004d15f48a5bb9b71103bcc3e1555">&#9670;&#160;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stable_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved. Elements are compared using the given comparison function comp.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a> </p>

</div>
</div>
<a id="gaa8e235b7f1654c13232e768201e17f4a" name="gaa8e235b7f1654c13232e768201e17f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8e235b7f1654c13232e768201e17f4a">&#9670;&#160;</a></span>swap_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto swap_ranges </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; ForwardIt2
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The first range of elements to swap. </td></tr>
    <tr><td class="paramname">last1</td><td>The first range of elements to swap. </td></tr>
    <tr><td class="paramname">first2</td><td>Beginning of the second range of elements to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element exchanged in the range beginning with <code>first2</code>.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap_ranges">https://en.cppreference.com/w/cpp/algorithm/swap_ranges</a> </p>

</div>
</div>
<a id="ga0d479673068495c0b88dcd93a99dfb57" name="ga0d479673068495c0b88dcd93a99dfb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d479673068495c0b88dcd93a99dfb57">&#9670;&#160;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename UnaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto transform </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by <code>[first, last)</code>.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">last</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">dest</td><td>The beginning of the destination range, may be equal to first. </td></tr>
    <tr><td class="paramname">op</td><td>Unary operation function object that will be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_8cpp-example.html#a4">string.cpp</a>, and <a class="el" href="vector_8cpp-example.html#a2">vector.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaa4f1eb9069005465b67c5d79eaae8bb9" name="gaa4f1eb9069005465b67c5d79eaae8bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f1eb9069005465b67c5d79eaae8bb9">&#9670;&#160;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename OutputIt , typename BinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto transform </td>
          <td>(</td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1</td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2</td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by <code>[first, last)</code>.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">last</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">dest</td><td>The beginning of the destination range, may be equal to first. </td></tr>
    <tr><td class="paramname">op</td><td>Unary operation function object that will be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf368b8bc471211756f0fd32f9d2c8968" name="gaf368b8bc471211756f0fd32f9d2c8968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf368b8bc471211756f0fd32f9d2c8968">&#9670;&#160;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="ga99f27339834dd24fea714a4b4ef5b383" name="ga99f27339834dd24fea714a4b4ef5b383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99f27339834dd24fea714a4b4ef5b383">&#9670;&#160;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="ga18330134b5b5074b665d9e91c994f5e2" name="ga18330134b5b5074b665d9e91c994f5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18330134b5b5074b665d9e91c994f5e2">&#9670;&#160;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.</p>
<p>Elements are compared using the given binary predicate pred. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="ga6aefae29604dcd0147171f39aa1380be" name="ga6aefae29604dcd0147171f39aa1380be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aefae29604dcd0147171f39aa1380be">&#9670;&#160;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; OutputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.</p>
<p>Elements are compared using the given binary predicate pred. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="ga25261717b25b3523e4fdb8d6420183d2" name="ga25261717b25b3523e4fdb8d6420183d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25261717b25b3523e4fdb8d6420183d2">&#9670;&#160;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto upper_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than <code>value</code>, or last if no such element is found.</p>
<p>The range <code>[first, last)</code> must be partitioned with respect to the expression <code>not (value &lt; element)</code> or <code>not comp(value, element)</code>, i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion. </p>

</div>
</div>
<a id="gad3130ebfc35a09b9488d205269fdac86" name="gad3130ebfc35a09b9488d205269fdac86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3130ebfc35a09b9488d205269fdac86">&#9670;&#160;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto upper_bound </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; ForwardIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than <code>value</code>, or last if no such element is found.</p>
<p>The range <code>[first, last)</code> must be partitioned with respect to the expression <code>not (value &lt; element)</code> or <code>not comp(value, element)</code>, i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Apr 26 2024 01:22:31 for tetl by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
