<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: char_traits&lt; char &gt; Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structetl_1_1char__traits_3_01char_01_4.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structetl_1_1char__traits_3_01char_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">char_traits&lt; char &gt; Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="char__traits_8hpp_source.html">char_traits.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0593aeccf22bdbcc27279257d3428eb5" id="r_a0593aeccf22bdbcc27279257d3428eb5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> = char</td></tr>
<tr class="separator:a0593aeccf22bdbcc27279257d3428eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae393554d5d9cb600f54c85049c15df9f" id="r_ae393554d5d9cb600f54c85049c15df9f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a> = int</td></tr>
<tr class="separator:ae393554d5d9cb600f54c85049c15df9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f913e9bcc697e6ef5d34ecf1a894b7b" id="r_a1f913e9bcc697e6ef5d34ecf1a894b7b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f913e9bcc697e6ef5d34ecf1a894b7b">off_type</a> = <a class="el" href="namespaceetl.html#a66b66173615e2c5f0568adb2cae8739f">streamoff</a></td></tr>
<tr class="separator:a1f913e9bcc697e6ef5d34ecf1a894b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe3507e677b9b4dccf456cb9182a19a4" id="r_abe3507e677b9b4dccf456cb9182a19a4"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe3507e677b9b4dccf456cb9182a19a4">assign</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> &amp;a, <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const &amp;b) noexcept -&gt; void</td></tr>
<tr class="memdesc:abe3507e677b9b4dccf456cb9182a19a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns character a to character r.  <br /></td></tr>
<tr class="separator:abe3507e677b9b4dccf456cb9182a19a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a8ec5d4879b97d1a16db15332da251" id="r_a32a8ec5d4879b97d1a16db15332da251"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32a8ec5d4879b97d1a16db15332da251">assign</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *str, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> token) -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *</td></tr>
<tr class="memdesc:a32a8ec5d4879b97d1a16db15332da251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns character a to each character in count characters in the character sequence pointed to by p.  <br /></td></tr>
<tr class="separator:a32a8ec5d4879b97d1a16db15332da251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599e2f31138ba3b6c4eb250d9f1242de" id="r_a599e2f31138ba3b6c4eb250d9f1242de"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a599e2f31138ba3b6c4eb250d9f1242de">compare</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *lhs, <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *rhs, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; int</td></tr>
<tr class="memdesc:a599e2f31138ba3b6c4eb250d9f1242de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first count characters of the character strings s1 and s2. The comparison is done lexicographically. If count is zero, strings are considered equal.  <br /></td></tr>
<tr class="separator:a599e2f31138ba3b6c4eb250d9f1242de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ed2dd8708c8f94c98ed98e132313aa" id="r_a92ed2dd8708c8f94c98ed98e132313aa"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92ed2dd8708c8f94c98ed98e132313aa">copy</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *dest, <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *source, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *</td></tr>
<tr class="memdesc:a92ed2dd8708c8f94c98ed98e132313aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies count characters from the character string pointed to by src to the character string pointed to by dest. Formally, for each i in [0, count), performs assign(src[i], dest[i]). The behavior is undefined if copied character ranges overlap, i.e. src is in [dest, dest + count).  <br /></td></tr>
<tr class="separator:a92ed2dd8708c8f94c98ed98e132313aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb65c73e0db1fa2c27391c96f92193b3" id="r_abb65c73e0db1fa2c27391c96f92193b3"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb65c73e0db1fa2c27391c96f92193b3">eof</a> () noexcept -&gt; <a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a></td></tr>
<tr class="memdesc:abb65c73e0db1fa2c27391c96f92193b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value not equivalent to any valid value of type char_type. Formally, returns a value e such that char_type&lt;char&gt;::eq_int_type(e, char_type&lt;char&gt;::to_int_type(c)) is false for all values c.  <br /></td></tr>
<tr class="separator:abb65c73e0db1fa2c27391c96f92193b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b0f876cdd15eb8a86d3b63f6426c58" id="r_a03b0f876cdd15eb8a86d3b63f6426c58"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03b0f876cdd15eb8a86d3b63f6426c58">eq</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> a, <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> b) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a03b0f876cdd15eb8a86d3b63f6426c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a and b are equal, false otherwise.  <br /></td></tr>
<tr class="separator:a03b0f876cdd15eb8a86d3b63f6426c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8de114e974f5af8355458d47bd5f9f" id="r_add8de114e974f5af8355458d47bd5f9f"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add8de114e974f5af8355458d47bd5f9f">eq_int_type</a> (<a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a> lhs, <a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a> rhs) noexcept -&gt; bool</td></tr>
<tr class="memdesc:add8de114e974f5af8355458d47bd5f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two values of type int_type are equal.  <br /></td></tr>
<tr class="separator:add8de114e974f5af8355458d47bd5f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab58c0046e9a8344db387edfa96fa36c" id="r_aab58c0046e9a8344db387edfa96fa36c"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab58c0046e9a8344db387edfa96fa36c">find</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *str, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const &amp;token) -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *</td></tr>
<tr class="memdesc:aab58c0046e9a8344db387edfa96fa36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for character ch within the first count characters of the sequence pointed to by p.  <br /></td></tr>
<tr class="separator:aab58c0046e9a8344db387edfa96fa36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8650a329c0e55a20d0bb7417adad8aa" id="r_ac8650a329c0e55a20d0bb7417adad8aa"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8650a329c0e55a20d0bb7417adad8aa">length</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *str) -&gt; <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a></td></tr>
<tr class="memdesc:ac8650a329c0e55a20d0bb7417adad8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the character sequence pointed to by s, that is, the position of the terminating null character (CharT()).  <br /></td></tr>
<tr class="separator:ac8650a329c0e55a20d0bb7417adad8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c40a37733186e4cbd6671071e50c3ce" id="r_a1c40a37733186e4cbd6671071e50c3ce"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c40a37733186e4cbd6671071e50c3ce">lt</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> a, <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> b) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a1c40a37733186e4cbd6671071e50c3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is less than b, false otherwise.  <br /></td></tr>
<tr class="separator:a1c40a37733186e4cbd6671071e50c3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317db77855d8c0784da4368d803e6b03" id="r_a317db77855d8c0784da4368d803e6b03"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a317db77855d8c0784da4368d803e6b03">move</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *dest, <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *source, <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *</td></tr>
<tr class="memdesc:a317db77855d8c0784da4368d803e6b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies count characters from the character string pointed to by src to the character string pointed to by dest. Performs correctly even if the copied character ranges overlap, i.e. src is in [dest, dest + count).  <br /></td></tr>
<tr class="separator:a317db77855d8c0784da4368d803e6b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfe7ca47b0e7979c2f368d009ec238" id="r_a90cfe7ca47b0e7979c2f368d009ec238"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90cfe7ca47b0e7979c2f368d009ec238">not_eof</a> (<a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a> c) noexcept -&gt; <a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a></td></tr>
<tr class="memdesc:a90cfe7ca47b0e7979c2f368d009ec238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether e is not equivalent to eof value.  <br /></td></tr>
<tr class="separator:a90cfe7ca47b0e7979c2f368d009ec238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf4022594d376da39069b5b366984d" id="r_acdaf4022594d376da39069b5b366984d"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdaf4022594d376da39069b5b366984d">to_char_type</a> (<a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a> c) noexcept -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a></td></tr>
<tr class="memdesc:acdaf4022594d376da39069b5b366984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of int_type to char_type. If there are no equivalent value (such as when c is a copy of the <a class="el" href="#abb65c73e0db1fa2c27391c96f92193b3" title="Returns a value not equivalent to any valid value of type char_type. Formally, returns a value e such...">eof()</a> value), the result is unspecified. Formally, returns the value x such that char_type&lt;char&gt;::eq_int_type(c, char_type&lt;char&gt;::to_int_type(x)) is true, and an unspecified value if no such x exists.  <br /></td></tr>
<tr class="separator:acdaf4022594d376da39069b5b366984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487611715fbf2e1696439aa073f1790f" id="r_a487611715fbf2e1696439aa073f1790f"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a487611715fbf2e1696439aa073f1790f">to_int_type</a> (<a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> c) noexcept -&gt; <a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a></td></tr>
<tr class="memdesc:a487611715fbf2e1696439aa073f1790f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of char_type to int_type.  <br /></td></tr>
<tr class="separator:a487611715fbf2e1696439aa073f1790f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0593aeccf22bdbcc27279257d3428eb5" name="a0593aeccf22bdbcc27279257d3428eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0593aeccf22bdbcc27279257d3428eb5">&#9670;&#160;</a></span>char_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> = char</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae393554d5d9cb600f54c85049c15df9f" name="ae393554d5d9cb600f54c85049c15df9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae393554d5d9cb600f54c85049c15df9f">&#9670;&#160;</a></span>int_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a> = int</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f913e9bcc697e6ef5d34ecf1a894b7b" name="a1f913e9bcc697e6ef5d34ecf1a894b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f913e9bcc697e6ef5d34ecf1a894b7b">&#9670;&#160;</a></span>off_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1f913e9bcc697e6ef5d34ecf1a894b7b">off_type</a> = <a class="el" href="namespaceetl.html#a66b66173615e2c5f0568adb2cae8739f">streamoff</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abe3507e677b9b4dccf456cb9182a19a4" name="abe3507e677b9b4dccf456cb9182a19a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3507e677b9b4dccf456cb9182a19a4">&#9670;&#160;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; void </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns character a to character r. </p>

</div>
</div>
<a id="a32a8ec5d4879b97d1a16db15332da251" name="a32a8ec5d4879b97d1a16db15332da251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a8ec5d4879b97d1a16db15332da251">&#9670;&#160;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a></td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;) -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a>*
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns character a to each character in count characters in the character sequence pointed to by p. </p>

</div>
</div>
<a id="a599e2f31138ba3b6c4eb250d9f1242de" name="a599e2f31138ba3b6c4eb250d9f1242de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599e2f31138ba3b6c4eb250d9f1242de">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; int
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first count characters of the character strings s1 and s2. The comparison is done lexicographically. If count is zero, strings are considered equal. </p>

</div>
</div>
<a id="a92ed2dd8708c8f94c98ed98e132313aa" name="a92ed2dd8708c8f94c98ed98e132313aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ed2dd8708c8f94c98ed98e132313aa">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a>*
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies count characters from the character string pointed to by src to the character string pointed to by dest. Formally, for each i in [0, count), performs assign(src[i], dest[i]). The behavior is undefined if copied character ranges overlap, i.e. src is in [dest, dest + count). </p>

</div>
</div>
<a id="abb65c73e0db1fa2c27391c96f92193b3" name="abb65c73e0db1fa2c27391c96f92193b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb65c73e0db1fa2c27391c96f92193b3">&#9670;&#160;</a></span>eof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eof </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value not equivalent to any valid value of type char_type. Formally, returns a value e such that char_type&lt;char&gt;::eq_int_type(e, char_type&lt;char&gt;::to_int_type(c)) is false for all values c. </p>

</div>
</div>
<a id="a03b0f876cdd15eb8a86d3b63f6426c58" name="a03b0f876cdd15eb8a86d3b63f6426c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b0f876cdd15eb8a86d3b63f6426c58">&#9670;&#160;</a></span>eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a and b are equal, false otherwise. </p>

</div>
</div>
<a id="add8de114e974f5af8355458d47bd5f9f" name="add8de114e974f5af8355458d47bd5f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8de114e974f5af8355458d47bd5f9f">&#9670;&#160;</a></span>eq_int_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eq_int_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether two values of type int_type are equal. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/char_traits/eq_int_type">https://en.cppreference.com/w/cpp/string/char_traits/eq_int_type</a> </p>

</div>
</div>
<a id="aab58c0046e9a8344db387edfa96fa36c" name="aab58c0046e9a8344db387edfa96fa36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab58c0046e9a8344db387edfa96fa36c">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;) -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const*
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for character ch within the first count characters of the sequence pointed to by p. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first character in the range specified by [p, p<ul>
<li>count) that compares equal to ch, or a null pointer if not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac8650a329c0e55a20d0bb7417adad8aa" name="ac8650a329c0e55a20d0bb7417adad8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8650a329c0e55a20d0bb7417adad8aa">&#9670;&#160;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the character sequence pointed to by s, that is, the position of the terminating null character (CharT()). </p>

</div>
</div>
<a id="a1c40a37733186e4cbd6671071e50c3ce" name="a1c40a37733186e4cbd6671071e50c3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c40a37733186e4cbd6671071e50c3ce">&#9670;&#160;</a></span>lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a is less than b, false otherwise. </p>

</div>
</div>
<a id="a317db77855d8c0784da4368d803e6b03" name="a317db77855d8c0784da4368d803e6b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317db77855d8c0784da4368d803e6b03">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a> const *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#aee50235c04ef643cb7502785393220fe">size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a>*
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies count characters from the character string pointed to by src to the character string pointed to by dest. Performs correctly even if the copied character ranges overlap, i.e. src is in [dest, dest + count). </p>

</div>
</div>
<a id="a90cfe7ca47b0e7979c2f368d009ec238" name="a90cfe7ca47b0e7979c2f368d009ec238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cfe7ca47b0e7979c2f368d009ec238">&#9670;&#160;</a></span>not_eof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto not_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether e is not equivalent to eof value. </p>
<p>Formally if char_type&lt;char&gt;::eq_int_type(e,
char_type&lt;char&gt;::eof()) is false, returns e otherwise, returns a value f such that char_type&lt;char&gt;::eq_int_type(f, char_type&lt;char&gt;::eof()) is false </p>

</div>
</div>
<a id="acdaf4022594d376da39069b5b366984d" name="acdaf4022594d376da39069b5b366984d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaf4022594d376da39069b5b366984d">&#9670;&#160;</a></span>to_char_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto to_char_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a value of int_type to char_type. If there are no equivalent value (such as when c is a copy of the <a class="el" href="#abb65c73e0db1fa2c27391c96f92193b3" title="Returns a value not equivalent to any valid value of type char_type. Formally, returns a value e such...">eof()</a> value), the result is unspecified. Formally, returns the value x such that char_type&lt;char&gt;::eq_int_type(c, char_type&lt;char&gt;::to_int_type(x)) is true, and an unspecified value if no such x exists. </p>

</div>
</div>
<a id="a487611715fbf2e1696439aa073f1790f" name="a487611715fbf2e1696439aa073f1790f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487611715fbf2e1696439aa073f1790f">&#9670;&#160;</a></span>to_int_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto to_int_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0593aeccf22bdbcc27279257d3428eb5">char_type</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae393554d5d9cb600f54c85049c15df9f">int_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a value of char_type to int_type. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/etl/_string/<a class="el" href="char__traits_8hpp_source.html">char_traits.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html">char_traits&lt; char &gt;</a></li>
    <li class="footer">Generated on Tue Apr 16 2024 22:54:16 for tetl by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
