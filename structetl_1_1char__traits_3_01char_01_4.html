<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl::char_traits&lt; char &gt; Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tetl
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structetl_1_1char__traits_3_01char_01_4.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structetl_1_1char__traits_3_01char_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">etl::char_traits&lt; char &gt; Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char.  
 <a href="structetl_1_1char__traits_3_01char_01_4.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a03dfad65d012abdd4a79dd2f53802c60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> = char</td></tr>
<tr class="separator:a03dfad65d012abdd4a79dd2f53802c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96632c8decf0199053db5e32953ffbc9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a> = int</td></tr>
<tr class="separator:a96632c8decf0199053db5e32953ffbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3789287df9c2cbf14f3eb139e96369e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#aa3789287df9c2cbf14f3eb139e96369e">off_type</a> = <a class="el" href="namespaceetl.html#a8cc54c8127416c33c963bee08bc99596">streamoff</a></td></tr>
<tr class="separator:aa3789287df9c2cbf14f3eb139e96369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa4255c745f78d8d6bb370e1540985873"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#aa4255c745f78d8d6bb370e1540985873">assign</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> &amp;a, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const &amp;<a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; void</td></tr>
<tr class="memdesc:aa4255c745f78d8d6bb370e1540985873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns character a to character r.  <a href="structetl_1_1char__traits_3_01char_01_4.html#aa4255c745f78d8d6bb370e1540985873">More...</a><br /></td></tr>
<tr class="separator:aa4255c745f78d8d6bb370e1540985873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db65997c7eb8713b57f4d1f4591f4cc"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a6db65997c7eb8713b57f4d1f4591f4cc">eq</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> a, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a6db65997c7eb8713b57f4d1f4591f4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a and b are equal, false otherwise.  <a href="structetl_1_1char__traits_3_01char_01_4.html#a6db65997c7eb8713b57f4d1f4591f4cc">More...</a><br /></td></tr>
<tr class="separator:a6db65997c7eb8713b57f4d1f4591f4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94947f0afe5659c8876c65080be077c2"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a94947f0afe5659c8876c65080be077c2">lt</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> a, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> <a class="el" href="namespaceetl.html#a18b6c2ea4f13089ede1a42514f87e6c6">b</a>) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:a94947f0afe5659c8876c65080be077c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is less than b, false otherwise.  <a href="structetl_1_1char__traits_3_01char_01_4.html#a94947f0afe5659c8876c65080be077c2">More...</a><br /></td></tr>
<tr class="separator:a94947f0afe5659c8876c65080be077c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7be30969dd56e6084b467d0d7b14c8"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a6d7be30969dd56e6084b467d0d7b14c8">compare</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *<a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *rhs, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; int</td></tr>
<tr class="memdesc:a6d7be30969dd56e6084b467d0d7b14c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first count characters of the character strings s1 and s2. The comparison is done lexicographically. If count is zero, strings are considered equal.  <a href="structetl_1_1char__traits_3_01char_01_4.html#a6d7be30969dd56e6084b467d0d7b14c8">More...</a><br /></td></tr>
<tr class="separator:a6d7be30969dd56e6084b467d0d7b14c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec57591fba911fe5f55c5fc416dab59"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a2ec57591fba911fe5f55c5fc416dab59">length</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *str) -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a></td></tr>
<tr class="memdesc:a2ec57591fba911fe5f55c5fc416dab59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the character sequence pointed to by s, that is, the position of the terminating null character (CharT()).  <a href="structetl_1_1char__traits_3_01char_01_4.html#a2ec57591fba911fe5f55c5fc416dab59">More...</a><br /></td></tr>
<tr class="separator:a2ec57591fba911fe5f55c5fc416dab59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ee8c86549d889cb3e6fe01d2c9d7ab"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a63ee8c86549d889cb3e6fe01d2c9d7ab">find</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const &amp;token) -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *</td></tr>
<tr class="memdesc:a63ee8c86549d889cb3e6fe01d2c9d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for character ch within the first count characters of the sequence pointed to by p.  <a href="structetl_1_1char__traits_3_01char_01_4.html#a63ee8c86549d889cb3e6fe01d2c9d7ab">More...</a><br /></td></tr>
<tr class="separator:a63ee8c86549d889cb3e6fe01d2c9d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d1cc5ce8812b37b1dbaf79f2bfae3"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a0e7d1cc5ce8812b37b1dbaf79f2bfae3">move</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *dest, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *source, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *</td></tr>
<tr class="memdesc:a0e7d1cc5ce8812b37b1dbaf79f2bfae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies count characters from the character string pointed to by src to the character string pointed to by dest. Performs correctly even if the copied character ranges overlap, i.e. src is in [dest, dest + count).  <a href="structetl_1_1char__traits_3_01char_01_4.html#a0e7d1cc5ce8812b37b1dbaf79f2bfae3">More...</a><br /></td></tr>
<tr class="separator:a0e7d1cc5ce8812b37b1dbaf79f2bfae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845e942bb17f321f36ea246c7bc668b4"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a845e942bb17f321f36ea246c7bc668b4">copy</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *dest, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *source, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *</td></tr>
<tr class="memdesc:a845e942bb17f321f36ea246c7bc668b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies count characters from the character string pointed to by src to the character string pointed to by dest. Formally, for each i in [0, count), performs assign(src[i], dest[i]). The behavior is undefined if copied character ranges overlap, i.e. src is in [dest, dest + count).  <a href="structetl_1_1char__traits_3_01char_01_4.html#a845e942bb17f321f36ea246c7bc668b4">More...</a><br /></td></tr>
<tr class="separator:a845e942bb17f321f36ea246c7bc668b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7970b003d44734d2816961ebce54ca6d"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a7970b003d44734d2816961ebce54ca6d">assign</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *str, <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> <a class="el" href="namespaceetl.html#a3f9162720047d01bb438874bf56df5d2">count</a>, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> token) -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *</td></tr>
<tr class="memdesc:a7970b003d44734d2816961ebce54ca6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns character a to each character in count characters in the character sequence pointed to by p.  <a href="structetl_1_1char__traits_3_01char_01_4.html#a7970b003d44734d2816961ebce54ca6d">More...</a><br /></td></tr>
<tr class="separator:a7970b003d44734d2816961ebce54ca6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa018f7cc938b211975ec578ef3d4aeda"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#aa018f7cc938b211975ec578ef3d4aeda">to_char_type</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a> c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a></td></tr>
<tr class="memdesc:aa018f7cc938b211975ec578ef3d4aeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of int_type to char_type. If there are no equivalent value (such as when c is a copy of the <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#aa86eda99364036341c5992fcdbadaeae" title="Returns a value not equivalent to any valid value of type char_type. Formally, returns a value e such...">eof()</a> value), the result is unspecified. Formally, returns the value x such that char_type&lt;char&gt;::eq_int_type(c, char_type&lt;char&gt;::to_int_type(x)) is true, and an unspecified value if no such x exists.  <a href="structetl_1_1char__traits_3_01char_01_4.html#aa018f7cc938b211975ec578ef3d4aeda">More...</a><br /></td></tr>
<tr class="separator:aa018f7cc938b211975ec578ef3d4aeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1c7fd93cb1bd30ef3a10c9bd2f8ecf"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a1b1c7fd93cb1bd30ef3a10c9bd2f8ecf">to_int_type</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a></td></tr>
<tr class="memdesc:a1b1c7fd93cb1bd30ef3a10c9bd2f8ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value of char_type to int_type.  <a href="structetl_1_1char__traits_3_01char_01_4.html#a1b1c7fd93cb1bd30ef3a10c9bd2f8ecf">More...</a><br /></td></tr>
<tr class="separator:a1b1c7fd93cb1bd30ef3a10c9bd2f8ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6943e340e51a943cb51d42cd08eab5"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#aeb6943e340e51a943cb51d42cd08eab5">eq_int_type</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a> <a class="el" href="namespaceetl.html#a90533d8a4222a3a68dfc34fcd9b9e3a1">lhs</a>, <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a> rhs) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; bool</td></tr>
<tr class="memdesc:aeb6943e340e51a943cb51d42cd08eab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two values of type int_type are equal.  <a href="structetl_1_1char__traits_3_01char_01_4.html#aeb6943e340e51a943cb51d42cd08eab5">More...</a><br /></td></tr>
<tr class="separator:aeb6943e340e51a943cb51d42cd08eab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86eda99364036341c5992fcdbadaeae"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#aa86eda99364036341c5992fcdbadaeae">eof</a> () <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a></td></tr>
<tr class="memdesc:aa86eda99364036341c5992fcdbadaeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value not equivalent to any valid value of type char_type. Formally, returns a value e such that char_type&lt;char&gt;::eq_int_type(e, char_type&lt;char&gt;::to_int_type(c)) is false for all values c.  <a href="structetl_1_1char__traits_3_01char_01_4.html#aa86eda99364036341c5992fcdbadaeae">More...</a><br /></td></tr>
<tr class="separator:aa86eda99364036341c5992fcdbadaeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94114d1441ed1dfa598bbc4ccb08ba7"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#ac94114d1441ed1dfa598bbc4ccb08ba7">not_eof</a> (<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a> c) <a class="el" href="namespaceetl.html#a5489a5258551040b63e6eef9f49264d8">noexcept</a> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a></td></tr>
<tr class="memdesc:ac94114d1441ed1dfa598bbc4ccb08ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether e is not equivalent to eof value.  <a href="structetl_1_1char__traits_3_01char_01_4.html#ac94114d1441ed1dfa598bbc4ccb08ba7">More...</a><br /></td></tr>
<tr class="separator:ac94114d1441ed1dfa598bbc4ccb08ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a03dfad65d012abdd4a79dd2f53802c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dfad65d012abdd4a79dd2f53802c60">&#9670;&nbsp;</a></span>char_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> =  char</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96632c8decf0199053db5e32953ffbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96632c8decf0199053db5e32953ffbc9">&#9670;&nbsp;</a></span>int_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a> =  int</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3789287df9c2cbf14f3eb139e96369e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3789287df9c2cbf14f3eb139e96369e">&#9670;&nbsp;</a></span>off_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::<a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#aa3789287df9c2cbf14f3eb139e96369e">off_type</a> =  <a class="el" href="namespaceetl.html#a8cc54c8127416c33c963bee08bc99596">streamoff</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa4255c745f78d8d6bb370e1540985873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4255c745f78d8d6bb370e1540985873">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns character a to character r. </p>

</div>
</div>
<a id="a6db65997c7eb8713b57f4d1f4591f4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db65997c7eb8713b57f4d1f4591f4cc">&#9670;&nbsp;</a></span>eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a and b are equal, false otherwise. </p>

</div>
</div>
<a id="a94947f0afe5659c8876c65080be077c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94947f0afe5659c8876c65080be077c2">&#9670;&nbsp;</a></span>lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a is less than b, false otherwise. </p>

</div>
</div>
<a id="a6d7be30969dd56e6084b467d0d7b14c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7be30969dd56e6084b467d0d7b14c8">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first count characters of the character strings s1 and s2. The comparison is done lexicographically. If count is zero, strings are considered equal. </p>

</div>
</div>
<a id="a2ec57591fba911fe5f55c5fc416dab59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec57591fba911fe5f55c5fc416dab59">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the character sequence pointed to by s, that is, the position of the terminating null character (CharT()). </p>

</div>
</div>
<a id="a63ee8c86549d889cb3e6fe01d2c9d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ee8c86549d889cb3e6fe01d2c9d7ab">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const*
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for character ch within the first count characters of the sequence pointed to by p. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first character in the range specified by [p, p<ul>
<li>count) that compares equal to ch, or a null pointer if not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0e7d1cc5ce8812b37b1dbaf79f2bfae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7d1cc5ce8812b37b1dbaf79f2bfae3">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>*
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies count characters from the character string pointed to by src to the character string pointed to by dest. Performs correctly even if the copied character ranges overlap, i.e. src is in [dest, dest + count). </p>

</div>
</div>
<a id="a845e942bb17f321f36ea246c7bc668b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845e942bb17f321f36ea246c7bc668b4">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>*
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies count characters from the character string pointed to by src to the character string pointed to by dest. Formally, for each i in [0, count), performs assign(src[i], dest[i]). The behavior is undefined if copied character ranges overlap, i.e. src is in [dest, dest + count). </p>

</div>
</div>
<a id="a7970b003d44734d2816961ebce54ca6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7970b003d44734d2816961ebce54ca6d">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a9671046b2e5aea5a45a7f12fecc9f911">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>*
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns character a to each character in count characters in the character sequence pointed to by p. </p>

</div>
</div>
<a id="aa018f7cc938b211975ec578ef3d4aeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa018f7cc938b211975ec578ef3d4aeda">&#9670;&nbsp;</a></span>to_char_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::to_char_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a value of int_type to char_type. If there are no equivalent value (such as when c is a copy of the <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#aa86eda99364036341c5992fcdbadaeae" title="Returns a value not equivalent to any valid value of type char_type. Formally, returns a value e such...">eof()</a> value), the result is unspecified. Formally, returns the value x such that char_type&lt;char&gt;::eq_int_type(c, char_type&lt;char&gt;::to_int_type(x)) is true, and an unspecified value if no such x exists. </p>

</div>
</div>
<a id="a1b1c7fd93cb1bd30ef3a10c9bd2f8ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1c7fd93cb1bd30ef3a10c9bd2f8ecf">&#9670;&nbsp;</a></span>to_int_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::to_int_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a03dfad65d012abdd4a79dd2f53802c60">char_type</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a value of char_type to int_type. </p>

</div>
</div>
<a id="aeb6943e340e51a943cb51d42cd08eab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6943e340e51a943cb51d42cd08eab5">&#9670;&nbsp;</a></span>eq_int_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::eq_int_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether two values of type int_type are equal. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/char_traits/eq_int_type">https://en.cppreference.com/w/cpp/string/char_traits/eq_int_type</a> </p>

</div>
</div>
<a id="aa86eda99364036341c5992fcdbadaeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86eda99364036341c5992fcdbadaeae">&#9670;&nbsp;</a></span>eof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value not equivalent to any valid value of type char_type. Formally, returns a value e such that char_type&lt;char&gt;::eq_int_type(e, char_type&lt;char&gt;::to_int_type(c)) is false for all values c. </p>

</div>
</div>
<a id="ac94114d1441ed1dfa598bbc4ccb08ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94114d1441ed1dfa598bbc4ccb08ba7">&#9670;&nbsp;</a></span>not_eof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt;::not_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1char__traits_3_01char_01_4.html#a96632c8decf0199053db5e32953ffbc9">int_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether e is not equivalent to eof value. </p>
<p>Formally if char_type&lt;char&gt;::eq_int_type(e, char_type&lt;char&gt;::eof()) is false, returns e otherwise, returns a value f such that char_type&lt;char&gt;::eq_int_type(f, char_type&lt;char&gt;::eof()) is false </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/etl/_string/<a class="el" href="char__traits_8hpp_source.html">char_traits.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html">char_traits&lt; char &gt;</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
