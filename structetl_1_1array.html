<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl::array&lt; Type, Size &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('structetl_1_1array.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="structetl_1_1array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">etl::array&lt; Type, Size &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__containers-lib.html">Containers Library</a> &raquo; <a class="el" href="group__array-hpp.html">array.hpp</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A container that encapsulates fixed size arrays.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">etl/array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8bc76893d5fbdc7105a60b7f624f36c7" id="r_a8bc76893d5fbdc7105a60b7f624f36c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bc76893d5fbdc7105a60b7f624f36c7">value_type</a> = <a class="el" href="structetl_1_1static__vector.html">Type</a></td></tr>
<tr class="separator:a8bc76893d5fbdc7105a60b7f624f36c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16e24a6df7b236119c4225ccaad5bd6" id="r_ab16e24a6df7b236119c4225ccaad5bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> = <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a></td></tr>
<tr class="separator:ab16e24a6df7b236119c4225ccaad5bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eba3b8c684672f66f71c3b91f7cb0c" id="r_ab4eba3b8c684672f66f71c3b91f7cb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4eba3b8c684672f66f71c3b91f7cb0c">difference_type</a> = <a class="el" href="namespaceetl.html#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a></td></tr>
<tr class="separator:ab4eba3b8c684672f66f71c3b91f7cb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62d115a69d08ecd728042091ca90f9d" id="r_ab62d115a69d08ecd728042091ca90f9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab62d115a69d08ecd728042091ca90f9d">pointer</a> = <a class="el" href="structetl_1_1static__vector.html">Type</a>*</td></tr>
<tr class="separator:ab62d115a69d08ecd728042091ca90f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1abf9f27f51b840573a4cd9f48ce8fe" id="r_aa1abf9f27f51b840573a4cd9f48ce8fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1abf9f27f51b840573a4cd9f48ce8fe">const_pointer</a> = <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*</td></tr>
<tr class="separator:aa1abf9f27f51b840573a4cd9f48ce8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00032e42be228b44773af3bf6059b97d" id="r_a00032e42be228b44773af3bf6059b97d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a> = <a class="el" href="structetl_1_1static__vector.html">Type</a>&amp;</td></tr>
<tr class="separator:a00032e42be228b44773af3bf6059b97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613910aa29fa85d8ba523c567a0b7a24" id="r_a613910aa29fa85d8ba523c567a0b7a24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a> = <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;</td></tr>
<tr class="separator:a613910aa29fa85d8ba523c567a0b7a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b7a3cd793b2baa7dfc365d2df75a33" id="r_ae8b7a3cd793b2baa7dfc365d2df75a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b7a3cd793b2baa7dfc365d2df75a33">iterator</a> = <a class="el" href="structetl_1_1static__vector.html">Type</a>*</td></tr>
<tr class="separator:ae8b7a3cd793b2baa7dfc365d2df75a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11262ded26a65ad5a81df54ebbafb36a" id="r_a11262ded26a65ad5a81df54ebbafb36a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a> = <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*</td></tr>
<tr class="separator:a11262ded26a65ad5a81df54ebbafb36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665a946005473c899e5d11dfc9689d15" id="r_a665a946005473c899e5d11dfc9689d15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a665a946005473c899e5d11dfc9689d15">reverse_iterator</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="#ae8b7a3cd793b2baa7dfc365d2df75a33">iterator</a>&gt;</td></tr>
<tr class="separator:a665a946005473c899e5d11dfc9689d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbf0f09574b002d051f277051e327a3" id="r_a3bbf0f09574b002d051f277051e327a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a>&gt;</td></tr>
<tr class="separator:a3bbf0f09574b002d051f277051e327a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2fbc638f50ea8414194391ab8a17928c" id="r_a2fbc638f50ea8414194391ab8a17928c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fbc638f50ea8414194391ab8a17928c">at</a> (<a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; <a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a></td></tr>
<tr class="memdesc:a2fbc638f50ea8414194391ab8a17928c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the specified item with range checking.  <br /></td></tr>
<tr class="separator:a2fbc638f50ea8414194391ab8a17928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90189e85d2fa50447a796304e2c6a8df" id="r_a90189e85d2fa50447a796304e2c6a8df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90189e85d2fa50447a796304e2c6a8df">at</a> (<a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="structetl_1_1static__vector.html">pos</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a></td></tr>
<tr class="memdesc:a90189e85d2fa50447a796304e2c6a8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the specified const item with range checking.  <br /></td></tr>
<tr class="separator:a90189e85d2fa50447a796304e2c6a8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc42b55602ea9c9a3ddc08619788819" id="r_a6bc42b55602ea9c9a3ddc08619788819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bc42b55602ea9c9a3ddc08619788819">operator[]</a> (<a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; <a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a></td></tr>
<tr class="memdesc:a6bc42b55602ea9c9a3ddc08619788819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the specified item with range checking.  <br /></td></tr>
<tr class="separator:a6bc42b55602ea9c9a3ddc08619788819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac316953f9fe490ffd5fc9e9b92edb3" id="r_a6ac316953f9fe490ffd5fc9e9b92edb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac316953f9fe490ffd5fc9e9b92edb3">operator[]</a> (<a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="structetl_1_1static__vector.html">pos</a>) <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a></td></tr>
<tr class="memdesc:a6ac316953f9fe490ffd5fc9e9b92edb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the specified item with range checking.  <br /></td></tr>
<tr class="separator:a6ac316953f9fe490ffd5fc9e9b92edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fdce1edbd84cbe2b7e73db4cb7b2a0" id="r_af5fdce1edbd84cbe2b7e73db4cb7b2a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5fdce1edbd84cbe2b7e73db4cb7b2a0">front</a> () noexcept -&gt; <a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a></td></tr>
<tr class="memdesc:af5fdce1edbd84cbe2b7e73db4cb7b2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the first item.  <br /></td></tr>
<tr class="separator:af5fdce1edbd84cbe2b7e73db4cb7b2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ddbaf9991c1f3361115cbc7a308053" id="r_a47ddbaf9991c1f3361115cbc7a308053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ddbaf9991c1f3361115cbc7a308053">front</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a></td></tr>
<tr class="memdesc:a47ddbaf9991c1f3361115cbc7a308053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the first item.  <br /></td></tr>
<tr class="separator:a47ddbaf9991c1f3361115cbc7a308053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb6e6d162df52973f8890413ce358c6" id="r_aecb6e6d162df52973f8890413ce358c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecb6e6d162df52973f8890413ce358c6">back</a> () noexcept -&gt; <a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a></td></tr>
<tr class="memdesc:aecb6e6d162df52973f8890413ce358c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the last item.  <br /></td></tr>
<tr class="separator:aecb6e6d162df52973f8890413ce358c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad3558868df0015c40ee9f6d7c8ea2f" id="r_aaad3558868df0015c40ee9f6d7c8ea2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad3558868df0015c40ee9f6d7c8ea2f">back</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a></td></tr>
<tr class="memdesc:aaad3558868df0015c40ee9f6d7c8ea2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the last item.  <br /></td></tr>
<tr class="separator:aaad3558868df0015c40ee9f6d7c8ea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786d0c001f213ea3c3434114add4e43b" id="r_a786d0c001f213ea3c3434114add4e43b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a786d0c001f213ea3c3434114add4e43b">data</a> () noexcept -&gt; <a class="el" href="#ab62d115a69d08ecd728042091ca90f9d">pointer</a></td></tr>
<tr class="memdesc:a786d0c001f213ea3c3434114add4e43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="#a8fc08ca1e9c6f08dec0522e8ddd6b9c0" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case).  <br /></td></tr>
<tr class="separator:a786d0c001f213ea3c3434114add4e43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f9a01db60f5c519385b9b09e740a65" id="r_a92f9a01db60f5c519385b9b09e740a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92f9a01db60f5c519385b9b09e740a65">data</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#aa1abf9f27f51b840573a4cd9f48ce8fe">const_pointer</a></td></tr>
<tr class="memdesc:a92f9a01db60f5c519385b9b09e740a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="#a8fc08ca1e9c6f08dec0522e8ddd6b9c0" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case).  <br /></td></tr>
<tr class="separator:a92f9a01db60f5c519385b9b09e740a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd9cd341955f0d786cad1628c240b3e" id="r_abcd9cd341955f0d786cad1628c240b3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcd9cd341955f0d786cad1628c240b3e">begin</a> () noexcept -&gt; <a class="el" href="#ae8b7a3cd793b2baa7dfc365d2df75a33">iterator</a></td></tr>
<tr class="memdesc:abcd9cd341955f0d786cad1628c240b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <br /></td></tr>
<tr class="separator:abcd9cd341955f0d786cad1628c240b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3229de7845860b01e96667f483c792c" id="r_aa3229de7845860b01e96667f483c792c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3229de7845860b01e96667f483c792c">begin</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a></td></tr>
<tr class="memdesc:aa3229de7845860b01e96667f483c792c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <br /></td></tr>
<tr class="separator:aa3229de7845860b01e96667f483c792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab1c4b864d3358078bd2653d270943c" id="r_afab1c4b864d3358078bd2653d270943c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afab1c4b864d3358078bd2653d270943c">cbegin</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a></td></tr>
<tr class="memdesc:afab1c4b864d3358078bd2653d270943c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator to the beginning.  <br /></td></tr>
<tr class="separator:afab1c4b864d3358078bd2653d270943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c930d86af593fa6e738c306e938d8f" id="r_af4c930d86af593fa6e738c306e938d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c930d86af593fa6e738c306e938d8f">end</a> () noexcept -&gt; <a class="el" href="#ae8b7a3cd793b2baa7dfc365d2df75a33">iterator</a></td></tr>
<tr class="memdesc:af4c930d86af593fa6e738c306e938d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <br /></td></tr>
<tr class="separator:af4c930d86af593fa6e738c306e938d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaadf7ec8163006977bc45cdaf7a928a" id="r_acaadf7ec8163006977bc45cdaf7a928a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaadf7ec8163006977bc45cdaf7a928a">end</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a></td></tr>
<tr class="memdesc:acaadf7ec8163006977bc45cdaf7a928a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <br /></td></tr>
<tr class="separator:acaadf7ec8163006977bc45cdaf7a928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7fe72974f46129757100637dc5d646" id="r_a0f7fe72974f46129757100637dc5d646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f7fe72974f46129757100637dc5d646">cend</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a></td></tr>
<tr class="memdesc:a0f7fe72974f46129757100637dc5d646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator to the end.  <br /></td></tr>
<tr class="separator:a0f7fe72974f46129757100637dc5d646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325c6f7640365590e9c855d134303e23" id="r_a325c6f7640365590e9c855d134303e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a325c6f7640365590e9c855d134303e23">rbegin</a> () noexcept -&gt; <a class="el" href="#a665a946005473c899e5d11dfc9689d15">reverse_iterator</a></td></tr>
<tr class="memdesc:a325c6f7640365590e9c855d134303e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed array. It corresponds to the last element of the non-reversed array. If the array is empty, the returned iterator is equal to <a class="el" href="#aab00a180c673be0dff4b02fa95a79839" title="Returns a reverse iterator to the element following the last element of the reversed array....">rend()</a>.  <br /></td></tr>
<tr class="separator:a325c6f7640365590e9c855d134303e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5218e6c848dd64578566c5a338b28f3" id="r_aa5218e6c848dd64578566c5a338b28f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5218e6c848dd64578566c5a338b28f3">rbegin</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aa5218e6c848dd64578566c5a338b28f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed array. It corresponds to the last element of the non-reversed array. If the array is empty, the returned iterator is equal to <a class="el" href="#aab00a180c673be0dff4b02fa95a79839" title="Returns a reverse iterator to the element following the last element of the reversed array....">rend()</a>.  <br /></td></tr>
<tr class="separator:aa5218e6c848dd64578566c5a338b28f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4877d3078c14d083c83d52650b78c9e" id="r_ae4877d3078c14d083c83d52650b78c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4877d3078c14d083c83d52650b78c9e">crbegin</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ae4877d3078c14d083c83d52650b78c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed array. It corresponds to the last element of the non-reversed array. If the array is empty, the returned iterator is equal to <a class="el" href="#aab00a180c673be0dff4b02fa95a79839" title="Returns a reverse iterator to the element following the last element of the reversed array....">rend()</a>.  <br /></td></tr>
<tr class="separator:ae4877d3078c14d083c83d52650b78c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab00a180c673be0dff4b02fa95a79839" id="r_aab00a180c673be0dff4b02fa95a79839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab00a180c673be0dff4b02fa95a79839">rend</a> () noexcept -&gt; <a class="el" href="#a665a946005473c899e5d11dfc9689d15">reverse_iterator</a></td></tr>
<tr class="memdesc:aab00a180c673be0dff4b02fa95a79839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed array. It corresponds to the element preceding the first element of the non-reversed array. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:aab00a180c673be0dff4b02fa95a79839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ea25321a189347d55ab85efe4dcdfb" id="r_a28ea25321a189347d55ab85efe4dcdfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28ea25321a189347d55ab85efe4dcdfb">rend</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a28ea25321a189347d55ab85efe4dcdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed array. It corresponds to the element preceding the first element of the non-reversed array. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a28ea25321a189347d55ab85efe4dcdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dec7a667c68be9a8ae1cd2392bee1de" id="r_a6dec7a667c68be9a8ae1cd2392bee1de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dec7a667c68be9a8ae1cd2392bee1de">crend</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a6dec7a667c68be9a8ae1cd2392bee1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed array. It corresponds to the element preceding the first element of the non-reversed array. This element acts as a placeholder, attempting to access it results in undefined behavior.  <br /></td></tr>
<tr class="separator:a6dec7a667c68be9a8ae1cd2392bee1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95d041aab839daa49ab2d63ef7460ec" id="r_ae95d041aab839daa49ab2d63ef7460ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae95d041aab839daa49ab2d63ef7460ec">empty</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae95d041aab839daa49ab2d63ef7460ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="#abcd9cd341955f0d786cad1628c240b3e" title="Returns an iterator to the beginning.">begin()</a> == <a class="el" href="#af4c930d86af593fa6e738c306e938d8f" title="Returns an iterator to the end.">end()</a>.  <br /></td></tr>
<tr class="separator:ae95d041aab839daa49ab2d63ef7460ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc08ca1e9c6f08dec0522e8ddd6b9c0" id="r_a8fc08ca1e9c6f08dec0522e8ddd6b9c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fc08ca1e9c6f08dec0522e8ddd6b9c0">size</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a></td></tr>
<tr class="memdesc:a8fc08ca1e9c6f08dec0522e8ddd6b9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. distance(<a class="el" href="#abcd9cd341955f0d786cad1628c240b3e" title="Returns an iterator to the beginning.">begin()</a>, <a class="el" href="#af4c930d86af593fa6e738c306e938d8f" title="Returns an iterator to the end.">end()</a>).  <br /></td></tr>
<tr class="separator:a8fc08ca1e9c6f08dec0522e8ddd6b9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af462cd846d1e153ea507bd6e5ac598ec" id="r_af462cd846d1e153ea507bd6e5ac598ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af462cd846d1e153ea507bd6e5ac598ec">max_size</a> () <a class="el" href="structetl_1_1static__vector.html">const</a> noexcept -&gt; <a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a></td></tr>
<tr class="memdesc:af462cd846d1e153ea507bd6e5ac598ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. distance(<a class="el" href="#abcd9cd341955f0d786cad1628c240b3e" title="Returns an iterator to the beginning.">begin()</a>, <a class="el" href="#af4c930d86af593fa6e738c306e938d8f" title="Returns an iterator to the end.">end()</a>) for the largest container.  <br /></td></tr>
<tr class="separator:af462cd846d1e153ea507bd6e5ac598ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9f607957e9cd6f9840f56c73dd5eae" id="r_a9f9f607957e9cd6f9840f56c73dd5eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f9f607957e9cd6f9840f56c73dd5eae">fill</a> (<a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a> value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a9f9f607957e9cd6f9840f56c73dd5eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value value to all elements in the container.  <br /></td></tr>
<tr class="separator:a9f9f607957e9cd6f9840f56c73dd5eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19fd5b30400092080b463959e489395" id="r_ab19fd5b30400092080b463959e489395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19fd5b30400092080b463959e489395">swap</a> (<a class="el" href="structetl_1_1array.html">array</a> &amp;<a class="el" href="structetl_1_1static__vector.html">other</a>) noexcept(<a class="el" href="namespaceetl.html#a4fe0a7655d7b161139e48f8eb34838ac">is_nothrow_swappable_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ab19fd5b30400092080b463959e489395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other. Does not cause iterators and references to associate with the other container.  <br /></td></tr>
<tr class="separator:ab19fd5b30400092080b463959e489395"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab3ec4a357ac52e581d45047576bd002e" id="r_ab3ec4a357ac52e581d45047576bd002e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3ec4a357ac52e581d45047576bd002e">swap</a> (<a class="el" href="structetl_1_1array.html">array</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ab3ec4a357ac52e581d45047576bd002e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for array. Swaps the contents of lhs and rhs.  <br /></td></tr>
<tr class="separator:ab3ec4a357ac52e581d45047576bd002e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4e830b5de57b0d1c67280677c992a" id="r_a8bd4e830b5de57b0d1c67280677c992a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bd4e830b5de57b0d1c67280677c992a">operator==</a> (<a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a8bd4e830b5de57b0d1c67280677c992a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position.  <br /></td></tr>
<tr class="separator:a8bd4e830b5de57b0d1c67280677c992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66578f87f5e13ebca822ae1fef081442" id="r_a66578f87f5e13ebca822ae1fef081442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66578f87f5e13ebca822ae1fef081442">operator!=</a> (<a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a66578f87f5e13ebca822ae1fef081442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f0902fb41c93ffc3cfb1faca46e084" id="r_a55f0902fb41c93ffc3cfb1faca46e084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55f0902fb41c93ffc3cfb1faca46e084">operator&lt;</a> (<a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a55f0902fb41c93ffc3cfb1faca46e084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare.  <br /></td></tr>
<tr class="separator:a55f0902fb41c93ffc3cfb1faca46e084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79496c668b8897e66cba6fb437edd34" id="r_ad79496c668b8897e66cba6fb437edd34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad79496c668b8897e66cba6fb437edd34">operator&lt;=</a> (<a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ad79496c668b8897e66cba6fb437edd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b551796eb9b49716ae2ca6dd5dfed5" id="r_ab1b551796eb9b49716ae2ca6dd5dfed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1b551796eb9b49716ae2ca6dd5dfed5">operator&gt;</a> (<a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ab1b551796eb9b49716ae2ca6dd5dfed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad769293a87a5c718994c15a283597aba" id="r_ad769293a87a5c718994c15a283597aba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad769293a87a5c718994c15a283597aba">operator&gt;=</a> (<a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1array.html">array</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ad769293a87a5c718994c15a283597aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a4acb9fc77c91f6e92832d42185583633" id="r_a4acb9fc77c91f6e92832d42185583633"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... U&gt; </td></tr>
<tr class="memitem:a4acb9fc77c91f6e92832d42185583633"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4acb9fc77c91f6e92832d42185583633">array</a> (T, U...) -&gt; <a class="el" href="structetl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td></tr>
<tr class="memdesc:a4acb9fc77c91f6e92832d42185583633"><td class="mdescLeft">&#160;</td><td class="mdescRight">One deduction guide is provided for array to provide an equivalent of experimental::make_array for construction of array from a variadic parameter pack. The program is ill-formed if (is_same_v&lt;T, U&gt; and ...) is not true. Note that it is true when sizeof...(U) is zero.  <br /></td></tr>
<tr class="separator:a4acb9fc77c91f6e92832d42185583633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bce012c4b201c8f654c4eee78555ef" id="r_a52bce012c4b201c8f654c4eee78555ef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:a52bce012c4b201c8f654c4eee78555ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52bce012c4b201c8f654c4eee78555ef">is_tuple_like</a></td></tr>
<tr class="separator:a52bce012c4b201c8f654c4eee78555ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7523a3dfaad4821bb37a62e49ae19564" id="r_a7523a3dfaad4821bb37a62e49ae19564"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Index, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </td></tr>
<tr class="memitem:a7523a3dfaad4821bb37a62e49ae19564"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7523a3dfaad4821bb37a62e49ae19564">get</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;<a class="el" href="structetl_1_1array.html">array</a>) noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:a7523a3dfaad4821bb37a62e49ae19564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the Ith element element from the array. I must be an integer value in range [0, N). This is enforced at compile time as opposed to <a class="el" href="#a2fbc638f50ea8414194391ab8a17928c" title="Accesses the specified item with range checking.">at()</a> or operator[].  <br /></td></tr>
<tr class="separator:a7523a3dfaad4821bb37a62e49ae19564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64420ef7894f5d9a1c2f33d35f3136e" id="r_ab64420ef7894f5d9a1c2f33d35f3136e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Index, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </td></tr>
<tr class="memitem:ab64420ef7894f5d9a1c2f33d35f3136e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab64420ef7894f5d9a1c2f33d35f3136e">get</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1array.html">array</a>) noexcept -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:ab64420ef7894f5d9a1c2f33d35f3136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36575eb140868e578429286e8ec62e6e" id="r_a36575eb140868e578429286e8ec62e6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Index, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </td></tr>
<tr class="memitem:a36575eb140868e578429286e8ec62e6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36575eb140868e578429286e8ec62e6e">get</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;&amp;<a class="el" href="structetl_1_1array.html">array</a>) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="separator:a36575eb140868e578429286e8ec62e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519806e08910c96f1f59dc84109b2c60" id="r_a519806e08910c96f1f59dc84109b2c60"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Index, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </td></tr>
<tr class="memitem:a519806e08910c96f1f59dc84109b2c60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a519806e08910c96f1f59dc84109b2c60">get</a> (<a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1array.html">array</a>) noexcept -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="separator:a519806e08910c96f1f59dc84109b2c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473fe47c2383d723c9b37fa6af55104" id="r_ab473fe47c2383d723c9b37fa6af55104"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:ab473fe47c2383d723c9b37fa6af55104"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab473fe47c2383d723c9b37fa6af55104">to_array</a> (T(&amp;a)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) -&gt; <a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="namespaceetl.html#a7d3ea939d0e932fceedbae01d7a3af90">remove_cv_t</a>&lt; T &gt;, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:ab473fe47c2383d723c9b37fa6af55104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a array from the one dimensional built-in array a. The elements of the array are copy-initialized from the corresponding element of a. Copying or moving multidimensional built-in array is not supported.  <br /></td></tr>
<tr class="separator:ab473fe47c2383d723c9b37fa6af55104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206fb932614fa86d56d410c37f786760" id="r_a206fb932614fa86d56d410c37f786760"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:a206fb932614fa86d56d410c37f786760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a206fb932614fa86d56d410c37f786760">to_array</a> (T(&amp;&amp;a)[<a class="el" href="structetl_1_1static__vector.html">N</a>])</td></tr>
<tr class="separator:a206fb932614fa86d56d410c37f786760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt;<br />
struct etl::array&lt; Type, Size &gt;</div><p>A container that encapsulates fixed size arrays. </p>
<p>This container is an aggregate type with the same semantics as a struct holding a C-style array Type[N] as its only non-static data member. Unlike a C-style array, it doesn't decay to Type* automatically. As an aggregate type, it can be initialized with aggregate-initialization given at most N initializers that are convertible to Type: <code>array&lt;int, 3&gt; a = {1,2,3};</code></p>
<div class="fragment"><div class="line"><span class="comment">// SPDX-License-Identifier: BSL-1.0</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#undef NDEBUG</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="algorithm_8hpp.html">etl/algorithm.hpp</a>&gt;</span> <span class="comment">// for all_of, copy</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="array_8hpp.html">etl/array.hpp</a>&gt;</span>     <span class="comment">// for array</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cassert_8hpp.html">etl/cassert.hpp</a>&gt;</span>   <span class="comment">// for TETL_ASSERT</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterator_8hpp.html">etl/iterator.hpp</a>&gt;</span>  <span class="comment">// for begin, end</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span>  <span class="comment">// for printf</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span> <span class="comment">// for EXIT_SUCCESS</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_struct" href="structetl_1_1static__vector.html">main</a>() -&gt; <span class="keywordtype">int</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_function" href="group__algorithm-hpp.html#gac76b028bf28233ada520a5bc0d52f6b9">etl::all_of</a>;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_struct" href="structetl_1_1array.html">etl::array</a>;</div>
<div class="line">    <span class="keyword">using </span><a class="code hl_function" href="group__algorithm-hpp.html#gad3271ee1abafc543f4bf69cc20b01ded">etl::copy</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_struct" href="structetl_1_1static__vector.html">src</a> = <a class="code hl_struct" href="structetl_1_1array.html">array</a>{1, 2, 3, 4}; <span class="comment">// size &amp; type are deduced</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code hl_struct" href="structetl_1_1static__vector.html">item</a> : <a class="code hl_struct" href="structetl_1_1static__vector.html">src</a>) {</div>
<div class="line">        <a class="code hl_struct" href="structetl_1_1static__vector.html">printf</a>(<span class="stringliteral">&quot;%d\n&quot;</span>, <a class="code hl_struct" href="structetl_1_1static__vector.html">item</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    src.fill(42);</div>
<div class="line">    <a class="code hl_define" href="macro_8hpp.html#a0437873c880d530d0e43a83a0c413d95">TETL_ASSERT</a>(all_of(begin(src), end(src), [](<span class="keyword">auto</span> v) { <span class="keywordflow">return</span> v == 42; }));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">decltype</span>(src) dest = {};</div>
<div class="line">    <a class="code hl_define" href="macro_8hpp.html#a0437873c880d530d0e43a83a0c413d95">TETL_ASSERT</a>(<a class="code hl_function" href="group__algorithm-hpp.html#gac76b028bf28233ada520a5bc0d52f6b9">all_of</a>(<a class="code hl_variable" href="namespaceetl_1_1ranges_1_1cpo.html#a3359121d1e6b6048466a7042367de263">begin</a>(dest), <a class="code hl_variable" href="namespaceetl_1_1ranges_1_1cpo.html#aabcecd54adfa279c6e77f2fce24f48a6">end</a>(dest), [](<span class="keyword">auto</span> v) { <span class="keywordflow">return</span> v == 0; }));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__algorithm-hpp.html#gad3271ee1abafc543f4bf69cc20b01ded">copy</a>(<a class="code hl_variable" href="namespaceetl_1_1ranges_1_1cpo.html#a3359121d1e6b6048466a7042367de263">begin</a>(src), <a class="code hl_variable" href="namespaceetl_1_1ranges_1_1cpo.html#aabcecd54adfa279c6e77f2fce24f48a6">end</a>(src), <a class="code hl_variable" href="namespaceetl_1_1ranges_1_1cpo.html#a3359121d1e6b6048466a7042367de263">begin</a>(dest));</div>
<div class="line">    <a class="code hl_define" href="macro_8hpp.html#a0437873c880d530d0e43a83a0c413d95">TETL_ASSERT</a>(<a class="code hl_function" href="group__algorithm-hpp.html#gac76b028bf28233ada520a5bc0d52f6b9">all_of</a>(<a class="code hl_variable" href="namespaceetl_1_1ranges_1_1cpo.html#a3359121d1e6b6048466a7042367de263">begin</a>(dest), <a class="code hl_variable" href="namespaceetl_1_1ranges_1_1cpo.html#aabcecd54adfa279c6e77f2fce24f48a6">end</a>(dest), [](<span class="keyword">auto</span> v) { <span class="keywordflow">return</span> v == 42; }));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="exit_8hpp.html#a687984f47d8cce148d1b914d2b79612a">EXIT_SUCCESS</a>;</div>
<div class="line">}</div>
<div class="ttc" id="aalgorithm_8hpp_html"><div class="ttname"><a href="algorithm_8hpp.html">algorithm.hpp</a></div></div>
<div class="ttc" id="aarray_8hpp_html"><div class="ttname"><a href="array_8hpp.html">array.hpp</a></div></div>
<div class="ttc" id="acassert_8hpp_html"><div class="ttname"><a href="cassert_8hpp.html">cassert.hpp</a></div></div>
<div class="ttc" id="aexit_8hpp_html_a687984f47d8cce148d1b914d2b79612a"><div class="ttname"><a href="exit_8hpp.html#a687984f47d8cce148d1b914d2b79612a">EXIT_SUCCESS</a></div><div class="ttdeci">#define EXIT_SUCCESS</div><div class="ttdoc">Successful execution of a program.</div><div class="ttdef"><b>Definition</b> exit.hpp:8</div></div>
<div class="ttc" id="agroup__algorithm-hpp_html_gac76b028bf28233ada520a5bc0d52f6b9"><div class="ttname"><a href="group__algorithm-hpp.html#gac76b028bf28233ada520a5bc0d52f6b9">etl::all_of</a></div><div class="ttdeci">constexpr auto all_of(InputIt first, InputIt last, Predicate p) -&gt; bool</div><div class="ttdoc">Checks if unary predicate p returns true for all elements in the range [first, last).</div><div class="ttdef"><b>Definition</b> all_of.hpp:15</div></div>
<div class="ttc" id="agroup__algorithm-hpp_html_gad3271ee1abafc543f4bf69cc20b01ded"><div class="ttname"><a href="group__algorithm-hpp.html#gad3271ee1abafc543f4bf69cc20b01ded">etl::copy</a></div><div class="ttdeci">constexpr auto copy(InputIt first, InputIt last, OutputIt destination) -&gt; OutputIt</div><div class="ttdoc">Copies the elements in the range, defined by [first, last), to another range beginning at destination...</div><div class="ttdef"><b>Definition</b> copy.hpp:20</div></div>
<div class="ttc" id="aiterator_8hpp_html"><div class="ttname"><a href="iterator_8hpp.html">iterator.hpp</a></div></div>
<div class="ttc" id="amacro_8hpp_html_a0437873c880d530d0e43a83a0c413d95"><div class="ttname"><a href="macro_8hpp.html#a0437873c880d530d0e43a83a0c413d95">TETL_ASSERT</a></div><div class="ttdeci">#define TETL_ASSERT(...)</div><div class="ttdoc">Assertion macro with customizable runtime behavior.</div><div class="ttdef"><b>Definition</b> macro.hpp:68</div></div>
<div class="ttc" id="anamespaceetl_1_1ranges_1_1cpo_html_a3359121d1e6b6048466a7042367de263"><div class="ttname"><a href="namespaceetl_1_1ranges_1_1cpo.html#a3359121d1e6b6048466a7042367de263">etl::ranges::cpo::begin</a></div><div class="ttdeci">constexpr auto begin</div><div class="ttdef"><b>Definition</b> begin.hpp:62</div></div>
<div class="ttc" id="anamespaceetl_1_1ranges_1_1cpo_html_aabcecd54adfa279c6e77f2fce24f48a6"><div class="ttname"><a href="namespaceetl_1_1ranges_1_1cpo.html#aabcecd54adfa279c6e77f2fce24f48a6">etl::ranges::cpo::end</a></div><div class="ttdeci">constexpr auto end</div><div class="ttdef"><b>Definition</b> end.hpp:57</div></div>
<div class="ttc" id="astructetl_1_1array_html"><div class="ttname"><a href="structetl_1_1array.html">etl::array</a></div><div class="ttdoc">A container that encapsulates fixed size arrays.</div><div class="ttdef"><b>Definition</b> array.hpp:38</div></div>
<div class="ttc" id="astructetl_1_1static__vector_html"><div class="ttname"><a href="structetl_1_1static__vector.html">etl::static_vector</a></div><div class="ttdoc">Dynamically-resizable fixed-capacity vector.</div><div class="ttdef"><b>Definition</b> static_vector.hpp:326</div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="array_8cpp-example.html#_a1">array.cpp</a>, and <a class="el" href="set_8cpp-example.html#_a0">set.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8bc76893d5fbdc7105a60b7f624f36c7" name="a8bc76893d5fbdc7105a60b7f624f36c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc76893d5fbdc7105a60b7f624f36c7">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::value_type = <a class="el" href="structetl_1_1static__vector.html">Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab16e24a6df7b236119c4225ccaad5bd6" name="ab16e24a6df7b236119c4225ccaad5bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16e24a6df7b236119c4225ccaad5bd6">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::size_type = <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4eba3b8c684672f66f71c3b91f7cb0c" name="ab4eba3b8c684672f66f71c3b91f7cb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eba3b8c684672f66f71c3b91f7cb0c">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::difference_type = <a class="el" href="namespaceetl.html#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab62d115a69d08ecd728042091ca90f9d" name="ab62d115a69d08ecd728042091ca90f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62d115a69d08ecd728042091ca90f9d">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::pointer = <a class="el" href="structetl_1_1static__vector.html">Type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1abf9f27f51b840573a4cd9f48ce8fe" name="aa1abf9f27f51b840573a4cd9f48ce8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1abf9f27f51b840573a4cd9f48ce8fe">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::const_pointer = <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00032e42be228b44773af3bf6059b97d" name="a00032e42be228b44773af3bf6059b97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00032e42be228b44773af3bf6059b97d">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::reference = <a class="el" href="structetl_1_1static__vector.html">Type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a613910aa29fa85d8ba523c567a0b7a24" name="a613910aa29fa85d8ba523c567a0b7a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613910aa29fa85d8ba523c567a0b7a24">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::const_reference = <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8b7a3cd793b2baa7dfc365d2df75a33" name="ae8b7a3cd793b2baa7dfc365d2df75a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b7a3cd793b2baa7dfc365d2df75a33">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::iterator = <a class="el" href="structetl_1_1static__vector.html">Type</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11262ded26a65ad5a81df54ebbafb36a" name="a11262ded26a65ad5a81df54ebbafb36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11262ded26a65ad5a81df54ebbafb36a">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::const_iterator = <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a665a946005473c899e5d11dfc9689d15" name="a665a946005473c899e5d11dfc9689d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665a946005473c899e5d11dfc9689d15">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::reverse_iterator = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="#ae8b7a3cd793b2baa7dfc365d2df75a33">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bbf0f09574b002d051f277051e327a3" name="a3bbf0f09574b002d051f277051e327a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbf0f09574b002d051f277051e327a3">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::const_reverse_iterator = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2fbc638f50ea8414194391ab8a17928c" name="a2fbc638f50ea8414194391ab8a17928c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc638f50ea8414194391ab8a17928c">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the specified item with range checking. </p>

</div>
</div>
<a id="a90189e85d2fa50447a796304e2c6a8df" name="a90189e85d2fa50447a796304e2c6a8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90189e85d2fa50447a796304e2c6a8df">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the specified const item with range checking. </p>

</div>
</div>
<a id="a6bc42b55602ea9c9a3ddc08619788819" name="a6bc42b55602ea9c9a3ddc08619788819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc42b55602ea9c9a3ddc08619788819">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the specified item with range checking. </p>

</div>
</div>
<a id="a6ac316953f9fe490ffd5fc9e9b92edb3" name="a6ac316953f9fe490ffd5fc9e9b92edb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac316953f9fe490ffd5fc9e9b92edb3">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the specified item with range checking. </p>

</div>
</div>
<a id="af5fdce1edbd84cbe2b7e73db4cb7b2a0" name="af5fdce1edbd84cbe2b7e73db4cb7b2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fdce1edbd84cbe2b7e73db4cb7b2a0">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the first item. </p>

</div>
</div>
<a id="a47ddbaf9991c1f3361115cbc7a308053" name="a47ddbaf9991c1f3361115cbc7a308053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ddbaf9991c1f3361115cbc7a308053">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the first item. </p>

</div>
</div>
<a id="aecb6e6d162df52973f8890413ce358c6" name="aecb6e6d162df52973f8890413ce358c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb6e6d162df52973f8890413ce358c6">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a00032e42be228b44773af3bf6059b97d">reference</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the last item. </p>

</div>
</div>
<a id="aaad3558868df0015c40ee9f6d7c8ea2f" name="aaad3558868df0015c40ee9f6d7c8ea2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad3558868df0015c40ee9f6d7c8ea2f">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the last item. </p>

</div>
</div>
<a id="a786d0c001f213ea3c3434114add4e43b" name="a786d0c001f213ea3c3434114add4e43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786d0c001f213ea3c3434114add4e43b">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ab62d115a69d08ecd728042091ca90f9d">pointer</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="#a8fc08ca1e9c6f08dec0522e8ddd6b9c0" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case). </p>

</div>
</div>
<a id="a92f9a01db60f5c519385b9b09e740a65" name="a92f9a01db60f5c519385b9b09e740a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f9a01db60f5c519385b9b09e740a65">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#aa1abf9f27f51b840573a4cd9f48ce8fe">const_pointer</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="#a8fc08ca1e9c6f08dec0522e8ddd6b9c0" title="Returns the number of elements in the container, i.e. distance(begin(), end()).">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="#a786d0c001f213ea3c3434114add4e43b" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case). </p>

</div>
</div>
<a id="abcd9cd341955f0d786cad1628c240b3e" name="abcd9cd341955f0d786cad1628c240b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd9cd341955f0d786cad1628c240b3e">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae8b7a3cd793b2baa7dfc365d2df75a33">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>

</div>
</div>
<a id="aa3229de7845860b01e96667f483c792c" name="aa3229de7845860b01e96667f483c792c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3229de7845860b01e96667f483c792c">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>

</div>
</div>
<a id="afab1c4b864d3358078bd2653d270943c" name="afab1c4b864d3358078bd2653d270943c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab1c4b864d3358078bd2653d270943c">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an const iterator to the beginning. </p>

</div>
</div>
<a id="af4c930d86af593fa6e738c306e938d8f" name="af4c930d86af593fa6e738c306e938d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c930d86af593fa6e738c306e938d8f">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae8b7a3cd793b2baa7dfc365d2df75a33">iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>

</div>
</div>
<a id="acaadf7ec8163006977bc45cdaf7a928a" name="acaadf7ec8163006977bc45cdaf7a928a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaadf7ec8163006977bc45cdaf7a928a">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end. </p>

</div>
</div>
<a id="a0f7fe72974f46129757100637dc5d646" name="a0f7fe72974f46129757100637dc5d646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7fe72974f46129757100637dc5d646">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a11262ded26a65ad5a81df54ebbafb36a">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an const iterator to the end. </p>

</div>
</div>
<a id="a325c6f7640365590e9c855d134303e23" name="a325c6f7640365590e9c855d134303e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325c6f7640365590e9c855d134303e23">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a665a946005473c899e5d11dfc9689d15">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed array. It corresponds to the last element of the non-reversed array. If the array is empty, the returned iterator is equal to <a class="el" href="#aab00a180c673be0dff4b02fa95a79839" title="Returns a reverse iterator to the element following the last element of the reversed array....">rend()</a>. </p>

</div>
</div>
<a id="aa5218e6c848dd64578566c5a338b28f3" name="aa5218e6c848dd64578566c5a338b28f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5218e6c848dd64578566c5a338b28f3">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed array. It corresponds to the last element of the non-reversed array. If the array is empty, the returned iterator is equal to <a class="el" href="#aab00a180c673be0dff4b02fa95a79839" title="Returns a reverse iterator to the element following the last element of the reversed array....">rend()</a>. </p>

</div>
</div>
<a id="ae4877d3078c14d083c83d52650b78c9e" name="ae4877d3078c14d083c83d52650b78c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4877d3078c14d083c83d52650b78c9e">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed array. It corresponds to the last element of the non-reversed array. If the array is empty, the returned iterator is equal to <a class="el" href="#aab00a180c673be0dff4b02fa95a79839" title="Returns a reverse iterator to the element following the last element of the reversed array....">rend()</a>. </p>

</div>
</div>
<a id="aab00a180c673be0dff4b02fa95a79839" name="aab00a180c673be0dff4b02fa95a79839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab00a180c673be0dff4b02fa95a79839">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a665a946005473c899e5d11dfc9689d15">reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed array. It corresponds to the element preceding the first element of the non-reversed array. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a28ea25321a189347d55ab85efe4dcdfb" name="a28ea25321a189347d55ab85efe4dcdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ea25321a189347d55ab85efe4dcdfb">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed array. It corresponds to the element preceding the first element of the non-reversed array. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a6dec7a667c68be9a8ae1cd2392bee1de" name="a6dec7a667c68be9a8ae1cd2392bee1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dec7a667c68be9a8ae1cd2392bee1de">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#a3bbf0f09574b002d051f277051e327a3">const_reverse_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed array. It corresponds to the element preceding the first element of the non-reversed array. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="ae95d041aab839daa49ab2d63ef7460ec" name="ae95d041aab839daa49ab2d63ef7460ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95d041aab839daa49ab2d63ef7460ec">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <a class="el" href="#abcd9cd341955f0d786cad1628c240b3e" title="Returns an iterator to the beginning.">begin()</a> == <a class="el" href="#af4c930d86af593fa6e738c306e938d8f" title="Returns an iterator to the end.">end()</a>. </p>

</div>
</div>
<a id="a8fc08ca1e9c6f08dec0522e8ddd6b9c0" name="a8fc08ca1e9c6f08dec0522e8ddd6b9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc08ca1e9c6f08dec0522e8ddd6b9c0">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. distance(<a class="el" href="#abcd9cd341955f0d786cad1628c240b3e" title="Returns an iterator to the beginning.">begin()</a>, <a class="el" href="#af4c930d86af593fa6e738c306e938d8f" title="Returns an iterator to the end.">end()</a>). </p>

</div>
</div>
<a id="af462cd846d1e153ea507bd6e5ac598ec" name="af462cd846d1e153ea507bd6e5ac598ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af462cd846d1e153ea507bd6e5ac598ec">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; <a class="el" href="#ab16e24a6df7b236119c4225ccaad5bd6">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations, i.e. distance(<a class="el" href="#abcd9cd341955f0d786cad1628c240b3e" title="Returns an iterator to the beginning.">begin()</a>, <a class="el" href="#af4c930d86af593fa6e738c306e938d8f" title="Returns an iterator to the end.">end()</a>) for the largest container. </p>
<p>Because each array&lt;T, N&gt; is a fixed-size container, the value returned by max_size equals N (which is also the value returned by size) </p>

</div>
</div>
<a id="a9f9f607957e9cd6f9840f56c73dd5eae" name="a9f9f607957e9cd6f9840f56c73dd5eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9f607957e9cd6f9840f56c73dd5eae">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a613910aa29fa85d8ba523c567a0b7a24">const_reference</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value value to all elements in the container. </p>

</div>
</div>
<a id="ab19fd5b30400092080b463959e489395" name="ab19fd5b30400092080b463959e489395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19fd5b30400092080b463959e489395">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. Does not cause iterators and references to associate with the other container. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ab3ec4a357ac52e581d45047576bd002e" name="ab3ec4a357ac52e581d45047576bd002e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ec4a357ac52e581d45047576bd002e">&#9670;&#160;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for array. Swaps the contents of lhs and rhs. </p>

</div>
</div>
<a id="a8bd4e830b5de57b0d1c67280677c992a" name="a8bd4e830b5de57b0d1c67280677c992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd4e830b5de57b0d1c67280677c992a">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="a66578f87f5e13ebca822ae1fef081442" name="a66578f87f5e13ebca822ae1fef081442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66578f87f5e13ebca822ae1fef081442">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55f0902fb41c93ffc3cfb1faca46e084" name="a55f0902fb41c93ffc3cfb1faca46e084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f0902fb41c93ffc3cfb1faca46e084">&#9670;&#160;</a></span>operator&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="ad79496c668b8897e66cba6fb437edd34" name="ad79496c668b8897e66cba6fb437edd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79496c668b8897e66cba6fb437edd34">&#9670;&#160;</a></span>operator&lt;=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1b551796eb9b49716ae2ca6dd5dfed5" name="ab1b551796eb9b49716ae2ca6dd5dfed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b551796eb9b49716ae2ca6dd5dfed5">&#9670;&#160;</a></span>operator&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad769293a87a5c718994c15a283597aba" name="ad769293a87a5c718994c15a283597aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad769293a87a5c718994c15a283597aba">&#9670;&#160;</a></span>operator&gt;=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4acb9fc77c91f6e92832d42185583633" name="a4acb9fc77c91f6e92832d42185583633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acb9fc77c91f6e92832d42185583633">&#9670;&#160;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U...</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  <a class="el" href="structetl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One deduction guide is provided for array to provide an equivalent of experimental::make_array for construction of array from a variadic parameter pack. The program is ill-formed if (is_same_v&lt;T, U&gt; and ...) is not true. Note that it is true when sizeof...(U) is zero. </p>

</div>
</div>
<a id="a52bce012c4b201c8f654c4eee78555ef" name="a52bce012c4b201c8f654c4eee78555ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bce012c4b201c8f654c4eee78555ef">&#9670;&#160;</a></span>is_tuple_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_tuple_like&lt; <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7523a3dfaad4821bb37a62e49ae19564" name="a7523a3dfaad4821bb37a62e49ae19564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7523a3dfaad4821bb37a62e49ae19564">&#9670;&#160;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Index, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td> -&gt; T&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the Ith element element from the array. I must be an integer value in range [0, N). This is enforced at compile time as opposed to <a class="el" href="#a2fbc638f50ea8414194391ab8a17928c" title="Accesses the specified item with range checking.">at()</a> or operator[]. </p>

</div>
</div>
<a id="ab64420ef7894f5d9a1c2f33d35f3136e" name="ab64420ef7894f5d9a1c2f33d35f3136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64420ef7894f5d9a1c2f33d35f3136e">&#9670;&#160;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Index, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td> -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36575eb140868e578429286e8ec62e6e" name="a36575eb140868e578429286e8ec62e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36575eb140868e578429286e8ec62e6e">&#9670;&#160;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Index, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a519806e08910c96f1f59dc84109b2c60" name="a519806e08910c96f1f59dc84109b2c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519806e08910c96f1f59dc84109b2c60">&#9670;&#160;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Index, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> Size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">array</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td> -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab473fe47c2383d723c9b37fa6af55104" name="ab473fe47c2383d723c9b37fa6af55104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473fe47c2383d723c9b37fa6af55104">&#9670;&#160;</a></span>to_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_array </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>a</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1array.html">array</a>&lt;<a class="el" href="namespaceetl.html#a7d3ea939d0e932fceedbae01d7a3af90">remove_cv_t</a>&lt;T&gt;, <a class="el" href="structetl_1_1static__vector.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a array from the one dimensional built-in array a. The elements of the array are copy-initialized from the corresponding element of a. Copying or moving multidimensional built-in array is not supported. </p>

</div>
</div>
<a id="a206fb932614fa86d56d410c37f786760" name="a206fb932614fa86d56d410c37f786760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206fb932614fa86d56d410c37f786760">&#9670;&#160;</a></span>to_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="namespaceetl.html#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_array </td>
          <td>(</td>
          <td class="paramtype">T(&amp;&amp;)</td>          <td class="paramname"><span class="paramname"><em>a</em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/etl/_array/<a class="el" href="__array_2array_8hpp_source.html">array.hpp</a></li>
<li>include/etl/_array/<a class="el" href="to__array_8hpp_source.html">to_array.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="structetl_1_1array.html">array</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
