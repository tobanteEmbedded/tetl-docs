<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceetl.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">etl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1chrono.html">chrono</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html">chrono_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html">complex_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1meta.html">meta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1numbers.html">numbers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1ranges.html">ranges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1simd__abi.html">simd_abi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1string__view__literals.html">string_view_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swap__no__throw.html">_swap_no_throw</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swappable__with__helper.html">_swappable_with_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swappable__with__helper_3_01T_00_01U_00_01void__t_3_01decltype_07swap_07declval_3a85b88c6bbfa63467fd799de16a3d15b.html">_swappable_with_helper&lt; T, U, void_t&lt; decltype(swap(declval&lt; T &gt;(), declval&lt; U &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__const.html">add_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const.  <a href="structetl_1_1add__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__cv.html">add_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile.  <a href="structetl_1_1add__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a lvalue reference type of T.  <a href="structetl_1_1add__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__pointer.html">add_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined.  <a href="structetl_1_1add__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rvalue reference type of T.  <a href="structetl_1_1add__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__volatile.html">add_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile.  <a href="structetl_1_1add__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1adopt__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align. The default value of Align is the most stringent (the largest) alignment requirement for any object whose size is at most Len. If the default value is not used, Align must be the value of alignof(T) for some type T, or the behavior is undefined.  <a href="structetl_1_1aligned__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__union.html">aligned_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitable for use as uninitialized storage for an object of any of the types listed in Types. The size of the storage is at least Len. <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> also determines the strictest (largest) alignment requirement among all Types and makes it available as the constant alignment_value. If sizeof...(Types) == 0 or if any of the types in Types is not a complete object type, the behavior is undefined. It is implementation-defined whether any extended alignment is supported. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> is undefined.  <a href="structetl_1_1aligned__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1alignment__of.html">alignment_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1alignment__of.html" title="alignment_of">alignment_of</a>  <a href="structetl_1_1alignment__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects.  <a href="structetl_1_1allocator__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that encapsulates fixed size arrays.  <a href="structetl_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1assert__msg.html">assert_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Payload for an assertion.  <a href="structetl_1_1assert__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a LegacyOutputIterator that appends to a container for which it was constructed. The container's push_back() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a no-op.  <a href="structetl_1_1back__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__function__call.html">bad_function_call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__optional__access.html">bad_optional_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a type of object to be thrown by etl::optional::value when accessing an optional object that does not contain a value.  <a href="structetl_1_1bad__optional__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__variant__access.html">bad_variant_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">etl::bad_variant_access</a> is the type of the exception thrown in the following situations: (1) etl::get(etl::variant) called with an index or type that does not match the currently active alternative. (2) <a class="el" href="#a2f45e7a98a49bac4a0e8006a9c784f8a" title="Applies the visitor vis (Callable that can be called with any combination of types from variants) to ...">etl::visit</a> called to visit a variant that is valueless_by_exception  <a href="structetl_1_1bad__variant__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__bitset.html">basic_bitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__common__reference.html">basic_common_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="structetl_1_1basic__common__reference.html" title="The class template basic_common_reference is a customization point that allows users to influence the...">basic_common_reference</a> is a customization point that allows users to influence the result of <a class="el" href="structetl_1_1common__reference.html" title="Determines the common reference type of the types T..., that is, the type to which all the types in T...">common_reference</a> for user-defined types (typically proxy references). The primary template is empty.  <a href="structetl_1_1basic__common__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__common__reference_3_01pair_3_01T1_00_01T2_01_4_00_01pair_3_01U1_00_01U2_01_4_00_01TQual_00_01UQual_01_4.html">basic_common_reference&lt; pair&lt; T1, T2 &gt;, pair&lt; U1, U2 &gt;, TQual, UQual &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__arg.html">basic_format_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to formatting state consisting of the formatting arguments and the output iterator.  <a href="structetl_1_1basic__format__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> class with fixed size capacity.  <a href="structetl_1_1basic__static__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__streambuf.html">basic_streambuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="structetl_1_1basic__string__view.html" title="The class template basic_string_view describes an object that can refer to a constant contiguous sequ...">basic_string_view</a> describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. A typical implementation holds only two members: a pointer to constant CharType and a size.  <a href="structetl_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bernoulli__distribution.html">bernoulli_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1bidirectional__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1binary__t.html">binary_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and.html">bit_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise AND. Effectively calls <code>operator&amp;</code> on type T.  <a href="structetl_1_1bit__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and_3_01void_01_4.html">bit_and&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not.html">bit_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise NOT. Effectively calls <code>operator~</code> on type T.  <a href="structetl_1_1bit__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not_3_01void_01_4.html">bit_not&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or.html">bit_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise OR. Effectively calls operator| on type T.  <a href="structetl_1_1bit__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or_3_01void_01_4.html">bit_or&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor.html">bit_xor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise XOR. Effectively calls operator^ on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/bit_xor">https://en.cppreference.com/w/cpp/utility/functional/bit_xor</a>.  <a href="structetl_1_1bit__xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor_3_01void_01_4.html">bit_xor&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators.  <a href="structetl_1_1bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits.html">char_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class. The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types. If an operation on traits emits an exception, the behavior is undefined.  <a href="structetl_1_1char__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html">char_traits&lt; char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char.  <a href="structetl_1_1char__traits_3_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01wchar__t_01_4.html">char_traits&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference.html">common_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common reference type of the types T..., that is, the type to which all the types in T... can be converted or bound. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. The behavior is undefined if any of the types in T... is an incomplete type other than (possibly cv-qualified) void.  <a href="structetl_1_1common__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_01T_01_4.html">common_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_01T_00_01U_01_4.html">common_reference&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_4.html">common_reference&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type.html">common_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common type among all types <code>T...</code>, that is the type all <code>T...</code> can be implicitly converted to. If such a type exists, the member type names that type. Otherwise, there is no member type.  <a href="structetl_1_1common__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html">common_type&lt; chrono::duration&lt; Rep1, Period1 &gt;, chrono::duration&lt; Rep2, Period2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two etl::chrono::durations, whose period is the greatest common divisor of Period1 and Period2.  <a href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html">common_type&lt; chrono::time_point&lt; Clock, Duration1 &gt;, chrono::time_point&lt; Clock, Duration2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two chrono::time_points.  <a href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T_01_4.html">common_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html">common_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html">common_type&lt; T1, T2, R... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1compare__three__way__result.html">compare_three_way_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1compare__three__way__result_3_01T_00_01U_01_4.html">compare_three_way_result&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A complex number.  <a href="structetl_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional.html">conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.  <a href="structetl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html">conditional&lt; false, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits.  <a href="structetl_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1const__where__expression.html">const_where_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1contiguous__iterator__tag.html">contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1contiguous__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1decay.html">decay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type.  <a href="structetl_1_1decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__accessor.html">default_accessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__delete.html">default_delete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__delete_3_01T_0f_0e_4.html">default_delete&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__searcher.html">default_searcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default searcher. A class suitable for use with Searcher overload of <a class="el" href="#aa6b2f5d7fd6a15ab6fc4d30c1a716a6e" title="Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range [first,...">etl::search</a> that delegates the search operation to the pre-C++17 standard library's <a class="el" href="#aa6b2f5d7fd6a15ab6fc4d30c1a716a6e" title="Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range [first,...">etl::search</a>.  <a href="structetl_1_1default__searcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1defer__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to identify the destroying delete form of operator delete.  <a href="structetl_1_1destroying__delete__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits.  <a href="structetl_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1div__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides.html">divides</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing division. Effectively calls operator/ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/divides">https://en.cppreference.com/w/cpp/utility/functional/divides</a>.  <a href="structetl_1_1divides.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides_3_01void_01_4.html">divides&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1domain__error.html">domain_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1dynamic__array.html">dynamic_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1empty__c__array.html">empty_c_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html">enable_if&lt; true, Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator== on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/equal_to">https://en.cppreference.com/w/cpp/utility/functional/equal_to</a>.  <a href="structetl_1_1equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to_3_01void_01_4.html">equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1exception.html">exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1expected.html">expected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent.html">extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array type, provides the member constant value equal to the number of elements along the Nth dimension of the array, if N is in [0, rank_v&lt;T&gt;). For any other type, or if T is an array of unknown bound along its first dimension and N is 0, value is 0.  <a href="structetl_1_1extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_010_01_4.html">extent&lt; T[], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_01N_01_4.html">extent&lt; T[], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_010_01_4.html">extent&lt; T[I], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_01N_01_4.html">extent&lt; T[I], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extents.html">extents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1flat__set.html">flat_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> is a container adaptor that provides an associative container interface that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves. <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> supports random access iterators. Any sequence container supporting random access iteration can be used to instantiate <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a>.  <a href="structetl_1_1flat__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1format__to__n__result.html" title="etl::format_to_n_result has no base classes, or members other than out, size and implicitly declared ...">etl::format_to_n_result</a> has no base classes, or members other than out, size and implicitly declared special member functions.  <a href="structetl_1_1format__to__n__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter.html">formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enabled specializations of formatter define formatting rules for a given type. Enabled specializations meet the Formatter requirements.  <a href="structetl_1_1formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_01const_01_5_00_01char_01_4.html">formatter&lt; char const *, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_00_01char_01_4.html">formatter&lt; char, char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard specializations for basic type char.  <a href="structetl_1_1formatter_3_01char_00_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_0fN_0e_00_01char_01_4.html">formatter&lt; char[N], char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01etl_1_1static__string_3_01Capacity_01_4_00_01char_01_4.html">formatter&lt; etl::static_string&lt; Capacity &gt;, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01etl_1_1string__view_00_01char_01_4.html">formatter&lt; etl::string_view, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01int_00_01char_01_4.html">formatter&lt; int, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01long_01long_00_01char_01_4.html">formatter&lt; long long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01long_00_01char_01_4.html">formatter&lt; long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01short_00_01char_01_4.html">formatter&lt; short, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_01long_00_01char_01_4.html">formatter&lt; unsigned long long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_00_01char_01_4.html">formatter&lt; unsigned long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01short_00_01char_01_4.html">formatter&lt; unsigned short, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_00_01char_01_4.html">formatter&lt; unsigned, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1forward__iterator__tag.html">forward_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1forward__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive numerical input conversion.  <a href="structetl_1_1from__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is an LegacyOutputIterator that prepends elements to a container for which it was constructed. The container's push_front() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is a no-op.  <a href="structetl_1_1front__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1full__extent__t.html">full_extent_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning view of a callable.  <a href="structetl_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_01noexcept_01_4.html">function_ref&lt; R(Args...) noexcept &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater.html">greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater">https://en.cppreference.com/w/cpp/utility/functional/greater</a>.  <a href="structetl_1_1greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater_3_01void_01_4.html">greater&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal.html">greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater_equal">https://en.cppreference.com/w/cpp/utility/functional/greater_equal</a>.  <a href="structetl_1_1greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal_3_01void_01_4.html">greater_equal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1half.html">half</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TriviallyCopyable and if any two objects of type T with the same value have the same object representation, provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1has__unique__object__representations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__virtual__destructor.html">has_virtual_destructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <a href="structetl_1_1has__virtual__destructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash  <a href="structetl_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01bool_01_4.html">hash&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char_01_4.html">hash&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char16__t_01_4.html">hash&lt; char16_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char32__t_01_4.html">hash&lt; char32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char8__t_01_4.html">hash&lt; char8_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01double_01_4.html">hash&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01etl_1_1nullptr__t_01_4.html">hash&lt; etl::nullptr_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html">hash&lt; etl::optional&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template specialization of <a class="el" href="structetl_1_1hash.html" title="hash">etl::hash</a> for the <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> class allows users to obtain hashes of the values contained in optional objects.  <a href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01float_01_4.html">hash&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01int_01_4.html">hash&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01_4.html">hash&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01double_01_4.html">hash&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01long_01_4.html">hash&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01short_01_4.html">hash&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01signed_01char_01_4.html">hash&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01T_01_5_01_4.html">hash&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01char_01_4.html">hash&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01int_01_4.html">hash&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01_4.html">hash&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01long_01_4.html">hash&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01short_01_4.html">hash&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01wchar__t_01_4.html">hash&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1identity.html" title="etl::identity is a function object type whose operator() returns its argument unchanged.">etl::identity</a> is a function object type whose operator() returns its argument unchanged.  <a href="structetl_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ignore.html">ignore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with <a class="el" href="#a0d1ede89bcd679cdd58f45d98b785cd8">etl::tie</a> when unpacking a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>, as a placeholder for the arguments that are not used.  <a href="structetl_1_1ignore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1imaxdiv__t.html">imaxdiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1imaxdiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <code>optional</code>, <code>variant</code>, and <code>any</code> to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits.html">incrementable_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_5_01_4.html">incrementable_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_4.html">incrementable_traits&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01const_01_4.html">incrementable_traits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits.html">indirectly_readable_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01I_01_4.html">indirectly_readable_traits&lt; I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_5_01_4.html">indirectly_readable_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_4.html">indirectly_readable_traits&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01const_01_4.html">indirectly_readable_traits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__function_3_01R_07Args_8_8_8_08_00_01Capacity_00_01Alignment_01_4.html">inplace_function&lt; R(Args...), Capacity, Alignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__vector.html">inplace_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__vector_3_01T_00_010_01_4.html">inplace_vector&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1input__iterator__tag.html">input_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1input__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1invalid__argument.html">invalid_argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1invoke__result.html">invoke_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the return type of an INVOKE expression at compile time. F and all types in ArgTypes can be any complete type, array of unknown bound, or (possibly cv-qualified) void. The behavior of a program that adds specializations for any of the templates described on this page is undefined. This implementation is copied from <b>cppreference.com</b>.  <a href="structetl_1_1invoke__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ios__base.html">ios_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__abstract.html">is_abstract</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__aggregate.html">is_aggregate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__any__of.html">is_any_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined.  <a href="structetl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false.  <a href="structetl_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T_0f_0e_4.html">is_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T_0fN_0e_4.html">is_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__assignable.html">is_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval&lt;T&gt;()</a> = <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__base__of.html">is_base_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::fmtflags_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::iostate_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::openmode_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of known bound. Provides the member constant value which is equal to true, if T is an array type of known bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__bounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array_3_01T_0fN_0e_4.html">is_bounded_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__integer.html">is_builtin_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__signed__integer.html">is_builtin_signed_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__unsigned__integer.html">is_builtin_unsigned_integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if T is <code>unsigned char</code> or <code>unsigned short</code> or <code>unsigned int</code> or <code>unsigned long</code> or <code>unsigned long long</code>  <a href="structetl_1_1is__builtin__unsigned__integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__class.html">is_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__compound.html">is_compound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__compound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const.html">is_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const_3_01T_01const_01_4.html">is_const&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the imaginary function definition <code>To test() { return <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;From&gt;(); }</code> is well-formed, (that is, either <code><a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;From&gt;()</code> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <code><a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a></code> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered.  <a href="structetl_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_constructible&lt;T, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible.html">is_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.  <a href="structetl_1_1is__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01Type_0f_0e_4.html">is_destructible&lt; Type[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01void_01_4.html">is_destructible&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__empty.html">is_empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f T is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__enum.html">is_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum.html">is_error_condition_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum_3_01errc_01_4.html">is_error_condition_enum&lt; errc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__final.html">is_final</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a final class (that is, a class declared with the final specifier), provides the member constant value equal true. For any other type, value is false. If T is a class type, T shall be a complete type; otherwise, the behavior is undefined.  <a href="structetl_1_1is__final.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false.  <a href="structetl_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__function.html">is_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a fundamental type (that is, arithmetic type, void, or nullptr_t), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__fundamental.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_374fbed591f2848368bdbdd39f8c8e31.html">is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), false_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_63505ad1d5845f9b40fca2dabe8d3bef.html">is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__integral.html">is_integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a lvalue reference type. Provides the member constant value which is equal to true, if T is a lvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference_3_01T_01_6_01_4.html">is_lvalue_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__object__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function,...">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined.  <a href="structetl_1_1is__member__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval&lt;T&gt;()</a> = <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__nothrow__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable_3_01T_00_01U_01_4.html">is_nothrow_assignable&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__nothrow__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__convertible_3_01From_00_01To_01_4.html">is_nothrow_convertible&lt; From, To &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_nothrow_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_nothrow_constructible&lt;T, T const&amp;&gt;.  <a href="structetl_1_1is__nothrow__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__nothrow__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__nothrow__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_01_4.html">is_nothrow_destructible&lt; Type &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_6_01_4.html">is_nothrow_destructible&lt; Type &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_0fN_0e_4.html">is_nothrow_destructible&lt; Type[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__object.html">is_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_placeholder&lt; detail::placeholder_type&lt; N &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01_4.html">is_placeholder&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01volatile_01_4.html">is_placeholder&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01volatile_01_4.html">is_placeholder&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__polymorphic.html">is_polymorphic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference.html">is_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type (lvalue reference or rvalue reference), provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__reference.html" title="If T is a reference type (lvalue reference or rvalue reference), provides the member constant value e...">is_reference</a> or is_reference_v is undefined.  <a href="structetl_1_1is__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html">is_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html">is_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference__wrapper_3_01reference__wrapper_3_01U_01_4_01_4.html">is_reference_wrapper&lt; reference_wrapper&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a rvalue reference type. Provides the member constant value which is equal to true, if T is a rvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference_3_01T_01_6_6_01_4.html">is_rvalue_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scoped__enum_3_01T_00_01true_01_4.html">is_scoped_enum&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__signed.html">is_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false.  <a href="structetl_1_1is__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__specialized.html">is_specialized</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__specialized_3_01Template_00_01T_00_01etl_1_1void__t_3_01decltype_07Template_3_01T_01_4_02_03_08_4_01_4.html">is_specialized&lt; Template, T, etl::void_t&lt; decltype(Template&lt; T &gt;{})&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__standard__layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable.html">is_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_swappable_with&lt;T&amp;, T&amp;&gt;::value</a>.  <a href="structetl_1_1is__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivial.html">is_trivial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TrivialType (that is, a scalar type, a trivially copyable class with a trivial default constructor, or array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__trivial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval&lt;T&gt;()</a> = <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__trivially__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__trivially__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_trivially_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_trivially_constructible&lt;T, T const&amp;&gt;.  <a href="structetl_1_1is__trivially__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copyable.html">is_trivially_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a TriviallyCopyable type, provides the member constant value equal to true. For any other type, value is false. The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly cv-qualified). group is_trivial_copyable.  <a href="structetl_1_1is__trivially__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__trivially__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__destructible.html">is_trivially_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage occupied by trivially destructible objects may be reused without calling the destructor.  <a href="structetl_1_1is__trivially__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__typename.html">is_typename</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of unknown bound. Provides the member constant value which is equal to true, if T is an array type of unknown bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__unbounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array_3_01T_0f_0e_4.html">is_unbounded_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__union.html">is_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined.  <a href="structetl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01const_01_4.html">is_unsigned&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01const_01volatile_01_4.html">is_unsigned&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01volatile_01_4.html">is_unsigned&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__void.html">is_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile.html">is_volatile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile_3_01T_01volatile_01_4.html">is_volatile&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1iterator__traits.html" title="iterator_traits is the type trait class that provides uniform interface to the properties of LegacyIt...">iterator_traits</a> is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators.  <a href="structetl_1_1iterator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits_3_01T_01_5_01_4.html">iterator_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__left.html">layout_left</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__right.html">layout_right</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__stride.html">layout_stride</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1ldiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1length__error.html">length_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less.html">less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less">https://en.cppreference.com/w/cpp/utility/functional/less</a>.  <a href="structetl_1_1less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less_3_01void_01_4.html">less&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal.html">less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less_equal">https://en.cppreference.com/w/cpp/utility/functional/less_equal</a>.  <a href="structetl_1_1less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal_3_01void_01_4.html">less_equal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1lldiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1lock__guard.html">lock_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block. When a <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object was created, the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is destructed and the mutex is released. The <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> struct is non-copyable.  <a href="structetl_1_1lock__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logic__error.html">logic_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and.html">logical_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_and">https://en.cppreference.com/w/cpp/utility/functional/logical_and</a>.  <a href="structetl_1_1logical__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and_3_01void_01_4.html">logical_and&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not.html">logical_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_not">https://en.cppreference.com/w/cpp/utility/functional/logical_not</a>.  <a href="structetl_1_1logical__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not_3_01void_01_4.html">logical_not&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or.html">logical_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_or">https://en.cppreference.com/w/cpp/utility/functional/logical_or</a>.  <a href="structetl_1_1logical__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or_3_01void_01_4.html">logical_or&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__signed.html">make_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__signed.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_signed</a> is undefined.  <a href="structetl_1_1make__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined.  <a href="structetl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1max__align__t.html">max_align_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1max__align__t.html" title="etl::max_align_t is a trivial standard-layout type whose alignment requirement is at least as strict ...">etl::max_align_t</a> is a trivial standard-layout type whose alignment requirement is at least as strict (as large) as that of every scalar type.  <a href="structetl_1_1max__align__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1mdarray.html">mdarray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1mdspan.html">mdspan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus.html">minus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing subtraction. Effectively calls operator- on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/minus">https://en.cppreference.com/w/cpp/utility/functional/minus</a>.  <a href="structetl_1_1minus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus_3_01void_01_4.html">minus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus.html">modulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for computing remainders of divisions. Implements operator% for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/modulus">https://en.cppreference.com/w/cpp/utility/functional/modulus</a>.  <a href="structetl_1_1modulus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus_3_01void_01_4.html">modulus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit type intended for use as a well-behaved empty alternative in <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>. In particular, a variant of non-default-constructible types may list <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> as its first alternative: this makes the variant itself default-constructible.  <a href="structetl_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monotonic__allocator.html">monotonic_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies.html">multiplies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing multiplication. Effectively calls operator* on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/multiplies">https://en.cppreference.com/w/cpp/utility/functional/multiplies</a>.  <a href="structetl_1_1multiplies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies_3_01void_01_4.html">multiplies&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate.html">negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing negation. Effectively calls operator- on an instance of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/negate">https://en.cppreference.com/w/cpp/utility/functional/negate</a>.  <a href="structetl_1_1negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate_3_01void_01_4.html">negate&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical negation of the type trait B.  <a href="structetl_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nontype__t.html">nontype_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to.html">not_equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator!= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/not_equal_to">https://en.cppreference.com/w/cpp/utility/functional/not_equal_to</a>.  <a href="structetl_1_1not__equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to_3_01void_01_4.html">not_equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nothrow__t.html">nothrow_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> is an empty class type used to disambiguate the overloads of throwing and non-throwing allocation functions.  <a href="structetl_1_1nothrow__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> is an empty class type used to indicate optional type with uninitialized state. In particular, <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> has a constructor with <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">nullopt_t</a> as a single argument, which creates an optional that does not contain a value.  <a href="structetl_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01bool_01_4.html">numeric_limits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01char_01_4.html">numeric_limits&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01char8__t_01_4.html">numeric_limits&lt; char8_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01double_01_4.html">numeric_limits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01float_01_4.html">numeric_limits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01int_01_4.html">numeric_limits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01_4.html">numeric_limits&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01double_01_4.html">numeric_limits&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01long_01_4.html">numeric_limits&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01short_01_4.html">numeric_limits&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01signed_01char_01_4.html">numeric_limits&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01_4.html">numeric_limits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01volatile_01_4.html">numeric_limits&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01volatile_01_4.html">numeric_limits&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01char_01_4.html">numeric_limits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01int_01_4.html">numeric_limits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01long_01_4.html">numeric_limits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01long_01long_01_4.html">numeric_limits&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01short_01_4.html">numeric_limits&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template optional manages an optional contained value, i.e. a value that may or may not be present.  <a href="structetl_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1optional_3_01T_01_6_01_4.html">optional&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1out__of__range.html">out_of_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1output__iterator__tag.html">output_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1output__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overflow__error.html">overflow_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overload.html">overload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a> with two elements. If neither T1 nor T2 is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of pair is trivial.  <a href="structetl_1_1pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a> is an empty class tag type used to disambiguate between different functions that take two tuple arguments.  <a href="structetl_1_1piecewise__construct__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus.html">plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing addition. Effectively calls operator+ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/plus">https://en.cppreference.com/w/cpp/utility/functional/plus</a>.  <a href="structetl_1_1plus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus_3_01void_01_4.html">plus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__int__pair.html">pointer_int_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct implements a pair of a pointer and small integer. It is designed to represent this in the space required by one pointer by bitmangling the integer into the low part of the pointer. This can only be done for small integers: typically up to 3 bits, but it depends on the number of bits available according to <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for the type.  <a href="structetl_1_1pointer__int__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__int__pair__info.html">pointer_int_pair_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits.html">pointer_like_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits type that is used to handle pointer types and things that are just wrappers for pointers as a uniform entity.  <a href="structetl_1_1pointer__like__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01pointer__int__pair_3_01PtrT_00_01IntBits_00_01IntT_00_01PtrTraits_01_4_01_4.html">pointer_like_traits&lt; pointer_int_pair&lt; PtrT, IntBits, IntT, PtrTraits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html">pointer_like_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for non-cvr pointers.  <a href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html">pointer_like_traits&lt; T const * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const pointers.  <a href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html">pointer_like_traits&lt; T const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const things.  <a href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html">pointer_like_traits&lt; uintptr_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for uintptr_t.  <a href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__traits.html">pointer_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types.  <a href="structetl_1_1pointer__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html">pointer_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types. <a href="https://en.cppreference.com/w/cpp/memory/pointer_traits">https://en.cppreference.com/w/cpp/memory/pointer_traits</a>.  <a href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1random__access__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1range__error.html">range_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank.html">rank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined.  <a href="structetl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T_0f_0e_4.html">rank&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T_0fN_0e_4.html">rank&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The typename template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t.  <a href="structetl_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less.html">ratio_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__not__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">etl::static_vector</a>) which cannot normally hold references. Specifically, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a CopyConstructible and CopyAssignable wrapper around a reference to object or reference to function of type T. Instances of <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> are objects (they can be copied or stored in containers) but they are implicitly convertible to T&amp;, so that they can be used as arguments with the functions that take the underlying type by reference. If the stored reference is Callable, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is callable with the same arguments.  <a href="structetl_1_1reference__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X,...">remove_all_extents</a> is undefined.  <a href="structetl_1_1remove__all__extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T_0f_0e_4.html">remove_all_extents&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T_0fN_0e_4.html">remove_all_extents&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const.html">remove_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const.  <a href="structetl_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html">remove_const&lt; Type const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present.  <a href="structetl_1_1remove__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type T is a reference type, provides the member typedef type which is the type referred to by T with its topmost cv-qualifiers removed. Otherwise type is T with its topmost cv-qualifiers removed.  <a href="structetl_1_1remove__cvref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent.html">remove_extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T....">remove_extent</a> is undefined.  <a href="structetl_1_1remove__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T_0f_0e_4.html">remove_extent&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T_0fN_0e_4.html">remove_extent&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer, then type is the same as T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__pointer.html" title="Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer,...">remove_pointer</a> is undefined.  <a href="structetl_1_1remove__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5_01_4.html">remove_pointer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01_4.html">remove_pointer&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01volatile_01_4.html">remove_pointer&lt; T *const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5volatile_01_4.html">remove_pointer&lt; T *volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html">remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html">remove_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile.  <a href="structetl_1_1remove__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html">remove_volatile&lt; Type volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a> is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, <code><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a></code> produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator. This is the iterator returned by member functions <code><a class="el" href="#aef0e9ff3b7516f90525a93acb5fccc8e" title="Returns an iterator to the reverse-beginning of the given container.">rbegin()</a></code> and <code><a class="el" href="#ab55d22696b4d22653a103d0726157a18" title="Returns an iterator to the reverse-end of the given container.">rend()</a></code> of the standard library containers.  <a href="structetl_1_1reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1runtime__error.html">runtime_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1scope__exit.html">scope_exit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <code><a class="el" href="structetl_1_1scope__exit.html" title="The class template scope_exit is a general-purpose scope guard intended to call its exit function whe...">scope_exit</a></code> is a general-purpose scope guard intended to call its exit function when a scope is exited.  <a href="structetl_1_1scope__exit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1small__ptr.html">small_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed pointer to specified size. Intended to be used as a drop in replacement for native pointers.  <a href="structetl_1_1small__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning view over a contiguous sequence of objects.  <a href="structetl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1stack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stack class is a container adapter that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.  <a href="structetl_1_1stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html">static_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1static__set.html" title="static_set is an associative container that contains a sorted set of unique objects of type Key....">static_set</a> is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare.  <a href="structetl_1_1static__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically-resizable fixed-capacity vector.  <a href="structetl_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1strided__slice.html">strided_slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1string__constant.html">string_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1strong__ordering.html">strong_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1submdspan__mapping__result.html">submdspan_mapping_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1timespec.html">timespec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tm.html">tm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive numerical output conversion.  <a href="structetl_1_1to__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1try__to__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element.html">tuple_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface.  <a href="structetl_1_1tuple__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01array_3_01T_00_01N_01_4_01_4.html">tuple_element&lt; I, array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01etl_1_1complex_3_01T_01_4_01_4.html">tuple_element&lt; I, etl::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_element&lt; I, pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specializations of <a class="el" href="structetl_1_1tuple__element.html" title="Provides compile-time indexed access to the type of the elements of the array using tuple-like interf...">tuple_element</a> for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if I &gt;= 2.  <a href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01_4.html">tuple_element&lt; I, T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01volatile_01_4.html">tuple_element&lt; I, T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01volatile_01_4.html">tuple_element&lt; I, T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01tuple_3_01Ts_8_8_8_01_4_01_4.html">tuple_element&lt; I, tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size.html">tuple_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html">tuple_size&lt; array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the number of elements in an array as a compile-time constant expression.  <a href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1complex_3_01T_01_4_01_4.html">tuple_size&lt; etl::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_size&lt; pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization of <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a> for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.  <a href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01_4.html">tuple_size&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01volatile_01_4.html">tuple_size&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01volatile_01_4.html">tuple_size&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01tuple_3_01Ts_8_8_8_01_4_01_4.html">tuple_size&lt; tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1underflow__error.html">underflow_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1underlying__type.html">underlying_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type of an enum.  <a href="structetl_1_1underlying__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unexpect__t.html">unexpect_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unexpected.html">unexpected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uniform__int__distribution.html">uniform_int_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uniform__real__distribution.html">uniform_real_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__array.html">uninitialized_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__array_3_01T_00_01Size_01_4.html">uninitialized_array&lt; T, Size &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__union.html">uninitialized_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unique__lock.html">unique_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a> is a general-purpose mutex ownership wrapper allowing deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use with condition variables.  <a href="structetl_1_1unique__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__ref__decay.html">unwrap_ref_decay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__reference.html">unwrap_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__reference_3_01etl_1_1reference__wrapper_3_01T_01_4_01_4.html">unwrap_reference&lt; etl::reference_wrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false.  <a href="structetl_1_1uses__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionetl_1_1variadic__union.html">variadic_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionetl_1_1variadic__union_3_01T_00_01Ts_8_8_8_01_4.html">variadic_union&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant.html">variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template variant represents a type-safe union. An instance of variant at any given time either holds a value of one of its alternative types.  <a href="structetl_1_1variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant2.html">variant2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.  <a href="structetl_1_1variant__alternative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01etl_1_1variant2_3_01Ts_8_8_8_01_4_01_4.html">variant_alternative&lt; Idx, etl::variant2&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01etl_1_1variant_3_01Ts_8_8_8_01_4_01_4.html">variant_alternative&lt; Idx, etl::variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01_4.html">variant_alternative&lt; Idx, T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01volatile_01_4.html">variant_alternative&lt; Idx, T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01volatile_01_4.html">variant_alternative&lt; Idx, T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size.html">variant_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01const_01_4.html">variant_size&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01const_01volatile_01_4.html">variant_size&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01volatile_01_4.html">variant_size&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01variant2_3_01Ts_8_8_8_01_4_01_4.html">variant_size&lt; variant2&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01variant_3_01Ts_8_8_8_01_4_01_4.html">variant_size&lt; variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1weak__ordering.html">weak_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1where__expression.html">where_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xorshift.html">xorshift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>  <a href="structetl_1_1xorshift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128plus.html">xoshiro128plus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128plusplus.html">xoshiro128plusplus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128starstar.html">xoshiro128starstar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1bitmask__type.html">bitmask_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1three__way__comparable.html">three_way_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1assignable__from.html">assignable_from</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1boolean__testable.html">boolean_testable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__integer.html">builtin_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__signed__integer.html">builtin_signed_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">builtin_unsigned_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1common__reference__with.html">common_reference_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1common__with.html">common_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1constructible__from.html">constructible_from</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructible_from concept specifies that a variable of type T can be initialized with the given set of argument types Args.... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1convertible__to.html">convertible_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept convertible_to&lt;From, To&gt; specifies that an expression of the same type and value category as those of declval&lt;From&gt;() can be implicitly and explicitly converted to the type To, and the two forms of conversion are equivalent. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1copy__constructible.html">copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept copy_constructible is satisfied if T is an lvalue reference type, or if it is a move_constructible object type where an object of that type can constructed from a (possibly const) lvalue or const rvalue of that type in both direct- and copy-initialization contexts with the usual semantics (a copy is constructed with the source unchanged). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1copyable.html">copyable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1default__initializable.html">default_initializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default_initializable concept checks whether variables of type T can be value-initialized (T() is well-formed); direct-list-initialized from an empty initializer list (T{} is well-formed); and default-initialized (T t; is well-formed). Access checking is performed as if in a context unrelated to T. Only the validity of the immediate context of the variable initialization is considered. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1derived__from.html">derived_from</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept derived_from&lt;Derived, Base&gt; is satisfied if and only if Base is a class type that is either Derived or a public and unambiguous base of Derived, ignoring cv-qualifiers. Note that this behaviour is different to is_base_of when Base is a private or protected base of Derived. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1destructible.html">destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept destructible specifies the concept of all types whose instances can safely be destroyed at the end of their lifetime (including reference types). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1equality__comparable.html">equality_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1equivalence__relation.html">equivalence_relation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1floating__point.html">floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept floating_point&lt;T&gt; is satisfied if and only if T is a floating-point type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1integral.html">integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept integral&lt;T&gt; is satisfied if and only if T is an integral type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1invocable.html">invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__bidirectional__iterator.html">legacy_bidirectional_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__forward__iterator.html">legacy_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__input__iterator.html">legacy_input_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__iterator.html">legacy_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1movable.html">movable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1move__constructible.html">move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept move_constructible is satisfied if T is a reference type, or if it is an object type where an object of that type can be constructed from an rvalue of that type in both direct- and copy-initialization contexts, with the usual semantics. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1predicate.html">predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1referenceable.html">referenceable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1regular.html">regular</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1regular__invocable.html">regular_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1relation.html">relation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1same__as.html">same_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept same_as&lt;T, U&gt; is satisfied if and only if T and U denote the same type. same_as&lt;T, U&gt; subsumes same_as&lt;U, T&gt; and vice versa. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1semiregular.html">semiregular</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1signed__integral.html">signed_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept signed_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_signed_v&lt;T&gt; is true. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1strict__weak__order.html">strict_weak_order</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1swappable.html">swappable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1unsigned__integral.html">unsigned_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept unsigned_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_unsigned_v&lt;T&gt; is true. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1weakly__equality__comparable__with.html">weakly_equality_comparable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1incrementable.html">incrementable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__readable.html">indirectly_readable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__regular__unary__invocable.html">indirectly_regular_unary_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__unary__invocable.html">indirectly_unary_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1input__or__output__iterator.html">input_or_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1sentinel__for.html">sentinel_for</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1weakly__incrementable.html">weakly_incrementable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1pair__like.html">pair_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1tuple__like.html">tuple_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1693d67d03475372752f9e6973d67a8d" id="r_ga1693d67d03475372752f9e6973d67a8d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueType</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:ga1693d67d03475372752f9e6973d67a8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array.html#ga1693d67d03475372752f9e6973d67a8d">c_array</a> = <a class="el" href="structetl_1_1static__vector.html">ValueType</a>[<a class="el" href="structetl_1_1static__vector.html">Size</a>]</td></tr>
<tr class="separator:ga1693d67d03475372752f9e6973d67a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef34e23d4cca9aba8d78eeb0ae8fcd2e" id="r_gaef34e23d4cca9aba8d78eeb0ae8fcd2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaef34e23d4cca9aba8d78eeb0ae8fcd2e">float_t</a> = <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaef34e23d4cca9aba8d78eeb0ae8fcd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as float.  <br /></td></tr>
<tr class="separator:gaef34e23d4cca9aba8d78eeb0ae8fcd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0daa9c087aab901d5a05c155b62581" id="r_ga8b0daa9c087aab901d5a05c155b62581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8b0daa9c087aab901d5a05c155b62581">double_t</a> = <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8b0daa9c087aab901d5a05c155b62581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as double.  <br /></td></tr>
<tr class="separator:ga8b0daa9c087aab901d5a05c155b62581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8152600ad2707187b2826f06f7b489a" id="r_ab8152600ad2707187b2826f06f7b489a"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab8152600ad2707187b2826f06f7b489a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8152600ad2707187b2826f06f7b489a">common_comparison_category_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a>&lt;Ts...&gt;::type</td></tr>
<tr class="separator:ab8152600ad2707187b2826f06f7b489a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b715f3a9d55a158e1659f797689b0c" id="r_a08b715f3a9d55a158e1659f797689b0c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U  = T&gt; </td></tr>
<tr class="memitem:a08b715f3a9d55a158e1659f797689b0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08b715f3a9d55a158e1659f797689b0c">compare_three_way_result_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;() &lt;=&gt; <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t</a>&lt;U&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;())</td></tr>
<tr class="separator:a08b715f3a9d55a158e1659f797689b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2c9350d32e78a0e4c960b9859ccb40" id="r_afb2c9350d32e78a0e4c960b9859ccb40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">nullptr</a>)</td></tr>
<tr class="memdesc:afb2c9350d32e78a0e4c960b9859ccb40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type.  <br /></td></tr>
<tr class="separator:afb2c9350d32e78a0e4c960b9859ccb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac63559b08846022abfeabda8583ed87" id="r_aac63559b08846022abfeabda8583ed87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a> = <a class="el" href="builtin__types_8hpp.html#a19bfe4995271e67306bab6dc974ed002">TETL_BUILTIN_PTRDIFF</a></td></tr>
<tr class="memdesc:aac63559b08846022abfeabda8583ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aac63559b08846022abfeabda8583ed87" title="etl::ptrdiff_t is the signed integer type of the result of subtracting two pointers.">etl::ptrdiff_t</a> is the signed integer type of the result of subtracting two pointers.  <br /></td></tr>
<tr class="separator:aac63559b08846022abfeabda8583ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee50235c04ef643cb7502785393220fe" id="r_aee50235c04ef643cb7502785393220fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> = <a class="el" href="builtin__types_8hpp.html#ab236bea848bc390350ba3fc38ae07819">TETL_BUILTIN_SIZET</a></td></tr>
<tr class="memdesc:aee50235c04ef643cb7502785393220fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aee50235c04ef643cb7502785393220fe" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> is the unsigned integer type of the result of the sizeof operator.  <br /></td></tr>
<tr class="separator:aee50235c04ef643cb7502785393220fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e8ca666d23e897fd1d9f8411c6ca8" id="r_a711e8ca666d23e897fd1d9f8411c6ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a711e8ca666d23e897fd1d9f8411c6ca8">int_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:a711e8ca666d23e897fd1d9f8411c6ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:a711e8ca666d23e897fd1d9f8411c6ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4c952a1c7a141ed7115060bf4c22b0" id="r_a4b4c952a1c7a141ed7115060bf4c22b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b4c952a1c7a141ed7115060bf4c22b0">int_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a4b4c952a1c7a141ed7115060bf4c22b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a4b4c952a1c7a141ed7115060bf4c22b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32de47c4408fa865e1b8b99eb992d458" id="r_a32de47c4408fa865e1b8b99eb992d458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32de47c4408fa865e1b8b99eb992d458">int_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:a32de47c4408fa865e1b8b99eb992d458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:a32de47c4408fa865e1b8b99eb992d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff54514318ff648eb363a442f171c06" id="r_abff54514318ff648eb363a442f171c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abff54514318ff648eb363a442f171c06">int_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:abff54514318ff648eb363a442f171c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:abff54514318ff648eb363a442f171c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff47f46aff9c632e1283854fda8dc0e1" id="r_aff47f46aff9c632e1283854fda8dc0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff47f46aff9c632e1283854fda8dc0e1">int_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:aff47f46aff9c632e1283854fda8dc0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:aff47f46aff9c632e1283854fda8dc0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb2df1d7cc3d4d2c87221169156614f" id="r_a5cb2df1d7cc3d4d2c87221169156614f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cb2df1d7cc3d4d2c87221169156614f">int_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a5cb2df1d7cc3d4d2c87221169156614f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a5cb2df1d7cc3d4d2c87221169156614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce02c549a43d9c5f85a2b39b7c8c4b" id="r_ae2ce02c549a43d9c5f85a2b39b7c8c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2ce02c549a43d9c5f85a2b39b7c8c4b">int_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:ae2ce02c549a43d9c5f85a2b39b7c8c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:ae2ce02c549a43d9c5f85a2b39b7c8c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a53a2f96f40b0aeddf74828d71712e" id="r_a85a53a2f96f40b0aeddf74828d71712e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a53a2f96f40b0aeddf74828d71712e">int_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:a85a53a2f96f40b0aeddf74828d71712e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:a85a53a2f96f40b0aeddf74828d71712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ed057e79c7de5d1451928e10dcf46d" id="r_a52ed057e79c7de5d1451928e10dcf46d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52ed057e79c7de5d1451928e10dcf46d">int8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:a52ed057e79c7de5d1451928e10dcf46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 8 bits.  <br /></td></tr>
<tr class="separator:a52ed057e79c7de5d1451928e10dcf46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962db76b841f05bb03ac61766d75d791" id="r_a962db76b841f05bb03ac61766d75d791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a962db76b841f05bb03ac61766d75d791">int16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a962db76b841f05bb03ac61766d75d791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 16 bits.  <br /></td></tr>
<tr class="separator:a962db76b841f05bb03ac61766d75d791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e2791ab5c84359b03776662eb994b6" id="r_a07e2791ab5c84359b03776662eb994b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07e2791ab5c84359b03776662eb994b6">int32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:a07e2791ab5c84359b03776662eb994b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 32 bits.  <br /></td></tr>
<tr class="separator:a07e2791ab5c84359b03776662eb994b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bed93ea1d934540fd05d361a6fc7c5e" id="r_a3bed93ea1d934540fd05d361a6fc7c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bed93ea1d934540fd05d361a6fc7c5e">int64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:a3bed93ea1d934540fd05d361a6fc7c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 64 bits.  <br /></td></tr>
<tr class="separator:a3bed93ea1d934540fd05d361a6fc7c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64887361e0411caef7d81a411f3a6868" id="r_a64887361e0411caef7d81a411f3a6868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64887361e0411caef7d81a411f3a6868">intmax_t</a> = <a class="el" href="builtin__types_8hpp.html#ad8678dda9c4b939fee5244864c53ada1">TETL_BUILTIN_INTMAX</a></td></tr>
<tr class="memdesc:a64887361e0411caef7d81a411f3a6868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum-width signed integer type.  <br /></td></tr>
<tr class="separator:a64887361e0411caef7d81a411f3a6868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd46e49593ca8eb7a2a60667662abf4" id="r_a3fd46e49593ca8eb7a2a60667662abf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd46e49593ca8eb7a2a60667662abf4">intptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a021098c463419df8b156d80c9153387e">TETL_BUILTIN_INTPTR</a></td></tr>
<tr class="memdesc:a3fd46e49593ca8eb7a2a60667662abf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type capable of holding a pointer.  <br /></td></tr>
<tr class="separator:a3fd46e49593ca8eb7a2a60667662abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8e71ca66f676d88d4bfc4023421cd9" id="r_aba8e71ca66f676d88d4bfc4023421cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba8e71ca66f676d88d4bfc4023421cd9">uint_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:aba8e71ca66f676d88d4bfc4023421cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:aba8e71ca66f676d88d4bfc4023421cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516df22f1e6a839bc251cc699c90ab56" id="r_a516df22f1e6a839bc251cc699c90ab56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a516df22f1e6a839bc251cc699c90ab56">uint_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a516df22f1e6a839bc251cc699c90ab56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a516df22f1e6a839bc251cc699c90ab56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ae5542021173d59890b67e0f5dcd20" id="r_a39ae5542021173d59890b67e0f5dcd20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ae5542021173d59890b67e0f5dcd20">uint_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:a39ae5542021173d59890b67e0f5dcd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:a39ae5542021173d59890b67e0f5dcd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b174a549a84b470b20998da935f674" id="r_a49b174a549a84b470b20998da935f674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49b174a549a84b470b20998da935f674">uint_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a49b174a549a84b470b20998da935f674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:a49b174a549a84b470b20998da935f674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9da1f87db9cd7b9d1f76ade9b44c94" id="r_a3e9da1f87db9cd7b9d1f76ade9b44c94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e9da1f87db9cd7b9d1f76ade9b44c94">uint_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:a3e9da1f87db9cd7b9d1f76ade9b44c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:a3e9da1f87db9cd7b9d1f76ade9b44c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce3c5bd0ff2f44caabd1b4d707887fc" id="r_acce3c5bd0ff2f44caabd1b4d707887fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acce3c5bd0ff2f44caabd1b4d707887fc">uint_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:acce3c5bd0ff2f44caabd1b4d707887fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:acce3c5bd0ff2f44caabd1b4d707887fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35f8b747d163b033b7d4bf5b18b2f61" id="r_ad35f8b747d163b033b7d4bf5b18b2f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad35f8b747d163b033b7d4bf5b18b2f61">uint_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:ad35f8b747d163b033b7d4bf5b18b2f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:ad35f8b747d163b033b7d4bf5b18b2f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace30aa068da2786e3178c001a9dcb45f" id="r_ace30aa068da2786e3178c001a9dcb45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace30aa068da2786e3178c001a9dcb45f">uint_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:ace30aa068da2786e3178c001a9dcb45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:ace30aa068da2786e3178c001a9dcb45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71924434159564bc3aa4bd2930947053" id="r_a71924434159564bc3aa4bd2930947053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71924434159564bc3aa4bd2930947053">uint8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:a71924434159564bc3aa4bd2930947053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 8 bits.  <br /></td></tr>
<tr class="separator:a71924434159564bc3aa4bd2930947053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46518a317507676ba5887e53ca4bf5bd" id="r_a46518a317507676ba5887e53ca4bf5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46518a317507676ba5887e53ca4bf5bd">uint16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a46518a317507676ba5887e53ca4bf5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 16 bits.  <br /></td></tr>
<tr class="separator:a46518a317507676ba5887e53ca4bf5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac524e3389ea120063f493b23ce5ba2a6" id="r_ac524e3389ea120063f493b23ce5ba2a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac524e3389ea120063f493b23ce5ba2a6">uint32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:ac524e3389ea120063f493b23ce5ba2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 32 bits.  <br /></td></tr>
<tr class="separator:ac524e3389ea120063f493b23ce5ba2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbbc3f006120acc1de719e7d8ee6f40" id="r_a5bbbc3f006120acc1de719e7d8ee6f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bbbc3f006120acc1de719e7d8ee6f40">uint64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a5bbbc3f006120acc1de719e7d8ee6f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 64 bits.  <br /></td></tr>
<tr class="separator:a5bbbc3f006120acc1de719e7d8ee6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05138bec421765330b01b925aae5d89f" id="r_a05138bec421765330b01b925aae5d89f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05138bec421765330b01b925aae5d89f">uintmax_t</a> = <a class="el" href="builtin__types_8hpp.html#a64175350ea04c19125422816cd6184e1">TETL_BUILTIN_UINTMAX</a></td></tr>
<tr class="memdesc:a05138bec421765330b01b925aae5d89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum-width unsigned integer type.  <br /></td></tr>
<tr class="separator:a05138bec421765330b01b925aae5d89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d944a371245d51e3b9ea011f7b97f43" id="r_a1d944a371245d51e3b9ea011f7b97f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d944a371245d51e3b9ea011f7b97f43">uintptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a3b013e093af0767d757a3606463295d9">TETL_BUILTIN_UINTPTR</a></td></tr>
<tr class="memdesc:a1d944a371245d51e3b9ea011f7b97f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type capable of holding a pointer.  <br /></td></tr>
<tr class="separator:a1d944a371245d51e3b9ea011f7b97f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cb041233ab00ef4358f99afedca8d0" id="r_a78cb041233ab00ef4358f99afedca8d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78cb041233ab00ef4358f99afedca8d0">clock_t</a> = <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="separator:a78cb041233ab00ef4358f99afedca8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62da72e20fc89d790a5f88420496d0d7" id="r_a62da72e20fc89d790a5f88420496d0d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62da72e20fc89d790a5f88420496d0d7">time_t</a> = <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:a62da72e20fc89d790a5f88420496d0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic type capable of representing times.  <br /></td></tr>
<tr class="separator:a62da72e20fc89d790a5f88420496d0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4e6bc2deecad0fb678bfe7c838df5e" id="r_afb4e6bc2deecad0fb678bfe7c838df5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> = <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="separator:afb4e6bc2deecad0fb678bfe7c838df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8c737296655b44480da4fb422add24" id="r_abd8c737296655b44480da4fb422add24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd8c737296655b44480da4fb422add24">format_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">format_context</a>&gt;</td></tr>
<tr class="separator:abd8c737296655b44480da4fb422add24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff8faaf423d40e312921ee1506eaf5b" id="r_afff8faaf423d40e312921ee1506eaf5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff8faaf423d40e312921ee1506eaf5b">wformat_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a>&gt;</td></tr>
<tr class="separator:afff8faaf423d40e312921ee1506eaf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadb6bf7ddccdb7fc0a95da5b0b911ef" id="r_afadb6bf7ddccdb7fc0a95da5b0b911ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">format_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;&gt;, <a class="el" href="structetl_1_1static__vector.html">char</a>&gt;</td></tr>
<tr class="memdesc:afadb6bf7ddccdb7fc0a95da5b0b911ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to formatting state consisting of the formatting arguments and the output iterator.  <br /></td></tr>
<tr class="separator:afadb6bf7ddccdb7fc0a95da5b0b911ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b255764cde83db44d0e61eebc55d36" id="r_a03b255764cde83db44d0e61eebc55d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;&gt;, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;</td></tr>
<tr class="separator:a03b255764cde83db44d0e61eebc55d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f31f076b2eb408741895533f9222baa" id="r_a7f31f076b2eb408741895533f9222baa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f31f076b2eb408741895533f9222baa">format_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;</td></tr>
<tr class="separator:a7f31f076b2eb408741895533f9222baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a60587ace165efab2fc40bddf69c89c" id="r_a9a60587ace165efab2fc40bddf69c89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a60587ace165efab2fc40bddf69c89c">wformat_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;</td></tr>
<tr class="separator:a9a60587ace165efab2fc40bddf69c89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a828fb91283babdb0eef8e0d9010cb" id="r_a56a828fb91283babdb0eef8e0d9010cb"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a56a828fb91283babdb0eef8e0d9010cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56a828fb91283babdb0eef8e0d9010cb">format_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="#ae7cfb52ab2d82ff12cd2e0340315447f">type_identity_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&gt;...&gt;</td></tr>
<tr class="separator:a56a828fb91283babdb0eef8e0d9010cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c1b057042c87184f2220c79696ef73" id="r_a69c1b057042c87184f2220c79696ef73"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a69c1b057042c87184f2220c79696ef73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69c1b057042c87184f2220c79696ef73">wformat_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>, <a class="el" href="#ae7cfb52ab2d82ff12cd2e0340315447f">type_identity_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&gt;...&gt;</td></tr>
<tr class="separator:a69c1b057042c87184f2220c79696ef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dfe0d6b5c463f72f72a6bf14e21b0f" id="r_a05dfe0d6b5c463f72f72a6bf14e21b0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </td></tr>
<tr class="memitem:a05dfe0d6b5c463f72f72a6bf14e21b0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">diff_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;<a class="el" href="#a2d55d5d88d171bb347117b67a8741b65">etl::remove_cvref_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>&gt;&gt;::difference_type</td></tr>
<tr class="separator:a05dfe0d6b5c463f72f72a6bf14e21b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636c37daca18857edd92e6fa8ebb6627" id="r_a636c37daca18857edd92e6fa8ebb6627"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a636c37daca18857edd92e6fa8ebb6627"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a636c37daca18857edd92e6fa8ebb6627">stringbuf</a> = <a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td></tr>
<tr class="separator:a636c37daca18857edd92e6fa8ebb6627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b66173615e2c5f0568adb2cae8739f" id="r_a66b66173615e2c5f0568adb2cae8739f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b66173615e2c5f0568adb2cae8739f">streamoff</a> = <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="separator:a66b66173615e2c5f0568adb2cae8739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcecc45ff4539025dd0eb1cea84021f9" id="r_afcecc45ff4539025dd0eb1cea84021f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcecc45ff4539025dd0eb1cea84021f9">streamsize</a> = <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt;</td></tr>
<tr class="separator:afcecc45ff4539025dd0eb1cea84021f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad753b7ec242604e8139a352b4d049398" id="r_ad753b7ec242604e8139a352b4d049398"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Iters&gt; </td></tr>
<tr class="memitem:ad753b7ec242604e8139a352b4d049398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad753b7ec242604e8139a352b4d049398">indirect_result_t</a> = <a class="el" href="#a601366c5cf97ac29c08fc7b51db875a9">etl::invoke_result_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, <a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">etl::iter_reference_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iters</a>&gt;...&gt;</td></tr>
<tr class="separator:ad753b7ec242604e8139a352b4d049398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa4cba4e97f7e0ff2dbb2f8238d5734" id="r_a7aa4cba4e97f7e0ff2dbb2f8238d5734"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> T&gt; </td></tr>
<tr class="memitem:a7aa4cba4e97f7e0ff2dbb2f8238d5734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7aa4cba4e97f7e0ff2dbb2f8238d5734">iter_common_reference_t</a> = <a class="el" href="#afe1164daef675b01dddc89c2b7c28d80">etl::common_reference_t</a>&lt;<a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">etl::iter_reference_t</a>&lt;T&gt;, <a class="el" href="#afe275d17dd765cd278253e72900c895f">etl::iter_value_t</a>&lt;T&gt;&amp;&gt;</td></tr>
<tr class="separator:a7aa4cba4e97f7e0ff2dbb2f8238d5734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bccf0617839402578ce56ea06409b5" id="r_a89bccf0617839402578ce56ea06409b5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a89bccf0617839402578ce56ea06409b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89bccf0617839402578ce56ea06409b5">iter_difference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::iter_difference&lt;T&gt;::type</td></tr>
<tr class="separator:a89bccf0617839402578ce56ea06409b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c2555dd1910c170ae137cc8cdceb7" id="r_ad39c2555dd1910c170ae137cc8cdceb7"><td class="memTemplParams" colspan="2">template&lt;etl::detail::dereferenceable T&gt; </td></tr>
<tr class="memitem:ad39c2555dd1910c170ae137cc8cdceb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">iter_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(*<a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;T&amp;&gt;())</td></tr>
<tr class="separator:ad39c2555dd1910c170ae137cc8cdceb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bec1ad7f12ec0170c07608d82af228" id="r_ac0bec1ad7f12ec0170c07608d82af228"><td class="memTemplParams" colspan="2">template&lt;etl::detail::dereferenceable T&gt; </td></tr>
<tr class="memitem:ac0bec1ad7f12ec0170c07608d82af228"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0bec1ad7f12ec0170c07608d82af228">iter_rvalue_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="namespaceetl_1_1ranges_1_1cpo.html#a78d082ea4928d84830a8184d72aedca6">etl::ranges::iter_move</a>(<a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;T&amp;&gt;()))</td></tr>
<tr class="separator:ac0bec1ad7f12ec0170c07608d82af228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe275d17dd765cd278253e72900c895f" id="r_afe275d17dd765cd278253e72900c895f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afe275d17dd765cd278253e72900c895f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe275d17dd765cd278253e72900c895f">iter_value_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::iter_value&lt;T&gt;::type</td></tr>
<tr class="separator:afe275d17dd765cd278253e72900c895f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6729ebb98236f93b98f0492cb3415fb7" id="r_a6729ebb98236f93b98f0492cb3415fb7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> Iter, <a class="el" href="conceptetl_1_1indirectly__regular__unary__invocable.html">etl::indirectly_regular_unary_invocable</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; Proj&gt; </td></tr>
<tr class="memitem:a6729ebb98236f93b98f0492cb3415fb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6729ebb98236f93b98f0492cb3415fb7">projected</a> = etl::detail::projected_impl&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>, <a class="el" href="structetl_1_1static__vector.html">Proj</a>&gt;::type</td></tr>
<tr class="separator:a6729ebb98236f93b98f0492cb3415fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53bcc0a66170293af1f9319d4663d1a" id="r_ac53bcc0a66170293af1f9319d4663d1a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexType</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Rank&gt; </td></tr>
<tr class="memitem:ac53bcc0a66170293af1f9319d4663d1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac53bcc0a66170293af1f9319d4663d1a">dextents</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::dextents_impl&lt;<a class="el" href="structetl_1_1static__vector.html">IndexType</a>, <a class="el" href="#a3c526d8179a55ec15611d7627272e067">etl::make_index_sequence</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Rank</a>&gt;&gt;::type</td></tr>
<tr class="separator:ac53bcc0a66170293af1f9319d4663d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f26afef63b527bf205bb01455a515b" id="r_aa2f26afef63b527bf205bb01455a515b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2f26afef63b527bf205bb01455a515b">new_handler</a> = <a class="el" href="structetl_1_1static__vector.html">void</a> (*)()</td></tr>
<tr class="memdesc:aa2f26afef63b527bf205bb01455a515b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aa2f26afef63b527bf205bb01455a515b" title="etl::new_handler is the function pointer type (pointer to function that takes no arguments and return...">etl::new_handler</a> is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions etl::set_new_handler and etl::get_new_handler  <br /></td></tr>
<tr class="separator:aa2f26afef63b527bf205bb01455a515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355c433e6d91bee78ed9c6448e77aeb4" id="r_ga355c433e6d91bee78ed9c6448e77aeb4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga355c433e6d91bee78ed9c6448e77aeb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga355c433e6d91bee78ed9c6448e77aeb4">ratio_add</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga355c433e6d91bee78ed9c6448e77aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_add denotes the result of adding two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga355c433e6d91bee78ed9c6448e77aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a3d5969bc4fe12c5f31a130821b9ce" id="r_gac1a3d5969bc4fe12c5f31a130821b9ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:gac1a3d5969bc4fe12c5f31a130821b9ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#gac1a3d5969bc4fe12c5f31a130821b9ce">ratio_divide</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den, R1::den * R2::num&gt;</td></tr>
<tr class="memdesc:gac1a3d5969bc4fe12c5f31a130821b9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_divide denotes the result of dividing two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:gac1a3d5969bc4fe12c5f31a130821b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471b6ab570a3512d31a677dc0ab4743d" id="r_ga471b6ab570a3512d31a677dc0ab4743d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga471b6ab570a3512d31a677dc0ab4743d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga471b6ab570a3512d31a677dc0ab4743d">ratio_multiply</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::num, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga471b6ab570a3512d31a677dc0ab4743d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_multiply denotes the result of multiplying two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga471b6ab570a3512d31a677dc0ab4743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bcee71a1ca1a48e5c5485d3aaad395" id="r_ga25bcee71a1ca1a48e5c5485d3aaad395"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga25bcee71a1ca1a48e5c5485d3aaad395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga25bcee71a1ca1a48e5c5485d3aaad395">ratio_subtract</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga25bcee71a1ca1a48e5c5485d3aaad395"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_subtract denotes the result of subtracting two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga25bcee71a1ca1a48e5c5485d3aaad395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cac3d2bc7e91527aa7422b304a2c3b9" id="r_a2cac3d2bc7e91527aa7422b304a2c3b9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a2cac3d2bc7e91527aa7422b304a2c3b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">static_string</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td></tr>
<tr class="memdesc:a2cac3d2bc7e91527aa7422b304a2c3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'char'.  <br /></td></tr>
<tr class="separator:a2cac3d2bc7e91527aa7422b304a2c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddab558c296b52627438267301b1976" id="r_a1ddab558c296b52627438267301b1976"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a1ddab558c296b52627438267301b1976"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ddab558c296b52627438267301b1976">static_wstring</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td></tr>
<tr class="memdesc:a1ddab558c296b52627438267301b1976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'wchar_t'.  <br /></td></tr>
<tr class="separator:a1ddab558c296b52627438267301b1976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7f02db9e66eaec8dccdca2f4e98a2f" id="r_a6f7f02db9e66eaec8dccdca2f4e98a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">string_view</a> = <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;&gt;</td></tr>
<tr class="memdesc:a6f7f02db9e66eaec8dccdca2f4e98a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedefs for common character type.  <br /></td></tr>
<tr class="separator:a6f7f02db9e66eaec8dccdca2f4e98a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88df1a5f5c335cb6cf4909b47882e53" id="r_ae88df1a5f5c335cb6cf4909b47882e53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae88df1a5f5c335cb6cf4909b47882e53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, T&gt;::type</td></tr>
<tr class="separator:ae88df1a5f5c335cb6cf4909b47882e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9600db38eaa1a27a206f9fb90b1dedb7" id="r_a9600db38eaa1a27a206f9fb90b1dedb7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Len, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Align = alignof(detail::aligned_storage_impl&lt;Len&gt;)&gt; </td></tr>
<tr class="memitem:a9600db38eaa1a27a206f9fb90b1dedb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9600db38eaa1a27a206f9fb90b1dedb7">aligned_storage_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1aligned__storage.html">etl::aligned_storage</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Len</a>, <a class="el" href="structetl_1_1static__vector.html">Align</a>&gt;::type</td></tr>
<tr class="separator:a9600db38eaa1a27a206f9fb90b1dedb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9513446f02808e2f74f025a795d894c2" id="r_a9513446f02808e2f74f025a795d894c2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Len, typename... Types&gt; </td></tr>
<tr class="memitem:a9513446f02808e2f74f025a795d894c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9513446f02808e2f74f025a795d894c2">aligned_union_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1aligned__union.html">etl::aligned_union</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Len</a>, Types...&gt;::type</td></tr>
<tr class="separator:a9513446f02808e2f74f025a795d894c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c90336c94cb0db8abdd10603a3c7cc" id="r_ac5c90336c94cb0db8abdd10603a3c7cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B&gt; </td></tr>
<tr class="memitem:ac5c90336c94cb0db8abdd10603a3c7cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">B</a>&gt;</td></tr>
<tr class="separator:ac5c90336c94cb0db8abdd10603a3c7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e9c28fa52ab73ef48e5cbed20c66fd" id="r_aa4e9c28fa52ab73ef48e5cbed20c66fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4e9c28fa52ab73ef48e5cbed20c66fd">true_type</a> = <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">true</a>&gt;</td></tr>
<tr class="separator:aa4e9c28fa52ab73ef48e5cbed20c66fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15d3ff5d80b8c8c22e9ce862353ba55" id="r_ad15d3ff5d80b8c8c22e9ce862353ba55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad15d3ff5d80b8c8c22e9ce862353ba55">false_type</a> = <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">false</a>&gt;</td></tr>
<tr class="separator:ad15d3ff5d80b8c8c22e9ce862353ba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1164daef675b01dddc89c2b7c28d80" id="r_afe1164daef675b01dddc89c2b7c28d80"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:afe1164daef675b01dddc89c2b7c28d80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe1164daef675b01dddc89c2b7c28d80">common_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__reference.html">common_reference</a>&lt;T...&gt;::type</td></tr>
<tr class="separator:afe1164daef675b01dddc89c2b7c28d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d6d310a0bc8bcb40b024f5259088a6" id="r_a29d6d310a0bc8bcb40b024f5259088a6"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a29d6d310a0bc8bcb40b024f5259088a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29d6d310a0bc8bcb40b024f5259088a6">common_type_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__type.html">etl::common_type</a>&lt;T...&gt;::type</td></tr>
<tr class="separator:a29d6d310a0bc8bcb40b024f5259088a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccf02556580259044928051b1689171" id="r_a4ccf02556580259044928051b1689171"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; </td></tr>
<tr class="memitem:a4ccf02556580259044928051b1689171"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ccf02556580259044928051b1689171">conditional_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1conditional.html">etl::conditional</a>&lt;<a class="el" href="structetl_1_1static__vector.html">B</a>, T, <a class="el" href="structetl_1_1static__vector.html">F</a>&gt;::type</td></tr>
<tr class="separator:a4ccf02556580259044928051b1689171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f3c9ab2c53f9192c2899fc8efb263d" id="r_a24f3c9ab2c53f9192c2899fc8efb263d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a24f3c9ab2c53f9192c2899fc8efb263d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a24f3c9ab2c53f9192c2899fc8efb263d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e9cb7fadbcfaa2afb5b94058b8e34c" id="r_a93e9cb7fadbcfaa2afb5b94058b8e34c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B, <a class="el" href="structetl_1_1static__vector.html">typename</a> T  = void&gt; </td></tr>
<tr class="memitem:a93e9cb7fadbcfaa2afb5b94058b8e34c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structetl_1_1static__vector.html">B</a>, T&gt;::type</td></tr>
<tr class="separator:a93e9cb7fadbcfaa2afb5b94058b8e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa543888abe1d65f79e9b1a62b95dc55" id="r_aaa543888abe1d65f79e9b1a62b95dc55"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I&gt; </td></tr>
<tr class="memitem:aaa543888abe1d65f79e9b1a62b95dc55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa543888abe1d65f79e9b1a62b95dc55">index_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">etl::integral_constant</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="structetl_1_1static__vector.html">I</a>&gt;</td></tr>
<tr class="separator:aaa543888abe1d65f79e9b1a62b95dc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601366c5cf97ac29c08fc7b51db875a9" id="r_a601366c5cf97ac29c08fc7b51db875a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a601366c5cf97ac29c08fc7b51db875a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a601366c5cf97ac29c08fc7b51db875a9">invoke_result_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1invoke__result.html">etl::invoke_result</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, ArgTypes...&gt;::type</td></tr>
<tr class="separator:a601366c5cf97ac29c08fc7b51db875a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab130b8cdd79b1e59a593d4cb1c6ffe13" id="r_ab130b8cdd79b1e59a593d4cb1c6ffe13"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:ab130b8cdd79b1e59a593d4cb1c6ffe13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab130b8cdd79b1e59a593d4cb1c6ffe13">is_constructible</a> = detail::is_constructible_helper&lt;<a class="el" href="#ab8ddf9531fc4ac7ce28574db20c8f20e">etl::void_t</a>&lt;&gt;, T, Args...&gt;</td></tr>
<tr class="separator:ab130b8cdd79b1e59a593d4cb1c6ffe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd5f69b53391404e954cf610afa6c54" id="r_aafd5f69b53391404e954cf610afa6c54"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aafd5f69b53391404e954cf610afa6c54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt;T&gt;::type</td></tr>
<tr class="separator:aafd5f69b53391404e954cf610afa6c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeda2fce2dea6fa29533488400dd386" id="r_aabeda2fce2dea6fa29533488400dd386"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aabeda2fce2dea6fa29533488400dd386"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aabeda2fce2dea6fa29533488400dd386">make_unsigned_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td></tr>
<tr class="separator:aabeda2fce2dea6fa29533488400dd386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffde65d0200b12233a0dff1979cc210" id="r_a0ffde65d0200b12233a0dff1979cc210"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0ffde65d0200b12233a0dff1979cc210"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ffde65d0200b12233a0dff1979cc210">remove_all_extents_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a0ffde65d0200b12233a0dff1979cc210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ac8d2d02fd6d54092f32339587b6ed" id="r_ae7ac8d2d02fd6d54092f32339587b6ed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae7ac8d2d02fd6d54092f32339587b6ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7ac8d2d02fd6d54092f32339587b6ed">remove_const_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__const.html">etl::remove_const</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ae7ac8d2d02fd6d54092f32339587b6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9629a84441c7647c5374e5f1ada63df5" id="r_a9629a84441c7647c5374e5f1ada63df5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9629a84441c7647c5374e5f1ada63df5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9629a84441c7647c5374e5f1ada63df5">remove_cv_t</a> = <a class="el" href="#ae7ac8d2d02fd6d54092f32339587b6ed">etl::remove_const_t</a>&lt;<a class="el" href="#ad8be2e70b3b5f54ad08dcfc5af63c9da">etl::remove_volatile_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a9629a84441c7647c5374e5f1ada63df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d55d5d88d171bb347117b67a8741b65" id="r_a2d55d5d88d171bb347117b67a8741b65"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a2d55d5d88d171bb347117b67a8741b65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d55d5d88d171bb347117b67a8741b65">remove_cvref_t</a> = <a class="el" href="#a9629a84441c7647c5374e5f1ada63df5">etl::remove_cv_t</a>&lt;<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a2d55d5d88d171bb347117b67a8741b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0303895778ee0a3f41e112cb7553ef" id="r_a3a0303895778ee0a3f41e112cb7553ef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3a0303895778ee0a3f41e112cb7553ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a0303895778ee0a3f41e112cb7553ef">remove_extent_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__extent.html">etl::remove_extent</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a3a0303895778ee0a3f41e112cb7553ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65c39ad5cff999e37c5009b047655a4" id="r_af65c39ad5cff999e37c5009b047655a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af65c39ad5cff999e37c5009b047655a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af65c39ad5cff999e37c5009b047655a4">remove_pointer_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__pointer.html">etl::remove_pointer</a>&lt;T&gt;::type</td></tr>
<tr class="separator:af65c39ad5cff999e37c5009b047655a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9319953b536fc8279d2a105b02d1a938" id="r_a9319953b536fc8279d2a105b02d1a938"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9319953b536fc8279d2a105b02d1a938"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a9319953b536fc8279d2a105b02d1a938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8be2e70b3b5f54ad08dcfc5af63c9da" id="r_ad8be2e70b3b5f54ad08dcfc5af63c9da"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad8be2e70b3b5f54ad08dcfc5af63c9da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8be2e70b3b5f54ad08dcfc5af63c9da">remove_volatile_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__volatile.html">etl::remove_volatile</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ad8be2e70b3b5f54ad08dcfc5af63c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3d3a54ac48d364dc4b3a06a7522126" id="r_a2a3d3a54ac48d364dc4b3a06a7522126"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> N&gt; </td></tr>
<tr class="memitem:a2a3d3a54ac48d364dc4b3a06a7522126"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a3d3a54ac48d364dc4b3a06a7522126">smallest_size_t</a></td></tr>
<tr class="memdesc:a2a3d3a54ac48d364dc4b3a06a7522126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest fixed-width unsigned integer type that can represent values in the range [0, N].  <br /></td></tr>
<tr class="separator:a2a3d3a54ac48d364dc4b3a06a7522126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cfb52ab2d82ff12cd2e0340315447f" id="r_ae7cfb52ab2d82ff12cd2e0340315447f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae7cfb52ab2d82ff12cd2e0340315447f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7cfb52ab2d82ff12cd2e0340315447f">type_identity_t</a> = T</td></tr>
<tr class="separator:ae7cfb52ab2d82ff12cd2e0340315447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68cdd3b170a7e28ceeb562ad04c2853" id="r_aa68cdd3b170a7e28ceeb562ad04c2853"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa68cdd3b170a7e28ceeb562ad04c2853"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa68cdd3b170a7e28ceeb562ad04c2853">underlying_type_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1underlying__type.html">etl::underlying_type</a>&lt;T&gt;::type</td></tr>
<tr class="separator:aa68cdd3b170a7e28ceeb562ad04c2853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfe1ea88386619b73c8642aaac66548" id="r_aadfe1ea88386619b73c8642aaac66548"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aadfe1ea88386619b73c8642aaac66548"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aadfe1ea88386619b73c8642aaac66548">unwrap_ref_decay_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1unwrap__ref__decay.html">etl::unwrap_ref_decay</a>&lt;T&gt;::type</td></tr>
<tr class="separator:aadfe1ea88386619b73c8642aaac66548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ddf9531fc4ac7ce28574db20c8f20e" id="r_ab8ddf9531fc4ac7ce28574db20c8f20e"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ab8ddf9531fc4ac7ce28574db20c8f20e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8ddf9531fc4ac7ce28574db20c8f20e">void_t</a> = <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:ab8ddf9531fc4ac7ce28574db20c8f20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c41ad6b9af06544b52833e235bb14dd" id="r_a6c41ad6b9af06544b52833e235bb14dd"><td class="memTemplParams" colspan="2">template&lt;etl::size_t... Ints&gt; </td></tr>
<tr class="memitem:a6c41ad6b9af06544b52833e235bb14dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c41ad6b9af06544b52833e235bb14dd">index_sequence</a> = <a class="el" href="structetl_1_1integer__sequence.html">etl::integer_sequence</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, Ints...&gt;</td></tr>
<tr class="separator:a6c41ad6b9af06544b52833e235bb14dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c526d8179a55ec15611d7627272e067" id="r_a3c526d8179a55ec15611d7627272e067"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:a3c526d8179a55ec15611d7627272e067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c526d8179a55ec15611d7627272e067">make_index_sequence</a> = <a class="el" href="#a4c97ecfe358afc1b3c226c0d7036da95">etl::make_integer_sequence</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a>&gt;</td></tr>
<tr class="separator:a3c526d8179a55ec15611d7627272e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26496b89801597f0e24f146bc25bb3ca" id="r_a26496b89801597f0e24f146bc25bb3ca"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a26496b89801597f0e24f146bc25bb3ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26496b89801597f0e24f146bc25bb3ca">index_sequence_for</a> = <a class="el" href="#a3c526d8179a55ec15611d7627272e067">etl::make_index_sequence</a>&lt;sizeof...(T)&gt;</td></tr>
<tr class="separator:a26496b89801597f0e24f146bc25bb3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c97ecfe358afc1b3c226c0d7036da95" id="r_a4c97ecfe358afc1b3c226c0d7036da95"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , T Size&gt; </td></tr>
<tr class="memitem:a4c97ecfe358afc1b3c226c0d7036da95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c97ecfe358afc1b3c226c0d7036da95">make_integer_sequence</a> = <a class="el" href="builtin__functions_8hpp.html#a303c6144751de3e45c44990112e8b1cb">TETL_BUILTIN_INT_SEQ</a>(T, <a class="el" href="structetl_1_1static__vector.html">Size</a>)</td></tr>
<tr class="separator:a4c97ecfe358afc1b3c226c0d7036da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b611e97373f7c9c739f58a942f9de05" id="r_a7b611e97373f7c9c739f58a942f9de05"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7b611e97373f7c9c739f58a942f9de05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, T&gt;::type</td></tr>
<tr class="separator:a7b611e97373f7c9c739f58a942f9de05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac437d8206f0e17da3a896c5f4d17f95a" id="r_ac437d8206f0e17da3a896c5f4d17f95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac437d8206f0e17da3a896c5f4d17f95a">atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000'000&gt;</td></tr>
<tr class="separator:ac437d8206f0e17da3a896c5f4d17f95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626e7a2087ed63adf28928bc61505210" id="r_a626e7a2087ed63adf28928bc61505210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a626e7a2087ed63adf28928bc61505210">femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000&gt;</td></tr>
<tr class="separator:a626e7a2087ed63adf28928bc61505210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1999fbf9a32aa8544e0ffa747d47518d" id="r_a1999fbf9a32aa8544e0ffa747d47518d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1999fbf9a32aa8544e0ffa747d47518d">pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000&gt;</td></tr>
<tr class="separator:a1999fbf9a32aa8544e0ffa747d47518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1718104bd02150cc3a553b7289ea2d2d" id="r_a1718104bd02150cc3a553b7289ea2d2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1718104bd02150cc3a553b7289ea2d2d">nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000&gt;</td></tr>
<tr class="separator:a1718104bd02150cc3a553b7289ea2d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b69df89587850ded6209b864e7569" id="r_af06b69df89587850ded6209b864e7569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af06b69df89587850ded6209b864e7569">micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000&gt;</td></tr>
<tr class="separator:af06b69df89587850ded6209b864e7569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10931e9eceef3f81bae9ea43bdd8e89" id="r_ab10931e9eceef3f81bae9ea43bdd8e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10931e9eceef3f81bae9ea43bdd8e89">milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000&gt;</td></tr>
<tr class="separator:ab10931e9eceef3f81bae9ea43bdd8e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037ed5d2bc56f378210678d84bcc854b" id="r_a037ed5d2bc56f378210678d84bcc854b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a037ed5d2bc56f378210678d84bcc854b">centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td></tr>
<tr class="separator:a037ed5d2bc56f378210678d84bcc854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c874769f867849c115ae2d1867a02" id="r_a5e1c874769f867849c115ae2d1867a02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e1c874769f867849c115ae2d1867a02">deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td></tr>
<tr class="separator:a5e1c874769f867849c115ae2d1867a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb47ecbe72de3b6984811c6a1c8c6d5b" id="r_aeb47ecbe72de3b6984811c6a1c8c6d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb47ecbe72de3b6984811c6a1c8c6d5b">deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td></tr>
<tr class="separator:aeb47ecbe72de3b6984811c6a1c8c6d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee06e415331cdede5a5e81a37ae91014" id="r_aee06e415331cdede5a5e81a37ae91014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee06e415331cdede5a5e81a37ae91014">hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td></tr>
<tr class="separator:aee06e415331cdede5a5e81a37ae91014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118ab5d9112082a698afa3512c99a46e" id="r_a118ab5d9112082a698afa3512c99a46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a118ab5d9112082a698afa3512c99a46e">kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000, 1&gt;</td></tr>
<tr class="separator:a118ab5d9112082a698afa3512c99a46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7fbb2fd3099cd6e2bb5a712becf41c" id="r_a8b7fbb2fd3099cd6e2bb5a712becf41c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b7fbb2fd3099cd6e2bb5a712becf41c">mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000, 1&gt;</td></tr>
<tr class="separator:a8b7fbb2fd3099cd6e2bb5a712becf41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0782f438fdf0a5e815bb88d8116543a" id="r_aa0782f438fdf0a5e815bb88d8116543a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0782f438fdf0a5e815bb88d8116543a">giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000, 1&gt;</td></tr>
<tr class="separator:aa0782f438fdf0a5e815bb88d8116543a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0850018459aaecf06435ee5eb9f0d8" id="r_abb0850018459aaecf06435ee5eb9f0d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb0850018459aaecf06435ee5eb9f0d8">tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:abb0850018459aaecf06435ee5eb9f0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e47bd1a852d56651ef8b41a86a86fa8" id="r_a8e47bd1a852d56651ef8b41a86a86fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e47bd1a852d56651ef8b41a86a86fa8">peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:a8e47bd1a852d56651ef8b41a86a86fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe49b8885eb17fdade12acd5f37acad" id="r_aabe49b8885eb17fdade12acd5f37acad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabe49b8885eb17fdade12acd5f37acad">exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:aabe49b8885eb17fdade12acd5f37acad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaceb52d5e58265d474290d1e17bcf1716" id="r_gaceb52d5e58265d474290d1e17bcf1716"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bit.html#gaceb52d5e58265d474290d1e17bcf1716">endian</a> { <a class="el" href="group__bit.html#ggaceb52d5e58265d474290d1e17bcf1716aaae6635e044ac56046b2893a529b5114">little</a> = implementation defined
, <a class="el" href="group__bit.html#ggaceb52d5e58265d474290d1e17bcf1716ad861877da56b8b4ceb35c8cbfdf65bb4">big</a> = implementation defined
, <a class="el" href="group__bit.html#ggaceb52d5e58265d474290d1e17bcf1716a8e5f3adee38c8fccc13c1f3be0143796">native</a> = implementation defined
 }</td></tr>
<tr class="memdesc:gaceb52d5e58265d474290d1e17bcf1716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the endianness of all scalar types. If all scalar types are little-endian, <code>endian::native</code> equals <code>endian::little</code>. If all scalar types are big-endian, <code>endian::native</code> equals <code>endian::big</code>.  <a href="group__bit.html#gaceb52d5e58265d474290d1e17bcf1716">More...</a><br /></td></tr>
<tr class="separator:gaceb52d5e58265d474290d1e17bcf1716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc55212e09044ea8a258cd3a53d90dde" id="r_abc55212e09044ea8a258cd3a53d90dde"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc55212e09044ea8a258cd3a53d90dde">chars_format</a> : etl::uint8_t { <a class="el" href="#abc55212e09044ea8a258cd3a53d90ddea55a95650a66b53ecbb960b53d985b964">scientific</a> = 0x1
, <a class="el" href="#abc55212e09044ea8a258cd3a53d90ddeacec315e3d0975e5cc2811d5d8725f149">fixed</a> = 0x2
, <a class="el" href="#abc55212e09044ea8a258cd3a53d90ddeab8d1b43eae73587ba56baef574709ecb">hex</a> = 0x4
, <a class="el" href="#abc55212e09044ea8a258cd3a53d90ddea958153f1b8b96ec4c4eb2147429105d9">general</a> = fixed | scientific
 }</td></tr>
<tr class="memdesc:abc55212e09044ea8a258cd3a53d90dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BitmaskType used to specify floating-point formatting for to_chars and from_chars.  <a href="#abc55212e09044ea8a258cd3a53d90dde">More...</a><br /></td></tr>
<tr class="separator:abc55212e09044ea8a258cd3a53d90dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592fe78d9bf66455d12aa075f36313b6" id="r_a592fe78d9bf66455d12aa075f36313b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a592fe78d9bf66455d12aa075f36313b6">float_denorm_style</a> { <a class="el" href="#a592fe78d9bf66455d12aa075f36313b6ae6e5a92659b76e353da685746ec7a715">denorm_indeterminate</a> = -1
, <a class="el" href="#a592fe78d9bf66455d12aa075f36313b6ae1126f121e8e78fad4c2ea93b9154f70">denorm_absent</a> = 0
, <a class="el" href="#a592fe78d9bf66455d12aa075f36313b6ace9911a51bfc23dca58b86c67b0adfac">denorm_present</a> = 1
 }</td></tr>
<tr class="separator:a592fe78d9bf66455d12aa075f36313b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdaf6c7e8a65859bf550443989c5a66" id="r_a3bdaf6c7e8a65859bf550443989c5a66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66">float_round_style</a> { <br />
&#160;&#160;<a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66aef8e73dd0b0f1899790b6ba2bb47be7d">round_indeterminate</a> = -1
, <a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66a2378935a2849c4d049d5e5a01324e827">round_toward_zero</a> = 0
, <a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66aae97e229f8502c244371d7f7e3105afc">round_to_nearest</a> = 1
, <a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66a33f65225750a8f3edc0b6601fa7bcd52">round_toward_infinity</a> = 2
, <br />
&#160;&#160;<a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66ad9c511acb4735515f2402087641e9725">round_toward_neg_infinity</a> = 3
<br />
 }</td></tr>
<tr class="separator:a3bdaf6c7e8a65859bf550443989c5a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9590e0d8ba5b7b8a2d709113c3e7bb" id="r_a8c9590e0d8ba5b7b8a2d709113c3e7bb"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c9590e0d8ba5b7b8a2d709113c3e7bb">align_val_t</a> : etl::size_t </td></tr>
<tr class="memdesc:a8c9590e0d8ba5b7b8a2d709113c3e7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than the default, pass that alignment requirement as an argument of type align_val_t to the selected allocation/deallocation function.  <a href="#a8c9590e0d8ba5b7b8a2d709113c3e7bb">More...</a><br /></td></tr>
<tr class="separator:a8c9590e0d8ba5b7b8a2d709113c3e7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31f743d6273b64f3e8a3121813ea243" id="r_aa31f743d6273b64f3e8a3121813ea243"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa31f743d6273b64f3e8a3121813ea243">errc</a> { <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a8ab69162f060cc46b805b3265ad1cdf1">address_family_not_supported</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a8e2bc80599069d337b43dff6edfb6891">address_in_use</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a20abf2ffbf6e82e36405843f269d6438">address_not_available</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ab5580b198f691ab2df12f5e2ab974373">already_connected</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a1b245b26b5ea3428c050d7f1503d7715">argument_list_too_long</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a4b82222a0895b538d0597092b3ceab3e">argument_out_of_domain</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aaf169f73a82794128aa491c4b4f1c071">bad_address</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a9941c5c8c58ff058b870e94e96ac38e1">bad_file_descriptor</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ac7944ab5d2e25bf75b267d070b506d1c">bad_message</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a2f0338eed54503152be1d31c93c9c2f1">broken_pipe</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a2f8f27a7eef1ad585c7ab6f25a6c2c79">connection_aborted</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a81cf222a9b1530171fdfd66c3f734989">connection_already_in_progress</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a53793ee58fc24168a0d6549c3cb2df8e">connection_refused</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243abf39bfc8665384194e343c08ab344405">connection_reset</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6177070a517d51a4382ab0d7c88e5b58">cross_device_link</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a326032e01f2a5e14c7f730f4d03d753a">destination_address_required</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ab3ab5338a00f49c4451851cc5442f370">device_or_resource_busy</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6a336135d33e62f49edc55f29354e12e">directory_not_empty</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a4dfaf9c996cf045f32d17edc9754fc95">executable_format_error</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a41edf636e3c7b59f797348fc58472258">file_exists</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aa1e14bfb89b41ddf654b1772c8fd2e74">file_too_large</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6e56e6ed055b9771b8192a4f229fee27">filename_too_long</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aa33c516bbdfb179cef733c8daeb97bed">function_not_supported</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243afe2377fbd16d7f335474e1df7d6376bf">host_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a054e5b4ff59331386872de744d661719">identifier_removed</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a53a9e57a679708b2d8ff0ccd8ec96b18">illegal_byte_sequence</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a45fe7da1767194b580aeba752d7b44ae">inappropriate_io_control_operation</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243afadb76763385627e57ec386c9b6038f0">interrupted</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ae55d43eabeefe5a8271b4a3c898bd18f">invalid_argument</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243abd86a2c65caf6a270b916234ab321ce3">invalid_seek</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243acccc32f2a5f7dc7b87d2f85daea66789">io_error</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243af3c51d7ea75a76f26c0a2bdc00c4e006">is_a_directory</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ade5f4bc2f8a4690176e22e83196b9fd3">message_size</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a93b16d34b1689f66f0cfed60e99c0009">network_down</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a0e1d200ae35ede416bf85f84093ce37a">network_reset</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a608a68344b4eb1fe0690861a83828816">network_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a618ead44397b73cf0baa08b460b66c39">no_buffer_space</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ad08d4c854a6810cebd2a8ab61876f919">no_child_process</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243add431dfaf61ea842693dca8be1ebcaf7">no_link</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a58688487c3e24313637a76bd29881e64">no_lock_available</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aeec0f03ad92584c78835c10ab79d7f42">no_message_available</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243acec935db07cfc57caafa37e98eafb213">no_message</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243abed8a9032d9366c28582a0ad59a31525">no_protocol_option</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a1a5334dd8d1ca56e33887bd44630641b">no_space_on_device</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ad8b1d94a0ac09c6d55b2ed68f0836142">no_stream_resources</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a5c83a012eac17bbf458df5804801e373">no_such_device_or_address</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243af42b2e58729e2783b683c8610977fc22">no_such_device</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a2e70fc89b08f26fa3fc77694c91e8f7a">no_such_file_or_directory</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ad91a9b8a734f2bef4b778f89806cbab7">no_such_process</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a21e867ca95e1dfecff4701863547dcec">not_a_directory</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a22ac64bb14c46bcbc338a21950b6e722">not_a_socket</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6e752b7a04543e5052b2d0dd05eca0fa">not_a_stream</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a69c2dbb5917ca550a862e9c1c839bca1">not_connected</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aafdb5594dc3e484fc1bfd7c564d550c1">not_enough_memory</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aa55e82356e9721946aa9ba954733c6f0">not_supported</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243afd3d0bdcc9eb9e68534b7d055c5fe586">operation_canceled</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a4c7eb50b6d86ac8a130ebebc18dbe263">operation_in_progress</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a8344b3d509942f035d5e303022f9b986">operation_not_permitted</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a69bf074bf052ee4c9047b62fe7c24569">operation_not_supported</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a738abdaead9cd7b2e2ea19a34764b385">operation_would_block</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a2abac2fa6722c56b2ea17ac6c4097f68">owner_dead</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ae8ee838822072f02738dbd7d97ea03fc">permission_denied</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a9665c745d0a9132d8da6ed55e89a0564">protocol_error</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aa2635acef8b9a3e1c40923829722d472">protocol_not_supported</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a06108efce8ef1cd8aa4cc440f8b4317f">read_only_file_system</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aed65f7649c6f0e365673d65a9d8119d8">resource_deadlock_would_occur</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ae46a97ea2906921c8c626890bde832cf">resource_unavailable_try_again</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a8e0fafb181567cc468e1ee81983d739d">result_out_of_range</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6805059549401365b824b54573a6f46e">state_not_recoverable</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ac1a620a30954dc9402a811453c2c3e3f">stream_timeout</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ad2f80f12d22bb099fcf1062db660b567">text_file_busy</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a56c27b1ab1a5a5a0eae853cabb4dc0c1">timed_out</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a3130d1d4e000cdc1e7c47013e313c10e">too_many_files_open_in_system</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aed2c33c8fe874cfeba6f4a7747c62d05">too_many_files_open</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243abfe22fc9b27a8ff13186aba60b6bc5c8">too_many_links</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a33c78baca1480479c88aa4d50cb68206">too_many_symbolic_link_levels</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a143653b075bff946193644ba6d97fa5d">value_too_large</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a81cac28a38438710de9856af4a8bcd0b">wrong_protocol_type</a>
<br />
 }</td></tr>
<tr class="memdesc:aa31f743d6273b64f3e8a3121813ea243"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scoped enumeration <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes.  <a href="#aa31f743d6273b64f3e8a3121813ea243">More...</a><br /></td></tr>
<tr class="separator:aa31f743d6273b64f3e8a3121813ea243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5c92ae723acdba8ce0f48be8530154" id="r_a6a5c92ae723acdba8ce0f48be8530154"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154">implementation</a> { <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1">freestanding</a> = 0
, <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154a734d3030ff72ad8d9678efa82b1db7d2">hosted</a> = 1
 }</td></tr>
<tr class="separator:a6a5c92ae723acdba8ce0f48be8530154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72411d869deb28d3d6a0f7d0d77dd1de" id="r_a72411d869deb28d3d6a0f7d0d77dd1de"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> : unsigned char { <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1dea6289bbfa378818f7066ccad5847da5a2">cpp_17</a> = 17
, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1dea4c7aabdc3eb0d845c62edfb822b0fe5a">cpp_20</a> = 20
, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1deaf7d98f68372c9de30cc2d571b75b19d7">cpp_23</a> = 23
, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff">cpp_26</a> = 26
 }</td></tr>
<tr class="memdesc:a72411d869deb28d3d6a0f7d0d77dd1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for the currently selected C++ standard version. Unlike the official macro <code>__cplusplus</code>, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips.  <a href="#a72411d869deb28d3d6a0f7d0d77dd1de">More...</a><br /></td></tr>
<tr class="separator:a72411d869deb28d3d6a0f7d0d77dd1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acf27092e22460faafdb958cac56c6fec" id="r_acf27092e22460faafdb958cac56c6fec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:acf27092e22460faafdb958cac56c6fec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type</td></tr>
<tr class="memdesc:acf27092e22460faafdb958cac56c6fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value.  <br /></td></tr>
<tr class="separator:acf27092e22460faafdb958cac56c6fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a8919c2c9cca7f4eb38f2199797c37" id="r_ad2a8919c2c9cca7f4eb38f2199797c37"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ad2a8919c2c9cca7f4eb38f2199797c37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2a8919c2c9cca7f4eb38f2199797c37">equal</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad2a8919c2c9cca7f4eb38f2199797c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise.  <br /></td></tr>
<tr class="separator:ad2a8919c2c9cca7f4eb38f2199797c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fb0dac9928f1cf33cc07f069cac971" id="r_a13fb0dac9928f1cf33cc07f069cac971"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a13fb0dac9928f1cf33cc07f069cac971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13fb0dac9928f1cf33cc07f069cac971">equal</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a13fb0dac9928f1cf33cc07f069cac971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79340eb0330b4f112afc47f71e3d844" id="r_ab79340eb0330b4f112afc47f71e3d844"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ab79340eb0330b4f112afc47f71e3d844"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab79340eb0330b4f112afc47f71e3d844">equal</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ab79340eb0330b4f112afc47f71e3d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb7da13869cc2911d1dd3ebfbc49681" id="r_a8cb7da13869cc2911d1dd3ebfbc49681"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a8cb7da13869cc2911d1dd3ebfbc49681"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8cb7da13869cc2911d1dd3ebfbc49681">equal</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a8cb7da13869cc2911d1dd3ebfbc49681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0065deb93b945a04f6875db16eba3fd3" id="r_a0065deb93b945a04f6875db16eba3fd3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a0065deb93b945a04f6875db16eba3fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0065deb93b945a04f6875db16eba3fd3">equal_range</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:a0065deb93b945a04f6875db16eba3fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a0065deb93b945a04f6875db16eba3fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7225526a11c7ee4454afce37e9bfd031" id="r_a7225526a11c7ee4454afce37e9bfd031"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7225526a11c7ee4454afce37e9bfd031"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7225526a11c7ee4454afce37e9bfd031">equal_range</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;</td></tr>
<tr class="separator:a7225526a11c7ee4454afce37e9bfd031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d64a767f3a1408540f8d99f0da4cf68" id="r_ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4d64a767f3a1408540f8d99f0da4cf68">exchange_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9378dad55c6bc1835467e35f3d096808" id="r_ga9378dad55c6bc1835467e35f3d096808"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ga9378dad55c6bc1835467e35f3d096808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga9378dad55c6bc1835467e35f3d096808">exchange_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga9378dad55c6bc1835467e35f3d096808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga9378dad55c6bc1835467e35f3d096808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7166349fd110372de5c865fe5767f97" id="r_ad7166349fd110372de5c865fe5767f97"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad7166349fd110372de5c865fe5767f97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7166349fd110372de5c865fe5767f97">fill</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ad7166349fd110372de5c865fe5767f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ad7166349fd110372de5c865fe5767f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52b4d387889126b64b88ca2150c6ddc" id="r_ae52b4d387889126b64b88ca2150c6ddc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae52b4d387889126b64b88ca2150c6ddc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae52b4d387889126b64b88ca2150c6ddc">fill_n</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ae52b4d387889126b64b88ca2150c6ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise.  <br /></td></tr>
<tr class="separator:ae52b4d387889126b64b88ca2150c6ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af123f494fccf3d1e9420928c32915189" id="r_af123f494fccf3d1e9420928c32915189"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af123f494fccf3d1e9420928c32915189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af123f494fccf3d1e9420928c32915189">find</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:af123f494fccf3d1e9420928c32915189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element equal to value.  <br /></td></tr>
<tr class="separator:af123f494fccf3d1e9420928c32915189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ba00834faefda2a3d9b112d053f889" id="r_a99ba00834faefda2a3d9b112d053f889"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a99ba00834faefda2a3d9b112d053f889"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99ba00834faefda2a3d9b112d053f889">find_end</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td></tr>
<tr class="memdesc:a99ba00834faefda2a3d9b112d053f889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:a99ba00834faefda2a3d9b112d053f889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3668f0480d1f8d6976de08b3658eb97e" id="r_a3668f0480d1f8d6976de08b3658eb97e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:a3668f0480d1f8d6976de08b3658eb97e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3668f0480d1f8d6976de08b3658eb97e">find_end</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td></tr>
<tr class="separator:a3668f0480d1f8d6976de08b3658eb97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac49fa522ef832adfa9ebb8c4592ca60" id="r_aac49fa522ef832adfa9ebb8c4592ca60"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:aac49fa522ef832adfa9ebb8c4592ca60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac49fa522ef832adfa9ebb8c4592ca60">find_first_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:aac49fa522ef832adfa9ebb8c4592ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred.  <br /></td></tr>
<tr class="separator:aac49fa522ef832adfa9ebb8c4592ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fd28c3677d3bebf66460a3e492f3c0" id="r_a74fd28c3677d3bebf66460a3e492f3c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a74fd28c3677d3bebf66460a3e492f3c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74fd28c3677d3bebf66460a3e492f3c0">find_first_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:a74fd28c3677d3bebf66460a3e492f3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast).  <br /></td></tr>
<tr class="separator:a74fd28c3677d3bebf66460a3e492f3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214a2898fc2820379237f4cc89e3249f" id="r_a214a2898fc2820379237f4cc89e3249f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a214a2898fc2820379237f4cc89e3249f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a214a2898fc2820379237f4cc89e3249f">find_if</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:a214a2898fc2820379237f4cc89e3249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate p returns true.  <br /></td></tr>
<tr class="separator:a214a2898fc2820379237f4cc89e3249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd10eb98eb927ed2e7efb96bbbebac30" id="r_abd10eb98eb927ed2e7efb96bbbebac30"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:abd10eb98eb927ed2e7efb96bbbebac30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd10eb98eb927ed2e7efb96bbbebac30">find_if_not</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:abd10eb98eb927ed2e7efb96bbbebac30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate q returns false.  <br /></td></tr>
<tr class="separator:abd10eb98eb927ed2e7efb96bbbebac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fe21109f4f9d8ce7a3364bb45e9eae" id="r_a14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> &gt; </td></tr>
<tr class="memitem:a14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14fe21109f4f9d8ce7a3364bb45e9eae">for_each</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> f) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a></td></tr>
<tr class="memdesc:a14fe21109f4f9d8ce7a3364bb45e9eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order.  <br /></td></tr>
<tr class="separator:a14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef3395c26e44857cb21437ffbd285e7" id="r_a5ef3395c26e44857cb21437ffbd285e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> &gt; </td></tr>
<tr class="memitem:a5ef3395c26e44857cb21437ffbd285e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ef3395c26e44857cb21437ffbd285e7">for_each_n</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="structetl_1_1static__vector.html">n</a>, <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> f) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:a5ef3395c26e44857cb21437ffbd285e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order.  <br /></td></tr>
<tr class="separator:a5ef3395c26e44857cb21437ffbd285e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379d8ee0b21dfbdc9b0e5e4d7762eb43" id="r_a379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Generator</a> &gt; </td></tr>
<tr class="memitem:a379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a379d8ee0b21dfbdc9b0e5e4d7762eb43">generate</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Generator</a> g) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns each element in range <code>[first, last)</code> a value generated by the given function object g.  <br /></td></tr>
<tr class="separator:a379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12543b4f9ab02e90be68988a60f74dbe" id="r_a12543b4f9ab02e90be68988a60f74dbe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">SizeT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Generator</a> &gt; </td></tr>
<tr class="memitem:a12543b4f9ab02e90be68988a60f74dbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12543b4f9ab02e90be68988a60f74dbe">generate_n</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">SizeT</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="structetl_1_1static__vector.html">Generator</a> g) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a12543b4f9ab02e90be68988a60f74dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise.  <br /></td></tr>
<tr class="separator:a12543b4f9ab02e90be68988a60f74dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe96d864c89d47ea3902b6fc8826d2b5" id="r_afe96d864c89d47ea3902b6fc8826d2b5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:afe96d864c89d47ea3902b6fc8826d2b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe96d864c89d47ea3902b6fc8826d2b5">gnome_sort</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:afe96d864c89d47ea3902b6fc8826d2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Gnome_sort">https://en.wikipedia.org/wiki/Gnome_sort</a>.  <br /></td></tr>
<tr class="separator:afe96d864c89d47ea3902b6fc8826d2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee8f3605b778d70c05a5697ffae6192" id="r_a4ee8f3605b778d70c05a5697ffae6192"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:a4ee8f3605b778d70c05a5697ffae6192"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ee8f3605b778d70c05a5697ffae6192">gnome_sort</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a4ee8f3605b778d70c05a5697ffae6192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0d5db89d1e54d2ccb479a559df46aa" id="r_a5f0d5db89d1e54d2ccb479a559df46aa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a5f0d5db89d1e54d2ccb479a559df46aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f0d5db89d1e54d2ccb479a559df46aa">includes</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5f0d5db89d1e54d2ccb479a559df46aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted.  <br /></td></tr>
<tr class="separator:a5f0d5db89d1e54d2ccb479a559df46aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d74dfc016d11d54f60ad30618fc276" id="r_ae0d74dfc016d11d54f60ad30618fc276"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:ae0d74dfc016d11d54f60ad30618fc276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0d74dfc016d11d54f60ad30618fc276">includes</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ae0d74dfc016d11d54f60ad30618fc276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ac00af714eca3a603115a96d226d1" id="r_af90ac00af714eca3a603115a96d226d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:af90ac00af714eca3a603115a96d226d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af90ac00af714eca3a603115a96d226d1">inplace_merge</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="#aeb088ae74a2ec53c8c206de329935df4">begin</a>, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="structetl_1_1static__vector.html">mid</a>, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="#aa26698de685cc42e99c0c560d05ca93c">end</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:af90ac00af714eca3a603115a96d226d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last).  <br /></td></tr>
<tr class="separator:af90ac00af714eca3a603115a96d226d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485ce5c1c0690a9616ba899fe2db7a10" id="r_a485ce5c1c0690a9616ba899fe2db7a10"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:a485ce5c1c0690a9616ba899fe2db7a10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a485ce5c1c0690a9616ba899fe2db7a10">inplace_merge</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="structetl_1_1static__vector.html">mid</a>, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a485ce5c1c0690a9616ba899fe2db7a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1189f81daa0314d4422781edab8a4e83" id="r_a1189f81daa0314d4422781edab8a4e83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a1189f81daa0314d4422781edab8a4e83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1189f81daa0314d4422781edab8a4e83">insertion_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a1189f81daa0314d4422781edab8a4e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. <a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a>.  <br /></td></tr>
<tr class="separator:a1189f81daa0314d4422781edab8a4e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819f2e196782c8f996a7a6d85853564b" id="r_a819f2e196782c8f996a7a6d85853564b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a819f2e196782c8f996a7a6d85853564b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a819f2e196782c8f996a7a6d85853564b">insertion_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a819f2e196782c8f996a7a6d85853564b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3a106198fbf6b07743f082cec761fa" id="r_a7c3a106198fbf6b07743f082cec761fa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a7c3a106198fbf6b07743f082cec761fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c3a106198fbf6b07743f082cec761fa">is_partitioned</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a7c3a106198fbf6b07743f082cec761fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty. <a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned">https://en.cppreference.com/w/cpp/algorithm/is_partitioned</a>.  <br /></td></tr>
<tr class="separator:a7c3a106198fbf6b07743f082cec761fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ca70817d9b940ccd963245edb804e7" id="r_ab7ca70817d9b940ccd963245edb804e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:ab7ca70817d9b940ccd963245edb804e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7ca70817d9b940ccd963245edb804e7">is_permutation</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab7ca70817d9b940ccd963245edb804e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given.  <br /></td></tr>
<tr class="separator:ab7ca70817d9b940ccd963245edb804e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebb0727381b2818e6575c43ad064189" id="r_acebb0727381b2818e6575c43ad064189"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:acebb0727381b2818e6575c43ad064189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acebb0727381b2818e6575c43ad064189">is_permutation</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:acebb0727381b2818e6575c43ad064189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25741a63c525afca9eaf8054b7122a9" id="r_aa25741a63c525afca9eaf8054b7122a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:aa25741a63c525afca9eaf8054b7122a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa25741a63c525afca9eaf8054b7122a9">is_sorted</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aa25741a63c525afca9eaf8054b7122a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:aa25741a63c525afca9eaf8054b7122a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a1d40ec7a46d94456bc76abf70910c" id="r_af0a1d40ec7a46d94456bc76abf70910c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:af0a1d40ec7a46d94456bc76abf70910c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0a1d40ec7a46d94456bc76abf70910c">is_sorted</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:af0a1d40ec7a46d94456bc76abf70910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ed3932bcae919d183136bb3dcf658" id="r_aa76ed3932bcae919d183136bb3dcf658"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:aa76ed3932bcae919d183136bb3dcf658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa76ed3932bcae919d183136bb3dcf658">is_sorted_until</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:aa76ed3932bcae919d183136bb3dcf658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb2f98e7a5c930b843b813c8885ff0e" id="r_a1eb2f98e7a5c930b843b813c8885ff0e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a1eb2f98e7a5c930b843b813c8885ff0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1eb2f98e7a5c930b843b813c8885ff0e">is_sorted_until</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a1eb2f98e7a5c930b843b813c8885ff0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:a1eb2f98e7a5c930b843b813c8885ff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1249aee36691133f6b783a82290f8e" id="r_a7a1249aee36691133f6b783a82290f8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:a7a1249aee36691133f6b783a82290f8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a1249aee36691133f6b783a82290f8e">iter_swap</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> a, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> b) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a7a1249aee36691133f6b783a82290f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of the elements the given iterators are pointing to.  <br /></td></tr>
<tr class="separator:a7a1249aee36691133f6b783a82290f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb90a196cbc728c59a4f2f16a9a9befd" id="r_acb90a196cbc728c59a4f2f16a9a9befd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:acb90a196cbc728c59a4f2f16a9a9befd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb90a196cbc728c59a4f2f16a9a9befd">lexicographical_compare</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">f1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">l1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">f2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">l2</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:acb90a196cbc728c59a4f2f16a9a9befd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>.  <br /></td></tr>
<tr class="separator:acb90a196cbc728c59a4f2f16a9a9befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbb8794e1a09c00341acc4070284bd3" id="r_a6bbb8794e1a09c00341acc4070284bd3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a6bbb8794e1a09c00341acc4070284bd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6bbb8794e1a09c00341acc4070284bd3">lexicographical_compare</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">f1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">l1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">f2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">l2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a6bbb8794e1a09c00341acc4070284bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eac84d4e60cc02ce593a33117a79ba3" id="r_a7eac84d4e60cc02ce593a33117a79ba3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a7eac84d4e60cc02ce593a33117a79ba3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7eac84d4e60cc02ce593a33117a79ba3">lower_bound</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a7eac84d4e60cc02ce593a33117a79ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found.  <br /></td></tr>
<tr class="separator:a7eac84d4e60cc02ce593a33117a79ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef2815c598ddf680df6562ff413fc89" id="r_aeef2815c598ddf680df6562ff413fc89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aeef2815c598ddf680df6562ff413fc89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeef2815c598ddf680df6562ff413fc89">lower_bound</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:aeef2815c598ddf680df6562ff413fc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3eca1793f7f38aeb756464984eb194" id="r_a5f3eca1793f7f38aeb756464984eb194"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:a5f3eca1793f7f38aeb756464984eb194"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f3eca1793f7f38aeb756464984eb194">max</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a5f3eca1793f7f38aeb756464984eb194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b.  <br /></td></tr>
<tr class="separator:a5f3eca1793f7f38aeb756464984eb194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b79e7341165c49fa24ea2d66a761a5" id="r_ab9b79e7341165c49fa24ea2d66a761a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ab9b79e7341165c49fa24ea2d66a761a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9b79e7341165c49fa24ea2d66a761a5">max</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:ab9b79e7341165c49fa24ea2d66a761a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b, using a compare function.  <br /></td></tr>
<tr class="separator:ab9b79e7341165c49fa24ea2d66a761a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847a74164e6c1a692093c156b35eb30" id="r_ac847a74164e6c1a692093c156b35eb30"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ac847a74164e6c1a692093c156b35eb30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac847a74164e6c1a692093c156b35eb30">max_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:ac847a74164e6c1a692093c156b35eb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <br /></td></tr>
<tr class="separator:ac847a74164e6c1a692093c156b35eb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4b38361c7330f3c5996fef40213eed" id="r_a3b4b38361c7330f3c5996fef40213eed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a3b4b38361c7330f3c5996fef40213eed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b4b38361c7330f3c5996fef40213eed">max_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a3b4b38361c7330f3c5996fef40213eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <br /></td></tr>
<tr class="separator:a3b4b38361c7330f3c5996fef40213eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390da486f87fc7f5e59fd16cb3015c25" id="r_a390da486f87fc7f5e59fd16cb3015c25"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a390da486f87fc7f5e59fd16cb3015c25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a390da486f87fc7f5e59fd16cb3015c25">merge</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a390da486f87fc7f5e59fd16cb3015c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>.  <br /></td></tr>
<tr class="separator:a390da486f87fc7f5e59fd16cb3015c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de3be8fc3e9e834497d00be337e09ea" id="r_a2de3be8fc3e9e834497d00be337e09ea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a2de3be8fc3e9e834497d00be337e09ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2de3be8fc3e9e834497d00be337e09ea">merge</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:a2de3be8fc3e9e834497d00be337e09ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d076e41cf7830be44fc5fc1322d9f49" id="r_a0d076e41cf7830be44fc5fc1322d9f49"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a0d076e41cf7830be44fc5fc1322d9f49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d076e41cf7830be44fc5fc1322d9f49">merge_sort</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a0d076e41cf7830be44fc5fc1322d9f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a>.  <br /></td></tr>
<tr class="separator:a0d076e41cf7830be44fc5fc1322d9f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e07086e339175ad2433a095b9205e87" id="r_a9e07086e339175ad2433a095b9205e87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:a9e07086e339175ad2433a095b9205e87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e07086e339175ad2433a095b9205e87">merge_sort</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a9e07086e339175ad2433a095b9205e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810b4260b22a58b461be941fa6acb745" id="r_a810b4260b22a58b461be941fa6acb745"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:a810b4260b22a58b461be941fa6acb745"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a810b4260b22a58b461be941fa6acb745">min</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a810b4260b22a58b461be941fa6acb745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b.  <br /></td></tr>
<tr class="separator:a810b4260b22a58b461be941fa6acb745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c60a3adb053935acbf3c8a91a0a035" id="r_a80c60a3adb053935acbf3c8a91a0a035"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a80c60a3adb053935acbf3c8a91a0a035"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80c60a3adb053935acbf3c8a91a0a035">min</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a80c60a3adb053935acbf3c8a91a0a035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b, using a compare function.  <br /></td></tr>
<tr class="separator:a80c60a3adb053935acbf3c8a91a0a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb64c2aeca7185a3fdd03bff27f93f2" id="r_a4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4fb64c2aeca7185a3fdd03bff27f93f2">min_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a4fb64c2aeca7185a3fdd03bff27f93f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <br /></td></tr>
<tr class="separator:a4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5571b6aa07c8298071d5e43411200c" id="r_a4b5571b6aa07c8298071d5e43411200c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a4b5571b6aa07c8298071d5e43411200c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b5571b6aa07c8298071d5e43411200c">min_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a4b5571b6aa07c8298071d5e43411200c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <br /></td></tr>
<tr class="separator:a4b5571b6aa07c8298071d5e43411200c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf8c00a7d8e6e8c5eff71f1063fad52" id="r_a2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2cf8c00a7d8e6e8c5eff71f1063fad52">minmax</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp; &gt;</td></tr>
<tr class="memdesc:a2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <br /></td></tr>
<tr class="separator:a2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7517750d66b576d14d06fd58d74b1" id="r_a8fe7517750d66b576d14d06fd58d74b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8fe7517750d66b576d14d06fd58d74b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8fe7517750d66b576d14d06fd58d74b1">minmax</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp; &gt;</td></tr>
<tr class="memdesc:a8fe7517750d66b576d14d06fd58d74b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <br /></td></tr>
<tr class="separator:a8fe7517750d66b576d14d06fd58d74b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68fb6c83c244cd496ea25c4f5a9d01f" id="r_aa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:aa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa68fb6c83c244cd496ea25c4f5a9d01f">minmax_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:aa68fb6c83c244cd496ea25c4f5a9d01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:aa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ee575bad4a7b0cecd1869f7ecdc942" id="r_a26ee575bad4a7b0cecd1869f7ecdc942"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a26ee575bad4a7b0cecd1869f7ecdc942"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26ee575bad4a7b0cecd1869f7ecdc942">minmax_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:a26ee575bad4a7b0cecd1869f7ecdc942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a26ee575bad4a7b0cecd1869f7ecdc942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272907f42acd772ea50acaa07ffb12aa" id="r_a272907f42acd772ea50acaa07ffb12aa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a272907f42acd772ea50acaa07ffb12aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a272907f42acd772ea50acaa07ffb12aa">mismatch</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt;</td></tr>
<tr class="memdesc:a272907f42acd772ea50acaa07ffb12aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred.  <br /></td></tr>
<tr class="separator:a272907f42acd772ea50acaa07ffb12aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc526e4d807581e208306a999a8a51" id="r_a05cc526e4d807581e208306a999a8a51"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a05cc526e4d807581e208306a999a8a51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05cc526e4d807581e208306a999a8a51">mismatch</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:a05cc526e4d807581e208306a999a8a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1833ff8cfefd00fbce92848e93af31e4" id="r_a1833ff8cfefd00fbce92848e93af31e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a1833ff8cfefd00fbce92848e93af31e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1833ff8cfefd00fbce92848e93af31e4">mismatch</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:a1833ff8cfefd00fbce92848e93af31e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371e9767b06eb932a467448a6e8e32fc" id="r_a371e9767b06eb932a467448a6e8e32fc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a371e9767b06eb932a467448a6e8e32fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a371e9767b06eb932a467448a6e8e32fc">mismatch</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:a371e9767b06eb932a467448a6e8e32fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9060e0931516472a88f4657d835684a9" id="r_a9060e0931516472a88f4657d835684a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a9060e0931516472a88f4657d835684a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9060e0931516472a88f4657d835684a9">move</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a9060e0931516472a88f4657d835684a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.  <br /></td></tr>
<tr class="separator:a9060e0931516472a88f4657d835684a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af551d4e71ff0eabb8f92409796fcf33d" id="r_af551d4e71ff0eabb8f92409796fcf33d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> &gt; </td></tr>
<tr class="memitem:af551d4e71ff0eabb8f92409796fcf33d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af551d4e71ff0eabb8f92409796fcf33d">move_backward</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a></td></tr>
<tr class="memdesc:af551d4e71ff0eabb8f92409796fcf33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:af551d4e71ff0eabb8f92409796fcf33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816a532bf04d7e7c0a846b930a571a1d" id="r_a816a532bf04d7e7c0a846b930a571a1d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a816a532bf04d7e7c0a846b930a571a1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a816a532bf04d7e7c0a846b930a571a1d">none_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a816a532bf04d7e7c0a846b930a571a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a816a532bf04d7e7c0a846b930a571a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a975e8950c5e7cc4ff7f97638d34a53" id="r_a8a975e8950c5e7cc4ff7f97638d34a53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a8a975e8950c5e7cc4ff7f97638d34a53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a975e8950c5e7cc4ff7f97638d34a53">nth_element</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> <a class="el" href="structetl_1_1static__vector.html">nth</a>, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a8a975e8950c5e7cc4ff7f97638d34a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that:  <br /></td></tr>
<tr class="separator:a8a975e8950c5e7cc4ff7f97638d34a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477060cd9d79c15a82456242a3005517" id="r_a477060cd9d79c15a82456242a3005517"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a477060cd9d79c15a82456242a3005517"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a477060cd9d79c15a82456242a3005517">nth_element</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> <a class="el" href="structetl_1_1static__vector.html">nth</a>, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a477060cd9d79c15a82456242a3005517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae05431e1f03b692ae88a58f8629a057" id="r_aae05431e1f03b692ae88a58f8629a057"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:aae05431e1f03b692ae88a58f8629a057"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aae05431e1f03b692ae88a58f8629a057">partial_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> <a class="el" href="structetl_1_1static__vector.html">middle</a>, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:aae05431e1f03b692ae88a58f8629a057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified.  <br /></td></tr>
<tr class="separator:aae05431e1f03b692ae88a58f8629a057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3bdc4477493e7bc5c106a53a3a314" id="r_a88a3bdc4477493e7bc5c106a53a3a314"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a88a3bdc4477493e7bc5c106a53a3a314"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88a3bdc4477493e7bc5c106a53a3a314">partial_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> <a class="el" href="structetl_1_1static__vector.html">middle</a>, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a88a3bdc4477493e7bc5c106a53a3a314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dc6d94b5e29f2351debc8dff607246" id="r_a58dc6d94b5e29f2351debc8dff607246"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a58dc6d94b5e29f2351debc8dff607246"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58dc6d94b5e29f2351debc8dff607246">partition</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a58dc6d94b5e29f2351debc8dff607246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved.  <br /></td></tr>
<tr class="separator:a58dc6d94b5e29f2351debc8dff607246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac406ce808473104b511907657832cd92" id="r_ac406ce808473104b511907657832cd92"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ac406ce808473104b511907657832cd92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac406ce808473104b511907657832cd92">partition_copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt1</a> <a class="el" href="structetl_1_1static__vector.html">destinationTrue</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a> <a class="el" href="structetl_1_1static__vector.html">destinationFalse</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">OutputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a> &gt;</td></tr>
<tr class="memdesc:ac406ce808473104b511907657832cd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false.  <br /></td></tr>
<tr class="separator:ac406ce808473104b511907657832cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59eeccfe79ec5ab27f96d577417ca35a" id="r_a59eeccfe79ec5ab27f96d577417ca35a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a59eeccfe79ec5ab27f96d577417ca35a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59eeccfe79ec5ab27f96d577417ca35a">partition_point</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a59eeccfe79ec5ab27f96d577417ca35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p.  <br /></td></tr>
<tr class="separator:a59eeccfe79ec5ab27f96d577417ca35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecba2ecefe71607f67bec456ff072fd" id="r_a1ecba2ecefe71607f67bec456ff072fd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1ecba2ecefe71607f67bec456ff072fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ecba2ecefe71607f67bec456ff072fd">remove</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a1ecba2ecefe71607f67bec456ff072fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <br /></td></tr>
<tr class="separator:a1ecba2ecefe71607f67bec456ff072fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdb5717541ddef9974357131dc1d248" id="r_aafdb5717541ddef9974357131dc1d248"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aafdb5717541ddef9974357131dc1d248"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafdb5717541ddef9974357131dc1d248">remove_copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:aafdb5717541ddef9974357131dc1d248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value.  <br /></td></tr>
<tr class="separator:aafdb5717541ddef9974357131dc1d248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdbbf4b495def4cb406f6af3ef25882" id="r_a8bdbbf4b495def4cb406f6af3ef25882"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a8bdbbf4b495def4cb406f6af3ef25882"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8bdbbf4b495def4cb406f6af3ef25882">remove_copy_if</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a8bdbbf4b495def4cb406f6af3ef25882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:a8bdbbf4b495def4cb406f6af3ef25882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cf73ac58ec2b4dd086be384cbbdd7d" id="r_a22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22cf73ac58ec2b4dd086be384cbbdd7d">remove_if</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a22cf73ac58ec2b4dd086be384cbbdd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <br /></td></tr>
<tr class="separator:a22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e970687eb65ad36a17922ed1be6764a" id="r_a7e970687eb65ad36a17922ed1be6764a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7e970687eb65ad36a17922ed1be6764a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e970687eb65ad36a17922ed1be6764a">replace</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">oldValue</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">newValue</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a7e970687eb65ad36a17922ed1be6764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value.  <br /></td></tr>
<tr class="separator:a7e970687eb65ad36a17922ed1be6764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13040e3fc5925b1bc966782f36635444" id="r_a13040e3fc5925b1bc966782f36635444"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a13040e3fc5925b1bc966782f36635444"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13040e3fc5925b1bc966782f36635444">replace_if</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">newValue</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a13040e3fc5925b1bc966782f36635444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:a13040e3fc5925b1bc966782f36635444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3169a8bd10088a7cf7d65b8aae66bc" id="r_abf3169a8bd10088a7cf7d65b8aae66bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:abf3169a8bd10088a7cf7d65b8aae66bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf3169a8bd10088a7cf7d65b8aae66bc">reverse</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:abf3169a8bd10088a7cf7d65b8aae66bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:abf3169a8bd10088a7cf7d65b8aae66bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5067524643b55244e12cb5eed183ddae" id="r_a5067524643b55244e12cb5eed183ddae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a5067524643b55244e12cb5eed183ddae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5067524643b55244e12cb5eed183ddae">reverse_copy</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a5067524643b55244e12cb5eed183ddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order.  <br /></td></tr>
<tr class="separator:a5067524643b55244e12cb5eed183ddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d4db23a06789c303ee8ec693d84129" id="r_a99d4db23a06789c303ee8ec693d84129"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a99d4db23a06789c303ee8ec693d84129"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99d4db23a06789c303ee8ec693d84129">rotate</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">nFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a99d4db23a06789c303ee8ec693d84129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on a range of elements.  <br /></td></tr>
<tr class="separator:a99d4db23a06789c303ee8ec693d84129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3ea43eb370058e059c95c0738eb379" id="r_a8e3ea43eb370058e059c95c0738eb379"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a8e3ea43eb370058e059c95c0738eb379"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e3ea43eb370058e059c95c0738eb379">rotate_copy</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">nFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a8e3ea43eb370058e059c95c0738eb379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element.  <br /></td></tr>
<tr class="separator:a8e3ea43eb370058e059c95c0738eb379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b2f5d7fd6a15ab6fc4d30c1a716a6e" id="r_aa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:aa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6b2f5d7fd6a15ab6fc4d30c1a716a6e">search</a> (<a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td></tr>
<tr class="memdesc:aa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:aa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9a9ec8c617610bf30e92fbaa678cd" id="r_a9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> &gt; </td></tr>
<tr class="memitem:a9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9fd9a9ec8c617610bf30e92fbaa678cd">search</a> (<a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td></tr>
<tr class="separator:a9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec0297d32d2f51e39c270a715b430d1" id="r_a8ec0297d32d2f51e39c270a715b430d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Searcher</a> &gt; </td></tr>
<tr class="memitem:a8ec0297d32d2f51e39c270a715b430d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ec0297d32d2f51e39c270a715b430d1">search</a> (<a class="el" href="structetl_1_1static__vector.html">FwdIt</a> first, <a class="el" href="structetl_1_1static__vector.html">FwdIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Searcher</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">searcher</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt</a></td></tr>
<tr class="separator:a8ec0297d32d2f51e39c270a715b430d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b828a0b5a5e92873f178d30c4bb9df" id="r_a07b828a0b5a5e92873f178d30c4bb9df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a07b828a0b5a5e92873f178d30c4bb9df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07b828a0b5a5e92873f178d30c4bb9df">search_n</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="structetl_1_1static__vector.html">ValueT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a07b828a0b5a5e92873f178d30c4bb9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value.  <br /></td></tr>
<tr class="separator:a07b828a0b5a5e92873f178d30c4bb9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52038b2431b48b42d039e54647d96493" id="r_a52038b2431b48b42d039e54647d96493"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueT</a> &gt; </td></tr>
<tr class="memitem:a52038b2431b48b42d039e54647d96493"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52038b2431b48b42d039e54647d96493">search_n</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="structetl_1_1static__vector.html">ValueT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:a52038b2431b48b42d039e54647d96493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32b3c3b80a92b66e5d7f118439492e" id="r_afe32b3c3b80a92b66e5d7f118439492e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:afe32b3c3b80a92b66e5d7f118439492e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe32b3c3b80a92b66e5d7f118439492e">set_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:afe32b3c3b80a92b66e5d7f118439492e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same.  <br /></td></tr>
<tr class="separator:afe32b3c3b80a92b66e5d7f118439492e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf15d37410e2266762deefec2f9552e2" id="r_abf15d37410e2266762deefec2f9552e2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:abf15d37410e2266762deefec2f9552e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf15d37410e2266762deefec2f9552e2">set_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:abf15d37410e2266762deefec2f9552e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa483f6d503afb56bafdb6c73eebdd8" id="r_acfa483f6d503afb56bafdb6c73eebdd8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:acfa483f6d503afb56bafdb6c73eebdd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfa483f6d503afb56bafdb6c73eebdd8">set_intersection</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:acfa483f6d503afb56bafdb6c73eebdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:acfa483f6d503afb56bafdb6c73eebdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac046bcca7d511bae026125e54c1f20e7" id="r_ac046bcca7d511bae026125e54c1f20e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ac046bcca7d511bae026125e54c1f20e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac046bcca7d511bae026125e54c1f20e7">set_intersection</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:ac046bcca7d511bae026125e54c1f20e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4249908e93f7b1367d3605c52b20a842" id="r_a4249908e93f7b1367d3605c52b20a842"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a4249908e93f7b1367d3605c52b20a842"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4249908e93f7b1367d3605c52b20a842">set_symmetric_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a4249908e93f7b1367d3605c52b20a842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at destination. The resulting range is also sorted.  <br /></td></tr>
<tr class="separator:a4249908e93f7b1367d3605c52b20a842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c80d1254a7659943993cacc3498dc38" id="r_a5c80d1254a7659943993cacc3498dc38"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a5c80d1254a7659943993cacc3498dc38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c80d1254a7659943993cacc3498dc38">set_symmetric_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:a5c80d1254a7659943993cacc3498dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd656aa427e48301b6fd14503854ff7" id="r_acfd656aa427e48301b6fd14503854ff7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:acfd656aa427e48301b6fd14503854ff7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfd656aa427e48301b6fd14503854ff7">set_union</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:acfd656aa427e48301b6fd14503854ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:acfd656aa427e48301b6fd14503854ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4135eaec81217633145f410048de3cbe" id="r_a4135eaec81217633145f410048de3cbe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a4135eaec81217633145f410048de3cbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4135eaec81217633145f410048de3cbe">set_union</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:a4135eaec81217633145f410048de3cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6d3457c4b1a845dce8219245bbc31c" id="r_a2a6d3457c4b1a845dce8219245bbc31c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a2a6d3457c4b1a845dce8219245bbc31c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a6d3457c4b1a845dce8219245bbc31c">shift_left</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">const</a> last, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a2a6d3457c4b1a845dce8219245bbc31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <br /></td></tr>
<tr class="separator:a2a6d3457c4b1a845dce8219245bbc31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465e2a36ddbbed9d12ad5403dccbb7b3" id="r_a465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> &gt; </td></tr>
<tr class="memitem:a465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a465e2a36ddbbed9d12ad5403dccbb7b3">shift_right</a> (<a class="el" href="structetl_1_1static__vector.html">BidiIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> last, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidiIt</a></td></tr>
<tr class="memdesc:a465e2a36ddbbed9d12ad5403dccbb7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <br /></td></tr>
<tr class="separator:a465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ef221b98a814660142c728ce9bac78" id="r_ad5ef221b98a814660142c728ce9bac78"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ad5ef221b98a814660142c728ce9bac78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5ef221b98a814660142c728ce9bac78">sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ad5ef221b98a814660142c728ce9bac78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is not guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ad5ef221b98a814660142c728ce9bac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9823f4c1911f50c9f7ac3b4a8be9f294" id="r_a9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9823f4c1911f50c9f7ac3b4a8be9f294">sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0402fada51d792d7500e9a8f196eb649" id="r_a0402fada51d792d7500e9a8f196eb649"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a0402fada51d792d7500e9a8f196eb649"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0402fada51d792d7500e9a8f196eb649">stable_partition</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> f, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="structetl_1_1static__vector.html">l</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td></tr>
<tr class="memdesc:a0402fada51d792d7500e9a8f196eb649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved.  <br /></td></tr>
<tr class="separator:a0402fada51d792d7500e9a8f196eb649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555004d15f48a5bb9b71103bcc3e1555" id="r_a555004d15f48a5bb9b71103bcc3e1555"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a555004d15f48a5bb9b71103bcc3e1555"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a555004d15f48a5bb9b71103bcc3e1555">stable_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a555004d15f48a5bb9b71103bcc3e1555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved. Elements are compared using the given comparison function comp.  <br /></td></tr>
<tr class="separator:a555004d15f48a5bb9b71103bcc3e1555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57756439702cf72053e29b5c7294d85" id="r_ab57756439702cf72053e29b5c7294d85"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ab57756439702cf72053e29b5c7294d85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab57756439702cf72053e29b5c7294d85">stable_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:ab57756439702cf72053e29b5c7294d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e235b7f1654c13232e768201e17f4a" id="r_aa8e235b7f1654c13232e768201e17f4a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:aa8e235b7f1654c13232e768201e17f4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8e235b7f1654c13232e768201e17f4a">swap_ranges</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td></tr>
<tr class="memdesc:aa8e235b7f1654c13232e768201e17f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>.  <br /></td></tr>
<tr class="separator:aa8e235b7f1654c13232e768201e17f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d479673068495c0b88dcd93a99dfb57" id="r_a0d479673068495c0b88dcd93a99dfb57"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryOp</a> &gt; </td></tr>
<tr class="memitem:a0d479673068495c0b88dcd93a99dfb57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d479673068495c0b88dcd93a99dfb57">transform</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">UnaryOp</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a0d479673068495c0b88dcd93a99dfb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a0d479673068495c0b88dcd93a99dfb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f1eb9069005465b67c5d79eaae8bb9" id="r_aa4f1eb9069005465b67c5d79eaae8bb9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> &gt; </td></tr>
<tr class="memitem:aa4f1eb9069005465b67c5d79eaae8bb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4f1eb9069005465b67c5d79eaae8bb9">transform</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:aa4f1eb9069005465b67c5d79eaae8bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f27339834dd24fea714a4b4ef5b383" id="r_a99f27339834dd24fea714a4b4ef5b383"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a99f27339834dd24fea714a4b4ef5b383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99f27339834dd24fea714a4b4ef5b383">unique</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a99f27339834dd24fea714a4b4ef5b383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range.  <br /></td></tr>
<tr class="separator:a99f27339834dd24fea714a4b4ef5b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af368b8bc471211756f0fd32f9d2c8968" id="r_af368b8bc471211756f0fd32f9d2c8968"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:af368b8bc471211756f0fd32f9d2c8968"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af368b8bc471211756f0fd32f9d2c8968">unique</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:af368b8bc471211756f0fd32f9d2c8968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range.  <br /></td></tr>
<tr class="separator:af368b8bc471211756f0fd32f9d2c8968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aefae29604dcd0147171f39aa1380be" id="r_a6aefae29604dcd0147171f39aa1380be"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a6aefae29604dcd0147171f39aa1380be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6aefae29604dcd0147171f39aa1380be">unique_copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a6aefae29604dcd0147171f39aa1380be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <br /></td></tr>
<tr class="separator:a6aefae29604dcd0147171f39aa1380be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18330134b5b5074b665d9e91c994f5e2" id="r_a18330134b5b5074b665d9e91c994f5e2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a18330134b5b5074b665d9e91c994f5e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18330134b5b5074b665d9e91c994f5e2">unique_copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a18330134b5b5074b665d9e91c994f5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <br /></td></tr>
<tr class="separator:a18330134b5b5074b665d9e91c994f5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3130ebfc35a09b9488d205269fdac86" id="r_ad3130ebfc35a09b9488d205269fdac86"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ad3130ebfc35a09b9488d205269fdac86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3130ebfc35a09b9488d205269fdac86">upper_bound</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:ad3130ebfc35a09b9488d205269fdac86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than <code>value</code>, or last if no such element is found.  <br /></td></tr>
<tr class="separator:ad3130ebfc35a09b9488d205269fdac86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25261717b25b3523e4fdb8d6420183d2" id="r_a25261717b25b3523e4fdb8d6420183d2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a25261717b25b3523e4fdb8d6420183d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a25261717b25b3523e4fdb8d6420183d2">upper_bound</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:a25261717b25b3523e4fdb8d6420183d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2498c6989c510ee8806df8ac266b6305" id="r_ga2498c6989c510ee8806df8ac266b6305"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> &gt; <br />
requires (detail::bit_castable_types&lt;<a class="el" href="structetl_1_1static__vector.html">To</a>, <a class="el" href="structetl_1_1static__vector.html">From</a>&gt;)</td></tr>
<tr class="memitem:ga2498c6989c510ee8806df8ac266b6305"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga2498c6989c510ee8806df8ac266b6305">bit_cast</a> (<a class="el" href="structetl_1_1static__vector.html">From</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">To</a></td></tr>
<tr class="memdesc:ga2498c6989c510ee8806df8ac266b6305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from.  <br /></td></tr>
<tr class="separator:ga2498c6989c510ee8806df8ac266b6305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5006351c988afecab30821e1ee41f2ed" id="r_ga5006351c988afecab30821e1ee41f2ed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga5006351c988afecab30821e1ee41f2ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga5006351c988afecab30821e1ee41f2ed">bit_ceil</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga5006351c988afecab30821e1ee41f2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the smallest integral power of two that is not smaller than x. If that value is not representable in UInt, the behavior is undefined. Call to this function is permitted in constant evaluation only if the undefined behavior does not occur.  <br /></td></tr>
<tr class="separator:ga5006351c988afecab30821e1ee41f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa305e9d1d725f6dfaebce56120c9f45d" id="r_gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaa305e9d1d725f6dfaebce56120c9f45d">bit_floor</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the largest integral power of two that is not greater than x. If x is zero, returns zero.  <br /></td></tr>
<tr class="separator:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31295beb3cd3da128d5df9392b56816" id="r_gae31295beb3cd3da128d5df9392b56816"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gae31295beb3cd3da128d5df9392b56816"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gae31295beb3cd3da128d5df9392b56816">bit_width</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:gae31295beb3cd3da128d5df9392b56816"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the number of bits needed to store the value x, that is, 1+log2(x). If x is zero, returns zero.  <br /></td></tr>
<tr class="separator:gae31295beb3cd3da128d5df9392b56816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a4e9ba0fafa208687f231ab27af92e" id="r_gae9a4e9ba0fafa208687f231ab27af92e"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gae9a4e9ba0fafa208687f231ab27af92e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gae9a4e9ba0fafa208687f231ab27af92e">byteswap</a> (T val) noexcept -&gt; T</td></tr>
<tr class="memdesc:gae9a4e9ba0fafa208687f231ab27af92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the bytes in the given integer value n.  <br /></td></tr>
<tr class="separator:gae9a4e9ba0fafa208687f231ab27af92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ff4047b7f7215764870239e29f7647" id="r_gaa8ff4047b7f7215764870239e29f7647"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa8ff4047b7f7215764870239e29f7647"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaa8ff4047b7f7215764870239e29f7647">countl_one</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:gaa8ff4047b7f7215764870239e29f7647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left").  <br /></td></tr>
<tr class="separator:gaa8ff4047b7f7215764870239e29f7647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120e955a7d833bee8e6c68c6a5639ca3" id="r_ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga120e955a7d833bee8e6c68c6a5639ca3">countl_zero</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left").  <br /></td></tr>
<tr class="separator:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e62f92367cf6ac4c456e52924e0814" id="r_gac7e62f92367cf6ac4c456e52924e0814"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gac7e62f92367cf6ac4c456e52924e0814"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gac7e62f92367cf6ac4c456e52924e0814">countr_one</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:gac7e62f92367cf6ac4c456e52924e0814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 bits in the value of x, starting from the least significant bit ("right").  <br /></td></tr>
<tr class="separator:gac7e62f92367cf6ac4c456e52924e0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a2e4bffa2cb54b6a5b018cbe2724690" id="r_ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga8a2e4bffa2cb54b6a5b018cbe2724690">countr_zero</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the least significant bit ("right").  <br /></td></tr>
<tr class="separator:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83522e02ec5bafd96be4cbdd71c207ae" id="r_ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga83522e02ec5bafd96be4cbdd71c207ae">flip_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e24662e346fc90c79dc7023e66ebd6d" id="r_ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga7e24662e346fc90c79dc7023e66ebd6d">flip_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip bit at position Pos.  <br /></td></tr>
<tr class="separator:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4732ae6a536891ce2d355378e0ac571c" id="r_ga4732ae6a536891ce2d355378e0ac571c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga4732ae6a536891ce2d355378e0ac571c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga4732ae6a536891ce2d355378e0ac571c">has_single_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga4732ae6a536891ce2d355378e0ac571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if x is an integral power of two.  <br /></td></tr>
<tr class="separator:ga4732ae6a536891ce2d355378e0ac571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb7a75a06b494847b855d850a44918" id="r_a99fb7a75a06b494847b855d850a44918"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a99fb7a75a06b494847b855d850a44918"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99fb7a75a06b494847b855d850a44918">operator&amp;</a> (T <a class="el" href="structetl_1_1static__vector.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:a99fb7a75a06b494847b855d850a44918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbe12aeee105b81dad6ee8d5bf70db5" id="r_a8dbe12aeee105b81dad6ee8d5bf70db5"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a8dbe12aeee105b81dad6ee8d5bf70db5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8dbe12aeee105b81dad6ee8d5bf70db5">operator|</a> (T <a class="el" href="structetl_1_1static__vector.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:a8dbe12aeee105b81dad6ee8d5bf70db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949f06ea9ccea69532ff49532f6cd7c7" id="r_a949f06ea9ccea69532ff49532f6cd7c7"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a949f06ea9ccea69532ff49532f6cd7c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a949f06ea9ccea69532ff49532f6cd7c7">operator^</a> (T <a class="el" href="structetl_1_1static__vector.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:a949f06ea9ccea69532ff49532f6cd7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2bdaacf0312586cd586bd854a7b35a" id="r_a8b2bdaacf0312586cd586bd854a7b35a"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a8b2bdaacf0312586cd586bd854a7b35a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b2bdaacf0312586cd586bd854a7b35a">operator~</a> (T <a class="el" href="structetl_1_1static__vector.html">x</a>) -&gt; T</td></tr>
<tr class="separator:a8b2bdaacf0312586cd586bd854a7b35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde4cd3357a82b4fb074755ab815223f" id="r_afde4cd3357a82b4fb074755ab815223f"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:afde4cd3357a82b4fb074755ab815223f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afde4cd3357a82b4fb074755ab815223f">operator|=</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:afde4cd3357a82b4fb074755ab815223f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcea5ac2499171347312a5f20051970" id="r_a2fcea5ac2499171347312a5f20051970"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a2fcea5ac2499171347312a5f20051970"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2fcea5ac2499171347312a5f20051970">operator&amp;=</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:a2fcea5ac2499171347312a5f20051970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa9d2eff6d0a0723cccce281bcf5619" id="r_acfa9d2eff6d0a0723cccce281bcf5619"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:acfa9d2eff6d0a0723cccce281bcf5619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfa9d2eff6d0a0723cccce281bcf5619">operator^=</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:acfa9d2eff6d0a0723cccce281bcf5619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484a219aea6406f7398208397bb244eb" id="r_ga484a219aea6406f7398208397bb244eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga484a219aea6406f7398208397bb244eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga484a219aea6406f7398208397bb244eb">popcount</a> (UInt val) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ga484a219aea6406f7398208397bb244eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 1 bits in the value of x.  <br /></td></tr>
<tr class="separator:ga484a219aea6406f7398208397bb244eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d7eab610ba1068c0cd27c9cc00a45a" id="r_ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga76d7eab610ba1068c0cd27c9cc00a45a">reset_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475638bd9306d99c55d5543eb3979b8f" id="r_ga475638bd9306d99c55d5543eb3979b8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga475638bd9306d99c55d5543eb3979b8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga475638bd9306d99c55d5543eb3979b8f">reset_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga475638bd9306d99c55d5543eb3979b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset bit at position Pos.  <br /></td></tr>
<tr class="separator:ga475638bd9306d99c55d5543eb3979b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3111087bb441d3683d06cb5af2e68c3c" id="r_ga3111087bb441d3683d06cb5af2e68c3c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga3111087bb441d3683d06cb5af2e68c3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga3111087bb441d3683d06cb5af2e68c3c">rotl</a> (UInt <a class="el" href="structetl_1_1static__vector.html">t</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">s</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga3111087bb441d3683d06cb5af2e68c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise left-rotating the value of x by s positions. This operation is also known as a left circular shift.  <br /></td></tr>
<tr class="separator:ga3111087bb441d3683d06cb5af2e68c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aeaa8cb213500ab9a8cf6ee98314d2a" id="r_ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga2aeaa8cb213500ab9a8cf6ee98314d2a">rotr</a> (UInt <a class="el" href="structetl_1_1static__vector.html">t</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">s</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise right-rotating the value of x by s positions. This operation is also known as a right circular shift.  <br /></td></tr>
<tr class="separator:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029b15dc4de2e5837b791049d6d16ed0" id="r_ga029b15dc4de2e5837b791049d6d16ed0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga029b15dc4de2e5837b791049d6d16ed0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga029b15dc4de2e5837b791049d6d16ed0">set_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga029b15dc4de2e5837b791049d6d16ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga029b15dc4de2e5837b791049d6d16ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12374769ae1db920c570b5b5b0cec13" id="r_gaa12374769ae1db920c570b5b5b0cec13"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa12374769ae1db920c570b5b5b0cec13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaa12374769ae1db920c570b5b5b0cec13">set_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a> value) -&gt; UInt</td></tr>
<tr class="memdesc:gaa12374769ae1db920c570b5b5b0cec13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>pos</code> to <code>value</code>.  <br /></td></tr>
<tr class="separator:gaa12374769ae1db920c570b5b5b0cec13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef0ecd7ca83244453f2e3ca077cf4d4" id="r_gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaeef0ecd7ca83244453f2e3ca077cf4d4">set_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>Pos</code>  <br /></td></tr>
<tr class="separator:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa73517548e29dd7eff01b08cd2619a2" id="r_gafa73517548e29dd7eff01b08cd2619a2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gafa73517548e29dd7eff01b08cd2619a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gafa73517548e29dd7eff01b08cd2619a2">set_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a> value) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gafa73517548e29dd7eff01b08cd2619a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>Pos</code> to <code>value</code>.  <br /></td></tr>
<tr class="separator:gafa73517548e29dd7eff01b08cd2619a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4773cf495c99535fcec3c02995c7427" id="r_gab4773cf495c99535fcec3c02995c7427"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gab4773cf495c99535fcec3c02995c7427"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gab4773cf495c99535fcec3c02995c7427">test_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gab4773cf495c99535fcec3c02995c7427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:gab4773cf495c99535fcec3c02995c7427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga726b254bcee55a0855832cfd3bafd000" id="r_ga726b254bcee55a0855832cfd3bafd000"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga726b254bcee55a0855832cfd3bafd000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga726b254bcee55a0855832cfd3bafd000">test_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga726b254bcee55a0855832cfd3bafd000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test bit at position <code>Pos</code>  <br /></td></tr>
<tr class="separator:ga726b254bcee55a0855832cfd3bafd000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91ff1be82212d980d87b1b7eee50ae" id="r_a3e91ff1be82212d980d87b1b7eee50ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:a3e91ff1be82212d980d87b1b7eee50ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e91ff1be82212d980d87b1b7eee50ae">operator&amp;</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:a3e91ff1be82212d980d87b1b7eee50ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary AND between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:a3e91ff1be82212d980d87b1b7eee50ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6dd579fe662e47108bc466e6f4b94a" id="r_afb6dd579fe662e47108bc466e6f4b94a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:afb6dd579fe662e47108bc466e6f4b94a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb6dd579fe662e47108bc466e6f4b94a">operator|</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:afb6dd579fe662e47108bc466e6f4b94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary OR between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:afb6dd579fe662e47108bc466e6f4b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a15b444153bb6f6f05086c199285cb" id="r_a40a15b444153bb6f6f05086c199285cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:a40a15b444153bb6f6f05086c199285cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40a15b444153bb6f6f05086c199285cb">operator^</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:a40a15b444153bb6f6f05086c199285cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary XOR between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:a40a15b444153bb6f6f05086c199285cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af087d859a13aefa1d1af499478179a59" id="r_af087d859a13aefa1d1af499478179a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af087d859a13aefa1d1af499478179a59">default_assert_handler</a> (<a class="el" href="structetl_1_1assert__msg.html">assert_msg</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">msg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:af087d859a13aefa1d1af499478179a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default assert handler. This will be called, if an assertion is triggered at runtime.  <br /></td></tr>
<tr class="separator:af087d859a13aefa1d1af499478179a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f0c06539ace1da2bddf4e0812b84bb" id="r_a59f0c06539ace1da2bddf4e0812b84bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59f0c06539ace1da2bddf4e0812b84bb">isalnum</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a59f0c06539ace1da2bddf4e0812b84bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is an alphanumeric character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a59f0c06539ace1da2bddf4e0812b84bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3971a86a072f5ef420f9446c69f3e9b8" id="r_a3971a86a072f5ef420f9446c69f3e9b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3971a86a072f5ef420f9446c69f3e9b8">isalpha</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a3971a86a072f5ef420f9446c69f3e9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is an alphabetic character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a3971a86a072f5ef420f9446c69f3e9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538306563b896d39ab29eb2c13bce86b" id="r_a538306563b896d39ab29eb2c13bce86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a538306563b896d39ab29eb2c13bce86b">isblank</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a538306563b896d39ab29eb2c13bce86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank characters.  <br /></td></tr>
<tr class="separator:a538306563b896d39ab29eb2c13bce86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368e8ddd21d388ae1504166640a1b80b" id="r_a368e8ddd21d388ae1504166640a1b80b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a368e8ddd21d388ae1504166640a1b80b">iscntrl</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a368e8ddd21d388ae1504166640a1b80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a control character as classified by the currently installed C locale. In the default, "C" locale, the control characters are the characters with the codes 0x00-0x1F and 0x7F.  <br /></td></tr>
<tr class="separator:a368e8ddd21d388ae1504166640a1b80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ada684f4a3c41f99153164e5465e49c" id="r_a7ada684f4a3c41f99153164e5465e49c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ada684f4a3c41f99153164e5465e49c">isdigit</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a7ada684f4a3c41f99153164e5465e49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is one of the 10 decimal digits: 0123456789.  <br /></td></tr>
<tr class="separator:a7ada684f4a3c41f99153164e5465e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce765b38ec7d09c9ef4e3424d24ce3b" id="r_a3ce765b38ec7d09c9ef4e3424d24ce3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ce765b38ec7d09c9ef4e3424d24ce3b">isgraph</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a3ce765b38ec7d09c9ef4e3424d24ce3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is graphic (has a graphical representation) as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a3ce765b38ec7d09c9ef4e3424d24ce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b19e10b64e3f368ecdf462fb07b15b" id="r_a66b19e10b64e3f368ecdf462fb07b15b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b19e10b64e3f368ecdf462fb07b15b">islower</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a66b19e10b64e3f368ecdf462fb07b15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is classified as a lowercase character according to the default C locale.  <br /></td></tr>
<tr class="separator:a66b19e10b64e3f368ecdf462fb07b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48a725052c02bf9e7e2b74019bcb27e" id="r_aa48a725052c02bf9e7e2b74019bcb27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa48a725052c02bf9e7e2b74019bcb27e">isprint</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:aa48a725052c02bf9e7e2b74019bcb27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if ch is a printable character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:aa48a725052c02bf9e7e2b74019bcb27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b14f213f7af1217b2d2cdf65f180738" id="r_a5b14f213f7af1217b2d2cdf65f180738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b14f213f7af1217b2d2cdf65f180738">ispunct</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a5b14f213f7af1217b2d2cdf65f180738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a punctuation character as classified by the current C locale.  <br /></td></tr>
<tr class="separator:a5b14f213f7af1217b2d2cdf65f180738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d797fc03c5126b24a821bd1fc122b3a" id="r_a9d797fc03c5126b24a821bd1fc122b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d797fc03c5126b24a821bd1fc122b3a">isspace</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a9d797fc03c5126b24a821bd1fc122b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is whitespace character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a9d797fc03c5126b24a821bd1fc122b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060875a823b3d041865221eecc9b93de" id="r_a060875a823b3d041865221eecc9b93de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a060875a823b3d041865221eecc9b93de">isupper</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a060875a823b3d041865221eecc9b93de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is classified as a uppercase character according to the default C locale.  <br /></td></tr>
<tr class="separator:a060875a823b3d041865221eecc9b93de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab501c4cabaa10c4b866b9c957ff5e16b" id="r_ab501c4cabaa10c4b866b9c957ff5e16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab501c4cabaa10c4b866b9c957ff5e16b">isxdigit</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ab501c4cabaa10c4b866b9c957ff5e16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF).  <br /></td></tr>
<tr class="separator:ab501c4cabaa10c4b866b9c957ff5e16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeee7b085cced6d915305f9ae1bee437" id="r_adeee7b085cced6d915305f9ae1bee437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeee7b085cced6d915305f9ae1bee437">tolower</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:adeee7b085cced6d915305f9ae1bee437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given character to lowercase according to the character conversion rules defined by the default C locale.  <br /></td></tr>
<tr class="separator:adeee7b085cced6d915305f9ae1bee437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5656409846cdb311fcc37acd590d9a" id="r_abf5656409846cdb311fcc37acd590d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf5656409846cdb311fcc37acd590d9a">toupper</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:abf5656409846cdb311fcc37acd590d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given character to uppercase according to the character conversion rules defined by the default C locale.  <br /></td></tr>
<tr class="separator:abf5656409846cdb311fcc37acd590d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7a4153c0b6a56949cfa7691169049b" id="r_a1f7a4153c0b6a56949cfa7691169049b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f7a4153c0b6a56949cfa7691169049b">isfinite</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a1f7a4153c0b6a56949cfa7691169049b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b70d7be5ca34b77def3ff9950ef1cc" id="r_a25b70d7be5ca34b77def3ff9950ef1cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b70d7be5ca34b77def3ff9950ef1cc">isinf</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a25b70d7be5ca34b77def3ff9950ef1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8986c9bc042cb46d1874b992a453180" id="r_ab8986c9bc042cb46d1874b992a453180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8986c9bc042cb46d1874b992a453180">isnan</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ab8986c9bc042cb46d1874b992a453180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf694dfa4152d5e19dfb263a24d0b3fd" id="r_aaf694dfa4152d5e19dfb263a24d0b3fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf694dfa4152d5e19dfb263a24d0b3fd">isnormal</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:aaf694dfa4152d5e19dfb263a24d0b3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4da52394b4be08dc83783c505ddc3a" id="r_a7f4da52394b4be08dc83783c505ddc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f4da52394b4be08dc83783c505ddc3a">signbit</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a7f4da52394b4be08dc83783c505ddc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57744d86f1f45347bc48d426591e1ce1" id="r_a57744d86f1f45347bc48d426591e1ce1"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> same_as&lt;<a class="el" href="structetl_1_1static__vector.html">Int</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</td></tr>
<tr class="memitem:a57744d86f1f45347bc48d426591e1ce1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57744d86f1f45347bc48d426591e1ce1">from_chars</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *first, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *last, <a class="el" href="structetl_1_1static__vector.html">Int</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:a57744d86f1f45347bc48d426591e1ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.  <br /></td></tr>
<tr class="separator:a57744d86f1f45347bc48d426591e1ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d46a108541ea7e9e622ba37063518f9" id="r_a6d46a108541ea7e9e622ba37063518f9"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> same_as&lt;T, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</td></tr>
<tr class="memitem:a6d46a108541ea7e9e622ba37063518f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d46a108541ea7e9e622ba37063518f9">to_chars</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *first, <a class="el" href="structetl_1_1static__vector.html">char</a> *last, T val, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:a6d46a108541ea7e9e622ba37063518f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <br /></td></tr>
<tr class="separator:a6d46a108541ea7e9e622ba37063518f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ada873a32749c139721424bd4a122d" id="r_a76ada873a32749c139721424bd4a122d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76ada873a32749c139721424bd4a122d">to_chars</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *, <a class="el" href="structetl_1_1static__vector.html">char</a> *, <a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">int</a>=10) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a76ada873a32749c139721424bd4a122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaba1a7c447283c046a48394e74172ea" id="r_aaaba1a7c447283c046a48394e74172ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#aaaba1a7c447283c046a48394e74172ea">operator&quot;&quot;_d</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> d) noexcept -&gt; <a class="el" href="structetl_1_1chrono_1_1day.html">etl::chrono::day</a></td></tr>
<tr class="memdesc:aaaba1a7c447283c046a48394e74172ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1day.html">etl::chrono::day</a> literal representing a day of the month in the calendar.  <br /></td></tr>
<tr class="separator:aaaba1a7c447283c046a48394e74172ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4723809483e46957434578efbbf37c8" id="r_ab4723809483e46957434578efbbf37c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#ab4723809483e46957434578efbbf37c8">operator&quot;&quot;_h</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> h) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#ae4c835a01e4830892ef9701461215a4e">etl::chrono::hours</a></td></tr>
<tr class="memdesc:ab4723809483e46957434578efbbf37c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing hours. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#ae4c835a01e4830892ef9701461215a4e" title="Signed integer type of at least 23 bits.">etl::chrono::hours(hrs)</a>.  <br /></td></tr>
<tr class="separator:ab4723809483e46957434578efbbf37c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4577bf7867d4337d8dd08dc3fc31900" id="r_ae4577bf7867d4337d8dd08dc3fc31900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#ae4577bf7867d4337d8dd08dc3fc31900">operator&quot;&quot;_h</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> h) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 3600, 1 &gt; &gt;</td></tr>
<tr class="memdesc:ae4577bf7867d4337d8dd08dc3fc31900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing hours. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#ae4c835a01e4830892ef9701461215a4e" title="Signed integer type of at least 23 bits.">etl::chrono::hours</a>.  <br /></td></tr>
<tr class="separator:ae4577bf7867d4337d8dd08dc3fc31900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec4b5254ed6657b1f18b4d95cb6273b" id="r_a3ec4b5254ed6657b1f18b4d95cb6273b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a3ec4b5254ed6657b1f18b4d95cb6273b">operator&quot;&quot;_min</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a76434032b633191afff02bd6132b1fcf">etl::chrono::minutes</a></td></tr>
<tr class="memdesc:a3ec4b5254ed6657b1f18b4d95cb6273b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing minutes. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#a76434032b633191afff02bd6132b1fcf" title="Signed integer type of at least 29 bits.">etl::chrono::minutes(mins)</a>.  <br /></td></tr>
<tr class="separator:a3ec4b5254ed6657b1f18b4d95cb6273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffa7b6293471e52a5217851a25ed47f" id="r_afffa7b6293471e52a5217851a25ed47f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#afffa7b6293471e52a5217851a25ed47f">operator&quot;&quot;_min</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="structetl_1_1ratio.html">etl::ratio</a>&lt; 60, 1 &gt; &gt;</td></tr>
<tr class="memdesc:afffa7b6293471e52a5217851a25ed47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing minutes. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a76434032b633191afff02bd6132b1fcf" title="Signed integer type of at least 29 bits.">etl::chrono::minutes</a>.  <br /></td></tr>
<tr class="separator:afffa7b6293471e52a5217851a25ed47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf39bd85cf926b2a54efaa5bfffe433" id="r_accf39bd85cf926b2a54efaa5bfffe433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#accf39bd85cf926b2a54efaa5bfffe433">operator&quot;&quot;_s</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#ad74086ee1024e4cf191fcc7e461a2835">etl::chrono::seconds</a></td></tr>
<tr class="memdesc:accf39bd85cf926b2a54efaa5bfffe433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing seconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#ad74086ee1024e4cf191fcc7e461a2835" title="Signed integer type of at least 35 bits.">etl::chrono::seconds(mins)</a>.  <br /></td></tr>
<tr class="separator:accf39bd85cf926b2a54efaa5bfffe433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b537721ce0895c51b93d53d4542d746" id="r_a5b537721ce0895c51b93d53d4542d746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a5b537721ce0895c51b93d53d4542d746">operator&quot;&quot;_s</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="memdesc:a5b537721ce0895c51b93d53d4542d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing seconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#ad74086ee1024e4cf191fcc7e461a2835" title="Signed integer type of at least 35 bits.">etl::chrono::seconds</a>.  <br /></td></tr>
<tr class="separator:a5b537721ce0895c51b93d53d4542d746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e7126dbdb381ba91fc2640ad3d4d80" id="r_a06e7126dbdb381ba91fc2640ad3d4d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a06e7126dbdb381ba91fc2640ad3d4d80">operator&quot;&quot;_ms</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a2d20076b8b8ba2dbc8cbcaee638b48f1">etl::chrono::milliseconds</a></td></tr>
<tr class="memdesc:a06e7126dbdb381ba91fc2640ad3d4d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing milliseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#a2d20076b8b8ba2dbc8cbcaee638b48f1" title="Signed integer type of at least 45 bits.">etl::chrono::milliseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a06e7126dbdb381ba91fc2640ad3d4d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c45fa1092960236ed3d893f8ababb0c" id="r_a8c45fa1092960236ed3d893f8ababb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a8c45fa1092960236ed3d893f8ababb0c">operator&quot;&quot;_ms</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="#ab10931e9eceef3f81bae9ea43bdd8e89">etl::milli</a> &gt;</td></tr>
<tr class="memdesc:a8c45fa1092960236ed3d893f8ababb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing milliseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a2d20076b8b8ba2dbc8cbcaee638b48f1" title="Signed integer type of at least 45 bits.">etl::chrono::milliseconds</a>.  <br /></td></tr>
<tr class="separator:a8c45fa1092960236ed3d893f8ababb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cefb6c59cd3f3c6fc3d7c87b547074c" id="r_a6cefb6c59cd3f3c6fc3d7c87b547074c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a6cefb6c59cd3f3c6fc3d7c87b547074c">operator&quot;&quot;_us</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a080788fed03294e645b6718a9063b197">etl::chrono::microseconds</a></td></tr>
<tr class="memdesc:a6cefb6c59cd3f3c6fc3d7c87b547074c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing microseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#a080788fed03294e645b6718a9063b197" title="Signed integer type of at least 55 bits.">etl::chrono::microseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a6cefb6c59cd3f3c6fc3d7c87b547074c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f2fde9a4fd051a6bc050a417a1b859" id="r_a41f2fde9a4fd051a6bc050a417a1b859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a41f2fde9a4fd051a6bc050a417a1b859">operator&quot;&quot;_us</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="#af06b69df89587850ded6209b864e7569">etl::micro</a> &gt;</td></tr>
<tr class="memdesc:a41f2fde9a4fd051a6bc050a417a1b859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing microseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a080788fed03294e645b6718a9063b197" title="Signed integer type of at least 55 bits.">etl::chrono::microseconds</a>.  <br /></td></tr>
<tr class="separator:a41f2fde9a4fd051a6bc050a417a1b859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbff174c4704c0334cf0614ef691012" id="r_a5bbff174c4704c0334cf0614ef691012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a5bbff174c4704c0334cf0614ef691012">operator&quot;&quot;_ns</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#aa2bdb8896e8a0a6a257483bf345f97ec">etl::chrono::nanoseconds</a></td></tr>
<tr class="memdesc:a5bbff174c4704c0334cf0614ef691012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing nanoseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#aa2bdb8896e8a0a6a257483bf345f97ec" title="Signed integer type of at least 64 bits.">etl::chrono::nanoseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a5bbff174c4704c0334cf0614ef691012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b50f9e1b881a27f0114aabcbec55a3" id="r_a64b50f9e1b881a27f0114aabcbec55a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a64b50f9e1b881a27f0114aabcbec55a3">operator&quot;&quot;_ns</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="#a1718104bd02150cc3a553b7289ea2d2d">etl::nano</a> &gt;</td></tr>
<tr class="memdesc:a64b50f9e1b881a27f0114aabcbec55a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing nanoseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#aa2bdb8896e8a0a6a257483bf345f97ec" title="Signed integer type of at least 64 bits.">etl::chrono::nanoseconds</a>.  <br /></td></tr>
<tr class="separator:a64b50f9e1b881a27f0114aabcbec55a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a1ed136986f9f62b428fc9cff05a58" id="r_ga11a1ed136986f9f62b428fc9cff05a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga11a1ed136986f9f62b428fc9cff05a58">acos</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga11a1ed136986f9f62b428fc9cff05a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:ga11a1ed136986f9f62b428fc9cff05a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0e24810c31b2b4d6c03c4c797ee6b2" id="r_gaab0e24810c31b2b4d6c03c4c797ee6b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaab0e24810c31b2b4d6c03c4c797ee6b2">acosf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaab0e24810c31b2b4d6c03c4c797ee6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:gaab0e24810c31b2b4d6c03c4c797ee6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e0fd9460a48322d76bc75bf03963e8" id="r_ga38e0fd9460a48322d76bc75bf03963e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga38e0fd9460a48322d76bc75bf03963e8">acos</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga38e0fd9460a48322d76bc75bf03963e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:ga38e0fd9460a48322d76bc75bf03963e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69543b8c9d2a9c0be5a844d0ee4a2b28" id="r_ga69543b8c9d2a9c0be5a844d0ee4a2b28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga69543b8c9d2a9c0be5a844d0ee4a2b28">acos</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga69543b8c9d2a9c0be5a844d0ee4a2b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:ga69543b8c9d2a9c0be5a844d0ee4a2b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2279ca8b4d3e2c28ec4e4a299bf0c3a" id="r_gad2279ca8b4d3e2c28ec4e4a299bf0c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad2279ca8b4d3e2c28ec4e4a299bf0c3a">acosl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad2279ca8b4d3e2c28ec4e4a299bf0c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:gad2279ca8b4d3e2c28ec4e4a299bf0c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae221cba6ef4006b4b7335921da4b5b45" id="r_gae221cba6ef4006b4b7335921da4b5b45"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gae221cba6ef4006b4b7335921da4b5b45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae221cba6ef4006b4b7335921da4b5b45">acos</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gae221cba6ef4006b4b7335921da4b5b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:gae221cba6ef4006b4b7335921da4b5b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94aadcd386f23a070e188aa0e717455" id="r_gaa94aadcd386f23a070e188aa0e717455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa94aadcd386f23a070e188aa0e717455">acosh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaa94aadcd386f23a070e188aa0e717455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gaa94aadcd386f23a070e188aa0e717455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf50a85a3985477a435e269682f2f887a" id="r_gaf50a85a3985477a435e269682f2f887a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf50a85a3985477a435e269682f2f887a">acoshf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaf50a85a3985477a435e269682f2f887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gaf50a85a3985477a435e269682f2f887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277e2f5e73eee56e174cd743b427093e" id="r_ga277e2f5e73eee56e174cd743b427093e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga277e2f5e73eee56e174cd743b427093e">acosh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga277e2f5e73eee56e174cd743b427093e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga277e2f5e73eee56e174cd743b427093e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c27c5ea58d63cf8f388201d96bec2af" id="r_ga0c27c5ea58d63cf8f388201d96bec2af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0c27c5ea58d63cf8f388201d96bec2af">acosh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga0c27c5ea58d63cf8f388201d96bec2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga0c27c5ea58d63cf8f388201d96bec2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429c4dfa96d36adcdac87db72304bbee" id="r_ga429c4dfa96d36adcdac87db72304bbee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga429c4dfa96d36adcdac87db72304bbee">acoshl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga429c4dfa96d36adcdac87db72304bbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga429c4dfa96d36adcdac87db72304bbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa923b319e97d4aeabfe2730b7b13ef66" id="r_gaa923b319e97d4aeabfe2730b7b13ef66"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gaa923b319e97d4aeabfe2730b7b13ef66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa923b319e97d4aeabfe2730b7b13ef66">acosh</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaa923b319e97d4aeabfe2730b7b13ef66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gaa923b319e97d4aeabfe2730b7b13ef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50604fe33f743a5a96db3d5894b899ea" id="r_ga50604fe33f743a5a96db3d5894b899ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga50604fe33f743a5a96db3d5894b899ea">asin</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga50604fe33f743a5a96db3d5894b899ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga50604fe33f743a5a96db3d5894b899ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b76a26aa932ec109e5386f77168196" id="r_ga51b76a26aa932ec109e5386f77168196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga51b76a26aa932ec109e5386f77168196">asinf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga51b76a26aa932ec109e5386f77168196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga51b76a26aa932ec109e5386f77168196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01b199b8cbad2b6a6a6a62fdf677c69" id="r_gad01b199b8cbad2b6a6a6a62fdf677c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad01b199b8cbad2b6a6a6a62fdf677c69">asin</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad01b199b8cbad2b6a6a6a62fdf677c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:gad01b199b8cbad2b6a6a6a62fdf677c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e900fb29e26b00afd5ddffc99f7b537" id="r_ga6e900fb29e26b00afd5ddffc99f7b537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6e900fb29e26b00afd5ddffc99f7b537">asin</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga6e900fb29e26b00afd5ddffc99f7b537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga6e900fb29e26b00afd5ddffc99f7b537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cba14d8fe2e4ab545185b18a751e4c5" id="r_ga8cba14d8fe2e4ab545185b18a751e4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8cba14d8fe2e4ab545185b18a751e4c5">asinl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8cba14d8fe2e4ab545185b18a751e4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga8cba14d8fe2e4ab545185b18a751e4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28de5991fd85c129c572e136083a1a32" id="r_ga28de5991fd85c129c572e136083a1a32"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga28de5991fd85c129c572e136083a1a32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga28de5991fd85c129c572e136083a1a32">asin</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga28de5991fd85c129c572e136083a1a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga28de5991fd85c129c572e136083a1a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7859c18dbfae564f92d556e14fa7b6a" id="r_gac7859c18dbfae564f92d556e14fa7b6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac7859c18dbfae564f92d556e14fa7b6a">asinh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gac7859c18dbfae564f92d556e14fa7b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gac7859c18dbfae564f92d556e14fa7b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476f7ceb4dce8dfbda05dcde42d9103d" id="r_ga476f7ceb4dce8dfbda05dcde42d9103d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga476f7ceb4dce8dfbda05dcde42d9103d">asinhf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga476f7ceb4dce8dfbda05dcde42d9103d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga476f7ceb4dce8dfbda05dcde42d9103d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8505fcb3b44df45b2ad775124c5d099e" id="r_ga8505fcb3b44df45b2ad775124c5d099e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8505fcb3b44df45b2ad775124c5d099e">asinh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8505fcb3b44df45b2ad775124c5d099e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga8505fcb3b44df45b2ad775124c5d099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga304b637bf14e2ea87a61dc632ea06d02" id="r_ga304b637bf14e2ea87a61dc632ea06d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga304b637bf14e2ea87a61dc632ea06d02">asinh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga304b637bf14e2ea87a61dc632ea06d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga304b637bf14e2ea87a61dc632ea06d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fdc11c6a149dde153853117d7395182" id="r_ga4fdc11c6a149dde153853117d7395182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4fdc11c6a149dde153853117d7395182">asinhl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga4fdc11c6a149dde153853117d7395182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga4fdc11c6a149dde153853117d7395182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc2311ee0e019a8e8fde34127d616e38" id="r_gadc2311ee0e019a8e8fde34127d616e38"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gadc2311ee0e019a8e8fde34127d616e38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadc2311ee0e019a8e8fde34127d616e38">asinh</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gadc2311ee0e019a8e8fde34127d616e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gadc2311ee0e019a8e8fde34127d616e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050d30d9993cbfef460a649443ea4e14" id="r_ga050d30d9993cbfef460a649443ea4e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga050d30d9993cbfef460a649443ea4e14">atan</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga050d30d9993cbfef460a649443ea4e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:ga050d30d9993cbfef460a649443ea4e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc77c1f521b383cb7c8e3caea2ccd145" id="r_gadc77c1f521b383cb7c8e3caea2ccd145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadc77c1f521b383cb7c8e3caea2ccd145">atanf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gadc77c1f521b383cb7c8e3caea2ccd145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:gadc77c1f521b383cb7c8e3caea2ccd145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f38e6f2553eab83a47f6a250630516" id="r_gac7f38e6f2553eab83a47f6a250630516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac7f38e6f2553eab83a47f6a250630516">atan</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gac7f38e6f2553eab83a47f6a250630516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:gac7f38e6f2553eab83a47f6a250630516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7618da1cd9d1a0e9f80aa0e46738c503" id="r_ga7618da1cd9d1a0e9f80aa0e46738c503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7618da1cd9d1a0e9f80aa0e46738c503">atan</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga7618da1cd9d1a0e9f80aa0e46738c503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:ga7618da1cd9d1a0e9f80aa0e46738c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da6aa9cdb87c1dd54a93329b7a39b94" id="r_ga0da6aa9cdb87c1dd54a93329b7a39b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0da6aa9cdb87c1dd54a93329b7a39b94">atanl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga0da6aa9cdb87c1dd54a93329b7a39b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:ga0da6aa9cdb87c1dd54a93329b7a39b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f0eafca791de319aa3bd354b45f2af" id="r_gad7f0eafca791de319aa3bd354b45f2af"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gad7f0eafca791de319aa3bd354b45f2af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad7f0eafca791de319aa3bd354b45f2af">atan</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad7f0eafca791de319aa3bd354b45f2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:gad7f0eafca791de319aa3bd354b45f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3aa7a4e78ae3ce2384102d19c7012f0" id="r_gaa3aa7a4e78ae3ce2384102d19c7012f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa3aa7a4e78ae3ce2384102d19c7012f0">atan2</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaa3aa7a4e78ae3ce2384102d19c7012f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:gaa3aa7a4e78ae3ce2384102d19c7012f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af6a240c95112abd3800979b58338b8" id="r_ga7af6a240c95112abd3800979b58338b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7af6a240c95112abd3800979b58338b8">atan2f</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga7af6a240c95112abd3800979b58338b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:ga7af6a240c95112abd3800979b58338b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1793f80eaf46012c729372559f20a36" id="r_gac1793f80eaf46012c729372559f20a36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac1793f80eaf46012c729372559f20a36">atan2</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gac1793f80eaf46012c729372559f20a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:gac1793f80eaf46012c729372559f20a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913dc1d0214b7452ae06ae2744b10b52" id="r_ga913dc1d0214b7452ae06ae2744b10b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga913dc1d0214b7452ae06ae2744b10b52">atan2</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga913dc1d0214b7452ae06ae2744b10b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:ga913dc1d0214b7452ae06ae2744b10b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fecd8eed70865ec7a4bbaf336a108f" id="r_ga93fecd8eed70865ec7a4bbaf336a108f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga93fecd8eed70865ec7a4bbaf336a108f">atan2l</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga93fecd8eed70865ec7a4bbaf336a108f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:ga93fecd8eed70865ec7a4bbaf336a108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0085c94b22dfe824cd8181da9714026a" id="r_ga0085c94b22dfe824cd8181da9714026a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0085c94b22dfe824cd8181da9714026a">atanh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga0085c94b22dfe824cd8181da9714026a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga0085c94b22dfe824cd8181da9714026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae158c810a6fc7cd5ba3a30ad242fa665" id="r_gae158c810a6fc7cd5ba3a30ad242fa665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae158c810a6fc7cd5ba3a30ad242fa665">atanhf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gae158c810a6fc7cd5ba3a30ad242fa665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:gae158c810a6fc7cd5ba3a30ad242fa665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc6272738fda91f94464a0ff78196f2" id="r_ga3cc6272738fda91f94464a0ff78196f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3cc6272738fda91f94464a0ff78196f2">atanh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga3cc6272738fda91f94464a0ff78196f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga3cc6272738fda91f94464a0ff78196f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44fbe54fbbf219b24c4e2a9f1bc38cc6" id="r_ga44fbe54fbbf219b24c4e2a9f1bc38cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga44fbe54fbbf219b24c4e2a9f1bc38cc6">atanh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga44fbe54fbbf219b24c4e2a9f1bc38cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga44fbe54fbbf219b24c4e2a9f1bc38cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd5afff1dc0cd8c7e74a471a250cff5" id="r_ga5dd5afff1dc0cd8c7e74a471a250cff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5dd5afff1dc0cd8c7e74a471a250cff5">atanhl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga5dd5afff1dc0cd8c7e74a471a250cff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga5dd5afff1dc0cd8c7e74a471a250cff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4e3143d7e3727b642a830f9fceff16" id="r_ga9b4e3143d7e3727b642a830f9fceff16"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga9b4e3143d7e3727b642a830f9fceff16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9b4e3143d7e3727b642a830f9fceff16">atanh</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga9b4e3143d7e3727b642a830f9fceff16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga9b4e3143d7e3727b642a830f9fceff16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7312ab60735f030c31d877e771df25b" id="r_gad7312ab60735f030c31d877e771df25b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad7312ab60735f030c31d877e771df25b">beta</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad7312ab60735f030c31d877e771df25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y.  <br /></td></tr>
<tr class="separator:gad7312ab60735f030c31d877e771df25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ea0a5ab3eb1572d57df749fa2a1b29" id="r_ga43ea0a5ab3eb1572d57df749fa2a1b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga43ea0a5ab3eb1572d57df749fa2a1b29">betaf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga43ea0a5ab3eb1572d57df749fa2a1b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y.  <br /></td></tr>
<tr class="separator:ga43ea0a5ab3eb1572d57df749fa2a1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6feea40ab25c49385c9da90776c9181" id="r_gad6feea40ab25c49385c9da90776c9181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad6feea40ab25c49385c9da90776c9181">betal</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad6feea40ab25c49385c9da90776c9181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y.  <br /></td></tr>
<tr class="separator:gad6feea40ab25c49385c9da90776c9181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519930d517ee057032189d734e9fc5ed" id="r_ga519930d517ee057032189d734e9fc5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga519930d517ee057032189d734e9fc5ed">ceil</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga519930d517ee057032189d734e9fc5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:ga519930d517ee057032189d734e9fc5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddaf0fe8a1ffd02877c6e0f6746e554" id="r_ga1ddaf0fe8a1ffd02877c6e0f6746e554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1ddaf0fe8a1ffd02877c6e0f6746e554">ceilf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga1ddaf0fe8a1ffd02877c6e0f6746e554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:ga1ddaf0fe8a1ffd02877c6e0f6746e554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca876419c954b74e77fde43b651c1a45" id="r_gaca876419c954b74e77fde43b651c1a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaca876419c954b74e77fde43b651c1a45">ceil</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaca876419c954b74e77fde43b651c1a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:gaca876419c954b74e77fde43b651c1a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cef9baa2395afd4785ff2e97806a21" id="r_ga38cef9baa2395afd4785ff2e97806a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga38cef9baa2395afd4785ff2e97806a21">ceil</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga38cef9baa2395afd4785ff2e97806a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:ga38cef9baa2395afd4785ff2e97806a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7264f931bcdd9b7b9c418397d8a7ce0" id="r_gaa7264f931bcdd9b7b9c418397d8a7ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa7264f931bcdd9b7b9c418397d8a7ce0">ceill</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaa7264f931bcdd9b7b9c418397d8a7ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:gaa7264f931bcdd9b7b9c418397d8a7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9354a7eb610305457b39af8b541fb0e" id="r_gab9354a7eb610305457b39af8b541fb0e"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gab9354a7eb610305457b39af8b541fb0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab9354a7eb610305457b39af8b541fb0e">ceil</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gab9354a7eb610305457b39af8b541fb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:gab9354a7eb610305457b39af8b541fb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3311ce930de7a4c480eb2d18975fd413" id="r_ga3311ce930de7a4c480eb2d18975fd413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3311ce930de7a4c480eb2d18975fd413">copysign</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga3311ce930de7a4c480eb2d18975fd413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga3311ce930de7a4c480eb2d18975fd413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3b7765a523593f95aab5ee4a830a0a" id="r_ga5c3b7765a523593f95aab5ee4a830a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5c3b7765a523593f95aab5ee4a830a0a">copysignf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga5c3b7765a523593f95aab5ee4a830a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga5c3b7765a523593f95aab5ee4a830a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff1096301fd095ed4ce11c7d7da07e9" id="r_gadff1096301fd095ed4ce11c7d7da07e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadff1096301fd095ed4ce11c7d7da07e9">copysign</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gadff1096301fd095ed4ce11c7d7da07e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:gadff1096301fd095ed4ce11c7d7da07e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d191ad6ae48528f4b203b2ffc149db" id="r_ga07d191ad6ae48528f4b203b2ffc149db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga07d191ad6ae48528f4b203b2ffc149db">copysign</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga07d191ad6ae48528f4b203b2ffc149db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga07d191ad6ae48528f4b203b2ffc149db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a49b2265ca69e52783f386e10898bd6" id="r_ga6a49b2265ca69e52783f386e10898bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6a49b2265ca69e52783f386e10898bd6">copysignl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga6a49b2265ca69e52783f386e10898bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga6a49b2265ca69e52783f386e10898bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b56c844b2ce61b2d76a4d2c77396ce9" id="r_ga1b56c844b2ce61b2d76a4d2c77396ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1b56c844b2ce61b2d76a4d2c77396ce9">cos</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga1b56c844b2ce61b2d76a4d2c77396ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga1b56c844b2ce61b2d76a4d2c77396ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b64d241e55170c1c5ff3c81b7f049d8" id="r_ga6b64d241e55170c1c5ff3c81b7f049d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6b64d241e55170c1c5ff3c81b7f049d8">cosf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga6b64d241e55170c1c5ff3c81b7f049d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga6b64d241e55170c1c5ff3c81b7f049d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d37321a2b5d670a7f7e1d350e4a5d9" id="r_gaa6d37321a2b5d670a7f7e1d350e4a5d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa6d37321a2b5d670a7f7e1d350e4a5d9">cos</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaa6d37321a2b5d670a7f7e1d350e4a5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gaa6d37321a2b5d670a7f7e1d350e4a5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9bea6fec2b71789aa1efe4390cd8ca9" id="r_gad9bea6fec2b71789aa1efe4390cd8ca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad9bea6fec2b71789aa1efe4390cd8ca9">cos</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad9bea6fec2b71789aa1efe4390cd8ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gad9bea6fec2b71789aa1efe4390cd8ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b52639423f23e3404d217ee510d9d5a" id="r_ga6b52639423f23e3404d217ee510d9d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6b52639423f23e3404d217ee510d9d5a">cosl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga6b52639423f23e3404d217ee510d9d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga6b52639423f23e3404d217ee510d9d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46067cbddc095bd090dcb965bb4b1765" id="r_ga46067cbddc095bd090dcb965bb4b1765"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga46067cbddc095bd090dcb965bb4b1765"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga46067cbddc095bd090dcb965bb4b1765">cos</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga46067cbddc095bd090dcb965bb4b1765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga46067cbddc095bd090dcb965bb4b1765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0be4fdb5e458f645d1c425d2ae1651a" id="r_gaf0be4fdb5e458f645d1c425d2ae1651a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf0be4fdb5e458f645d1c425d2ae1651a">cosh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaf0be4fdb5e458f645d1c425d2ae1651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gaf0be4fdb5e458f645d1c425d2ae1651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07412925075eb7fdaff262a202c6d8b" id="r_gab07412925075eb7fdaff262a202c6d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab07412925075eb7fdaff262a202c6d8b">coshf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gab07412925075eb7fdaff262a202c6d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gab07412925075eb7fdaff262a202c6d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4f26d3503097887c1a08ebd5cb99ec" id="r_gabb4f26d3503097887c1a08ebd5cb99ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gabb4f26d3503097887c1a08ebd5cb99ec">cosh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gabb4f26d3503097887c1a08ebd5cb99ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gabb4f26d3503097887c1a08ebd5cb99ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff130df1c63fe44e621b49cb14b8aee0" id="r_gaff130df1c63fe44e621b49cb14b8aee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaff130df1c63fe44e621b49cb14b8aee0">cosh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaff130df1c63fe44e621b49cb14b8aee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gaff130df1c63fe44e621b49cb14b8aee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4c7883e2812a93178162463f1eca34" id="r_ga3f4c7883e2812a93178162463f1eca34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3f4c7883e2812a93178162463f1eca34">coshl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga3f4c7883e2812a93178162463f1eca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga3f4c7883e2812a93178162463f1eca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0697c64cd07048c3867686088e2a78e2" id="r_ga0697c64cd07048c3867686088e2a78e2"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga0697c64cd07048c3867686088e2a78e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0697c64cd07048c3867686088e2a78e2">cosh</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga0697c64cd07048c3867686088e2a78e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga0697c64cd07048c3867686088e2a78e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1181784239ab4a4d91bbb09c6e136260" id="r_ga1181784239ab4a4d91bbb09c6e136260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1181784239ab4a4d91bbb09c6e136260">erf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga1181784239ab4a4d91bbb09c6e136260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:ga1181784239ab4a4d91bbb09c6e136260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc5a060cd5e28fdeabcf1393a23f64e" id="r_ga4dc5a060cd5e28fdeabcf1393a23f64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4dc5a060cd5e28fdeabcf1393a23f64e">erff</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga4dc5a060cd5e28fdeabcf1393a23f64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:ga4dc5a060cd5e28fdeabcf1393a23f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13bbf02499fb50c7f713c884e7519cd6" id="r_ga13bbf02499fb50c7f713c884e7519cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga13bbf02499fb50c7f713c884e7519cd6">erf</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga13bbf02499fb50c7f713c884e7519cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:ga13bbf02499fb50c7f713c884e7519cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fcb9ae441725436b6e468541847f746" id="r_ga8fcb9ae441725436b6e468541847f746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8fcb9ae441725436b6e468541847f746">erf</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8fcb9ae441725436b6e468541847f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:ga8fcb9ae441725436b6e468541847f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cec8755ca64d6ee2774b2d1286f6e72" id="r_ga9cec8755ca64d6ee2774b2d1286f6e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9cec8755ca64d6ee2774b2d1286f6e72">erfl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga9cec8755ca64d6ee2774b2d1286f6e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:ga9cec8755ca64d6ee2774b2d1286f6e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e395cd217c6ad69d56705ae174a84d" id="r_ga33e395cd217c6ad69d56705ae174a84d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga33e395cd217c6ad69d56705ae174a84d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga33e395cd217c6ad69d56705ae174a84d">erf</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga33e395cd217c6ad69d56705ae174a84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:ga33e395cd217c6ad69d56705ae174a84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9635830aa0cf956dc1924dbd841ad8" id="r_ga6f9635830aa0cf956dc1924dbd841ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6f9635830aa0cf956dc1924dbd841ad8">exp</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga6f9635830aa0cf956dc1924dbd841ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:ga6f9635830aa0cf956dc1924dbd841ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4969b436b3ff78af213086a1d5fe52" id="r_gabc4969b436b3ff78af213086a1d5fe52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gabc4969b436b3ff78af213086a1d5fe52">expf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gabc4969b436b3ff78af213086a1d5fe52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:gabc4969b436b3ff78af213086a1d5fe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661cc4fffe4d999611477bbbfcc7e436" id="r_ga661cc4fffe4d999611477bbbfcc7e436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga661cc4fffe4d999611477bbbfcc7e436">exp</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga661cc4fffe4d999611477bbbfcc7e436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:ga661cc4fffe4d999611477bbbfcc7e436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32583e05b36ffdddc54f1ca3ec70a5b3" id="r_ga32583e05b36ffdddc54f1ca3ec70a5b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga32583e05b36ffdddc54f1ca3ec70a5b3">exp</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga32583e05b36ffdddc54f1ca3ec70a5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:ga32583e05b36ffdddc54f1ca3ec70a5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb6fdb732877131d7d8eaa6bf8fde15" id="r_ga5fb6fdb732877131d7d8eaa6bf8fde15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5fb6fdb732877131d7d8eaa6bf8fde15">expl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga5fb6fdb732877131d7d8eaa6bf8fde15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:ga5fb6fdb732877131d7d8eaa6bf8fde15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfd62b20f90b6b5275854d4bd14bb89a" id="r_gabfd62b20f90b6b5275854d4bd14bb89a"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gabfd62b20f90b6b5275854d4bd14bb89a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gabfd62b20f90b6b5275854d4bd14bb89a">exp</a> (T <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gabfd62b20f90b6b5275854d4bd14bb89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:gabfd62b20f90b6b5275854d4bd14bb89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40d830738a425fdaa77de5126137c9d" id="r_gae40d830738a425fdaa77de5126137c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae40d830738a425fdaa77de5126137c9d">fdim</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gae40d830738a425fdaa77de5126137c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:gae40d830738a425fdaa77de5126137c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab067c004a5ee6f46a9a6f7f86654154a" id="r_gab067c004a5ee6f46a9a6f7f86654154a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab067c004a5ee6f46a9a6f7f86654154a">fdimf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gab067c004a5ee6f46a9a6f7f86654154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:gab067c004a5ee6f46a9a6f7f86654154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1509070d05f6a7884ef06d44175925" id="r_ga1f1509070d05f6a7884ef06d44175925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1f1509070d05f6a7884ef06d44175925">fdim</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga1f1509070d05f6a7884ef06d44175925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:ga1f1509070d05f6a7884ef06d44175925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107975b19f18d51fe1b0fea4fa21fd6b" id="r_ga107975b19f18d51fe1b0fea4fa21fd6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga107975b19f18d51fe1b0fea4fa21fd6b">fdim</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga107975b19f18d51fe1b0fea4fa21fd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:ga107975b19f18d51fe1b0fea4fa21fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acecfd8db84e93791424bbc3d94714f" id="r_ga0acecfd8db84e93791424bbc3d94714f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0acecfd8db84e93791424bbc3d94714f">fdiml</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga0acecfd8db84e93791424bbc3d94714f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:ga0acecfd8db84e93791424bbc3d94714f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9a1a2e9572dfe0caa6a574405369fe" id="r_gabf9a1a2e9572dfe0caa6a574405369fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gabf9a1a2e9572dfe0caa6a574405369fe">floor</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gabf9a1a2e9572dfe0caa6a574405369fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:gabf9a1a2e9572dfe0caa6a574405369fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b269b4a8f158ef8fd4ebe3e6117fad8" id="r_ga2b269b4a8f158ef8fd4ebe3e6117fad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2b269b4a8f158ef8fd4ebe3e6117fad8">floorf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga2b269b4a8f158ef8fd4ebe3e6117fad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:ga2b269b4a8f158ef8fd4ebe3e6117fad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798ddc91a8ff660e3e5ae767103b2573" id="r_ga798ddc91a8ff660e3e5ae767103b2573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga798ddc91a8ff660e3e5ae767103b2573">floor</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga798ddc91a8ff660e3e5ae767103b2573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:ga798ddc91a8ff660e3e5ae767103b2573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa478a6f2a9aabe0513ff380f64c8378" id="r_gaaa478a6f2a9aabe0513ff380f64c8378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaaa478a6f2a9aabe0513ff380f64c8378">floor</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaaa478a6f2a9aabe0513ff380f64c8378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:gaaa478a6f2a9aabe0513ff380f64c8378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94649517d90ede186b90638c7db492a7" id="r_ga94649517d90ede186b90638c7db492a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga94649517d90ede186b90638c7db492a7">floorl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga94649517d90ede186b90638c7db492a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:ga94649517d90ede186b90638c7db492a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga887380216350a393815f666658553a54" id="r_ga887380216350a393815f666658553a54"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga887380216350a393815f666658553a54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga887380216350a393815f666658553a54">floor</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga887380216350a393815f666658553a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:ga887380216350a393815f666658553a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bcdbb66121fef621b27d7f70316c9f" id="r_ga00bcdbb66121fef621b27d7f70316c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga00bcdbb66121fef621b27d7f70316c9f">fma</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga00bcdbb66121fef621b27d7f70316c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:ga00bcdbb66121fef621b27d7f70316c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4663bcfb836899ed9faadca926cec52" id="r_gaf4663bcfb836899ed9faadca926cec52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf4663bcfb836899ed9faadca926cec52">fmaf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaf4663bcfb836899ed9faadca926cec52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:gaf4663bcfb836899ed9faadca926cec52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5894e1f0898f72ee4d749bf3ebe481a" id="r_gac5894e1f0898f72ee4d749bf3ebe481a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac5894e1f0898f72ee4d749bf3ebe481a">fma</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gac5894e1f0898f72ee4d749bf3ebe481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:gac5894e1f0898f72ee4d749bf3ebe481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9885e89bbef07cbda18deeb6baf7c5ba" id="r_ga9885e89bbef07cbda18deeb6baf7c5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9885e89bbef07cbda18deeb6baf7c5ba">fma</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga9885e89bbef07cbda18deeb6baf7c5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:ga9885e89bbef07cbda18deeb6baf7c5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8054035883ddf10f76dddbe361976fe4" id="r_ga8054035883ddf10f76dddbe361976fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8054035883ddf10f76dddbe361976fe4">fmal</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8054035883ddf10f76dddbe361976fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:ga8054035883ddf10f76dddbe361976fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa70d3059866e4b8121b7f68c8b3e98" id="r_gadaa70d3059866e4b8121b7f68c8b3e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadaa70d3059866e4b8121b7f68c8b3e98">fmax</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gadaa70d3059866e4b8121b7f68c8b3e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:gadaa70d3059866e4b8121b7f68c8b3e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga283c8ca45d511fdf2bc444db6a13db6a" id="r_ga283c8ca45d511fdf2bc444db6a13db6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga283c8ca45d511fdf2bc444db6a13db6a">fmaxf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga283c8ca45d511fdf2bc444db6a13db6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:ga283c8ca45d511fdf2bc444db6a13db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252d9ab2a9a452ca065f701fe2f0d5ab" id="r_ga252d9ab2a9a452ca065f701fe2f0d5ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga252d9ab2a9a452ca065f701fe2f0d5ab">fmax</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga252d9ab2a9a452ca065f701fe2f0d5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:ga252d9ab2a9a452ca065f701fe2f0d5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d1e573a47f6e45c034fa642143ffbf" id="r_ga53d1e573a47f6e45c034fa642143ffbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga53d1e573a47f6e45c034fa642143ffbf">fmax</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga53d1e573a47f6e45c034fa642143ffbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:ga53d1e573a47f6e45c034fa642143ffbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad3c69362f2624101b5f4c0f05ca4e3" id="r_gafad3c69362f2624101b5f4c0f05ca4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gafad3c69362f2624101b5f4c0f05ca4e3">fmaxl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gafad3c69362f2624101b5f4c0f05ca4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:gafad3c69362f2624101b5f4c0f05ca4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69af224f0f1dcf75045a329546454539" id="r_ga69af224f0f1dcf75045a329546454539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga69af224f0f1dcf75045a329546454539">fmin</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga69af224f0f1dcf75045a329546454539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:ga69af224f0f1dcf75045a329546454539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48d9860badaa088ca72788b9e1ee61e" id="r_gaf48d9860badaa088ca72788b9e1ee61e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf48d9860badaa088ca72788b9e1ee61e">fminf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaf48d9860badaa088ca72788b9e1ee61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:gaf48d9860badaa088ca72788b9e1ee61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8697722ec82db1de9d7411cbcb77989f" id="r_ga8697722ec82db1de9d7411cbcb77989f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8697722ec82db1de9d7411cbcb77989f">fmin</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8697722ec82db1de9d7411cbcb77989f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:ga8697722ec82db1de9d7411cbcb77989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e5cd4b9b2fc1428c493acc46e9158e" id="r_ga95e5cd4b9b2fc1428c493acc46e9158e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga95e5cd4b9b2fc1428c493acc46e9158e">fmin</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga95e5cd4b9b2fc1428c493acc46e9158e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:ga95e5cd4b9b2fc1428c493acc46e9158e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669fd2896aa32adef5d728a8413473fe" id="r_ga669fd2896aa32adef5d728a8413473fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga669fd2896aa32adef5d728a8413473fe">fminl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga669fd2896aa32adef5d728a8413473fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:ga669fd2896aa32adef5d728a8413473fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad31ccb95fa5e87e37eb042aef95f0dac" id="r_gad31ccb95fa5e87e37eb042aef95f0dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad31ccb95fa5e87e37eb042aef95f0dac">fmod</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gad31ccb95fa5e87e37eb042aef95f0dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:gad31ccb95fa5e87e37eb042aef95f0dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703cda91c0dcce6bd41bebefcaef7cfa" id="r_ga703cda91c0dcce6bd41bebefcaef7cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga703cda91c0dcce6bd41bebefcaef7cfa">fmodf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga703cda91c0dcce6bd41bebefcaef7cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:ga703cda91c0dcce6bd41bebefcaef7cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga502311c1812ecf633ad9b23c19042cf3" id="r_ga502311c1812ecf633ad9b23c19042cf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga502311c1812ecf633ad9b23c19042cf3">fmod</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga502311c1812ecf633ad9b23c19042cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:ga502311c1812ecf633ad9b23c19042cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9b4897566472c93109ce45ede4fe23" id="r_ga2c9b4897566472c93109ce45ede4fe23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2c9b4897566472c93109ce45ede4fe23">fmod</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga2c9b4897566472c93109ce45ede4fe23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:ga2c9b4897566472c93109ce45ede4fe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37522e6021832ad590458f01fb85b302" id="r_ga37522e6021832ad590458f01fb85b302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga37522e6021832ad590458f01fb85b302">fmodl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga37522e6021832ad590458f01fb85b302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:ga37522e6021832ad590458f01fb85b302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef65d68eb2809fdf28f84ba4cb9ddcb0" id="r_gaef65d68eb2809fdf28f84ba4cb9ddcb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaef65d68eb2809fdf28f84ba4cb9ddcb0">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaef65d68eb2809fdf28f84ba4cb9ddcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:gaef65d68eb2809fdf28f84ba4cb9ddcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ce9b544965e9e10ab119bcf528e9a7" id="r_ga95ce9b544965e9e10ab119bcf528e9a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga95ce9b544965e9e10ab119bcf528e9a7">hypotf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga95ce9b544965e9e10ab119bcf528e9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:ga95ce9b544965e9e10ab119bcf528e9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae25a1160334f62555b8f1147c07d855" id="r_gaae25a1160334f62555b8f1147c07d855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaae25a1160334f62555b8f1147c07d855">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaae25a1160334f62555b8f1147c07d855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:gaae25a1160334f62555b8f1147c07d855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96f76d5fad7b673c350d83944f6d8043" id="r_ga96f76d5fad7b673c350d83944f6d8043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga96f76d5fad7b673c350d83944f6d8043">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga96f76d5fad7b673c350d83944f6d8043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:ga96f76d5fad7b673c350d83944f6d8043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae219bdaec04a35376a4121abbdd6e403" id="r_gae219bdaec04a35376a4121abbdd6e403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae219bdaec04a35376a4121abbdd6e403">hypotl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gae219bdaec04a35376a4121abbdd6e403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:gae219bdaec04a35376a4121abbdd6e403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebac6f56dad6bbb43d32fd02b797082a" id="r_gaebac6f56dad6bbb43d32fd02b797082a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaebac6f56dad6bbb43d32fd02b797082a">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaebac6f56dad6bbb43d32fd02b797082a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:gaebac6f56dad6bbb43d32fd02b797082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb8298ed1711c3c88583c7021de8d09" id="r_ga4fb8298ed1711c3c88583c7021de8d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4fb8298ed1711c3c88583c7021de8d09">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga4fb8298ed1711c3c88583c7021de8d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:ga4fb8298ed1711c3c88583c7021de8d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46b41382252069a234a49a3f86f60f67" id="r_ga46b41382252069a234a49a3f86f60f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga46b41382252069a234a49a3f86f60f67">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga46b41382252069a234a49a3f86f60f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:ga46b41382252069a234a49a3f86f60f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee338b4a795e4fb1b7c0b78c9db74f1f" id="r_gaee338b4a795e4fb1b7c0b78c9db74f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaee338b4a795e4fb1b7c0b78c9db74f1f">isfinite</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gaee338b4a795e4fb1b7c0b78c9db74f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN.  <br /></td></tr>
<tr class="separator:gaee338b4a795e4fb1b7c0b78c9db74f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a2f3a81c9fd5d4f1622ab810dd46f2c" id="r_ga9a2f3a81c9fd5d4f1622ab810dd46f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9a2f3a81c9fd5d4f1622ab810dd46f2c">isfinite</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ga9a2f3a81c9fd5d4f1622ab810dd46f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa39ec48dfbc1eb4db9280a9f861195" id="r_ga2aa39ec48dfbc1eb4db9280a9f861195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2aa39ec48dfbc1eb4db9280a9f861195">isfinite</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ga2aa39ec48dfbc1eb4db9280a9f861195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4929f99b9e3887a3b3e6d79a8bc8b90" id="r_gad4929f99b9e3887a3b3e6d79a8bc8b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad4929f99b9e3887a3b3e6d79a8bc8b90">isinf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gad4929f99b9e3887a3b3e6d79a8bc8b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a positive or negative infinity.  <br /></td></tr>
<tr class="separator:gad4929f99b9e3887a3b3e6d79a8bc8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d34fa46237c6eaba8d1ae5d60fc1db" id="r_ga38d34fa46237c6eaba8d1ae5d60fc1db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga38d34fa46237c6eaba8d1ae5d60fc1db">isinf</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ga38d34fa46237c6eaba8d1ae5d60fc1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9066363a2f58c8ae28f552ced26dc75" id="r_gae9066363a2f58c8ae28f552ced26dc75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae9066363a2f58c8ae28f552ced26dc75">isinf</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:gae9066363a2f58c8ae28f552ced26dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1a8761a20e5e1776772fe35f2d955e" id="r_gace1a8761a20e5e1776772fe35f2d955e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:gace1a8761a20e5e1776772fe35f2d955e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gace1a8761a20e5e1776772fe35f2d955e">isinf</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:gace1a8761a20e5e1776772fe35f2d955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4931c1f16663033473fa99a430d07d9b" id="r_ga4931c1f16663033473fa99a430d07d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4931c1f16663033473fa99a430d07d9b">isnan</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga4931c1f16663033473fa99a430d07d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <br /></td></tr>
<tr class="separator:ga4931c1f16663033473fa99a430d07d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga018b25daf513092eb1a12dae74bd71e5" id="r_ga018b25daf513092eb1a12dae74bd71e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga018b25daf513092eb1a12dae74bd71e5">isnan</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ga018b25daf513092eb1a12dae74bd71e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac42ed915a942af2b65228826aae92e77" id="r_gac42ed915a942af2b65228826aae92e77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac42ed915a942af2b65228826aae92e77">isnan</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:gac42ed915a942af2b65228826aae92e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ebce8e7c8c14a50e69039ecedf0316" id="r_gaa5ebce8e7c8c14a50e69039ecedf0316"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:gaa5ebce8e7c8c14a50e69039ecedf0316"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa5ebce8e7c8c14a50e69039ecedf0316">isnan</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gaa5ebce8e7c8c14a50e69039ecedf0316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <br /></td></tr>
<tr class="separator:gaa5ebce8e7c8c14a50e69039ecedf0316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc29d72e030e4aed81ae36516bdd74b" id="r_ga7dc29d72e030e4aed81ae36516bdd74b"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:ga7dc29d72e030e4aed81ae36516bdd74b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7dc29d72e030e4aed81ae36516bdd74b">lerp</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> a, <a class="el" href="structetl_1_1static__vector.html">Float</a> b, <a class="el" href="structetl_1_1static__vector.html">Float</a> <a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Float</a></td></tr>
<tr class="memdesc:ga7dc29d72e030e4aed81ae36516bdd74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a+t(ba), i.e. the linear interpolation between a and b for the parameter t (or extrapolation, when t is outside the range [0,1]).  <br /></td></tr>
<tr class="separator:ga7dc29d72e030e4aed81ae36516bdd74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952ade8c6a107ccbc790414ad7e3a08b" id="r_ga952ade8c6a107ccbc790414ad7e3a08b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga952ade8c6a107ccbc790414ad7e3a08b">lgamma</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga952ade8c6a107ccbc790414ad7e3a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga952ade8c6a107ccbc790414ad7e3a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab423384d8c3b8ae5e4d2b8803c0a9926" id="r_gab423384d8c3b8ae5e4d2b8803c0a9926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab423384d8c3b8ae5e4d2b8803c0a9926">lgammaf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gab423384d8c3b8ae5e4d2b8803c0a9926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:gab423384d8c3b8ae5e4d2b8803c0a9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574f3e25d6dacc63b25e035a984caab4" id="r_ga574f3e25d6dacc63b25e035a984caab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga574f3e25d6dacc63b25e035a984caab4">lgamma</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga574f3e25d6dacc63b25e035a984caab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga574f3e25d6dacc63b25e035a984caab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01350c85781f91749ef0c3a61f7f3174" id="r_ga01350c85781f91749ef0c3a61f7f3174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga01350c85781f91749ef0c3a61f7f3174">lgamma</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga01350c85781f91749ef0c3a61f7f3174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga01350c85781f91749ef0c3a61f7f3174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd20233a764728c1b58bdd991dd8798a" id="r_gadd20233a764728c1b58bdd991dd8798a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadd20233a764728c1b58bdd991dd8798a">lgammal</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gadd20233a764728c1b58bdd991dd8798a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:gadd20233a764728c1b58bdd991dd8798a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764e7260866a5c3c61a9a51b61844b37" id="r_ga764e7260866a5c3c61a9a51b61844b37"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga764e7260866a5c3c61a9a51b61844b37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga764e7260866a5c3c61a9a51b61844b37">lgamma</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga764e7260866a5c3c61a9a51b61844b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga764e7260866a5c3c61a9a51b61844b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a75b64172bc4772ae32459754e63768" id="r_ga5a75b64172bc4772ae32459754e63768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5a75b64172bc4772ae32459754e63768">log</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga5a75b64172bc4772ae32459754e63768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga5a75b64172bc4772ae32459754e63768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14541b9824cd6820be94879878d29173" id="r_ga14541b9824cd6820be94879878d29173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga14541b9824cd6820be94879878d29173">logf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga14541b9824cd6820be94879878d29173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga14541b9824cd6820be94879878d29173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661e29b318888c5dab142306385daa27" id="r_ga661e29b318888c5dab142306385daa27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga661e29b318888c5dab142306385daa27">log</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga661e29b318888c5dab142306385daa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga661e29b318888c5dab142306385daa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758b1f8836537fd120e6a43ec143657e" id="r_ga758b1f8836537fd120e6a43ec143657e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga758b1f8836537fd120e6a43ec143657e">log</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga758b1f8836537fd120e6a43ec143657e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga758b1f8836537fd120e6a43ec143657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef3d6de6a38a1374a9f3e48a11873f2" id="r_gaeef3d6de6a38a1374a9f3e48a11873f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaeef3d6de6a38a1374a9f3e48a11873f2">logl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaeef3d6de6a38a1374a9f3e48a11873f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:gaeef3d6de6a38a1374a9f3e48a11873f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25718ca82a1524bf2f28154e87c3bbd2" id="r_ga25718ca82a1524bf2f28154e87c3bbd2"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga25718ca82a1524bf2f28154e87c3bbd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga25718ca82a1524bf2f28154e87c3bbd2">log</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga25718ca82a1524bf2f28154e87c3bbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga25718ca82a1524bf2f28154e87c3bbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e121a21d96d862846a8dd6a7d146fa8" id="r_ga7e121a21d96d862846a8dd6a7d146fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7e121a21d96d862846a8dd6a7d146fa8">log10</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga7e121a21d96d862846a8dd6a7d146fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga7e121a21d96d862846a8dd6a7d146fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b17bede4f9e5906deb56ec4f845c41" id="r_ga60b17bede4f9e5906deb56ec4f845c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga60b17bede4f9e5906deb56ec4f845c41">log10f</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga60b17bede4f9e5906deb56ec4f845c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga60b17bede4f9e5906deb56ec4f845c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad84527d44be6141bc0351fbf847e51" id="r_ga4ad84527d44be6141bc0351fbf847e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4ad84527d44be6141bc0351fbf847e51">log10</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga4ad84527d44be6141bc0351fbf847e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga4ad84527d44be6141bc0351fbf847e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa865ca3dcb2351e2a3fb02c7b8171b9b" id="r_gaa865ca3dcb2351e2a3fb02c7b8171b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa865ca3dcb2351e2a3fb02c7b8171b9b">log10</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaa865ca3dcb2351e2a3fb02c7b8171b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:gaa865ca3dcb2351e2a3fb02c7b8171b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7186dd4004ef53b28e2872d0e5f30ac6" id="r_ga7186dd4004ef53b28e2872d0e5f30ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7186dd4004ef53b28e2872d0e5f30ac6">log10l</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga7186dd4004ef53b28e2872d0e5f30ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga7186dd4004ef53b28e2872d0e5f30ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga055baa67112222894bfbc096ddeec343" id="r_ga055baa67112222894bfbc096ddeec343"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga055baa67112222894bfbc096ddeec343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga055baa67112222894bfbc096ddeec343">log10</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga055baa67112222894bfbc096ddeec343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga055baa67112222894bfbc096ddeec343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0dc2a04f24b015efbc1d749d8af4c0e" id="r_gae0dc2a04f24b015efbc1d749d8af4c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae0dc2a04f24b015efbc1d749d8af4c0e">log1p</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gae0dc2a04f24b015efbc1d749d8af4c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="group__cmath.html#ga5a75b64172bc4772ae32459754e63768" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:gae0dc2a04f24b015efbc1d749d8af4c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ceec6b47194b6218670a6a38324516b" id="r_ga0ceec6b47194b6218670a6a38324516b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0ceec6b47194b6218670a6a38324516b">log1pf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga0ceec6b47194b6218670a6a38324516b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="group__cmath.html#ga5a75b64172bc4772ae32459754e63768" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:ga0ceec6b47194b6218670a6a38324516b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12f8274c143cf8a3143eb4d918ae3b2" id="r_gad12f8274c143cf8a3143eb4d918ae3b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad12f8274c143cf8a3143eb4d918ae3b2">log1p</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad12f8274c143cf8a3143eb4d918ae3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="group__cmath.html#ga5a75b64172bc4772ae32459754e63768" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:gad12f8274c143cf8a3143eb4d918ae3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07475d41b22316960815b3d50f148156" id="r_ga07475d41b22316960815b3d50f148156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga07475d41b22316960815b3d50f148156">log1p</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga07475d41b22316960815b3d50f148156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="group__cmath.html#ga5a75b64172bc4772ae32459754e63768" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:ga07475d41b22316960815b3d50f148156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac82247b08fd64f14d6120ddb97dd44f7" id="r_gac82247b08fd64f14d6120ddb97dd44f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac82247b08fd64f14d6120ddb97dd44f7">log1pl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gac82247b08fd64f14d6120ddb97dd44f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="group__cmath.html#ga5a75b64172bc4772ae32459754e63768" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:gac82247b08fd64f14d6120ddb97dd44f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa368190d0e6d7651af656e2d90b90bf3" id="r_gaa368190d0e6d7651af656e2d90b90bf3"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gaa368190d0e6d7651af656e2d90b90bf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa368190d0e6d7651af656e2d90b90bf3">log1p</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaa368190d0e6d7651af656e2d90b90bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="group__cmath.html#ga5a75b64172bc4772ae32459754e63768" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:gaa368190d0e6d7651af656e2d90b90bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7fb3e6d3600c8a676f922cad1c6c4d4" id="r_gae7fb3e6d3600c8a676f922cad1c6c4d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae7fb3e6d3600c8a676f922cad1c6c4d4">log2</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gae7fb3e6d3600c8a676f922cad1c6c4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:gae7fb3e6d3600c8a676f922cad1c6c4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071ff2ff89eeb3ac71fc6bb2891fc055" id="r_ga071ff2ff89eeb3ac71fc6bb2891fc055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga071ff2ff89eeb3ac71fc6bb2891fc055">log2f</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga071ff2ff89eeb3ac71fc6bb2891fc055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga071ff2ff89eeb3ac71fc6bb2891fc055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a9b906b733b6b964285c7216d83e49c" id="r_ga8a9b906b733b6b964285c7216d83e49c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8a9b906b733b6b964285c7216d83e49c">log2</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8a9b906b733b6b964285c7216d83e49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga8a9b906b733b6b964285c7216d83e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffebb5db1927e7b7b51c98433c4d6517" id="r_gaffebb5db1927e7b7b51c98433c4d6517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaffebb5db1927e7b7b51c98433c4d6517">log2</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaffebb5db1927e7b7b51c98433c4d6517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:gaffebb5db1927e7b7b51c98433c4d6517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8abc9673ac68a415596cbc534fc307c" id="r_gad8abc9673ac68a415596cbc534fc307c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad8abc9673ac68a415596cbc534fc307c">log2l</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad8abc9673ac68a415596cbc534fc307c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:gad8abc9673ac68a415596cbc534fc307c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06eb20ebfee69d9f55ab468b9cc420c7" id="r_ga06eb20ebfee69d9f55ab468b9cc420c7"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga06eb20ebfee69d9f55ab468b9cc420c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga06eb20ebfee69d9f55ab468b9cc420c7">log2</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga06eb20ebfee69d9f55ab468b9cc420c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:ga06eb20ebfee69d9f55ab468b9cc420c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efdcfc19324e3e04f9368cece16244f" id="r_ga9efdcfc19324e3e04f9368cece16244f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9efdcfc19324e3e04f9368cece16244f">lrint</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga9efdcfc19324e3e04f9368cece16244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga9efdcfc19324e3e04f9368cece16244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca941408e9c364428b2587af9bca033" id="r_ga4ca941408e9c364428b2587af9bca033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4ca941408e9c364428b2587af9bca033">lrintf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga4ca941408e9c364428b2587af9bca033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga4ca941408e9c364428b2587af9bca033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541a33c411499961bd3e08733707140f" id="r_ga541a33c411499961bd3e08733707140f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga541a33c411499961bd3e08733707140f">lrint</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga541a33c411499961bd3e08733707140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga541a33c411499961bd3e08733707140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f44d4156ec3e888fbcbdc58e2d1d9eb" id="r_ga5f44d4156ec3e888fbcbdc58e2d1d9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5f44d4156ec3e888fbcbdc58e2d1d9eb">lrint</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga5f44d4156ec3e888fbcbdc58e2d1d9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga5f44d4156ec3e888fbcbdc58e2d1d9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14c44304eebfdfc43c7bb881bfb7cf4" id="r_gaa14c44304eebfdfc43c7bb881bfb7cf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa14c44304eebfdfc43c7bb881bfb7cf4">lrintl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:gaa14c44304eebfdfc43c7bb881bfb7cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:gaa14c44304eebfdfc43c7bb881bfb7cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9466128546cf8b58e9221df02f82b56d" id="r_ga9466128546cf8b58e9221df02f82b56d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga9466128546cf8b58e9221df02f82b56d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9466128546cf8b58e9221df02f82b56d">lrint</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga9466128546cf8b58e9221df02f82b56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga9466128546cf8b58e9221df02f82b56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e2f14842eae5461374d32134da63da" id="r_ga85e2f14842eae5461374d32134da63da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga85e2f14842eae5461374d32134da63da">llrint</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga85e2f14842eae5461374d32134da63da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga85e2f14842eae5461374d32134da63da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga116fe6cace461371abbfd41ccf54e291" id="r_ga116fe6cace461371abbfd41ccf54e291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga116fe6cace461371abbfd41ccf54e291">llrintf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga116fe6cace461371abbfd41ccf54e291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga116fe6cace461371abbfd41ccf54e291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga180c24891e630b3f18c0b4b9cb061029" id="r_ga180c24891e630b3f18c0b4b9cb061029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga180c24891e630b3f18c0b4b9cb061029">llrint</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga180c24891e630b3f18c0b4b9cb061029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga180c24891e630b3f18c0b4b9cb061029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b59bd85c99252163730280e1121450" id="r_gae3b59bd85c99252163730280e1121450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae3b59bd85c99252163730280e1121450">llrint</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:gae3b59bd85c99252163730280e1121450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:gae3b59bd85c99252163730280e1121450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d8b7c2252d2757e38b9896cf9be1ff" id="r_ga49d8b7c2252d2757e38b9896cf9be1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga49d8b7c2252d2757e38b9896cf9be1ff">llrintl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga49d8b7c2252d2757e38b9896cf9be1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga49d8b7c2252d2757e38b9896cf9be1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97392fcf514d03d3134a3baf48272937" id="r_ga97392fcf514d03d3134a3baf48272937"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga97392fcf514d03d3134a3baf48272937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga97392fcf514d03d3134a3baf48272937">llrint</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ga97392fcf514d03d3134a3baf48272937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga97392fcf514d03d3134a3baf48272937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b23f23746d65434dd57cbf03dde471" id="r_ga92b23f23746d65434dd57cbf03dde471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga92b23f23746d65434dd57cbf03dde471">nanf</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga92b23f23746d65434dd57cbf03dde471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <br /></td></tr>
<tr class="separator:ga92b23f23746d65434dd57cbf03dde471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b0eae0f0faa4e81c4fdbb7ecb99f64" id="r_ga08b0eae0f0faa4e81c4fdbb7ecb99f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga08b0eae0f0faa4e81c4fdbb7ecb99f64">nan</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga08b0eae0f0faa4e81c4fdbb7ecb99f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <br /></td></tr>
<tr class="separator:ga08b0eae0f0faa4e81c4fdbb7ecb99f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ef6ce5627884455b58fbf76bd8c8ea" id="r_gab2ef6ce5627884455b58fbf76bd8c8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab2ef6ce5627884455b58fbf76bd8c8ea">nanl</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gab2ef6ce5627884455b58fbf76bd8c8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <br /></td></tr>
<tr class="separator:gab2ef6ce5627884455b58fbf76bd8c8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3ff973e51c840722b01eca0e1af274" id="r_gaaa3ff973e51c840722b01eca0e1af274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaaa3ff973e51c840722b01eca0e1af274">nextafter</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">from</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaaa3ff973e51c840722b01eca0e1af274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <br /></td></tr>
<tr class="separator:gaaa3ff973e51c840722b01eca0e1af274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dcbc27b4908c97a6afd89f89b9cd525" id="r_ga3dcbc27b4908c97a6afd89f89b9cd525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3dcbc27b4908c97a6afd89f89b9cd525">nextafterf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">from</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga3dcbc27b4908c97a6afd89f89b9cd525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <br /></td></tr>
<tr class="separator:ga3dcbc27b4908c97a6afd89f89b9cd525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3520d2487f82a9efbef4e6df25e28905" id="r_ga3520d2487f82a9efbef4e6df25e28905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3520d2487f82a9efbef4e6df25e28905">nextafter</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">from</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga3520d2487f82a9efbef4e6df25e28905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <br /></td></tr>
<tr class="separator:ga3520d2487f82a9efbef4e6df25e28905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ccd55507890350381ab591f83ec80e" id="r_ga65ccd55507890350381ab591f83ec80e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga65ccd55507890350381ab591f83ec80e">pow</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> base, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__cmath.html#ga6f9635830aa0cf956dc1924dbd841ad8">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga65ccd55507890350381ab591f83ec80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga65ccd55507890350381ab591f83ec80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad55d0cf247d8674fe1c6116b3328cc21" id="r_gad55d0cf247d8674fe1c6116b3328cc21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad55d0cf247d8674fe1c6116b3328cc21">powf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> base, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__cmath.html#ga6f9635830aa0cf956dc1924dbd841ad8">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gad55d0cf247d8674fe1c6116b3328cc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:gad55d0cf247d8674fe1c6116b3328cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4988f2e075719ba3d210798d7a4c41" id="r_ga6f4988f2e075719ba3d210798d7a4c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6f4988f2e075719ba3d210798d7a4c41">pow</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__cmath.html#ga6f9635830aa0cf956dc1924dbd841ad8">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga6f4988f2e075719ba3d210798d7a4c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga6f4988f2e075719ba3d210798d7a4c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0e589686d56d5bdf6af9a6cdc8cce8" id="r_ga3e0e589686d56d5bdf6af9a6cdc8cce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3e0e589686d56d5bdf6af9a6cdc8cce8">pow</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__cmath.html#ga6f9635830aa0cf956dc1924dbd841ad8">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga3e0e589686d56d5bdf6af9a6cdc8cce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga3e0e589686d56d5bdf6af9a6cdc8cce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2faf58ce4c1c2fd993748a69cecd13c5" id="r_ga2faf58ce4c1c2fd993748a69cecd13c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2faf58ce4c1c2fd993748a69cecd13c5">powl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__cmath.html#ga6f9635830aa0cf956dc1924dbd841ad8">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga2faf58ce4c1c2fd993748a69cecd13c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga2faf58ce4c1c2fd993748a69cecd13c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32cff7420fed14a1ae8a7b15a2ee3ffe" id="r_ga32cff7420fed14a1ae8a7b15a2ee3ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga32cff7420fed14a1ae8a7b15a2ee3ffe">pow</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> base, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga32cff7420fed14a1ae8a7b15a2ee3ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga32cff7420fed14a1ae8a7b15a2ee3ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbf71111fe08fe36439f7f8ff386071" id="r_ga5bbf71111fe08fe36439f7f8ff386071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5bbf71111fe08fe36439f7f8ff386071">pow</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga5bbf71111fe08fe36439f7f8ff386071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga5bbf71111fe08fe36439f7f8ff386071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga186fa5b37164f5f923f9dcc5fad2b831" id="r_ga186fa5b37164f5f923f9dcc5fad2b831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga186fa5b37164f5f923f9dcc5fad2b831">pow</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga186fa5b37164f5f923f9dcc5fad2b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga186fa5b37164f5f923f9dcc5fad2b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d0ba97813a6d3794162cdc11f39c75" id="r_gaf2d0ba97813a6d3794162cdc11f39c75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf2d0ba97813a6d3794162cdc11f39c75">remainder</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaf2d0ba97813a6d3794162cdc11f39c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:gaf2d0ba97813a6d3794162cdc11f39c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d49f0cdedd4430d83b237bc96cba962" id="r_ga1d49f0cdedd4430d83b237bc96cba962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1d49f0cdedd4430d83b237bc96cba962">remainderf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga1d49f0cdedd4430d83b237bc96cba962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:ga1d49f0cdedd4430d83b237bc96cba962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e922528ea738cb036a8c917caf0414f" id="r_ga5e922528ea738cb036a8c917caf0414f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5e922528ea738cb036a8c917caf0414f">remainder</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga5e922528ea738cb036a8c917caf0414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:ga5e922528ea738cb036a8c917caf0414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae696b6d50fefabd62921ce139258065e" id="r_gae696b6d50fefabd62921ce139258065e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae696b6d50fefabd62921ce139258065e">remainder</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gae696b6d50fefabd62921ce139258065e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:gae696b6d50fefabd62921ce139258065e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bcb0b3d00f14721c9789ac0aed6e26" id="r_ga35bcb0b3d00f14721c9789ac0aed6e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga35bcb0b3d00f14721c9789ac0aed6e26">remainderl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga35bcb0b3d00f14721c9789ac0aed6e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:ga35bcb0b3d00f14721c9789ac0aed6e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b82891bedb870579150afb24c75018" id="r_ga47b82891bedb870579150afb24c75018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga47b82891bedb870579150afb24c75018">rint</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga47b82891bedb870579150afb24c75018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga47b82891bedb870579150afb24c75018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b16975e01d95a7658e320c27e80715" id="r_gab3b16975e01d95a7658e320c27e80715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab3b16975e01d95a7658e320c27e80715">rintf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gab3b16975e01d95a7658e320c27e80715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:gab3b16975e01d95a7658e320c27e80715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72dc5cf6f75e993b6f14aa70b8fbabb" id="r_gab72dc5cf6f75e993b6f14aa70b8fbabb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab72dc5cf6f75e993b6f14aa70b8fbabb">rint</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gab72dc5cf6f75e993b6f14aa70b8fbabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:gab72dc5cf6f75e993b6f14aa70b8fbabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cb9a1a27b90a9caf7b8f8ca19a377e" id="r_ga28cb9a1a27b90a9caf7b8f8ca19a377e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga28cb9a1a27b90a9caf7b8f8ca19a377e">rint</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga28cb9a1a27b90a9caf7b8f8ca19a377e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga28cb9a1a27b90a9caf7b8f8ca19a377e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04364ca7c76677ba6ca7448f9a3b00bc" id="r_ga04364ca7c76677ba6ca7448f9a3b00bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga04364ca7c76677ba6ca7448f9a3b00bc">rintl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga04364ca7c76677ba6ca7448f9a3b00bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga04364ca7c76677ba6ca7448f9a3b00bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3273c48edc44f821db7773c25c2abf5d" id="r_ga3273c48edc44f821db7773c25c2abf5d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga3273c48edc44f821db7773c25c2abf5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3273c48edc44f821db7773c25c2abf5d">rint</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga3273c48edc44f821db7773c25c2abf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga3273c48edc44f821db7773c25c2abf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ece6b0eeb98b1650638dbbbb09cda23" id="r_ga8ece6b0eeb98b1650638dbbbb09cda23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8ece6b0eeb98b1650638dbbbb09cda23">round</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga8ece6b0eeb98b1650638dbbbb09cda23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:ga8ece6b0eeb98b1650638dbbbb09cda23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f67bbe153f9daa0cbd56587131bfd3" id="r_ga25f67bbe153f9daa0cbd56587131bfd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga25f67bbe153f9daa0cbd56587131bfd3">roundf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga25f67bbe153f9daa0cbd56587131bfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:ga25f67bbe153f9daa0cbd56587131bfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20c80803dd9917b164ebef227db3ed1" id="r_gad20c80803dd9917b164ebef227db3ed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad20c80803dd9917b164ebef227db3ed1">round</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad20c80803dd9917b164ebef227db3ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:gad20c80803dd9917b164ebef227db3ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc8394cdaabbc0790662af74f6574a3" id="r_ga3cc8394cdaabbc0790662af74f6574a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3cc8394cdaabbc0790662af74f6574a3">round</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga3cc8394cdaabbc0790662af74f6574a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:ga3cc8394cdaabbc0790662af74f6574a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94747d1de39c6586935e11628963eee" id="r_gae94747d1de39c6586935e11628963eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae94747d1de39c6586935e11628963eee">roundl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gae94747d1de39c6586935e11628963eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:gae94747d1de39c6586935e11628963eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ecfb26da0d8c15ff0f23281b6d4fa5" id="r_ga35ecfb26da0d8c15ff0f23281b6d4fa5"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga35ecfb26da0d8c15ff0f23281b6d4fa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga35ecfb26da0d8c15ff0f23281b6d4fa5">round</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga35ecfb26da0d8c15ff0f23281b6d4fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:ga35ecfb26da0d8c15ff0f23281b6d4fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7506d6f1c9f1562f76ddf3085ab653ad" id="r_ga7506d6f1c9f1562f76ddf3085ab653ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7506d6f1c9f1562f76ddf3085ab653ad">signbit</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga7506d6f1c9f1562f76ddf3085ab653ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:ga7506d6f1c9f1562f76ddf3085ab653ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab158f9b28e09533819c5781922c6cdfd" id="r_gab158f9b28e09533819c5781922c6cdfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab158f9b28e09533819c5781922c6cdfd">signbit</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gab158f9b28e09533819c5781922c6cdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:gab158f9b28e09533819c5781922c6cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ca6b6c05a7686713a1efaeeb4ae60d" id="r_ga35ca6b6c05a7686713a1efaeeb4ae60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga35ca6b6c05a7686713a1efaeeb4ae60d">signbit</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga35ca6b6c05a7686713a1efaeeb4ae60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:ga35ca6b6c05a7686713a1efaeeb4ae60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee827ed61119db05b66ea42c6ca5742" id="r_gabee827ed61119db05b66ea42c6ca5742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gabee827ed61119db05b66ea42c6ca5742">sin</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gabee827ed61119db05b66ea42c6ca5742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:gabee827ed61119db05b66ea42c6ca5742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363575e96defcb73babe3378b250ab96" id="r_ga363575e96defcb73babe3378b250ab96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga363575e96defcb73babe3378b250ab96">sinf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga363575e96defcb73babe3378b250ab96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:ga363575e96defcb73babe3378b250ab96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e696ed3092e5a62045e99a5c5598e2" id="r_ga96e696ed3092e5a62045e99a5c5598e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga96e696ed3092e5a62045e99a5c5598e2">sin</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga96e696ed3092e5a62045e99a5c5598e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:ga96e696ed3092e5a62045e99a5c5598e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649075fa9acf717a873c7203929242a9" id="r_ga649075fa9acf717a873c7203929242a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga649075fa9acf717a873c7203929242a9">sin</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga649075fa9acf717a873c7203929242a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:ga649075fa9acf717a873c7203929242a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81ee0f470ef3824f040878a2ad1b165c" id="r_ga81ee0f470ef3824f040878a2ad1b165c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga81ee0f470ef3824f040878a2ad1b165c">sinl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga81ee0f470ef3824f040878a2ad1b165c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:ga81ee0f470ef3824f040878a2ad1b165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07583e54247b8e2fab3fad9d5d25873e" id="r_ga07583e54247b8e2fab3fad9d5d25873e"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga07583e54247b8e2fab3fad9d5d25873e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga07583e54247b8e2fab3fad9d5d25873e">sin</a> (T num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga07583e54247b8e2fab3fad9d5d25873e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:ga07583e54247b8e2fab3fad9d5d25873e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06830c89453f38692a070341789c5ada" id="r_ga06830c89453f38692a070341789c5ada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga06830c89453f38692a070341789c5ada">sinh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga06830c89453f38692a070341789c5ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga06830c89453f38692a070341789c5ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc0c8e397bc6f72a71a493da9d0feb65" id="r_gafc0c8e397bc6f72a71a493da9d0feb65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gafc0c8e397bc6f72a71a493da9d0feb65">sinhf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gafc0c8e397bc6f72a71a493da9d0feb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gafc0c8e397bc6f72a71a493da9d0feb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd130d9da0b245419fceb59d99c8f26" id="r_ga1cd130d9da0b245419fceb59d99c8f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1cd130d9da0b245419fceb59d99c8f26">sinh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga1cd130d9da0b245419fceb59d99c8f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga1cd130d9da0b245419fceb59d99c8f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb541096f27e868926f6b4ac9c66648" id="r_ga8cb541096f27e868926f6b4ac9c66648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8cb541096f27e868926f6b4ac9c66648">sinh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8cb541096f27e868926f6b4ac9c66648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga8cb541096f27e868926f6b4ac9c66648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbfe20cf12f097d721ff918c18fe523a" id="r_gacbfe20cf12f097d721ff918c18fe523a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gacbfe20cf12f097d721ff918c18fe523a">sinhl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gacbfe20cf12f097d721ff918c18fe523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gacbfe20cf12f097d721ff918c18fe523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956f17ccc22563322921dfc13a006050" id="r_ga956f17ccc22563322921dfc13a006050"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga956f17ccc22563322921dfc13a006050"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga956f17ccc22563322921dfc13a006050">sinh</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga956f17ccc22563322921dfc13a006050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga956f17ccc22563322921dfc13a006050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee507c8cfe43c8b4db84786a500b0e2a" id="r_gaee507c8cfe43c8b4db84786a500b0e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaee507c8cfe43c8b4db84786a500b0e2a">sqrt</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaee507c8cfe43c8b4db84786a500b0e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:gaee507c8cfe43c8b4db84786a500b0e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa15ac1ee624011bf5f4358d2e133ad17" id="r_gaa15ac1ee624011bf5f4358d2e133ad17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa15ac1ee624011bf5f4358d2e133ad17">sqrtf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaa15ac1ee624011bf5f4358d2e133ad17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:gaa15ac1ee624011bf5f4358d2e133ad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ace0191001caa6f64e0a19166a147ae" id="r_ga7ace0191001caa6f64e0a19166a147ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7ace0191001caa6f64e0a19166a147ae">sqrt</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga7ace0191001caa6f64e0a19166a147ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:ga7ace0191001caa6f64e0a19166a147ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31cc59fdcd0b0e6fe47e105bcfe3f6f9" id="r_ga31cc59fdcd0b0e6fe47e105bcfe3f6f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga31cc59fdcd0b0e6fe47e105bcfe3f6f9">sqrt</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga31cc59fdcd0b0e6fe47e105bcfe3f6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:ga31cc59fdcd0b0e6fe47e105bcfe3f6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d1792d7684e697e99dbab7160e9c48" id="r_ga06d1792d7684e697e99dbab7160e9c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga06d1792d7684e697e99dbab7160e9c48">sqrtl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga06d1792d7684e697e99dbab7160e9c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:ga06d1792d7684e697e99dbab7160e9c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70eeceedd0d7ba7d7ac10b7399b6d2c2" id="r_ga70eeceedd0d7ba7d7ac10b7399b6d2c2"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga70eeceedd0d7ba7d7ac10b7399b6d2c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga70eeceedd0d7ba7d7ac10b7399b6d2c2">sqrt</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga70eeceedd0d7ba7d7ac10b7399b6d2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:ga70eeceedd0d7ba7d7ac10b7399b6d2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e419bd6dfddb5077876e81fe4c9478e" id="r_ga9e419bd6dfddb5077876e81fe4c9478e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9e419bd6dfddb5077876e81fe4c9478e">tan</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga9e419bd6dfddb5077876e81fe4c9478e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga9e419bd6dfddb5077876e81fe4c9478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95d5f88be021c2e5604f3c73a346c178" id="r_ga95d5f88be021c2e5604f3c73a346c178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga95d5f88be021c2e5604f3c73a346c178">tanf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga95d5f88be021c2e5604f3c73a346c178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga95d5f88be021c2e5604f3c73a346c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22851c99b004fa4b43659e41aa5b4a8" id="r_gab22851c99b004fa4b43659e41aa5b4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab22851c99b004fa4b43659e41aa5b4a8">tan</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gab22851c99b004fa4b43659e41aa5b4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gab22851c99b004fa4b43659e41aa5b4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a5e0584fe383ae26dc342fd870bb1b" id="r_gaa3a5e0584fe383ae26dc342fd870bb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa3a5e0584fe383ae26dc342fd870bb1b">tan</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaa3a5e0584fe383ae26dc342fd870bb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gaa3a5e0584fe383ae26dc342fd870bb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7981b2761ed309a12d574ea7b42543" id="r_gaae7981b2761ed309a12d574ea7b42543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaae7981b2761ed309a12d574ea7b42543">tanl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaae7981b2761ed309a12d574ea7b42543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gaae7981b2761ed309a12d574ea7b42543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b5743476d2e8e3322e089b7a018dfc" id="r_gaa4b5743476d2e8e3322e089b7a018dfc"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gaa4b5743476d2e8e3322e089b7a018dfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa4b5743476d2e8e3322e089b7a018dfc">tan</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaa4b5743476d2e8e3322e089b7a018dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gaa4b5743476d2e8e3322e089b7a018dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf343cf1730a0ed0b40fa6c929b0dab" id="r_ga4bf343cf1730a0ed0b40fa6c929b0dab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4bf343cf1730a0ed0b40fa6c929b0dab">tanh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga4bf343cf1730a0ed0b40fa6c929b0dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga4bf343cf1730a0ed0b40fa6c929b0dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d46e807418d26c2a7759cbfab02b72a" id="r_ga6d46e807418d26c2a7759cbfab02b72a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6d46e807418d26c2a7759cbfab02b72a">tanhf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga6d46e807418d26c2a7759cbfab02b72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga6d46e807418d26c2a7759cbfab02b72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga790f3ebf241e522dbb8f9ddb5ecf8301" id="r_ga790f3ebf241e522dbb8f9ddb5ecf8301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga790f3ebf241e522dbb8f9ddb5ecf8301">tanh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga790f3ebf241e522dbb8f9ddb5ecf8301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga790f3ebf241e522dbb8f9ddb5ecf8301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32d2e0422188b651005ac234beb54d2" id="r_gab32d2e0422188b651005ac234beb54d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab32d2e0422188b651005ac234beb54d2">tanh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gab32d2e0422188b651005ac234beb54d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:gab32d2e0422188b651005ac234beb54d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae21f7a8c9356084f0ae2632962da532" id="r_gaae21f7a8c9356084f0ae2632962da532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaae21f7a8c9356084f0ae2632962da532">tanhl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaae21f7a8c9356084f0ae2632962da532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:gaae21f7a8c9356084f0ae2632962da532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc0fc24a0abef90f6d6016de00ab847" id="r_ga5fc0fc24a0abef90f6d6016de00ab847"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga5fc0fc24a0abef90f6d6016de00ab847"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5fc0fc24a0abef90f6d6016de00ab847">tanh</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga5fc0fc24a0abef90f6d6016de00ab847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga5fc0fc24a0abef90f6d6016de00ab847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075d32d3b4294027e82274f2d892df7c" id="r_ga075d32d3b4294027e82274f2d892df7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga075d32d3b4294027e82274f2d892df7c">tgamma</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga075d32d3b4294027e82274f2d892df7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga075d32d3b4294027e82274f2d892df7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67cc458d480c315807346ae741e909d9" id="r_ga67cc458d480c315807346ae741e909d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga67cc458d480c315807346ae741e909d9">tgammaf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga67cc458d480c315807346ae741e909d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga67cc458d480c315807346ae741e909d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c78080019a4d11ff8f688d6aaf59dd" id="r_ga82c78080019a4d11ff8f688d6aaf59dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga82c78080019a4d11ff8f688d6aaf59dd">tgamma</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga82c78080019a4d11ff8f688d6aaf59dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga82c78080019a4d11ff8f688d6aaf59dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b4a8a777f41c9b6b469ad70d25c031" id="r_ga43b4a8a777f41c9b6b469ad70d25c031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga43b4a8a777f41c9b6b469ad70d25c031">tgamma</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga43b4a8a777f41c9b6b469ad70d25c031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga43b4a8a777f41c9b6b469ad70d25c031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeedb170320e69f563ba810bcbee6b2e0" id="r_gaeedb170320e69f563ba810bcbee6b2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaeedb170320e69f563ba810bcbee6b2e0">tgammal</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaeedb170320e69f563ba810bcbee6b2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:gaeedb170320e69f563ba810bcbee6b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed286a17417c4ce8132a2b80ac63881b" id="r_gaed286a17417c4ce8132a2b80ac63881b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gaed286a17417c4ce8132a2b80ac63881b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaed286a17417c4ce8132a2b80ac63881b">tgamma</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaed286a17417c4ce8132a2b80ac63881b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:gaed286a17417c4ce8132a2b80ac63881b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e537c9ad8ab972ba8d71f3b19b45d52" id="r_ga6e537c9ad8ab972ba8d71f3b19b45d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6e537c9ad8ab972ba8d71f3b19b45d52">trunc</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga6e537c9ad8ab972ba8d71f3b19b45d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:ga6e537c9ad8ab972ba8d71f3b19b45d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a5c20de653a2cb02c7a45828b64daf" id="r_gaa5a5c20de653a2cb02c7a45828b64daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa5a5c20de653a2cb02c7a45828b64daf">truncf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaa5a5c20de653a2cb02c7a45828b64daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:gaa5a5c20de653a2cb02c7a45828b64daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4305af59a0861ebd6f9c8e4d30309281" id="r_ga4305af59a0861ebd6f9c8e4d30309281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4305af59a0861ebd6f9c8e4d30309281">trunc</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga4305af59a0861ebd6f9c8e4d30309281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:ga4305af59a0861ebd6f9c8e4d30309281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29b9ba02b260d27b8a8c440a167afa6" id="r_gaf29b9ba02b260d27b8a8c440a167afa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf29b9ba02b260d27b8a8c440a167afa6">trunc</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaf29b9ba02b260d27b8a8c440a167afa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:gaf29b9ba02b260d27b8a8c440a167afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30781fa4c32627e7c6be2ab566a0b67" id="r_gaf30781fa4c32627e7c6be2ab566a0b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf30781fa4c32627e7c6be2ab566a0b67">truncl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaf30781fa4c32627e7c6be2ab566a0b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:gaf30781fa4c32627e7c6be2ab566a0b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b08310e6f9a4455d6515f1246542667" id="r_ga9b08310e6f9a4455d6515f1246542667"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga9b08310e6f9a4455d6515f1246542667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9b08310e6f9a4455d6515f1246542667">trunc</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga9b08310e6f9a4455d6515f1246542667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:ga9b08310e6f9a4455d6515f1246542667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982037f958b7b332615a47e0458470a4" id="r_a982037f958b7b332615a47e0458470a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a982037f958b7b332615a47e0458470a4">is_eq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a982037f958b7b332615a47e0458470a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af0c0f3f06fcc2acc7fb473b8060eab" id="r_a2af0c0f3f06fcc2acc7fb473b8060eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af0c0f3f06fcc2acc7fb473b8060eab">is_neq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a2af0c0f3f06fcc2acc7fb473b8060eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a85d1d883c6a4b7c74721dcfa9d3d" id="r_a266a85d1d883c6a4b7c74721dcfa9d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a266a85d1d883c6a4b7c74721dcfa9d3d">is_lt</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a266a85d1d883c6a4b7c74721dcfa9d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5180426dd93c0ed7faa85c5b9aaeca8" id="r_af5180426dd93c0ed7faa85c5b9aaeca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5180426dd93c0ed7faa85c5b9aaeca8">is_lteq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:af5180426dd93c0ed7faa85c5b9aaeca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aac3f063804059658718a8e9e19195" id="r_af9aac3f063804059658718a8e9e19195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9aac3f063804059658718a8e9e19195">is_gt</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:af9aac3f063804059658718a8e9e19195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511c9b1ac1fc84868ea3530a2b2fc111" id="r_a511c9b1ac1fc84868ea3530a2b2fc111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a511c9b1ac1fc84868ea3530a2b2fc111">is_gteq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a511c9b1ac1fc84868ea3530a2b2fc111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe732728abf637284509396f07e7e428" id="r_gabe732728abf637284509396f07e7e428"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gabe732728abf637284509396f07e7e428"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gabe732728abf637284509396f07e7e428">abs</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; T</td></tr>
<tr class="separator:gabe732728abf637284509396f07e7e428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c18e9f715e3983b7a71347ce6e0e2c1" id="r_ga0c18e9f715e3983b7a71347ce6e0e2c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga0c18e9f715e3983b7a71347ce6e0e2c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; T</td></tr>
<tr class="separator:ga0c18e9f715e3983b7a71347ce6e0e2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac21be8ae65aa553b7b584624a2aa3325" id="r_gac21be8ae65aa553b7b584624a2aa3325"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:gac21be8ae65aa553b7b584624a2aa3325"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac21be8ae65aa553b7b584624a2aa3325">arg</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> f) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; &gt;</td></tr>
<tr class="separator:gac21be8ae65aa553b7b584624a2aa3325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3702b79ef03a1b00289fb59cc09b9c0" id="r_gac3702b79ef03a1b00289fb59cc09b9c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:gac3702b79ef03a1b00289fb59cc09b9c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac3702b79ef03a1b00289fb59cc09b9c0">arg</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt; &gt;</td></tr>
<tr class="separator:gac3702b79ef03a1b00289fb59cc09b9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1ea907ad0e2faef6a9dc5daae77f10" id="r_a8f1ea907ad0e2faef6a9dc5daae77f10"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8f1ea907ad0e2faef6a9dc5daae77f10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f1ea907ad0e2faef6a9dc5daae77f10">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;val) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a8f1ea907ad0e2faef6a9dc5daae77f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8518792aba8f0c6bfdf3518364ab586c" id="r_a8518792aba8f0c6bfdf3518364ab586c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8518792aba8f0c6bfdf3518364ab586c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8518792aba8f0c6bfdf3518364ab586c">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;val) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a8518792aba8f0c6bfdf3518364ab586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71864baa5b16ae3823bed93daadd854e" id="r_a71864baa5b16ae3823bed93daadd854e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a71864baa5b16ae3823bed93daadd854e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71864baa5b16ae3823bed93daadd854e">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a71864baa5b16ae3823bed93daadd854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2343a7c24574c0a76def77f277d07e" id="r_afd2343a7c24574c0a76def77f277d07e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afd2343a7c24574c0a76def77f277d07e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd2343a7c24574c0a76def77f277d07e">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:afd2343a7c24574c0a76def77f277d07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278c443da9c85213dd35424e55083798" id="r_a278c443da9c85213dd35424e55083798"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a278c443da9c85213dd35424e55083798"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a278c443da9c85213dd35424e55083798">operator+</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a278c443da9c85213dd35424e55083798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368b52e0bd3a7839fd60d3f5e39cbb0f" id="r_a368b52e0bd3a7839fd60d3f5e39cbb0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a368b52e0bd3a7839fd60d3f5e39cbb0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a368b52e0bd3a7839fd60d3f5e39cbb0f">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a368b52e0bd3a7839fd60d3f5e39cbb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af027a8b3ad1bb5ca5f5179ed2206ad66" id="r_af027a8b3ad1bb5ca5f5179ed2206ad66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af027a8b3ad1bb5ca5f5179ed2206ad66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af027a8b3ad1bb5ca5f5179ed2206ad66">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:af027a8b3ad1bb5ca5f5179ed2206ad66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa390de4495e3c0ec93c4491c5639143" id="r_aaa390de4495e3c0ec93c4491c5639143"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aaa390de4495e3c0ec93c4491c5639143"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa390de4495e3c0ec93c4491c5639143">operator-</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:aaa390de4495e3c0ec93c4491c5639143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade01d8f935d63f6d9cba9fbe323f8821" id="r_ade01d8f935d63f6d9cba9fbe323f8821"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ade01d8f935d63f6d9cba9fbe323f8821"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade01d8f935d63f6d9cba9fbe323f8821">operator*</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ade01d8f935d63f6d9cba9fbe323f8821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9749f0f6e219a2633cc87acdfe48904" id="r_af9749f0f6e219a2633cc87acdfe48904"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af9749f0f6e219a2633cc87acdfe48904"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9749f0f6e219a2633cc87acdfe48904">operator*</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:af9749f0f6e219a2633cc87acdfe48904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfad387b2163cd13b324a0f466cb12cd" id="r_acfad387b2163cd13b324a0f466cb12cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:acfad387b2163cd13b324a0f466cb12cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfad387b2163cd13b324a0f466cb12cd">operator*</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:acfad387b2163cd13b324a0f466cb12cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b89ab01f9efe7650b6a97888f1e869" id="r_ac1b89ab01f9efe7650b6a97888f1e869"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac1b89ab01f9efe7650b6a97888f1e869"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1b89ab01f9efe7650b6a97888f1e869">operator/</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ac1b89ab01f9efe7650b6a97888f1e869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdc7ea9b09001e49518715162e70290" id="r_aafdc7ea9b09001e49518715162e70290"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aafdc7ea9b09001e49518715162e70290"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafdc7ea9b09001e49518715162e70290">operator/</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:aafdc7ea9b09001e49518715162e70290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9660b9b2b46b561d976ffbf7dbde8d69" id="r_a9660b9b2b46b561d976ffbf7dbde8d69"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9660b9b2b46b561d976ffbf7dbde8d69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9660b9b2b46b561d976ffbf7dbde8d69">operator/</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a9660b9b2b46b561d976ffbf7dbde8d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27742612e6861226707341546907da1e" id="r_a27742612e6861226707341546907da1e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a27742612e6861226707341546907da1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a27742612e6861226707341546907da1e">operator==</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a27742612e6861226707341546907da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746cebe9104d4847df63754ab19eeb7" id="r_af746cebe9104d4847df63754ab19eeb7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af746cebe9104d4847df63754ab19eeb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af746cebe9104d4847df63754ab19eeb7">operator==</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:af746cebe9104d4847df63754ab19eeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bab80e6235274bcc58d29d59d310a0" id="r_a32bab80e6235274bcc58d29d59d310a0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a32bab80e6235274bcc58d29d59d310a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32bab80e6235274bcc58d29d59d310a0">operator==</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a32bab80e6235274bcc58d29d59d310a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c27b4cf9bc931994626a2ef5dccdd31" id="r_a0c27b4cf9bc931994626a2ef5dccdd31"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0c27b4cf9bc931994626a2ef5dccdd31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c27b4cf9bc931994626a2ef5dccdd31">operator!=</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a0c27b4cf9bc931994626a2ef5dccdd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ed7f0af0742e1a5ac4571b8a0cb1f8" id="r_a21ed7f0af0742e1a5ac4571b8a0cb1f8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a21ed7f0af0742e1a5ac4571b8a0cb1f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21ed7f0af0742e1a5ac4571b8a0cb1f8">operator!=</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a21ed7f0af0742e1a5ac4571b8a0cb1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b2c8e96c56c4b8a13d0a122cf47b17" id="r_a87b2c8e96c56c4b8a13d0a122cf47b17"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a87b2c8e96c56c4b8a13d0a122cf47b17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a87b2c8e96c56c4b8a13d0a122cf47b17">operator!=</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a87b2c8e96c56c4b8a13d0a122cf47b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853b7e0bec79c51fcf33f952a7415700" id="r_a853b7e0bec79c51fcf33f952a7415700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a853b7e0bec79c51fcf33f952a7415700">operator&quot;&quot;_il</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:a853b7e0bec79c51fcf33f952a7415700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f12cefe14e96cca9da3af660a66b7" id="r_a394f12cefe14e96cca9da3af660a66b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a394f12cefe14e96cca9da3af660a66b7">operator&quot;&quot;_il</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:a394f12cefe14e96cca9da3af660a66b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2266f4104a4fb536c9a02bcb8fa139d" id="r_ac2266f4104a4fb536c9a02bcb8fa139d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#ac2266f4104a4fb536c9a02bcb8fa139d">operator&quot;&quot;_i</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:ac2266f4104a4fb536c9a02bcb8fa139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f553b242808150befd3366a0aee09fc" id="r_a2f553b242808150befd3366a0aee09fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a2f553b242808150befd3366a0aee09fc">operator&quot;&quot;_i</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:a2f553b242808150befd3366a0aee09fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480d031789767adfbb12ca58dd47dec7" id="r_a480d031789767adfbb12ca58dd47dec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a480d031789767adfbb12ca58dd47dec7">operator&quot;&quot;_if</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">float</a> &gt;</td></tr>
<tr class="separator:a480d031789767adfbb12ca58dd47dec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa911f105ff040ac4aedea0f73e86dcf0" id="r_aa911f105ff040ac4aedea0f73e86dcf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#aa911f105ff040ac4aedea0f73e86dcf0">operator&quot;&quot;_if</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">float</a> &gt;</td></tr>
<tr class="separator:aa911f105ff040ac4aedea0f73e86dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdff3d2b9cf188d6aa0ab6981b9b2463" id="r_gacdff3d2b9cf188d6aa0ab6981b9b2463"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gacdff3d2b9cf188d6aa0ab6981b9b2463"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gacdff3d2b9cf188d6aa0ab6981b9b2463">conj</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gacdff3d2b9cf188d6aa0ab6981b9b2463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b84bca7e02dd7f5461ea14d2e9d7c2" id="r_gae8b84bca7e02dd7f5461ea14d2e9d7c2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:gae8b84bca7e02dd7f5461ea14d2e9d7c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gae8b84bca7e02dd7f5461ea14d2e9d7c2">conj</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> f) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; &gt;</td></tr>
<tr class="separator:gae8b84bca7e02dd7f5461ea14d2e9d7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16407258dec05ebfd7c590f4b3f6616" id="r_gaa16407258dec05ebfd7c590f4b3f6616"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:gaa16407258dec05ebfd7c590f4b3f6616"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gaa16407258dec05ebfd7c590f4b3f6616">conj</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt; &gt;</td></tr>
<tr class="separator:gaa16407258dec05ebfd7c590f4b3f6616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7510fce65931a22907d309fb6276e0f" id="r_gac7510fce65931a22907d309fb6276e0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gac7510fce65931a22907d309fb6276e0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac7510fce65931a22907d309fb6276e0f">cos</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gac7510fce65931a22907d309fb6276e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23006d21b437c40597aaee7a84424b7" id="r_gac23006d21b437c40597aaee7a84424b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gac23006d21b437c40597aaee7a84424b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac23006d21b437c40597aaee7a84424b7">cosh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gac23006d21b437c40597aaee7a84424b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c033181a3395adf8cdaaa82075552c9" id="r_ga9c033181a3395adf8cdaaa82075552c9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga9c033181a3395adf8cdaaa82075552c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga9c033181a3395adf8cdaaa82075552c9">imag</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; T</td></tr>
<tr class="separator:ga9c033181a3395adf8cdaaa82075552c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f07449995b80700bfdff5f514ee52d" id="r_gac9f07449995b80700bfdff5f514ee52d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:gac9f07449995b80700bfdff5f514ee52d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac9f07449995b80700bfdff5f514ee52d">imag</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a>) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;</td></tr>
<tr class="separator:gac9f07449995b80700bfdff5f514ee52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2e5c4b70fbcc0010c7869a077f05e5" id="r_ga0f2e5c4b70fbcc0010c7869a077f05e5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:ga0f2e5c4b70fbcc0010c7869a077f05e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga0f2e5c4b70fbcc0010c7869a077f05e5">imag</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a>) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:ga0f2e5c4b70fbcc0010c7869a077f05e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga028e3243afe345483aa28369337b416e" id="r_ga028e3243afe345483aa28369337b416e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga028e3243afe345483aa28369337b416e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga028e3243afe345483aa28369337b416e">log</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga028e3243afe345483aa28369337b416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade18a03ea75529b1b254300ce82929cf" id="r_gade18a03ea75529b1b254300ce82929cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gade18a03ea75529b1b254300ce82929cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gade18a03ea75529b1b254300ce82929cf">log10</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gade18a03ea75529b1b254300ce82929cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f970b8afc721e0d297f41f5b4e93b4f" id="r_ga5f970b8afc721e0d297f41f5b4e93b4f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga5f970b8afc721e0d297f41f5b4e93b4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga5f970b8afc721e0d297f41f5b4e93b4f">norm</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; T</td></tr>
<tr class="separator:ga5f970b8afc721e0d297f41f5b4e93b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0f057f14a0df74b805602e63f6006a" id="r_ga7e0f057f14a0df74b805602e63f6006a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:ga7e0f057f14a0df74b805602e63f6006a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga7e0f057f14a0df74b805602e63f6006a">norm</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> f) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; &gt;</td></tr>
<tr class="separator:ga7e0f057f14a0df74b805602e63f6006a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1653c839c2e17f1fe8d77b998c528a90" id="r_ga1653c839c2e17f1fe8d77b998c528a90"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:ga1653c839c2e17f1fe8d77b998c528a90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga1653c839c2e17f1fe8d77b998c528a90">norm</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt; &gt;</td></tr>
<tr class="separator:ga1653c839c2e17f1fe8d77b998c528a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568678757973b6b2d4c68a97b8140469" id="r_ga568678757973b6b2d4c68a97b8140469"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga568678757973b6b2d4c68a97b8140469"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga568678757973b6b2d4c68a97b8140469">polar</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">r</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">theta</a>=T()) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">etl::complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga568678757973b6b2d4c68a97b8140469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727365d7f0a7787d928e0a6fc4be3285" id="r_ga727365d7f0a7787d928e0a6fc4be3285"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga727365d7f0a7787d928e0a6fc4be3285"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga727365d7f0a7787d928e0a6fc4be3285">real</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; T</td></tr>
<tr class="separator:ga727365d7f0a7787d928e0a6fc4be3285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da6ba713910b5c4699cc53a7477a6cb" id="r_ga9da6ba713910b5c4699cc53a7477a6cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:ga9da6ba713910b5c4699cc53a7477a6cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga9da6ba713910b5c4699cc53a7477a6cb">real</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> f) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;</td></tr>
<tr class="separator:ga9da6ba713910b5c4699cc53a7477a6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0693f96f2a1a21bb0e90a987c1c327b" id="r_gae0693f96f2a1a21bb0e90a987c1c327b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:gae0693f96f2a1a21bb0e90a987c1c327b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gae0693f96f2a1a21bb0e90a987c1c327b">real</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a>&lt; <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:gae0693f96f2a1a21bb0e90a987c1c327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a55d91192ee62e13043d349a5c422e" id="r_ga76a55d91192ee62e13043d349a5c422e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga76a55d91192ee62e13043d349a5c422e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga76a55d91192ee62e13043d349a5c422e">sin</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga76a55d91192ee62e13043d349a5c422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c91cffc26040b2a72d63bd17de8e9e9" id="r_ga1c91cffc26040b2a72d63bd17de8e9e9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga1c91cffc26040b2a72d63bd17de8e9e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga1c91cffc26040b2a72d63bd17de8e9e9">sinh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga1c91cffc26040b2a72d63bd17de8e9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e0a48ba202c18300d1ceb29d562da4" id="r_ga41e0a48ba202c18300d1ceb29d562da4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga41e0a48ba202c18300d1ceb29d562da4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga41e0a48ba202c18300d1ceb29d562da4">tan</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga41e0a48ba202c18300d1ceb29d562da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4213f4318ec3d9fa063bc56c8a3170c" id="r_gac4213f4318ec3d9fa063bc56c8a3170c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gac4213f4318ec3d9fa063bc56c8a3170c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac4213f4318ec3d9fa063bc56c8a3170c">tanh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gac4213f4318ec3d9fa063bc56c8a3170c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a64d34e50bd46ac7c48f9c3b20ecfe" id="r_a02a64d34e50bd46ac7c48f9c3b20ecfe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a02a64d34e50bd46ac7c48f9c3b20ecfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02a64d34e50bd46ac7c48f9c3b20ecfe">to_integer</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="memdesc:a02a64d34e50bd46ac7c48f9c3b20ecfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return Int(b);</code>  <br /></td></tr>
<tr class="separator:a02a64d34e50bd46ac7c48f9c3b20ecfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eb9271474c81cef432c9a2b4afbee6" id="r_a36eb9271474c81cef432c9a2b4afbee6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a36eb9271474c81cef432c9a2b4afbee6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36eb9271474c81cef432c9a2b4afbee6">operator&lt;&lt;</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> b, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">shift</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:a36eb9271474c81cef432c9a2b4afbee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);</code>  <br /></td></tr>
<tr class="separator:a36eb9271474c81cef432c9a2b4afbee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51eea63a0ce9f777a6682aaf90f48696" id="r_a51eea63a0ce9f777a6682aaf90f48696"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a51eea63a0ce9f777a6682aaf90f48696"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51eea63a0ce9f777a6682aaf90f48696">operator&gt;&gt;</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> b, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">shift</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:a51eea63a0ce9f777a6682aaf90f48696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);</code>  <br /></td></tr>
<tr class="separator:a51eea63a0ce9f777a6682aaf90f48696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cb2843a224e246ba96818c029d3cbc" id="r_af1cb2843a224e246ba96818c029d3cbc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:af1cb2843a224e246ba96818c029d3cbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1cb2843a224e246ba96818c029d3cbc">operator&lt;&lt;=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">shift</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:af1cb2843a224e246ba96818c029d3cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return b = b &lt;&lt; shift;</code>  <br /></td></tr>
<tr class="separator:af1cb2843a224e246ba96818c029d3cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec81972434cf41e3465929f46a9d9e4" id="r_a5ec81972434cf41e3465929f46a9d9e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a5ec81972434cf41e3465929f46a9d9e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ec81972434cf41e3465929f46a9d9e4">operator&gt;&gt;=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">shift</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a5ec81972434cf41e3465929f46a9d9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return b = b &gt;&gt; shift;</code>  <br /></td></tr>
<tr class="separator:a5ec81972434cf41e3465929f46a9d9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae524596905624f411ac531dd57bdc7db" id="r_ae524596905624f411ac531dd57bdc7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae524596905624f411ac531dd57bdc7db">operator|</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:ae524596905624f411ac531dd57bdc7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) | static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:ae524596905624f411ac531dd57bdc7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86219208a90a3dde7323cc44e0df0ef4" id="r_a86219208a90a3dde7323cc44e0df0ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86219208a90a3dde7323cc44e0df0ef4">operator&amp;</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:a86219208a90a3dde7323cc44e0df0ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) &amp; static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:a86219208a90a3dde7323cc44e0df0ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f70d9e6f3612368a7a87afd88db9a49" id="r_a0f70d9e6f3612368a7a87afd88db9a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f70d9e6f3612368a7a87afd88db9a49">operator^</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:a0f70d9e6f3612368a7a87afd88db9a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) ^ static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:a0f70d9e6f3612368a7a87afd88db9a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea255f7742cda95d1dab63279b70687" id="r_aeea255f7742cda95d1dab63279b70687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeea255f7742cda95d1dab63279b70687">operator~</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> b) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:aeea255f7742cda95d1dab63279b70687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(~static_cast&lt;unsigned int&gt;(b));</code>  <br /></td></tr>
<tr class="separator:aeea255f7742cda95d1dab63279b70687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3816e8de39ecc8a024d86bd10a4f6f0" id="r_aa3816e8de39ecc8a024d86bd10a4f6f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3816e8de39ecc8a024d86bd10a4f6f0">operator|=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:aa3816e8de39ecc8a024d86bd10a4f6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs | rhs;</code>  <br /></td></tr>
<tr class="separator:aa3816e8de39ecc8a024d86bd10a4f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d19ed615073fb38a2b13da90e273c7c" id="r_a7d19ed615073fb38a2b13da90e273c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d19ed615073fb38a2b13da90e273c7c">operator&amp;=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a7d19ed615073fb38a2b13da90e273c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs &amp; rhs;</code>  <br /></td></tr>
<tr class="separator:a7d19ed615073fb38a2b13da90e273c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bdb2fbcbe02268c3ef208d91d5b702" id="r_a71bdb2fbcbe02268c3ef208d91d5b702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71bdb2fbcbe02268c3ef208d91d5b702">operator^=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a71bdb2fbcbe02268c3ef208d91d5b702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs ^ rhs;</code>  <br /></td></tr>
<tr class="separator:a71bdb2fbcbe02268c3ef208d91d5b702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bf898417a69084f2e08aa12510db7d" id="r_a27bf898417a69084f2e08aa12510db7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27bf898417a69084f2e08aa12510db7d">atof</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a27bf898417a69084f2e08aa12510db7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a27bf898417a69084f2e08aa12510db7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b33a1df966c3e01d825b336211e3ef" id="r_ae6b33a1df966c3e01d825b336211e3ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b33a1df966c3e01d825b336211e3ef">atoi</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ae6b33a1df966c3e01d825b336211e3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:ae6b33a1df966c3e01d825b336211e3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699027607c1a0d56baf456931b915e76" id="r_a699027607c1a0d56baf456931b915e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a699027607c1a0d56baf456931b915e76">atol</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a699027607c1a0d56baf456931b915e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:a699027607c1a0d56baf456931b915e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f1052e901c72fde401b3019f9437b1" id="r_aa7f1052e901c72fde401b3019f9437b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7f1052e901c72fde401b3019f9437b1">atoll</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:aa7f1052e901c72fde401b3019f9437b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:aa7f1052e901c72fde401b3019f9437b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2d6bdea1596be40cc1f1965d14d3a7" id="r_a2a2d6bdea1596be40cc1f1965d14d3a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a2d6bdea1596be40cc1f1965d14d3a7">div</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> y) noexcept -&gt; <a class="el" href="structetl_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:a2a2d6bdea1596be40cc1f1965d14d3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a2a2d6bdea1596be40cc1f1965d14d3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bafeda54d634206adcb005c3ec87be3" id="r_a6bafeda54d634206adcb005c3ec87be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bafeda54d634206adcb005c3ec87be3">labs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a6bafeda54d634206adcb005c3ec87be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a6bafeda54d634206adcb005c3ec87be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe969af8a9f77fea0bb9e0d7a82c5b3f" id="r_afe969af8a9f77fea0bb9e0d7a82c5b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe969af8a9f77fea0bb9e0d7a82c5b3f">div</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:afe969af8a9f77fea0bb9e0d7a82c5b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:afe969af8a9f77fea0bb9e0d7a82c5b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817f60653f2167239f303e63ec82d4d8" id="r_a817f60653f2167239f303e63ec82d4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a817f60653f2167239f303e63ec82d4d8">ldiv</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:a817f60653f2167239f303e63ec82d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a817f60653f2167239f303e63ec82d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d83917d527505e29d3a8d3afb413bc" id="r_a44d83917d527505e29d3a8d3afb413bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44d83917d527505e29d3a8d3afb413bc">llabs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a44d83917d527505e29d3a8d3afb413bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a44d83917d527505e29d3a8d3afb413bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6482fb76727697ae2e8c3d2da7de28d7" id="r_a6482fb76727697ae2e8c3d2da7de28d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6482fb76727697ae2e8c3d2da7de28d7">div</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:a6482fb76727697ae2e8c3d2da7de28d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a6482fb76727697ae2e8c3d2da7de28d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540df0e14af1fb716877eb210bd107b5" id="r_a540df0e14af1fb716877eb210bd107b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a540df0e14af1fb716877eb210bd107b5">lldiv</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:a540df0e14af1fb716877eb210bd107b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a540df0e14af1fb716877eb210bd107b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908461fb82d1921b7d9d47fefd69808f" id="r_a908461fb82d1921b7d9d47fefd69808f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a908461fb82d1921b7d9d47fefd69808f">strtod</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a908461fb82d1921b7d9d47fefd69808f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a908461fb82d1921b7d9d47fefd69808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ff85f301c7ae10d33eb06607976726" id="r_a17ff85f301c7ae10d33eb06607976726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17ff85f301c7ae10d33eb06607976726">strtof</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a17ff85f301c7ae10d33eb06607976726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a17ff85f301c7ae10d33eb06607976726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70d2daad7d58df41e035dc7b7d6ee1" id="r_a1a70d2daad7d58df41e035dc7b7d6ee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a70d2daad7d58df41e035dc7b7d6ee1">strtol</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last, <a class="el" href="structetl_1_1static__vector.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a1a70d2daad7d58df41e035dc7b7d6ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a1a70d2daad7d58df41e035dc7b7d6ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6baccbeb60e396a8222d877a5ef28f" id="r_afe6baccbeb60e396a8222d877a5ef28f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe6baccbeb60e396a8222d877a5ef28f">strtoll</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last, <a class="el" href="structetl_1_1static__vector.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:afe6baccbeb60e396a8222d877a5ef28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:afe6baccbeb60e396a8222d877a5ef28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30cff1b320a5ca627023644ccb321ef" id="r_ac30cff1b320a5ca627023644ccb321ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac30cff1b320a5ca627023644ccb321ef">strtold</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ac30cff1b320a5ca627023644ccb321ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ac30cff1b320a5ca627023644ccb321ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d60e5943db8f44ee5c351c7744db66" id="r_a11d60e5943db8f44ee5c351c7744db66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d60e5943db8f44ee5c351c7744db66">strtoul</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last, <a class="el" href="structetl_1_1static__vector.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a11d60e5943db8f44ee5c351c7744db66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a11d60e5943db8f44ee5c351c7744db66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab96db1ba94415b0dce36ec1327f314" id="r_a4ab96db1ba94415b0dce36ec1327f314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ab96db1ba94415b0dce36ec1327f314">strtoull</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last, <a class="el" href="structetl_1_1static__vector.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a4ab96db1ba94415b0dce36ec1327f314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a4ab96db1ba94415b0dce36ec1327f314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6740ef7f61c971d75fd44a39eac300f5" id="r_ga6740ef7f61c971d75fd44a39eac300f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga6740ef7f61c971d75fd44a39eac300f5">memchr</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> *ptr, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:ga6740ef7f61c971d75fd44a39eac300f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <br /></td></tr>
<tr class="separator:ga6740ef7f61c971d75fd44a39eac300f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7e9e584f1928136b069284b7c32f45" id="r_gafc7e9e584f1928136b069284b7c32f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gafc7e9e584f1928136b069284b7c32f45">memchr</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *ptr, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:gafc7e9e584f1928136b069284b7c32f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <br /></td></tr>
<tr class="separator:gafc7e9e584f1928136b069284b7c32f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ec3f6b7d154def9046012af9517965" id="r_ga08ec3f6b7d154def9046012af9517965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga08ec3f6b7d154def9046012af9517965">memcpy</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:ga08ec3f6b7d154def9046012af9517965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="group__cstring.html#ga4e0d1af4b8d0546159c26456db74a309" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead.  <br /></td></tr>
<tr class="separator:ga08ec3f6b7d154def9046012af9517965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e0d1af4b8d0546159c26456db74a309" id="r_ga4e0d1af4b8d0546159c26456db74a309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga4e0d1af4b8d0546159c26456db74a309">memmove</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:ga4e0d1af4b8d0546159c26456db74a309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap.  <br /></td></tr>
<tr class="separator:ga4e0d1af4b8d0546159c26456db74a309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987e078e2adade59dfd923d96f3ba4ce" id="r_ga987e078e2adade59dfd923d96f3ba4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga987e078e2adade59dfd923d96f3ba4ce">memset</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> *<a class="el" href="structetl_1_1static__vector.html">s</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> c, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:ga987e078e2adade59dfd923d96f3ba4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of c (converted to an unsigned char) into each of the rst n characters of the object pointed to by s.  <br /></td></tr>
<tr class="separator:ga987e078e2adade59dfd923d96f3ba4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5321996edb97a0bb3ce62286dd77d58e" id="r_ga5321996edb97a0bb3ce62286dd77d58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga5321996edb97a0bb3ce62286dd77d58e">strcat</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:ga5321996edb97a0bb3ce62286dd77d58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated.  <br /></td></tr>
<tr class="separator:ga5321996edb97a0bb3ce62286dd77d58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fca1e170d91ea2b0901d41ccb3f4ef6" id="r_ga6fca1e170d91ea2b0901d41ccb3f4ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga6fca1e170d91ea2b0901d41ccb3f4ef6">strchr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:ga6fca1e170d91ea2b0901d41ccb3f4ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ga6fca1e170d91ea2b0901d41ccb3f4ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab0d635f5b2d4f2b9cfceec2c41c373" id="r_ga1ab0d635f5b2d4f2b9cfceec2c41c373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga1ab0d635f5b2d4f2b9cfceec2c41c373">strchr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:ga1ab0d635f5b2d4f2b9cfceec2c41c373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ga1ab0d635f5b2d4f2b9cfceec2c41c373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03c96c75f1fa5b4153f1dab9148fd34" id="r_gaa03c96c75f1fa5b4153f1dab9148fd34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gaa03c96c75f1fa5b4153f1dab9148fd34">strcmp</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:gaa03c96c75f1fa5b4153f1dab9148fd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the C string lhs to the C string rhs.  <br /></td></tr>
<tr class="separator:gaa03c96c75f1fa5b4153f1dab9148fd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac458fbcee97fcd2a801b23b1a05587f8" id="r_gac458fbcee97fcd2a801b23b1a05587f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gac458fbcee97fcd2a801b23b1a05587f8">strcpy</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:gac458fbcee97fcd2a801b23b1a05587f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest.  <br /></td></tr>
<tr class="separator:gac458fbcee97fcd2a801b23b1a05587f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cb449a1f27e32af89154ce5d4b31dc" id="r_gaf0cb449a1f27e32af89154ce5d4b31dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gaf0cb449a1f27e32af89154ce5d4b31dc">strcspn</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:gaf0cb449a1f27e32af89154ce5d4b31dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src.  <br /></td></tr>
<tr class="separator:gaf0cb449a1f27e32af89154ce5d4b31dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847c7fe27bc536cdf5109074b14e81d7" id="r_ga847c7fe27bc536cdf5109074b14e81d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga847c7fe27bc536cdf5109074b14e81d7">strlen</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:ga847c7fe27bc536cdf5109074b14e81d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the C string str.  <br /></td></tr>
<tr class="separator:ga847c7fe27bc536cdf5109074b14e81d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f875253fd9982757bdb90f84284322c" id="r_ga3f875253fd9982757bdb90f84284322c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga3f875253fd9982757bdb90f84284322c">strncat</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:ga3f875253fd9982757bdb90f84284322c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated.  <br /></td></tr>
<tr class="separator:ga3f875253fd9982757bdb90f84284322c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc17ca72f164ecad9eb0bdf5fec43928" id="r_gacc17ca72f164ecad9eb0bdf5fec43928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gacc17ca72f164ecad9eb0bdf5fec43928">strncmp</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:gacc17ca72f164ecad9eb0bdf5fec43928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared.  <br /></td></tr>
<tr class="separator:gacc17ca72f164ecad9eb0bdf5fec43928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d78828452384f88828ac39373bdb7f" id="r_ga50d78828452384f88828ac39373bdb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga50d78828452384f88828ac39373bdb7f">strncpy</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:ga50d78828452384f88828ac39373bdb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest.  <br /></td></tr>
<tr class="separator:ga50d78828452384f88828ac39373bdb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a1eddfb9d029d0710fd07afafcf1fb" id="r_ga41a1eddfb9d029d0710fd07afafcf1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga41a1eddfb9d029d0710fd07afafcf1fb">strpbrk</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:ga41a1eddfb9d029d0710fd07afafcf1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <br /></td></tr>
<tr class="separator:ga41a1eddfb9d029d0710fd07afafcf1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042c917008dbbbd4e10d144f2b8153bf" id="r_ga042c917008dbbbd4e10d144f2b8153bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga042c917008dbbbd4e10d144f2b8153bf">strpbrk</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:ga042c917008dbbbd4e10d144f2b8153bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <br /></td></tr>
<tr class="separator:ga042c917008dbbbd4e10d144f2b8153bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d044d1f8e1c1b85fe30e4830ca04d7" id="r_gab1d044d1f8e1c1b85fe30e4830ca04d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gab1d044d1f8e1c1b85fe30e4830ca04d7">strrchr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:gab1d044d1f8e1c1b85fe30e4830ca04d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:gab1d044d1f8e1c1b85fe30e4830ca04d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ac7ed52583c6766a16279f6b2a56e2" id="r_ga21ac7ed52583c6766a16279f6b2a56e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga21ac7ed52583c6766a16279f6b2a56e2">strrchr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:ga21ac7ed52583c6766a16279f6b2a56e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ga21ac7ed52583c6766a16279f6b2a56e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f31dcdd10129882c6856b848a0ca8f" id="r_gae4f31dcdd10129882c6856b848a0ca8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gae4f31dcdd10129882c6856b848a0ca8f">strspn</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:gae4f31dcdd10129882c6856b848a0ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src.  <br /></td></tr>
<tr class="separator:gae4f31dcdd10129882c6856b848a0ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1553928b9c7f3cb2b4232652f7a8883" id="r_gab1553928b9c7f3cb2b4232652f7a8883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gab1553928b9c7f3cb2b4232652f7a8883">strstr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">haystack</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:gab1553928b9c7f3cb2b4232652f7a8883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:gab1553928b9c7f3cb2b4232652f7a8883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af5da7af9b58ac38ff5d4da3ff5434b" id="r_ga3af5da7af9b58ac38ff5d4da3ff5434b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga3af5da7af9b58ac38ff5d4da3ff5434b">strstr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">haystack</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:ga3af5da7af9b58ac38ff5d4da3ff5434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:ga3af5da7af9b58ac38ff5d4da3ff5434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b81f8645cb1474f15eb0afc8297a82" id="r_a95b81f8645cb1474f15eb0afc8297a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95b81f8645cb1474f15eb0afc8297a82">wcscat</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a95b81f8645cb1474f15eb0afc8297a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated.  <br /></td></tr>
<tr class="separator:a95b81f8645cb1474f15eb0afc8297a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48742a27f06adaa943c923168958fffd" id="r_a48742a27f06adaa943c923168958fffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48742a27f06adaa943c923168958fffd">wcschr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a48742a27f06adaa943c923168958fffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a48742a27f06adaa943c923168958fffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8528d93a4e282441b93ef41355de51" id="r_afa8528d93a4e282441b93ef41355de51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8528d93a4e282441b93ef41355de51">wcschr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:afa8528d93a4e282441b93ef41355de51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:afa8528d93a4e282441b93ef41355de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394989e435a3d8820b9887b0cb6f32d0" id="r_a394989e435a3d8820b9887b0cb6f32d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a394989e435a3d8820b9887b0cb6f32d0">wcscmp</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a394989e435a3d8820b9887b0cb6f32d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two null-terminated wide strings lexicographically.  <br /></td></tr>
<tr class="separator:a394989e435a3d8820b9887b0cb6f32d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6e17a8ddf3c4fbe89a15f971083a96" id="r_a9c6e17a8ddf3c4fbe89a15f971083a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c6e17a8ddf3c4fbe89a15f971083a96">wcscpy</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a9c6e17a8ddf3c4fbe89a15f971083a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a9c6e17a8ddf3c4fbe89a15f971083a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32c98dda497088d03d293fe8e7898f3" id="r_aa32c98dda497088d03d293fe8e7898f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa32c98dda497088d03d293fe8e7898f3">wcscspn</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:aa32c98dda497088d03d293fe8e7898f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src.  <br /></td></tr>
<tr class="separator:aa32c98dda497088d03d293fe8e7898f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76640f48ef8b4a03e9b81fd5ca4209a" id="r_ae76640f48ef8b4a03e9b81fd5ca4209a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76640f48ef8b4a03e9b81fd5ca4209a">wcslen</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a></td></tr>
<tr class="memdesc:ae76640f48ef8b4a03e9b81fd5ca4209a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.  <br /></td></tr>
<tr class="separator:ae76640f48ef8b4a03e9b81fd5ca4209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f1acddf72fe1e8ca96d2ba2ce4728a" id="r_af7f1acddf72fe1e8ca96d2ba2ce4728a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f1acddf72fe1e8ca96d2ba2ce4728a">wcsncat</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:af7f1acddf72fe1e8ca96d2ba2ce4728a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1).  <br /></td></tr>
<tr class="separator:af7f1acddf72fe1e8ca96d2ba2ce4728a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab6f756717b07001aa0cc5ed00d89dd" id="r_aeab6f756717b07001aa0cc5ed00d89dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeab6f756717b07001aa0cc5ed00d89dd">wcsncmp</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:aeab6f756717b07001aa0cc5ed00d89dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically.  <br /></td></tr>
<tr class="separator:aeab6f756717b07001aa0cc5ed00d89dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075bf5df5b479586668e8dfe6a56d0b7" id="r_a075bf5df5b479586668e8dfe6a56d0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075bf5df5b479586668e8dfe6a56d0b7">wcsncpy</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a075bf5df5b479586668e8dfe6a56d0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a075bf5df5b479586668e8dfe6a56d0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcddbba9daed153f19e883e9aea6f8d" id="r_a1dcddbba9daed153f19e883e9aea6f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dcddbba9daed153f19e883e9aea6f8d">wcspbrk</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a1dcddbba9daed153f19e883e9aea6f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a1dcddbba9daed153f19e883e9aea6f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa424e61dbe13ba0fa30a5c09f2045ac" id="r_afa424e61dbe13ba0fa30a5c09f2045ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa424e61dbe13ba0fa30a5c09f2045ac">wcspbrk</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:afa424e61dbe13ba0fa30a5c09f2045ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.  <br /></td></tr>
<tr class="separator:afa424e61dbe13ba0fa30a5c09f2045ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75f8bb32c928b359607a41c9f634e5" id="r_abb75f8bb32c928b359607a41c9f634e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb75f8bb32c928b359607a41c9f634e5">wcsrchr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:abb75f8bb32c928b359607a41c9f634e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:abb75f8bb32c928b359607a41c9f634e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef301df65d76aedef7c3211e00900a2" id="r_a5ef301df65d76aedef7c3211e00900a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ef301df65d76aedef7c3211e00900a2">wcsrchr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:a5ef301df65d76aedef7c3211e00900a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a5ef301df65d76aedef7c3211e00900a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3a2cd36229b80bef3fcc819e45291" id="r_a62a3a2cd36229b80bef3fcc819e45291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a3a2cd36229b80bef3fcc819e45291">wcsspn</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:a62a3a2cd36229b80bef3fcc819e45291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src.  <br /></td></tr>
<tr class="separator:a62a3a2cd36229b80bef3fcc819e45291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d69c1152ef7e628b1691179fc6f530" id="r_a74d69c1152ef7e628b1691179fc6f530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74d69c1152ef7e628b1691179fc6f530">wcsstr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">haystack</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a74d69c1152ef7e628b1691179fc6f530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:a74d69c1152ef7e628b1691179fc6f530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67cab31ecf7c17b7ea41fbc4c1d0bd5" id="r_ad67cab31ecf7c17b7ea41fbc4c1d0bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67cab31ecf7c17b7ea41fbc4c1d0bd5">wcsstr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">haystack</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:ad67cab31ecf7c17b7ea41fbc4c1d0bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:ad67cab31ecf7c17b7ea41fbc4c1d0bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175847a36c688adb123a34e9780ab25" id="r_a5175847a36c688adb123a34e9780ab25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5175847a36c688adb123a34e9780ab25">wmemchr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *ptr, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a5175847a36c688adb123a34e9780ab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.  <br /></td></tr>
<tr class="separator:a5175847a36c688adb123a34e9780ab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65747ecf11dff5d8f3be4a0f7793ca69" id="r_a65747ecf11dff5d8f3be4a0f7793ca69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65747ecf11dff5d8f3be4a0f7793ca69">wmemchr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *ptr, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:a65747ecf11dff5d8f3be4a0f7793ca69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.  <br /></td></tr>
<tr class="separator:a65747ecf11dff5d8f3be4a0f7793ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af171fdc02565644fe46f805df68af177" id="r_af171fdc02565644fe46f805df68af177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af171fdc02565644fe46f805df68af177">wmemcmp</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:af171fdc02565644fe46f805df68af177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically.  <br /></td></tr>
<tr class="separator:af171fdc02565644fe46f805df68af177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ebfa659c54260fe5e6e06ee48a906b" id="r_af2ebfa659c54260fe5e6e06ee48a906b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2ebfa659c54260fe5e6e06ee48a906b">wmemcpy</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:af2ebfa659c54260fe5e6e06ee48a906b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing.  <br /></td></tr>
<tr class="separator:af2ebfa659c54260fe5e6e06ee48a906b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72695f43a1b04ada99db35bf2396de5a" id="r_a72695f43a1b04ada99db35bf2396de5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72695f43a1b04ada99db35bf2396de5a">wmemmove</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a72695f43a1b04ada99db35bf2396de5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a72695f43a1b04ada99db35bf2396de5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181b3459989bb776b4fde2be3f0ff339" id="r_a181b3459989bb776b4fde2be3f0ff339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a181b3459989bb776b4fde2be3f0ff339">wmemset</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a181b3459989bb776b4fde2be3f0ff339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a181b3459989bb776b4fde2be3f0ff339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd605e16e8fe82cfcbe722d1cc32531" id="r_adcd605e16e8fe82cfcbe722d1cc32531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcd605e16e8fe82cfcbe722d1cc32531">iswalnum</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:adcd605e16e8fe82cfcbe722d1cc32531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale.  <br /></td></tr>
<tr class="separator:adcd605e16e8fe82cfcbe722d1cc32531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e7f38abfa4626a87a678221210ff20" id="r_a26e7f38abfa4626a87a678221210ff20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e7f38abfa4626a87a678221210ff20">iswalpha</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a26e7f38abfa4626a87a678221210ff20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale.  <br /></td></tr>
<tr class="separator:a26e7f38abfa4626a87a678221210ff20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ddfc9129d96c9d732bd42aae4d2b7e" id="r_af6ddfc9129d96c9d732bd42aae4d2b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6ddfc9129d96c9d732bd42aae4d2b7e">iswblank</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:af6ddfc9129d96c9d732bd42aae4d2b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters.  <br /></td></tr>
<tr class="separator:af6ddfc9129d96c9d732bd42aae4d2b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb4d7527b43f2bf80b6709558ce8751" id="r_abcb4d7527b43f2bf80b6709558ce8751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcb4d7527b43f2bf80b6709558ce8751">iswcntrl</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:abcb4d7527b43f2bf80b6709558ce8751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale.  <br /></td></tr>
<tr class="separator:abcb4d7527b43f2bf80b6709558ce8751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd57dd6cbdd4676e575a985b16fc6c73" id="r_acd57dd6cbdd4676e575a985b16fc6c73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd57dd6cbdd4676e575a985b16fc6c73">iswdigit</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:acd57dd6cbdd4676e575a985b16fc6c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.  <br /></td></tr>
<tr class="separator:acd57dd6cbdd4676e575a985b16fc6c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7497aa1630afdaae61880742d859160" id="r_ae7497aa1630afdaae61880742d859160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7497aa1630afdaae61880742d859160">iswgraph</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ae7497aa1630afdaae61880742d859160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~) or any graphical character specific to the current C locale.  <br /></td></tr>
<tr class="separator:ae7497aa1630afdaae61880742d859160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebca8a0e95d8a7c4b7fbe0022762b5c" id="r_acebca8a0e95d8a7c4b7fbe0022762b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acebca8a0e95d8a7c4b7fbe0022762b5c">iswlower</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:acebca8a0e95d8a7c4b7fbe0022762b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale.  <br /></td></tr>
<tr class="separator:acebca8a0e95d8a7c4b7fbe0022762b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c844b2e79830a5920aef8f6537b691d" id="r_a9c844b2e79830a5920aef8f6537b691d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c844b2e79830a5920aef8f6537b691d">iswprint</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a9c844b2e79830a5920aef8f6537b691d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~), space or any printable character specific to the current C locale.  <br /></td></tr>
<tr class="separator:a9c844b2e79830a5920aef8f6537b691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeae65f95769adaef057cef1e2072cf2" id="r_afeae65f95769adaef057cef1e2072cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeae65f95769adaef057cef1e2072cf2">iswpunct</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:afeae65f95769adaef057cef1e2072cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a punctuation character, i.e. it is one of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ or any punctuation character specific to the current locale.  <br /></td></tr>
<tr class="separator:afeae65f95769adaef057cef1e2072cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bc2486b7f8fe2d819d038bde3e96dd" id="r_a08bc2486b7f8fe2d819d038bde3e96dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08bc2486b7f8fe2d819d038bde3e96dd">iswspace</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a08bc2486b7f8fe2d819d038bde3e96dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:  <br /></td></tr>
<tr class="separator:a08bc2486b7f8fe2d819d038bde3e96dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597b876c6866c7f04154fcc066fd08ba" id="r_a597b876c6866c7f04154fcc066fd08ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a597b876c6866c7f04154fcc066fd08ba">iswupper</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a597b876c6866c7f04154fcc066fd08ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale.  <br /></td></tr>
<tr class="separator:a597b876c6866c7f04154fcc066fd08ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d8adf51dcb6a599f5da613d2e32b5d" id="r_a49d8adf51dcb6a599f5da613d2e32b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49d8adf51dcb6a599f5da613d2e32b5d">iswxdigit</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a49d8adf51dcb6a599f5da613d2e32b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF.  <br /></td></tr>
<tr class="separator:a49d8adf51dcb6a599f5da613d2e32b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acd9b1a67a38e589ba86c569aac0cb9" id="r_a9acd9b1a67a38e589ba86c569aac0cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9acd9b1a67a38e589ba86c569aac0cb9">towlower</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td></tr>
<tr class="memdesc:a9acd9b1a67a38e589ba86c569aac0cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given wide character to lowercase, if possible.  <br /></td></tr>
<tr class="separator:a9acd9b1a67a38e589ba86c569aac0cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdb01e19c1c3b047ac3a7586586f2fd" id="r_aefdb01e19c1c3b047ac3a7586586f2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefdb01e19c1c3b047ac3a7586586f2fd">towupper</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td></tr>
<tr class="memdesc:aefdb01e19c1c3b047ac3a7586586f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given wide character to uppercase, if possible.  <br /></td></tr>
<tr class="separator:aefdb01e19c1c3b047ac3a7586586f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1617ac5647781dfed036ade2fdb9c8" id="r_ga7a1617ac5647781dfed036ade2fdb9c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debugging.html#ga7a1617ac5647781dfed036ade2fdb9c8">breakpoint</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga7a1617ac5647781dfed036ade2fdb9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditional breakpoint: attempts to temporarily halt the execution of the program and transfer control to the debugger.  <br /></td></tr>
<tr class="separator:ga7a1617ac5647781dfed036ade2fdb9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a2659c0357fb2180dab051dfe348eb" id="r_gad9a2659c0357fb2180dab051dfe348eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debugging.html#gad9a2659c0357fb2180dab051dfe348eb">breakpoint_if_debugging</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:gad9a2659c0357fb2180dab051dfe348eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional breakpoint: attempts to temporarily halt the execution of the program and transfer control to the debugger if it were able to determine that the debugger is present. Acts as a no-op otherwise.  <br /></td></tr>
<tr class="separator:gad9a2659c0357fb2180dab051dfe348eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c8a352def3b5c249692e3ed0da20ad" id="r_ga17c8a352def3b5c249692e3ed0da20ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debugging.html#ga17c8a352def3b5c249692e3ed0da20ad">is_debugger_present</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga17c8a352def3b5c249692e3ed0da20ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to determine if the program is being executed with debugger present.  <br /></td></tr>
<tr class="separator:ga17c8a352def3b5c249692e3ed0da20ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015016635edaf10f86f54faa5493e625" id="r_a015016635edaf10f86f54faa5493e625"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Exception</a> &gt; </td></tr>
<tr class="memitem:a015016635edaf10f86f54faa5493e625"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#abb156b0e852ad82749ae42934d3b4dbf">TETL_NO_INLINE</a> <a class="el" href="attributes_8hpp.html#af0eb4be3e44a6a8a9235265e12ad89a7">TETL_COLD</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a015016635edaf10f86f54faa5493e625">raise</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">msg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a015016635edaf10f86f54faa5493e625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14cd5bdeb510c30773c0a14b86d5f8e" id="r_aa14cd5bdeb510c30773c0a14b86d5f8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">E</a> &gt; </td></tr>
<tr class="memitem:aa14cd5bdeb510c30773c0a14b86d5f8e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa14cd5bdeb510c30773c0a14b86d5f8e">unexpected</a> (<a class="el" href="structetl_1_1static__vector.html">E</a>) -&gt; unexpected&lt; <a class="el" href="structetl_1_1static__vector.html">E</a> &gt;</td></tr>
<tr class="separator:aa14cd5bdeb510c30773c0a14b86d5f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142c844e65677a96dcb134681d85e8a2" id="r_a142c844e65677a96dcb134681d85e8a2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a142c844e65677a96dcb134681d85e8a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a142c844e65677a96dcb134681d85e8a2">format_to</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIt</a> out, <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">fmt</a>, <a class="el" href="structetl_1_1static__vector.html">Args</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;... args) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a142c844e65677a96dcb134681d85e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and write the result to the output iterator out.  <br /></td></tr>
<tr class="separator:a142c844e65677a96dcb134681d85e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2b8092a29056d823a289eb08a11484" id="r_afa2b8092a29056d823a289eb08a11484"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> , typename... Args&gt; </td></tr>
<tr class="memitem:afa2b8092a29056d823a289eb08a11484"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa2b8092a29056d823a289eb08a11484">format_to_n</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIter</a> out, <a class="el" href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">diff_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> &gt; <a class="el" href="structetl_1_1static__vector.html">n</a>, <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">fmt</a>, <a class="el" href="structetl_1_1static__vector.html">Args</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;... args) -&gt; <a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a>&lt; <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> &gt;</td></tr>
<tr class="memdesc:afa2b8092a29056d823a289eb08a11484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and write the result to the output iterator out. At most n characters are written.  <br /></td></tr>
<tr class="separator:afa2b8092a29056d823a289eb08a11484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc7cabf52200c976eb934c6de9399fb" id="r_a0bc7cabf52200c976eb934c6de9399fb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Context</a>  = etl::format_context, typename... Args&gt; </td></tr>
<tr class="memitem:a0bc7cabf52200c976eb934c6de9399fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bc7cabf52200c976eb934c6de9399fb">make_format_args</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; detail::format_arg_store&lt; <a class="el" href="structetl_1_1static__vector.html">Context</a>, Args... &gt;</td></tr>
<tr class="separator:a0bc7cabf52200c976eb934c6de9399fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a9f575220aa9ab48e4d48b82093698" id="r_ae6a9f575220aa9ab48e4d48b82093698"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae6a9f575220aa9ab48e4d48b82093698"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6a9f575220aa9ab48e4d48b82093698">make_wformat_args</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; detail::format_arg_store&lt; <a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a>, Args... &gt;</td></tr>
<tr class="separator:ae6a9f575220aa9ab48e4d48b82093698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c2340a69881856d04c55c19bb5c291" id="r_a08c2340a69881856d04c55c19bb5c291"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a08c2340a69881856d04c55c19bb5c291"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08c2340a69881856d04c55c19bb5c291">vformat_to</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIt</a> out, <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">string_view</a> <a class="el" href="structetl_1_1static__vector.html">fmt</a>, <a class="el" href="#abd8c737296655b44480da4fb422add24">format_args</a> args) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:a08c2340a69881856d04c55c19bb5c291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa615187d5a248ab9e6493944c709279e" id="r_aa615187d5a248ab9e6493944c709279e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Func</a> , typename... BoundArgs&gt; </td></tr>
<tr class="memitem:aa615187d5a248ab9e6493944c709279e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa615187d5a248ab9e6493944c709279e">bind_front</a> (<a class="el" href="structetl_1_1static__vector.html">Func</a> &amp;&amp;func, <a class="el" href="structetl_1_1static__vector.html">BoundArgs</a> &amp;&amp;... <a class="el" href="structetl_1_1static__vector.html">boundArgs</a>)</td></tr>
<tr class="memdesc:aa615187d5a248ab9e6493944c709279e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args. In other words, bind_front(f,
bound_args...)(call_args...) is equivalent to invoke(f, bound_args..., call_args....).  <br /></td></tr>
<tr class="separator:aa615187d5a248ab9e6493944c709279e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcfb06e9497d99667ce90201fa5c056" id="r_abdcfb06e9497d99667ce90201fa5c056"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args&gt; </td></tr>
<tr class="memitem:abdcfb06e9497d99667ce90201fa5c056"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abdcfb06e9497d99667ce90201fa5c056">function_ref</a> (<a class="el" href="structetl_1_1static__vector.html">R</a>(*)(Args...)) -&gt; function_ref&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...)&gt;</td></tr>
<tr class="separator:abdcfb06e9497d99667ce90201fa5c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15165afbf59de637ccf27b635458ece" id="r_ac15165afbf59de637ccf27b635458ece"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:ac15165afbf59de637ccf27b635458ece"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac15165afbf59de637ccf27b635458ece">swap</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ac15165afbf59de637ccf27b635458ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:ac15165afbf59de637ccf27b635458ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cae3523aef79cbee6d0ad095484749" id="r_a06cae3523aef79cbee6d0ad095484749"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a06cae3523aef79cbee6d0ad095484749"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06cae3523aef79cbee6d0ad095484749">operator==</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;f, <a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a06cae3523aef79cbee6d0ad095484749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:a06cae3523aef79cbee6d0ad095484749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4874c4f433c6b61ab0bf85023f138b4c" id="r_a4874c4f433c6b61ab0bf85023f138b4c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a4874c4f433c6b61ab0bf85023f138b4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4874c4f433c6b61ab0bf85023f138b4c">operator!=</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;f, <a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a4874c4f433c6b61ab0bf85023f138b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:a4874c4f433c6b61ab0bf85023f138b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d46beb3d8ffc0ea6e9f5157d7f1b299" id="r_a1d46beb3d8ffc0ea6e9f5157d7f1b299"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a1d46beb3d8ffc0ea6e9f5157d7f1b299"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d46beb3d8ffc0ea6e9f5157d7f1b299">operator==</a> (<a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;f) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1d46beb3d8ffc0ea6e9f5157d7f1b299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:a1d46beb3d8ffc0ea6e9f5157d7f1b299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfdea32a40caa3a28fb120ded25d66e" id="r_afdfdea32a40caa3a28fb120ded25d66e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:afdfdea32a40caa3a28fb120ded25d66e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdfdea32a40caa3a28fb120ded25d66e">operator!=</a> (<a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;f) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:afdfdea32a40caa3a28fb120ded25d66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:afdfdea32a40caa3a28fb120ded25d66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64d857ac492271f013aef7076333c81" id="r_ab64d857ac492271f013aef7076333c81"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Args&gt; </td></tr>
<tr class="memitem:ab64d857ac492271f013aef7076333c81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab64d857ac492271f013aef7076333c81">invoke</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; <a class="el" href="#a601366c5cf97ac29c08fc7b51db875a9">etl::invoke_result_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">F</a>, Args... &gt;</td></tr>
<tr class="separator:ab64d857ac492271f013aef7076333c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8b1e57bc5b47496c1898878c7d6916" id="r_a4b8b1e57bc5b47496c1898878c7d6916"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Args&gt; <br />
requires (<a class="el" href="#a79bb140a0b590bb8a6eadea52d880d17">etl::is_invocable_r_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R</a>, <a class="el" href="structetl_1_1static__vector.html">F</a>, Args...&gt;)</td></tr>
<tr class="memitem:a4b8b1e57bc5b47496c1898878c7d6916"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b8b1e57bc5b47496c1898878c7d6916">invoke_r</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; <a class="el" href="structetl_1_1static__vector.html">R</a></td></tr>
<tr class="separator:a4b8b1e57bc5b47496c1898878c7d6916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea99b0f54121ebdd09e467ea46f3f865" id="r_aea99b0f54121ebdd09e467ea46f3f865"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; </td></tr>
<tr class="memitem:aea99b0f54121ebdd09e467ea46f3f865"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea99b0f54121ebdd09e467ea46f3f865">not_fn</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f) -&gt; detail::not_fn_t&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">etl::decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; &gt;</td></tr>
<tr class="separator:aea99b0f54121ebdd09e467ea46f3f865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92780374b4fcf868ff0a7cb7dddaa385" id="r_a92780374b4fcf868ff0a7cb7dddaa385"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> ConstFn&gt; </td></tr>
<tr class="memitem:a92780374b4fcf868ff0a7cb7dddaa385"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92780374b4fcf868ff0a7cb7dddaa385">not_fn</a> () noexcept -&gt; detail::stateless_not_fn&lt; <a class="el" href="structetl_1_1static__vector.html">ConstFn</a> &gt;</td></tr>
<tr class="separator:a92780374b4fcf868ff0a7cb7dddaa385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffcd97e84a642fa9f9f3297692d128e" id="r_a1ffcd97e84a642fa9f9f3297692d128e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1ffcd97e84a642fa9f9f3297692d128e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ffcd97e84a642fa9f9f3297692d128e">reference_wrapper</a> (T &amp;) -&gt; reference_wrapper&lt; T &gt;</td></tr>
<tr class="separator:a1ffcd97e84a642fa9f9f3297692d128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11516b369ddf80bc94d2f450200f5d11" id="r_a11516b369ddf80bc94d2f450200f5d11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a11516b369ddf80bc94d2f450200f5d11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11516b369ddf80bc94d2f450200f5d11">ref</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a11516b369ddf80bc94d2f450200f5d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result.  <br /></td></tr>
<tr class="separator:a11516b369ddf80bc94d2f450200f5d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea72996d2287ae1be393a1827dfa5bf" id="r_adea72996d2287ae1be393a1827dfa5bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adea72996d2287ae1be393a1827dfa5bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adea72996d2287ae1be393a1827dfa5bf">ref</a> (<a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="memdesc:adea72996d2287ae1be393a1827dfa5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result.  <br /></td></tr>
<tr class="separator:adea72996d2287ae1be393a1827dfa5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ebab5fc63c081909c10f9255347efb" id="r_a09ebab5fc63c081909c10f9255347efb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a09ebab5fc63c081909c10f9255347efb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09ebab5fc63c081909c10f9255347efb">cref</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td></tr>
<tr class="memdesc:a09ebab5fc63c081909c10f9255347efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. module Utility.  <br /></td></tr>
<tr class="separator:a09ebab5fc63c081909c10f9255347efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dede0554b7d9e1163a2be7f26702258" id="r_a3dede0554b7d9e1163a2be7f26702258"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3dede0554b7d9e1163a2be7f26702258"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3dede0554b7d9e1163a2be7f26702258">cref</a> (<a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td></tr>
<tr class="separator:a3dede0554b7d9e1163a2be7f26702258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ad6e6c525e1d3fb61aa60cab9f9dc3" id="r_af5ad6e6c525e1d3fb61aa60cab9f9dc3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af5ad6e6c525e1d3fb61aa60cab9f9dc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5ad6e6c525e1d3fb61aa60cab9f9dc3">cref</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;)=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:af5ad6e6c525e1d3fb61aa60cab9f9dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad815b7c902d91f337c10cb8c6876e87" id="r_aad815b7c902d91f337c10cb8c6876e87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">It</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Distance</a> &gt; </td></tr>
<tr class="memitem:aad815b7c902d91f337c10cb8c6876e87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad815b7c902d91f337c10cb8c6876e87">advance</a> (<a class="el" href="structetl_1_1static__vector.html">It</a> &amp;<a class="el" href="structetl_1_1static__vector.html">it</a>, <a class="el" href="structetl_1_1static__vector.html">Distance</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:aad815b7c902d91f337c10cb8c6876e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined.  <br /></td></tr>
<tr class="separator:aad815b7c902d91f337c10cb8c6876e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80a7746c87d52a34bfff83262802d0d" id="r_ae80a7746c87d52a34bfff83262802d0d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:ae80a7746c87d52a34bfff83262802d0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae80a7746c87d52a34bfff83262802d0d">back_inserter</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;<a class="el" href="structetl_1_1static__vector.html">container</a>) -&gt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt;</td></tr>
<tr class="memdesc:ae80a7746c87d52a34bfff83262802d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">back_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">back_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:ae80a7746c87d52a34bfff83262802d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb088ae74a2ec53c8c206de329935df4" id="r_aeb088ae74a2ec53c8c206de329935df4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:aeb088ae74a2ec53c8c206de329935df4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb088ae74a2ec53c8c206de329935df4">begin</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.begin())</td></tr>
<tr class="memdesc:aeb088ae74a2ec53c8c206de329935df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the given container c or array array. These templates rely on <code>C::begin()</code> having a reasonable implementation. Returns exactly c.begin(), which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns <code>C::iterator</code> when c is not const-qualified, and <code>C::const_iterator</code> otherwise. Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="#aeb088ae74a2ec53c8c206de329935df4" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated.  <br /></td></tr>
<tr class="separator:aeb088ae74a2ec53c8c206de329935df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67e324a8e2e3cc38ad6445c05a28ff7" id="r_ae67e324a8e2e3cc38ad6445c05a28ff7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:ae67e324a8e2e3cc38ad6445c05a28ff7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae67e324a8e2e3cc38ad6445c05a28ff7">begin</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.begin())</td></tr>
<tr class="separator:ae67e324a8e2e3cc38ad6445c05a28ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e8d50b9cb9fdffd5bbaeedcb74d2f1" id="r_af8e8d50b9cb9fdffd5bbaeedcb74d2f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:af8e8d50b9cb9fdffd5bbaeedcb74d2f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8e8d50b9cb9fdffd5bbaeedcb74d2f1">begin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:af8e8d50b9cb9fdffd5bbaeedcb74d2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ff9f99fa557857de8d9e6a4829d752" id="r_ab8ff9f99fa557857de8d9e6a4829d752"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:ab8ff9f99fa557857de8d9e6a4829d752"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8ff9f99fa557857de8d9e6a4829d752">cbegin</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(<a class="el" href="#aeb088ae74a2ec53c8c206de329935df4">begin</a>(c))) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#aeb088ae74a2ec53c8c206de329935df4">begin</a>(c))</td></tr>
<tr class="separator:ab8ff9f99fa557857de8d9e6a4829d752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22f9a30542666ba39fdc715089588b3" id="r_ac22f9a30542666ba39fdc715089588b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:ac22f9a30542666ba39fdc715089588b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac22f9a30542666ba39fdc715089588b3">data</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> &amp;c) noexcept(noexcept(c.data())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.data())</td></tr>
<tr class="memdesc:ac22f9a30542666ba39fdc715089588b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the block of memory containing the elements of the container.  <br /></td></tr>
<tr class="separator:ac22f9a30542666ba39fdc715089588b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525de672ed02219aff7c50e11401eb92" id="r_a525de672ed02219aff7c50e11401eb92"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a525de672ed02219aff7c50e11401eb92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a525de672ed02219aff7c50e11401eb92">data</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(c.data())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.data())</td></tr>
<tr class="separator:a525de672ed02219aff7c50e11401eb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae957b7252fd3e8ed42a5ed5e4e745fcd" id="r_ae957b7252fd3e8ed42a5ed5e4e745fcd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:ae957b7252fd3e8ed42a5ed5e4e745fcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae957b7252fd3e8ed42a5ed5e4e745fcd">data</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:ae957b7252fd3e8ed42a5ed5e4e745fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba994bcf39b8b428fec5852ea0cc728c" id="r_aba994bcf39b8b428fec5852ea0cc728c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">It</a> &gt; </td></tr>
<tr class="memitem:aba994bcf39b8b428fec5852ea0cc728c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba994bcf39b8b428fec5852ea0cc728c">distance</a> (<a class="el" href="structetl_1_1static__vector.html">It</a> first, <a class="el" href="structetl_1_1static__vector.html">It</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">It</a> &gt;::difference_type</td></tr>
<tr class="memdesc:aba994bcf39b8b428fec5852ea0cc728c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of hops from first to last.  <br /></td></tr>
<tr class="separator:aba994bcf39b8b428fec5852ea0cc728c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314873517bdae4e131a403c322a9763f" id="r_a314873517bdae4e131a403c322a9763f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a314873517bdae4e131a403c322a9763f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a314873517bdae4e131a403c322a9763f">empty</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(c.empty())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.empty())</td></tr>
<tr class="memdesc:a314873517bdae4e131a403c322a9763f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is empty.  <br /></td></tr>
<tr class="separator:a314873517bdae4e131a403c322a9763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7550de636fcc027498049a1d22c7bc9" id="r_ad7550de636fcc027498049a1d22c7bc9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:ad7550de636fcc027498049a1d22c7bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7550de636fcc027498049a1d22c7bc9">empty</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ad7550de636fcc027498049a1d22c7bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26698de685cc42e99c0c560d05ca93c" id="r_aa26698de685cc42e99c0c560d05ca93c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:aa26698de685cc42e99c0c560d05ca93c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa26698de685cc42e99c0c560d05ca93c">end</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.end())</td></tr>
<tr class="memdesc:aa26698de685cc42e99c0c560d05ca93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on.  <br /></td></tr>
<tr class="separator:aa26698de685cc42e99c0c560d05ca93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364b7fbf24361dad9b16ea5968b95c42" id="r_a364b7fbf24361dad9b16ea5968b95c42"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a364b7fbf24361dad9b16ea5968b95c42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a364b7fbf24361dad9b16ea5968b95c42">end</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.end())</td></tr>
<tr class="separator:a364b7fbf24361dad9b16ea5968b95c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7e5135fa0834bba2c1b028850ba144" id="r_afa7e5135fa0834bba2c1b028850ba144"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:afa7e5135fa0834bba2c1b028850ba144"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa7e5135fa0834bba2c1b028850ba144">end</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:afa7e5135fa0834bba2c1b028850ba144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab385b9f70c785ceb3a5b986f745ca81d" id="r_ab385b9f70c785ceb3a5b986f745ca81d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:ab385b9f70c785ceb3a5b986f745ca81d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab385b9f70c785ceb3a5b986f745ca81d">cend</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(<a class="el" href="#aa26698de685cc42e99c0c560d05ca93c">end</a>(c))) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#aa26698de685cc42e99c0c560d05ca93c">end</a>(c))</td></tr>
<tr class="separator:ab385b9f70c785ceb3a5b986f745ca81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cd5fdd90a750ceb082da63058a6816" id="r_aa8cd5fdd90a750ceb082da63058a6816"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:aa8cd5fdd90a750ceb082da63058a6816"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8cd5fdd90a750ceb082da63058a6816">front_inserter</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt;</td></tr>
<tr class="memdesc:aa8cd5fdd90a750ceb082da63058a6816"><td class="mdescLeft">&#160;</td><td class="mdescRight">front_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:aa8cd5fdd90a750ceb082da63058a6816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b5eb982170f3879c1af31e1f245e8e" id="r_ab6b5eb982170f3879c1af31e1f245e8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:ab6b5eb982170f3879c1af31e1f245e8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6b5eb982170f3879c1af31e1f245e8e">full</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(c.full())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.full())</td></tr>
<tr class="memdesc:ab6b5eb982170f3879c1af31e1f245e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is full.  <br /></td></tr>
<tr class="separator:ab6b5eb982170f3879c1af31e1f245e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d0a38b0d0530c7cdcea3add44e91d4" id="r_ab6d0a38b0d0530c7cdcea3add44e91d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:ab6d0a38b0d0530c7cdcea3add44e91d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6d0a38b0d0530c7cdcea3add44e91d4">full</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ab6d0a38b0d0530c7cdcea3add44e91d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e8085c3345374b117c1dc70edf9d9b" id="r_ab5e8085c3345374b117c1dc70edf9d9b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt; </td></tr>
<tr class="memitem:ab5e8085c3345374b117c1dc70edf9d9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5e8085c3345374b117c1dc70edf9d9b">next</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> <a class="el" href="structetl_1_1static__vector.html">it</a>, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>=1) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:ab5e8085c3345374b117c1dc70edf9d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth successor of iterator it.  <br /></td></tr>
<tr class="separator:ab5e8085c3345374b117c1dc70edf9d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9cd7356c493ca709070e97bf61ed63" id="r_a6d9cd7356c493ca709070e97bf61ed63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:a6d9cd7356c493ca709070e97bf61ed63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d9cd7356c493ca709070e97bf61ed63">prev</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="structetl_1_1static__vector.html">it</a>, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>=1) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td></tr>
<tr class="memdesc:a6d9cd7356c493ca709070e97bf61ed63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth predecessor of iterator it.  <br /></td></tr>
<tr class="separator:a6d9cd7356c493ca709070e97bf61ed63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0e9ff3b7516f90525a93acb5fccc8e" id="r_aef0e9ff3b7516f90525a93acb5fccc8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:aef0e9ff3b7516f90525a93acb5fccc8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef0e9ff3b7516f90525a93acb5fccc8e">rbegin</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rbegin())</td></tr>
<tr class="memdesc:aef0e9ff3b7516f90525a93acb5fccc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-beginning of the given container.  <br /></td></tr>
<tr class="separator:aef0e9ff3b7516f90525a93acb5fccc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9728314a1814cd3fd1c7beaa6a54271" id="r_ad9728314a1814cd3fd1c7beaa6a54271"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:ad9728314a1814cd3fd1c7beaa6a54271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9728314a1814cd3fd1c7beaa6a54271">rbegin</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rbegin())</td></tr>
<tr class="separator:ad9728314a1814cd3fd1c7beaa6a54271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b35374c826579acfd588a9e6f8b390" id="r_aa6b35374c826579acfd588a9e6f8b390"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:aa6b35374c826579acfd588a9e6f8b390"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6b35374c826579acfd588a9e6f8b390">rbegin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; T * &gt;</td></tr>
<tr class="separator:aa6b35374c826579acfd588a9e6f8b390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111d4cb9659c433d9702a48913416699" id="r_a111d4cb9659c433d9702a48913416699"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a111d4cb9659c433d9702a48913416699"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a111d4cb9659c433d9702a48913416699">crbegin</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#aef0e9ff3b7516f90525a93acb5fccc8e">rbegin</a>(c))</td></tr>
<tr class="separator:a111d4cb9659c433d9702a48913416699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55d22696b4d22653a103d0726157a18" id="r_ab55d22696b4d22653a103d0726157a18"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:ab55d22696b4d22653a103d0726157a18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab55d22696b4d22653a103d0726157a18">rend</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rend())</td></tr>
<tr class="memdesc:ab55d22696b4d22653a103d0726157a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-end of the given container.  <br /></td></tr>
<tr class="separator:ab55d22696b4d22653a103d0726157a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286af0157d3f2f88bdd154d26195e29a" id="r_a286af0157d3f2f88bdd154d26195e29a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a286af0157d3f2f88bdd154d26195e29a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a286af0157d3f2f88bdd154d26195e29a">rend</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rend())</td></tr>
<tr class="separator:a286af0157d3f2f88bdd154d26195e29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d58f51b451013d9255c48b59cdabee" id="r_ac0d58f51b451013d9255c48b59cdabee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:ac0d58f51b451013d9255c48b59cdabee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0d58f51b451013d9255c48b59cdabee">rend</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; T * &gt;</td></tr>
<tr class="separator:ac0d58f51b451013d9255c48b59cdabee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4853c0824b6cd2040223f031d427fab" id="r_ac4853c0824b6cd2040223f031d427fab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:ac4853c0824b6cd2040223f031d427fab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4853c0824b6cd2040223f031d427fab">crend</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#ab55d22696b4d22653a103d0726157a18">rend</a>(c))</td></tr>
<tr class="memdesc:ac4853c0824b6cd2040223f031d427fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-end of the given container.  <br /></td></tr>
<tr class="separator:ac4853c0824b6cd2040223f031d427fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0773cf088e3cccbce2905050fcdd0eb" id="r_af0773cf088e3cccbce2905050fcdd0eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </td></tr>
<tr class="memitem:af0773cf088e3cccbce2905050fcdd0eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0773cf088e3cccbce2905050fcdd0eb">make_reverse_iterator</a> (<a class="el" href="structetl_1_1static__vector.html">Iter</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt;</td></tr>
<tr class="memdesc:af0773cf088e3cccbce2905050fcdd0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function template that constructs a <a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">etl::reverse_iterator</a> for the given iterator i (which must be a LegacyBidirectionalIterator) with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:af0773cf088e3cccbce2905050fcdd0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9a7daa4f77fbf1aae7a1b941301cc" id="r_a9ac9a7daa4f77fbf1aae7a1b941301cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:a9ac9a7daa4f77fbf1aae7a1b941301cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ac9a7daa4f77fbf1aae7a1b941301cc">operator==</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a9ac9a7daa4f77fbf1aae7a1b941301cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:a9ac9a7daa4f77fbf1aae7a1b941301cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42d5ab2b854a73191219d9dd7768be5" id="r_aa42d5ab2b854a73191219d9dd7768be5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:aa42d5ab2b854a73191219d9dd7768be5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa42d5ab2b854a73191219d9dd7768be5">operator!=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aa42d5ab2b854a73191219d9dd7768be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:aa42d5ab2b854a73191219d9dd7768be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b87a87e119f906f153eb7a9dd4b27f" id="r_a86b87a87e119f906f153eb7a9dd4b27f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:a86b87a87e119f906f153eb7a9dd4b27f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86b87a87e119f906f153eb7a9dd4b27f">operator&lt;</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a86b87a87e119f906f153eb7a9dd4b27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:a86b87a87e119f906f153eb7a9dd4b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26706133b16070592575cd905122691" id="r_ab26706133b16070592575cd905122691"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:ab26706133b16070592575cd905122691"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab26706133b16070592575cd905122691">operator&lt;=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab26706133b16070592575cd905122691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:ab26706133b16070592575cd905122691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4156f3a7bdd78f42dba049d9cd2a7f" id="r_aca4156f3a7bdd78f42dba049d9cd2a7f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:aca4156f3a7bdd78f42dba049d9cd2a7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca4156f3a7bdd78f42dba049d9cd2a7f">operator&gt;</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aca4156f3a7bdd78f42dba049d9cd2a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:aca4156f3a7bdd78f42dba049d9cd2a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adada3b76df2e6fc502cf397340f36c22" id="r_adada3b76df2e6fc502cf397340f36c22"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:adada3b76df2e6fc502cf397340f36c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adada3b76df2e6fc502cf397340f36c22">operator&gt;=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:adada3b76df2e6fc502cf397340f36c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:adada3b76df2e6fc502cf397340f36c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6132e0e8e9af5871d3647489c0e9ab7f" id="r_a6132e0e8e9af5871d3647489c0e9ab7f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </td></tr>
<tr class="memitem:a6132e0e8e9af5871d3647489c0e9ab7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6132e0e8e9af5871d3647489c0e9ab7f">operator+</a> (<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>, <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">it</a>) noexcept(noexcept(it.base() - <a class="el" href="structetl_1_1static__vector.html">n</a>)) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt;</td></tr>
<tr class="memdesc:a6132e0e8e9af5871d3647489c0e9ab7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator it incremented by n.  <br /></td></tr>
<tr class="separator:a6132e0e8e9af5871d3647489c0e9ab7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d97b143943fdd5165246151965e6e1a" id="r_a2d97b143943fdd5165246151965e6e1a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iterator1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iterator2</a> &gt; </td></tr>
<tr class="memitem:a2d97b143943fdd5165246151965e6e1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d97b143943fdd5165246151965e6e1a">operator-</a> (<a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iterator1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iterator2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(rhs.base() - lhs.base())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(rhs.base() - lhs.base())</td></tr>
<tr class="memdesc:a2d97b143943fdd5165246151965e6e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two iterator adaptors.  <br /></td></tr>
<tr class="separator:a2d97b143943fdd5165246151965e6e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8701f2e299015f92e83f375a604ef61" id="r_ae8701f2e299015f92e83f375a604ef61"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:ae8701f2e299015f92e83f375a604ef61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8701f2e299015f92e83f375a604ef61">size</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(c.size())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.size())</td></tr>
<tr class="memdesc:ae8701f2e299015f92e83f375a604ef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the given container c or array array. Returns c.size(), converted to the return type if necessary.  <br /></td></tr>
<tr class="separator:ae8701f2e299015f92e83f375a604ef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256d0ca03ee6c9127ce2c4baefc0c50b" id="r_a256d0ca03ee6c9127ce2c4baefc0c50b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:a256d0ca03ee6c9127ce2c4baefc0c50b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a256d0ca03ee6c9127ce2c4baefc0c50b">size</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> (&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a></td></tr>
<tr class="separator:a256d0ca03ee6c9127ce2c4baefc0c50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67945df65c1fbfa26461032e32b8bd70" id="r_a67945df65c1fbfa26461032e32b8bd70"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a67945df65c1fbfa26461032e32b8bd70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67945df65c1fbfa26461032e32b8bd70">ssize</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="#a29d6d310a0bc8bcb40b024f5259088a6">common_type_t</a>&lt; <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a>, <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.size())&gt; &gt;</td></tr>
<tr class="separator:a67945df65c1fbfa26461032e32b8bd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584fdd298577a7f3d9696eefe3ddac61" id="r_a584fdd298577a7f3d9696eefe3ddac61"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a> N&gt; </td></tr>
<tr class="memitem:a584fdd298577a7f3d9696eefe3ddac61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a584fdd298577a7f3d9696eefe3ddac61">ssize</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> (&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">static_cast</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> &gt;(<a class="el" href="structetl_1_1static__vector.html">N</a>)]) noexcept -&gt; <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a></td></tr>
<tr class="separator:a584fdd298577a7f3d9696eefe3ddac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2bd83e2ec37c5b1298fae188a15607" id="r_a5e2bd83e2ec37c5b1298fae188a15607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e2bd83e2ec37c5b1298fae188a15607">abs</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a5e2bd83e2ec37c5b1298fae188a15607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a5e2bd83e2ec37c5b1298fae188a15607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e1eb0ffb77caba7f8242da4a5d7470" id="r_a51e1eb0ffb77caba7f8242da4a5d7470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e1eb0ffb77caba7f8242da4a5d7470">abs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="separator:a51e1eb0ffb77caba7f8242da4a5d7470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342a8a68c9a0f5c3ff1b3d5857553906" id="r_a342a8a68c9a0f5c3ff1b3d5857553906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a342a8a68c9a0f5c3ff1b3d5857553906">abs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="separator:a342a8a68c9a0f5c3ff1b3d5857553906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6fd8ce3d926357e36de32769335251" id="r_aee6fd8ce3d926357e36de32769335251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee6fd8ce3d926357e36de32769335251">abs</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="separator:aee6fd8ce3d926357e36de32769335251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d44cf8dff1d93939ca2e9adeec696a7" id="r_a5d44cf8dff1d93939ca2e9adeec696a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d44cf8dff1d93939ca2e9adeec696a7">abs</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:a5d44cf8dff1d93939ca2e9adeec696a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ed298b66e9f2fdd041b0fa9c5df301" id="r_a71ed298b66e9f2fdd041b0fa9c5df301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71ed298b66e9f2fdd041b0fa9c5df301">abs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:a71ed298b66e9f2fdd041b0fa9c5df301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1cf30946e4d50ba41f9328a82e2e62" id="r_aad1cf30946e4d50ba41f9328a82e2e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad1cf30946e4d50ba41f9328a82e2e62">fabs</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="separator:aad1cf30946e4d50ba41f9328a82e2e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9183bd4ec44e90e6830581cf15f8d165" id="r_a9183bd4ec44e90e6830581cf15f8d165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9183bd4ec44e90e6830581cf15f8d165">fabsf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="separator:a9183bd4ec44e90e6830581cf15f8d165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2dd0f4e4c727042a49eb7a07534b4d" id="r_abc2dd0f4e4c727042a49eb7a07534b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc2dd0f4e4c727042a49eb7a07534b4d">fabs</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:abc2dd0f4e4c727042a49eb7a07534b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fbc2879eaeb897fcaf8de7bd117125" id="r_af3fbc2879eaeb897fcaf8de7bd117125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3fbc2879eaeb897fcaf8de7bd117125">fabs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:af3fbc2879eaeb897fcaf8de7bd117125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01976f0c02d8a34fad11dff21277f288" id="r_a01976f0c02d8a34fad11dff21277f288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01976f0c02d8a34fad11dff21277f288">fabsl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:a01976f0c02d8a34fad11dff21277f288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86319ce6c017b8e0cbaed828b6dad2f7" id="r_a86319ce6c017b8e0cbaed828b6dad2f7"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a86319ce6c017b8e0cbaed828b6dad2f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86319ce6c017b8e0cbaed828b6dad2f7">ilog2</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="separator:a86319ce6c017b8e0cbaed828b6dad2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af1eade8d7b506ab0a6732e681a803b" id="r_a0af1eade8d7b506ab0a6732e681a803b"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a0af1eade8d7b506ab0a6732e681a803b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0af1eade8d7b506ab0a6732e681a803b">ipow</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> base, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">exponent</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="separator:a0af1eade8d7b506ab0a6732e681a803b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabc2a74c91be5a9c6b446824c7d2cee" id="r_afabc2a74c91be5a9c6b446824c7d2cee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> Base&gt; </td></tr>
<tr class="memitem:afabc2a74c91be5a9c6b446824c7d2cee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afabc2a74c91be5a9c6b446824c7d2cee">ipow</a> (<a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">Base</a>) <a class="el" href="structetl_1_1static__vector.html">exponent</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">Base</a>)</td></tr>
<tr class="separator:afabc2a74c91be5a9c6b446824c7d2cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8161915e533ff99801f4017d6737d978" id="r_a8161915e533ff99801f4017d6737d978"><td class="memTemplParams" colspan="2">template&lt;typename... Integrals&gt; <br />
requires (<a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">etl::is_convertible_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Integrals</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> ...)</td></tr>
<tr class="memitem:a8161915e533ff99801f4017d6737d978"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8161915e533ff99801f4017d6737d978">extents</a> (Integrals...) -&gt; extents&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>((<a class="el" href="structetl_1_1static__vector.html">Integrals</a>(), <a class="el" href="group__span.html#ga22e7be40fea564f0c1fe3d11229ef0f8">etl::dynamic_extent</a>))... &gt;</td></tr>
<tr class="separator:a8161915e533ff99801f4017d6737d978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe0d774229c098831602663bd591f28" id="r_a1fe0d774229c098831602663bd591f28"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CArray</a> &gt; <br />
requires (<a class="el" href="#a8b0e44222b6a1dc103286f3c5225ad93">is_array_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CArray</a>&gt; &amp;&amp; <a class="el" href="#a3c66bceba9ac1596666a40596ddf9b62">rank_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CArray</a>&gt; == 1)</td></tr>
<tr class="memitem:a1fe0d774229c098831602663bd591f28"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fe0d774229c098831602663bd591f28">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">CArray</a> &amp;) -&gt; mdspan&lt; <a class="el" href="#a0ffde65d0200b12233a0dff1979cc210">remove_all_extents_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CArray</a> &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, <a class="el" href="#a06332dc22e85765f2c195c703cc49068">extent_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CArray</a>, 0 &gt; &gt; &gt;</td></tr>
<tr class="separator:a1fe0d774229c098831602663bd591f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa581bd5419c1b5ce63db2ceefe37b971" id="r_aa581bd5419c1b5ce63db2ceefe37b971"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Pointer</a> &gt; <br />
requires (<a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">is_pointer_v</a>&lt;<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Pointer</a>&gt;&gt;)</td></tr>
<tr class="memitem:aa581bd5419c1b5ce63db2ceefe37b971"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa581bd5419c1b5ce63db2ceefe37b971">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">Pointer</a> &amp;&amp;) -&gt; mdspan&lt; <a class="el" href="#af65c39ad5cff999e37c5009b047655a4">remove_pointer_t</a>&lt; <a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Pointer</a> &gt; &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> &gt; &gt;</td></tr>
<tr class="separator:aa581bd5419c1b5ce63db2ceefe37b971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82de4f51577f9cfd914c0f916caf46fc" id="r_a82de4f51577f9cfd914c0f916caf46fc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , typename... Integrals&gt; <br />
requires ((<a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">is_convertible_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Integrals</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt; &amp;&amp; ...) &amp;&amp; sizeof...(<a class="el" href="structetl_1_1static__vector.html">Integrals</a>) &gt; 0)</td></tr>
<tr class="memitem:a82de4f51577f9cfd914c0f916caf46fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82de4f51577f9cfd914c0f916caf46fc">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">ElementType</a> *, Integrals...) -&gt; mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="#ac53bcc0a66170293af1f9319d4663d1a">dextents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, sizeof...(<a class="el" href="structetl_1_1static__vector.html">Integrals</a>)&gt; &gt;</td></tr>
<tr class="separator:a82de4f51577f9cfd914c0f916caf46fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4c4186488804dd6af16be8ffb48af4" id="r_adc4c4186488804dd6af16be8ffb48af4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexType</a> , size_t... ExtentsPack&gt; </td></tr>
<tr class="memitem:adc4c4186488804dd6af16be8ffb48af4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc4c4186488804dd6af16be8ffb48af4">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">ElementType</a> *, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexType</a>, ExtentsPack... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexType</a>, ExtentsPack... &gt; &gt;</td></tr>
<tr class="separator:adc4c4186488804dd6af16be8ffb48af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc583d3a74b54cf8a1b2f2de409a2b74" id="r_abc583d3a74b54cf8a1b2f2de409a2b74"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">MappingType</a> &gt; </td></tr>
<tr class="memitem:abc583d3a74b54cf8a1b2f2de409a2b74"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc583d3a74b54cf8a1b2f2de409a2b74">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">ElementType</a> *, <a class="el" href="structetl_1_1static__vector.html">MappingType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::layout_type &gt;</td></tr>
<tr class="separator:abc583d3a74b54cf8a1b2f2de409a2b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0eace36bd684274a175bbf90c48247" id="r_a0f0eace36bd684274a175bbf90c48247"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">MappingType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> &gt; </td></tr>
<tr class="memitem:a0f0eace36bd684274a175bbf90c48247"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f0eace36bd684274a175bbf90c48247">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">typename</a> AccessorType::data_handle_type <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, <a class="el" href="structetl_1_1static__vector.html">MappingType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">typename</a> AccessorType::element_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::layout_type, <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> &gt;</td></tr>
<tr class="separator:a0f0eace36bd684274a175bbf90c48247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9406cef0552ac36f0ea11e670081897" id="r_aa9406cef0552ac36f0ea11e670081897"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OffsetType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ExtentType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">StrideType</a> &gt; </td></tr>
<tr class="memitem:aa9406cef0552ac36f0ea11e670081897"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9406cef0552ac36f0ea11e670081897">strided_slice</a> (<a class="el" href="structetl_1_1static__vector.html">OffsetType</a>, <a class="el" href="structetl_1_1static__vector.html">ExtentType</a>, <a class="el" href="structetl_1_1static__vector.html">StrideType</a>) -&gt; strided_slice&lt; <a class="el" href="structetl_1_1static__vector.html">OffsetType</a>, <a class="el" href="structetl_1_1static__vector.html">ExtentType</a>, <a class="el" href="structetl_1_1static__vector.html">StrideType</a> &gt;</td></tr>
<tr class="separator:aa9406cef0552ac36f0ea11e670081897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af804eb418abea75441ce277a3d8ac9a4" id="r_af804eb418abea75441ce277a3d8ac9a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexT</a> , etl::size_t... Extents, typename... SliceSpecifiers&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1static__vector.html">slices</a>) == <a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt;<a class="el" href="structetl_1_1static__vector.html">IndexT</a>, Extents...&gt;::rank())</td></tr>
<tr class="memitem:af804eb418abea75441ce277a3d8ac9a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af804eb418abea75441ce277a3d8ac9a4">submdspan_extents</a> (<a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexT</a>, Extents... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">ext</a>, SliceSpecifiers... <a class="el" href="structetl_1_1static__vector.html">slices</a>)</td></tr>
<tr class="separator:af804eb418abea75441ce277a3d8ac9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ae02f44cb9f415d79d030c8ceb8c16" id="r_a21ae02f44cb9f415d79d030c8ceb8c16"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a21ae02f44cb9f415d79d030c8ceb8c16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21ae02f44cb9f415d79d030c8ceb8c16">addressof</a> (T &amp;<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a21ae02f44cb9f415d79d030c8ceb8c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;.  <br /></td></tr>
<tr class="separator:a21ae02f44cb9f415d79d030c8ceb8c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8d9c987fb1214a1989a00c3ac4d175" id="r_a2b8d9c987fb1214a1989a00c3ac4d175"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a2b8d9c987fb1214a1989a00c3ac4d175"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b8d9c987fb1214a1989a00c3ac4d175">addressof</a> (T &amp;<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a2b8d9c987fb1214a1989a00c3ac4d175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;.  <br /></td></tr>
<tr class="separator:a2b8d9c987fb1214a1989a00c3ac4d175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951855af4ae6cd241993c4f6bde82de5" id="r_a951855af4ae6cd241993c4f6bde82de5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a951855af4ae6cd241993c4f6bde82de5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a951855af4ae6cd241993c4f6bde82de5">addressof</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;)=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a951855af4ae6cd241993c4f6bde82de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410a978255250c24ca74fad8f26910d9" id="r_a410a978255250c24ca74fad8f26910d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a410a978255250c24ca74fad8f26910d9">align</a> (<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> alignment, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="#ae8701f2e299015f92e83f375a604ef61">size</a>, <a class="el" href="structetl_1_1static__vector.html">void</a> *&amp;ptr, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> &amp;<a class="el" href="structetl_1_1static__vector.html">space</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:a410a978255250c24ca74fad8f26910d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.  <br /></td></tr>
<tr class="separator:a410a978255250c24ca74fad8f26910d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867798dd2ddddb86806aa99a0ae9101" id="r_ae867798dd2ddddb86806aa99a0ae9101"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae867798dd2ddddb86806aa99a0ae9101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae867798dd2ddddb86806aa99a0ae9101">assume_aligned</a> (T *ptr) -&gt; T *</td></tr>
<tr class="memdesc:ae867798dd2ddddb86806aa99a0ae9101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned.  <br /></td></tr>
<tr class="separator:ae867798dd2ddddb86806aa99a0ae9101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ec2df5d7caffa501049e08c135fc1" id="r_a7f5ec2df5d7caffa501049e08c135fc1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args, <a class="el" href="structetl_1_1static__vector.html">typename</a>  = decltype(::new(etl::declval&lt;void*&gt;()) T(etl::declval&lt;Args&gt;()...))&gt; </td></tr>
<tr class="memitem:a7f5ec2df5d7caffa501049e08c135fc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f5ec2df5d7caffa501049e08c135fc1">construct_at</a> (T *p, <a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; T *</td></tr>
<tr class="memdesc:a7f5ec2df5d7caffa501049e08c135fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a T object initialized with arguments args... at given address p.  <br /></td></tr>
<tr class="separator:a7f5ec2df5d7caffa501049e08c135fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad349bf22ae9342501dceb73d04bfcb7e" id="r_ad349bf22ae9342501dceb73d04bfcb7e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ad349bf22ae9342501dceb73d04bfcb7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad349bf22ae9342501dceb73d04bfcb7e">destroy</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ad349bf22ae9342501dceb73d04bfcb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the objects in the range [first, last).  <br /></td></tr>
<tr class="separator:ad349bf22ae9342501dceb73d04bfcb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14a8af642cc7dc92cca033c1eff9fad" id="r_ae14a8af642cc7dc92cca033c1eff9fad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae14a8af642cc7dc92cca033c1eff9fad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae14a8af642cc7dc92cca033c1eff9fad">destroy_at</a> (T *p) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ae14a8af642cc7dc92cca033c1eff9fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling destroy(begin(*p), end(*p)).  <br /></td></tr>
<tr class="separator:ae14a8af642cc7dc92cca033c1eff9fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9f1ed59c6342c3bcd7f4ed746a0dda" id="r_a6d9f1ed59c6342c3bcd7f4ed746a0dda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; </td></tr>
<tr class="memitem:a6d9f1ed59c6342c3bcd7f4ed746a0dda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d9f1ed59c6342c3bcd7f4ed746a0dda">destroy_n</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a6d9f1ed59c6342c3bcd7f4ed746a0dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the n objects in the range starting at first.  <br /></td></tr>
<tr class="separator:a6d9f1ed59c6342c3bcd7f4ed746a0dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa171f5d95623a8a1268dc9134a02f972" id="r_aa171f5d95623a8a1268dc9134a02f972"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Ptr</a> &gt; </td></tr>
<tr class="memitem:aa171f5d95623a8a1268dc9134a02f972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa171f5d95623a8a1268dc9134a02f972">to_address</a> (<a class="el" href="structetl_1_1static__vector.html">Ptr</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;ptr) noexcept</td></tr>
<tr class="memdesc:aa171f5d95623a8a1268dc9134a02f972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by p without forming a reference to the object pointed to by p.  <br /></td></tr>
<tr class="separator:aa171f5d95623a8a1268dc9134a02f972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9487e53c09efc9a8837a2d074e441b99" id="r_a9487e53c09efc9a8837a2d074e441b99"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#abffc77cc5069dfe2c648737671e340d9">is_function_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a9487e53c09efc9a8837a2d074e441b99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9487e53c09efc9a8837a2d074e441b99">to_address</a> (T *ptr) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a9487e53c09efc9a8837a2d074e441b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by p without forming a reference to the object pointed to by p.  <br /></td></tr>
<tr class="separator:a9487e53c09efc9a8837a2d074e441b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676f4b08e61c8e7dab3c678610aede5f" id="r_a676f4b08e61c8e7dab3c678610aede5f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a676f4b08e61c8e7dab3c678610aede5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a676f4b08e61c8e7dab3c678610aede5f">uninitialized_fill</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a676f4b08e61c8e7dab3c678610aede5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga446d7a4c7b401cc37781c997c2c27666" id="r_ga446d7a4c7b401cc37781c997c2c27666"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:ga446d7a4c7b401cc37781c997c2c27666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga446d7a4c7b401cc37781c997c2c27666">abs</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">input</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a></td></tr>
<tr class="memdesc:ga446d7a4c7b401cc37781c997c2c27666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value.  <br /></td></tr>
<tr class="separator:ga446d7a4c7b401cc37781c997c2c27666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8f915bbbbe802e8277bc6c7334bbd1" id="r_gabb8f915bbbbe802e8277bc6c7334bbd1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:gabb8f915bbbbe802e8277bc6c7334bbd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gabb8f915bbbbe802e8277bc6c7334bbd1">accumulate</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Type</a> init) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a></td></tr>
<tr class="memdesc:gabb8f915bbbbe802e8277bc6c7334bbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gabb8f915bbbbe802e8277bc6c7334bbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424ee2f8a4a9c6883035310032321524" id="r_ga424ee2f8a4a9c6883035310032321524"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga424ee2f8a4a9c6883035310032321524"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga424ee2f8a4a9c6883035310032321524">accumulate</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Type</a> init, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a></td></tr>
<tr class="memdesc:ga424ee2f8a4a9c6883035310032321524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga424ee2f8a4a9c6883035310032321524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c9d06efc6545df1f62f896f3039ec0" id="r_ga99c9d06efc6545df1f62f896f3039ec0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__integer.html">etl::builtin_integer</a> Int&gt; </td></tr>
<tr class="memitem:ga99c9d06efc6545df1f62f896f3039ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga99c9d06efc6545df1f62f896f3039ec0">add_sat</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">Int</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="separator:ga99c9d06efc6545df1f62f896f3039ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e312ccaf077fc1515c569cbd885794" id="r_ga83e312ccaf077fc1515c569cbd885794"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga83e312ccaf077fc1515c569cbd885794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga83e312ccaf077fc1515c569cbd885794">adjacent_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ga83e312ccaf077fc1515c569cbd885794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between the second and the first of each adjacent pair of elements of the range [first, last) and writes them to the range beginning at destination + 1. An unmodified copy of *first is written to *destination.  <br /></td></tr>
<tr class="separator:ga83e312ccaf077fc1515c569cbd885794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644b57c780b4aaa5d094ceec2f74e4de" id="r_ga644b57c780b4aaa5d094ceec2f74e4de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga644b57c780b4aaa5d094ceec2f74e4de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga644b57c780b4aaa5d094ceec2f74e4de">adjacent_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:ga644b57c780b4aaa5d094ceec2f74e4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga955751ac2a2b96303705764b4bb30db3" id="r_ga955751ac2a2b96303705764b4bb30db3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">M</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; </td></tr>
<tr class="memitem:ga955751ac2a2b96303705764b4bb30db3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga955751ac2a2b96303705764b4bb30db3">gcd</a> (<a class="el" href="structetl_1_1static__vector.html">M</a> m, <a class="el" href="structetl_1_1static__vector.html">N</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="#a29d6d310a0bc8bcb40b024f5259088a6">etl::common_type_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">M</a>, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:ga955751ac2a2b96303705764b4bb30db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of the integers m and n.  <br /></td></tr>
<tr class="separator:ga955751ac2a2b96303705764b4bb30db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ad6461a0165e73290f0352e8fd4cd0" id="r_ga96ad6461a0165e73290f0352e8fd4cd0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga96ad6461a0165e73290f0352e8fd4cd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga96ad6461a0165e73290f0352e8fd4cd0">inner_product</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, T init) -&gt; T</td></tr>
<tr class="memdesc:ga96ad6461a0165e73290f0352e8fd4cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2.  <br /></td></tr>
<tr class="separator:ga96ad6461a0165e73290f0352e8fd4cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0ed0370d54cfcffdf5a5d84313c3bc" id="r_ga7c0ed0370d54cfcffdf5a5d84313c3bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation2</a> &gt; </td></tr>
<tr class="memitem:ga7c0ed0370d54cfcffdf5a5d84313c3bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga7c0ed0370d54cfcffdf5a5d84313c3bc">inner_product</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, T init, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation1</a> <a class="el" href="structetl_1_1static__vector.html">op1</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation2</a> <a class="el" href="structetl_1_1static__vector.html">op2</a>) -&gt; T</td></tr>
<tr class="separator:ga7c0ed0370d54cfcffdf5a5d84313c3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ee38a471c3e4fe67b474e4bf11cec8" id="r_ga38ee38a471c3e4fe67b474e4bf11cec8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga38ee38a471c3e4fe67b474e4bf11cec8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga38ee38a471c3e4fe67b474e4bf11cec8">iota</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga38ee38a471c3e4fe67b474e4bf11cec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value.  <br /></td></tr>
<tr class="separator:ga38ee38a471c3e4fe67b474e4bf11cec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa915cd734d0a5efbd9ac5e5f059f6a9f" id="r_gaa915cd734d0a5efbd9ac5e5f059f6a9f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">M</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <br />
requires (<a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">M</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">M</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</td></tr>
<tr class="memitem:gaa915cd734d0a5efbd9ac5e5f059f6a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gaa915cd734d0a5efbd9ac5e5f059f6a9f">lcm</a> (<a class="el" href="structetl_1_1static__vector.html">M</a> m, <a class="el" href="structetl_1_1static__vector.html">N</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="#a29d6d310a0bc8bcb40b024f5259088a6">common_type_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">M</a>, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:gaa915cd734d0a5efbd9ac5e5f059f6a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common multiple of the integers m and n.  <br /></td></tr>
<tr class="separator:gaa915cd734d0a5efbd9ac5e5f059f6a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95add6b4d15835797abab298377b728a" id="r_ga95add6b4d15835797abab298377b728a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Int</a> &gt; <br />
requires (<a class="el" href="#a396e4b8c756441b942c1619de108e56a">etl::is_integral_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Int</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">etl::is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Int</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</td></tr>
<tr class="memitem:ga95add6b4d15835797abab298377b728a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga95add6b4d15835797abab298377b728a">midpoint</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> a, <a class="el" href="structetl_1_1static__vector.html">Int</a> b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="memdesc:ga95add6b4d15835797abab298377b728a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns half the sum of a + b. If the sum is odd, the result is rounded towards a.  <br /></td></tr>
<tr class="separator:ga95add6b4d15835797abab298377b728a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6585cd4834d332ff438ca8af30a270cf" id="r_ga6585cd4834d332ff438ca8af30a270cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1floating__point.html">etl::floating_point</a> Float&gt; </td></tr>
<tr class="memitem:ga6585cd4834d332ff438ca8af30a270cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga6585cd4834d332ff438ca8af30a270cf">midpoint</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> a, <a class="el" href="structetl_1_1static__vector.html">Float</a> b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Float</a></td></tr>
<tr class="separator:ga6585cd4834d332ff438ca8af30a270cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ecea7106161c23a577360c57654c08" id="r_ga06ecea7106161c23a577360c57654c08"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Ptr</a> &gt; <br />
requires <a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">etl::is_pointer_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Ptr</a>&gt;</td></tr>
<tr class="memitem:ga06ecea7106161c23a577360c57654c08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga06ecea7106161c23a577360c57654c08">midpoint</a> (<a class="el" href="structetl_1_1static__vector.html">Ptr</a> a, <a class="el" href="structetl_1_1static__vector.html">Ptr</a> b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Ptr</a></td></tr>
<tr class="separator:ga06ecea7106161c23a577360c57654c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8650e67603d39eabc51d4f625fd33dd9" id="r_ga8650e67603d39eabc51d4f625fd33dd9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga8650e67603d39eabc51d4f625fd33dd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga8650e67603d39eabc51d4f625fd33dd9">partial_sum</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ga8650e67603d39eabc51d4f625fd33dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses the given binary function op, both applying <a class="el" href="#a9060e0931516472a88f4657d835684a9" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> to their operands on the left hand side.  <br /></td></tr>
<tr class="separator:ga8650e67603d39eabc51d4f625fd33dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48622cf727966c91682f2a36c6cc3695" id="r_ga48622cf727966c91682f2a36c6cc3695"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga48622cf727966c91682f2a36c6cc3695"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga48622cf727966c91682f2a36c6cc3695">partial_sum</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:ga48622cf727966c91682f2a36c6cc3695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c4ece300169efb3528dd8de1633ca66" id="r_ga1c4ece300169efb3528dd8de1633ca66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIter</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> &gt; </td></tr>
<tr class="memitem:ga1c4ece300169efb3528dd8de1633ca66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga1c4ece300169efb3528dd8de1633ca66">reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIter</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIter</a> last, T init, <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; T</td></tr>
<tr class="memdesc:ga1c4ece300169efb3528dd8de1633ca66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gabb8f915bbbbe802e8277bc6c7334bbd1" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:ga1c4ece300169efb3528dd8de1633ca66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c4d18cd54181d2f678ecbf4ca6110c" id="r_ga10c4d18cd54181d2f678ecbf4ca6110c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIter</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga10c4d18cd54181d2f678ecbf4ca6110c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga10c4d18cd54181d2f678ecbf4ca6110c">reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIter</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIter</a> last, T init) -&gt; T</td></tr>
<tr class="memdesc:ga10c4d18cd54181d2f678ecbf4ca6110c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gabb8f915bbbbe802e8277bc6c7334bbd1" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:ga10c4d18cd54181d2f678ecbf4ca6110c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aab27726885209d183d580fba57f1bb" id="r_ga1aab27726885209d183d580fba57f1bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIter</a> &gt; </td></tr>
<tr class="memitem:ga1aab27726885209d183d580fba57f1bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga1aab27726885209d183d580fba57f1bb">reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIter</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIter</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIter</a> &gt;::value_type</td></tr>
<tr class="memdesc:ga1aab27726885209d183d580fba57f1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gabb8f915bbbbe802e8277bc6c7334bbd1" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:ga1aab27726885209d183d580fba57f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a7150bf27fdb35cbafba959838e4e6" id="r_ga43a7150bf27fdb35cbafba959838e4e6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryReductionOp</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryTransformOp</a> &gt; </td></tr>
<tr class="memitem:ga43a7150bf27fdb35cbafba959838e4e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga43a7150bf27fdb35cbafba959838e4e6">transform_reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, T init, <a class="el" href="structetl_1_1static__vector.html">BinaryReductionOp</a> <a class="el" href="group__numeric.html#ga1c4ece300169efb3528dd8de1633ca66">reduce</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryTransformOp</a> <a class="el" href="#a0d479673068495c0b88dcd93a99dfb57">transform</a>) -&gt; T</td></tr>
<tr class="memdesc:ga43a7150bf27fdb35cbafba959838e4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce">https://en.cppreference.com/w/cpp/algorithm/transform_reduce</a>  <br /></td></tr>
<tr class="separator:ga43a7150bf27fdb35cbafba959838e4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab107a1f3770c53e8bae0569b29c8eb52" id="r_gab107a1f3770c53e8bae0569b29c8eb52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gab107a1f3770c53e8bae0569b29c8eb52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gab107a1f3770c53e8bae0569b29c8eb52">transform_reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, T init) -&gt; T</td></tr>
<tr class="memdesc:gab107a1f3770c53e8bae0569b29c8eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce">https://en.cppreference.com/w/cpp/algorithm/transform_reduce</a>  <br /></td></tr>
<tr class="separator:gab107a1f3770c53e8bae0569b29c8eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38fcd7a07285868feed538786ca5523" id="r_gab38fcd7a07285868feed538786ca5523"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryReductionOp</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryTransformOp</a> &gt; </td></tr>
<tr class="memitem:gab38fcd7a07285868feed538786ca5523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gab38fcd7a07285868feed538786ca5523">transform_reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, T init, <a class="el" href="structetl_1_1static__vector.html">BinaryReductionOp</a> <a class="el" href="group__numeric.html#ga1c4ece300169efb3528dd8de1633ca66">reduce</a>, <a class="el" href="structetl_1_1static__vector.html">UnaryTransformOp</a> <a class="el" href="#a0d479673068495c0b88dcd93a99dfb57">transform</a>) -&gt; T</td></tr>
<tr class="memdesc:gab38fcd7a07285868feed538786ca5523"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce">https://en.cppreference.com/w/cpp/algorithm/transform_reduce</a>  <br /></td></tr>
<tr class="separator:gab38fcd7a07285868feed538786ca5523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49c48774035c7f282eeaa3e6288dce8" id="r_ac49c48774035c7f282eeaa3e6288dce8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac49c48774035c7f282eeaa3e6288dce8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac49c48774035c7f282eeaa3e6288dce8">make_optional</a> (T &amp;&amp;value) -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">etl::decay_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ac49c48774035c7f282eeaa3e6288dce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object from value.  <br /></td></tr>
<tr class="separator:ac49c48774035c7f282eeaa3e6288dce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676d3a9766e7187541dac0084ca9352d" id="r_a676d3a9766e7187541dac0084ca9352d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a676d3a9766e7187541dac0084ca9352d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a676d3a9766e7187541dac0084ca9352d">make_optional</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a676d3a9766e7187541dac0084ca9352d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object constructed in-place from args...  <br /></td></tr>
<tr class="separator:a676d3a9766e7187541dac0084ca9352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b02cc74f13a05b6e8c659f3a3dccd6e" id="r_a2b02cc74f13a05b6e8c659f3a3dccd6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a2b02cc74f13a05b6e8c659f3a3dccd6e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b02cc74f13a05b6e8c659f3a3dccd6e">optional</a> (T) -&gt; optional&lt; T &gt;</td></tr>
<tr class="separator:a2b02cc74f13a05b6e8c659f3a3dccd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f2d4ced352c4bef45044a0a3ad530f" id="r_a52f2d4ced352c4bef45044a0a3ad530f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#a6a08681ad0c17b00662bfd185a081335">is_swappable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a52f2d4ced352c4bef45044a0a3ad530f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52f2d4ced352c4bef45044a0a3ad530f">swap</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a52f2d4ced352c4bef45044a0a3ad530f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:a52f2d4ced352c4bef45044a0a3ad530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad37d63683a7b7b60b5492a36214150" id="r_aaad37d63683a7b7b60b5492a36214150"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:aaad37d63683a7b7b60b5492a36214150"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaad37d63683a7b7b60b5492a36214150">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aaad37d63683a7b7b60b5492a36214150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:aaad37d63683a7b7b60b5492a36214150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d4eb3778aa88f9e5bea0b6f3f235f6" id="r_a64d4eb3778aa88f9e5bea0b6f3f235f6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a64d4eb3778aa88f9e5bea0b6f3f235f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a64d4eb3778aa88f9e5bea0b6f3f235f6">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a64d4eb3778aa88f9e5bea0b6f3f235f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:a64d4eb3778aa88f9e5bea0b6f3f235f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5293f688437c01e457055d0aa62d29" id="r_aba5293f688437c01e457055d0aa62d29"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:aba5293f688437c01e457055d0aa62d29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba5293f688437c01e457055d0aa62d29">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aba5293f688437c01e457055d0aa62d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:aba5293f688437c01e457055d0aa62d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224949455a49cb9684654d95c9682614" id="r_a224949455a49cb9684654d95c9682614"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a224949455a49cb9684654d95c9682614"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a224949455a49cb9684654d95c9682614">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a224949455a49cb9684654d95c9682614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:a224949455a49cb9684654d95c9682614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d4cbfad4362cf53ffd250086bee3a2" id="r_a86d4cbfad4362cf53ffd250086bee3a2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a86d4cbfad4362cf53ffd250086bee3a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86d4cbfad4362cf53ffd250086bee3a2">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a86d4cbfad4362cf53ffd250086bee3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:a86d4cbfad4362cf53ffd250086bee3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73784a2e80efe0c148139cde06dba117" id="r_a73784a2e80efe0c148139cde06dba117"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a73784a2e80efe0c148139cde06dba117"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73784a2e80efe0c148139cde06dba117">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a73784a2e80efe0c148139cde06dba117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:a73784a2e80efe0c148139cde06dba117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60614b8fd0ea8fb929abd91e7c03fcb" id="r_ad60614b8fd0ea8fb929abd91e7c03fcb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad60614b8fd0ea8fb929abd91e7c03fcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad60614b8fd0ea8fb929abd91e7c03fcb">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad60614b8fd0ea8fb929abd91e7c03fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:ad60614b8fd0ea8fb929abd91e7c03fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b443906f5ac16a642381e94f0883e5c" id="r_a4b443906f5ac16a642381e94f0883e5c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4b443906f5ac16a642381e94f0883e5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b443906f5ac16a642381e94f0883e5c">operator==</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a4b443906f5ac16a642381e94f0883e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a4b443906f5ac16a642381e94f0883e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f224b8bc7e8e7dbf2e21c2abd61d85b" id="r_a4f224b8bc7e8e7dbf2e21c2abd61d85b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4f224b8bc7e8e7dbf2e21c2abd61d85b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f224b8bc7e8e7dbf2e21c2abd61d85b">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a4f224b8bc7e8e7dbf2e21c2abd61d85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a4f224b8bc7e8e7dbf2e21c2abd61d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9854781fbbc0bb6595381d145ffe8a" id="r_a2f9854781fbbc0bb6595381d145ffe8a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a2f9854781fbbc0bb6595381d145ffe8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f9854781fbbc0bb6595381d145ffe8a">operator!=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a2f9854781fbbc0bb6595381d145ffe8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a2f9854781fbbc0bb6595381d145ffe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa925845eacf401c23d90a28fb0998458" id="r_aa925845eacf401c23d90a28fb0998458"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa925845eacf401c23d90a28fb0998458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa925845eacf401c23d90a28fb0998458">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aa925845eacf401c23d90a28fb0998458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:aa925845eacf401c23d90a28fb0998458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d6d7216975fa39b685f0a19a4fa276" id="r_ac6d6d7216975fa39b685f0a19a4fa276"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac6d6d7216975fa39b685f0a19a4fa276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6d6d7216975fa39b685f0a19a4fa276">operator&lt;</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ac6d6d7216975fa39b685f0a19a4fa276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:ac6d6d7216975fa39b685f0a19a4fa276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addca89d60d9fd283d993f6b1c1976179" id="r_addca89d60d9fd283d993f6b1c1976179"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:addca89d60d9fd283d993f6b1c1976179"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#addca89d60d9fd283d993f6b1c1976179">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:addca89d60d9fd283d993f6b1c1976179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:addca89d60d9fd283d993f6b1c1976179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffab0b95544793c992580effd801dee" id="r_a3ffab0b95544793c992580effd801dee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3ffab0b95544793c992580effd801dee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ffab0b95544793c992580effd801dee">operator&lt;=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a3ffab0b95544793c992580effd801dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a3ffab0b95544793c992580effd801dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a1952aebcb6d04fc5b5555aa3a7703" id="r_aa2a1952aebcb6d04fc5b5555aa3a7703"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa2a1952aebcb6d04fc5b5555aa3a7703"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2a1952aebcb6d04fc5b5555aa3a7703">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aa2a1952aebcb6d04fc5b5555aa3a7703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:aa2a1952aebcb6d04fc5b5555aa3a7703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dffe46043b72215a2006c5e9838d83" id="r_af1dffe46043b72215a2006c5e9838d83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af1dffe46043b72215a2006c5e9838d83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1dffe46043b72215a2006c5e9838d83">operator&gt;</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af1dffe46043b72215a2006c5e9838d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:af1dffe46043b72215a2006c5e9838d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2c16b034956f35bddb8c67e4494cbb" id="r_a6b2c16b034956f35bddb8c67e4494cbb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6b2c16b034956f35bddb8c67e4494cbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b2c16b034956f35bddb8c67e4494cbb">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6b2c16b034956f35bddb8c67e4494cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a6b2c16b034956f35bddb8c67e4494cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3bffc75cabc9b21dd991d66746129c" id="r_a0b3bffc75cabc9b21dd991d66746129c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0b3bffc75cabc9b21dd991d66746129c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b3bffc75cabc9b21dd991d66746129c">operator&gt;=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a0b3bffc75cabc9b21dd991d66746129c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a0b3bffc75cabc9b21dd991d66746129c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bd00052399cf9e75e7519c3bf58d51" id="r_a18bd00052399cf9e75e7519c3bf58d51"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a18bd00052399cf9e75e7519c3bf58d51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18bd00052399cf9e75e7519c3bf58d51">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a18bd00052399cf9e75e7519c3bf58d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a18bd00052399cf9e75e7519c3bf58d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac085d8eb145978f4b6c76ae7fab50571" id="r_ac085d8eb145978f4b6c76ae7fab50571"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ac085d8eb145978f4b6c76ae7fab50571"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac085d8eb145978f4b6c76ae7fab50571">operator==</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ac085d8eb145978f4b6c76ae7fab50571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:ac085d8eb145978f4b6c76ae7fab50571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc78483ca85630fcbad43a9f41b595f" id="r_aecc78483ca85630fcbad43a9f41b595f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:aecc78483ca85630fcbad43a9f41b595f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aecc78483ca85630fcbad43a9f41b595f">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aecc78483ca85630fcbad43a9f41b595f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:aecc78483ca85630fcbad43a9f41b595f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388444660ef75977706dfa713cf2b99e" id="r_a388444660ef75977706dfa713cf2b99e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a388444660ef75977706dfa713cf2b99e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a388444660ef75977706dfa713cf2b99e">operator!=</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a388444660ef75977706dfa713cf2b99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a388444660ef75977706dfa713cf2b99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1791cbc59df111391e3adc533f3c76f" id="r_ab1791cbc59df111391e3adc533f3c76f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ab1791cbc59df111391e3adc533f3c76f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1791cbc59df111391e3adc533f3c76f">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab1791cbc59df111391e3adc533f3c76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:ab1791cbc59df111391e3adc533f3c76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3eae96de48f2fd6467855eeba8c22a4" id="r_aa3eae96de48f2fd6467855eeba8c22a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:aa3eae96de48f2fd6467855eeba8c22a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa3eae96de48f2fd6467855eeba8c22a4">operator&lt;</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aa3eae96de48f2fd6467855eeba8c22a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:aa3eae96de48f2fd6467855eeba8c22a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31acc3ce509ae2930ad2dd4f4008cb3e" id="r_a31acc3ce509ae2930ad2dd4f4008cb3e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a31acc3ce509ae2930ad2dd4f4008cb3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a31acc3ce509ae2930ad2dd4f4008cb3e">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a31acc3ce509ae2930ad2dd4f4008cb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a31acc3ce509ae2930ad2dd4f4008cb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03c024c59f68b73a52401919908d525" id="r_ae03c024c59f68b73a52401919908d525"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ae03c024c59f68b73a52401919908d525"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae03c024c59f68b73a52401919908d525">operator&gt;</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae03c024c59f68b73a52401919908d525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:ae03c024c59f68b73a52401919908d525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea2269a4b47b1b1d90af476759fe39c" id="r_a6ea2269a4b47b1b1d90af476759fe39c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a6ea2269a4b47b1b1d90af476759fe39c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ea2269a4b47b1b1d90af476759fe39c">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6ea2269a4b47b1b1d90af476759fe39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a6ea2269a4b47b1b1d90af476759fe39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f65b464d8a1f49e75691ea39f79b44" id="r_a58f65b464d8a1f49e75691ea39f79b44"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a58f65b464d8a1f49e75691ea39f79b44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58f65b464d8a1f49e75691ea39f79b44">operator&lt;=</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a58f65b464d8a1f49e75691ea39f79b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a58f65b464d8a1f49e75691ea39f79b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a5203370e6084d1474bf9e4d0cd080" id="r_a07a5203370e6084d1474bf9e4d0cd080"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a07a5203370e6084d1474bf9e4d0cd080"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07a5203370e6084d1474bf9e4d0cd080">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a07a5203370e6084d1474bf9e4d0cd080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a07a5203370e6084d1474bf9e4d0cd080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9557503d3e688eaf3ca1fe3ff4056af4" id="r_a9557503d3e688eaf3ca1fe3ff4056af4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a9557503d3e688eaf3ca1fe3ff4056af4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9557503d3e688eaf3ca1fe3ff4056af4">operator&gt;=</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a9557503d3e688eaf3ca1fe3ff4056af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a9557503d3e688eaf3ca1fe3ff4056af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476438c577a79ab5e228c05ea53e8986" id="r_ga476438c577a79ab5e228c05ea53e8986"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Real</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Bits, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RNG</a> &gt; </td></tr>
<tr class="memitem:ga476438c577a79ab5e228c05ea53e8986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga476438c577a79ab5e228c05ea53e8986">generate_canonical</a> (<a class="el" href="structetl_1_1static__vector.html">RNG</a> &amp;g) noexcept(noexcept(g())) -&gt; <a class="el" href="structetl_1_1static__vector.html">Real</a></td></tr>
<tr class="memdesc:ga476438c577a79ab5e228c05ea53e8986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random floating point number in range [0,1).  <br /></td></tr>
<tr class="separator:ga476438c577a79ab5e228c05ea53e8986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634128d2b51dd1677291370fa7276399" id="r_a634128d2b51dd1677291370fa7276399"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a634128d2b51dd1677291370fa7276399"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a634128d2b51dd1677291370fa7276399">decay_copy</a> (T &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept(<a class="el" href="#af70f6258c3e925eeb2d27b652374660d">is_nothrow_convertible_v</a>&lt; T, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; T &gt; &gt;) -&gt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; T &gt;</td></tr>
<tr class="separator:a634128d2b51dd1677291370fa7276399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8ae9359da3a0a4cb0573e8cd219638" id="r_a0e8ae9359da3a0a4cb0573e8cd219638"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FuncT</a> &gt; </td></tr>
<tr class="memitem:a0e8ae9359da3a0a4cb0573e8cd219638"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e8ae9359da3a0a4cb0573e8cd219638">scope_exit</a> (<a class="el" href="structetl_1_1static__vector.html">FuncT</a>) -&gt; scope_exit&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">FuncT</a> &gt; &gt;</td></tr>
<tr class="separator:a0e8ae9359da3a0a4cb0573e8cd219638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae066ee7e8566233be5ae1d96840d0c27" id="r_ae066ee7e8566233be5ae1d96840d0c27"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:ae066ee7e8566233be5ae1d96840d0c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae066ee7e8566233be5ae1d96840d0c27">operator==</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae066ee7e8566233be5ae1d96840d0c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:ae066ee7e8566233be5ae1d96840d0c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b524b62bdc9f0a6c515bb44965cb68c" id="r_a3b524b62bdc9f0a6c515bb44965cb68c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:a3b524b62bdc9f0a6c515bb44965cb68c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b524b62bdc9f0a6c515bb44965cb68c">operator!=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a3b524b62bdc9f0a6c515bb44965cb68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:a3b524b62bdc9f0a6c515bb44965cb68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49df96265d6364140d73a8656425763" id="r_ad49df96265d6364140d73a8656425763"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:ad49df96265d6364140d73a8656425763"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad49df96265d6364140d73a8656425763">operator&lt;</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad49df96265d6364140d73a8656425763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:ad49df96265d6364140d73a8656425763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf24c3b1cefb36e0c44f1cfaf6bf3f61" id="r_acf24c3b1cefb36e0c44f1cfaf6bf3f61"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:acf24c3b1cefb36e0c44f1cfaf6bf3f61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf24c3b1cefb36e0c44f1cfaf6bf3f61">operator&lt;=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:acf24c3b1cefb36e0c44f1cfaf6bf3f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:acf24c3b1cefb36e0c44f1cfaf6bf3f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ccbb17eca7af36ce1a29e8d176f165" id="r_a17ccbb17eca7af36ce1a29e8d176f165"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:a17ccbb17eca7af36ce1a29e8d176f165"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17ccbb17eca7af36ce1a29e8d176f165">operator&gt;</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a17ccbb17eca7af36ce1a29e8d176f165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:a17ccbb17eca7af36ce1a29e8d176f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7a5ebdf6dec990fea752e60d99fc2c" id="r_adb7a5ebdf6dec990fea752e60d99fc2c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:adb7a5ebdf6dec990fea752e60d99fc2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb7a5ebdf6dec990fea752e60d99fc2c">operator&gt;=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:adb7a5ebdf6dec990fea752e60d99fc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:adb7a5ebdf6dec990fea752e60d99fc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10be93498b340088ebf6b854223c733f" id="r_a10be93498b340088ebf6b854223c733f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a10be93498b340088ebf6b854223c733f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10be93498b340088ebf6b854223c733f">swap</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a10be93498b340088ebf6b854223c733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:a10be93498b340088ebf6b854223c733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeda768ae3894ba5ab71ab85c206b19d" id="r_adeda768ae3894ba5ab71ab85c206b19d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Extent&gt; </td></tr>
<tr class="memitem:adeda768ae3894ba5ab71ab85c206b19d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adeda768ae3894ba5ab71ab85c206b19d">span</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a>(&amp;)[<a class="el" href="structetl_1_1static__vector.html">Extent</a>]) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Extent</a> &gt;</td></tr>
<tr class="separator:adeda768ae3894ba5ab71ab85c206b19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971583484d70115eb585a522b3d27c94" id="r_a971583484d70115eb585a522b3d27c94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:a971583484d70115eb585a522b3d27c94"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a971583484d70115eb585a522b3d27c94">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;</td></tr>
<tr class="separator:a971583484d70115eb585a522b3d27c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26de73efb9b95ad5ed7a2efee4db36d1" id="r_a26de73efb9b95ad5ed7a2efee4db36d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:a26de73efb9b95ad5ed7a2efee4db36d1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26de73efb9b95ad5ed7a2efee4db36d1">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;</td></tr>
<tr class="separator:a26de73efb9b95ad5ed7a2efee4db36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f81df02edb24d409273f1a4f4ae1da7" id="r_a0f81df02edb24d409273f1a4f4ae1da7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:a0f81df02edb24d409273f1a4f4ae1da7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f81df02edb24d409273f1a4f4ae1da7">span</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Element</a> &gt;</td></tr>
<tr class="separator:a0f81df02edb24d409273f1a4f4ae1da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929cb3ca520c09729a4166ed8244f76e" id="r_a929cb3ca520c09729a4166ed8244f76e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:a929cb3ca520c09729a4166ed8244f76e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a929cb3ca520c09729a4166ed8244f76e">span</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Element</a> &gt;</td></tr>
<tr class="separator:a929cb3ca520c09729a4166ed8244f76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1582db8c501fc2a0866681ff10eeef" id="r_aaa1582db8c501fc2a0866681ff10eeef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:aaa1582db8c501fc2a0866681ff10eeef"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa1582db8c501fc2a0866681ff10eeef">stack</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a>) -&gt; stack&lt; <a class="el" href="structetl_1_1static__vector.html">typename</a> Container::value_type, <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt;</td></tr>
<tr class="separator:aaa1582db8c501fc2a0866681ff10eeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bec9d408f2060c687550beff2bc22a" id="r_a49bec9d408f2060c687550beff2bc22a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; <br />
requires (<a class="el" href="#a6a08681ad0c17b00662bfd185a081335">is_swappable_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">C</a>&gt;)</td></tr>
<tr class="memitem:a49bec9d408f2060c687550beff2bc22a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49bec9d408f2060c687550beff2bc22a">swap</a> (<a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a49bec9d408f2060c687550beff2bc22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for stack. Swaps the contents of lhs and rhs. This overload only participates in overload resolution if is_swappable&lt;C&gt;::value is true.  <br /></td></tr>
<tr class="separator:a49bec9d408f2060c687550beff2bc22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37282f164092c4575c20cc3eb2be09e8" id="r_a37282f164092c4575c20cc3eb2be09e8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a37282f164092c4575c20cc3eb2be09e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a37282f164092c4575c20cc3eb2be09e8">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a37282f164092c4575c20cc3eb2be09e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a37282f164092c4575c20cc3eb2be09e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc09342ced2b7f24ff7651db389574" id="r_a44fc09342ced2b7f24ff7651db389574"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a44fc09342ced2b7f24ff7651db389574"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44fc09342ced2b7f24ff7651db389574">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a44fc09342ced2b7f24ff7651db389574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a44fc09342ced2b7f24ff7651db389574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ca62639f3d8a4e4e6ee781c0c9b6a6" id="r_ae7ca62639f3d8a4e4e6ee781c0c9b6a6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ae7ca62639f3d8a4e4e6ee781c0c9b6a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7ca62639f3d8a4e4e6ee781c0c9b6a6">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:ae7ca62639f3d8a4e4e6ee781c0c9b6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:ae7ca62639f3d8a4e4e6ee781c0c9b6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a27933aa122a6a535f3ccebc97f877" id="r_a75a27933aa122a6a535f3ccebc97f877"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a75a27933aa122a6a535f3ccebc97f877"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75a27933aa122a6a535f3ccebc97f877">operator+</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a75a27933aa122a6a535f3ccebc97f877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a75a27933aa122a6a535f3ccebc97f877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb50a33ec4c9a9055ea355c59ea86f5" id="r_a0eb50a33ec4c9a9055ea355c59ea86f5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a0eb50a33ec4c9a9055ea355c59ea86f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0eb50a33ec4c9a9055ea355c59ea86f5">operator+</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a0eb50a33ec4c9a9055ea355c59ea86f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a0eb50a33ec4c9a9055ea355c59ea86f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adf17474787513990f234ca72826619" id="r_a8adf17474787513990f234ca72826619"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a8adf17474787513990f234ca72826619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8adf17474787513990f234ca72826619">operator==</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a8adf17474787513990f234ca72826619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a8adf17474787513990f234ca72826619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f85e21843e35c81f29e31fecc4ea45d" id="r_a3f85e21843e35c81f29e31fecc4ea45d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a3f85e21843e35c81f29e31fecc4ea45d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f85e21843e35c81f29e31fecc4ea45d">operator==</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a3f85e21843e35c81f29e31fecc4ea45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a3f85e21843e35c81f29e31fecc4ea45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74dff6a048a2b86a6cd9e49f33f2099" id="r_af74dff6a048a2b86a6cd9e49f33f2099"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:af74dff6a048a2b86a6cd9e49f33f2099"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af74dff6a048a2b86a6cd9e49f33f2099">operator==</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af74dff6a048a2b86a6cd9e49f33f2099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:af74dff6a048a2b86a6cd9e49f33f2099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ff405e190d21367929b8538ffb325b" id="r_a45ff405e190d21367929b8538ffb325b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a45ff405e190d21367929b8538ffb325b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45ff405e190d21367929b8538ffb325b">operator!=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a45ff405e190d21367929b8538ffb325b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a45ff405e190d21367929b8538ffb325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17898ce525ba08e9d785effed53ff5ee" id="r_a17898ce525ba08e9d785effed53ff5ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a17898ce525ba08e9d785effed53ff5ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17898ce525ba08e9d785effed53ff5ee">operator!=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a17898ce525ba08e9d785effed53ff5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a17898ce525ba08e9d785effed53ff5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dcc12372f0b690c21d481f7c06e3ad" id="r_ad9dcc12372f0b690c21d481f7c06e3ad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ad9dcc12372f0b690c21d481f7c06e3ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9dcc12372f0b690c21d481f7c06e3ad">operator!=</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad9dcc12372f0b690c21d481f7c06e3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ad9dcc12372f0b690c21d481f7c06e3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a42997d8aa7aefa1919f1bcbd257a83" id="r_a1a42997d8aa7aefa1919f1bcbd257a83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a1a42997d8aa7aefa1919f1bcbd257a83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a42997d8aa7aefa1919f1bcbd257a83">operator&lt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a1a42997d8aa7aefa1919f1bcbd257a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a1a42997d8aa7aefa1919f1bcbd257a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aa37862308b3d67c585cd65bad3a21" id="r_ad2aa37862308b3d67c585cd65bad3a21"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:ad2aa37862308b3d67c585cd65bad3a21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2aa37862308b3d67c585cd65bad3a21">operator&lt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad2aa37862308b3d67c585cd65bad3a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ad2aa37862308b3d67c585cd65bad3a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5a3b63a243a620d7ce34eaa4ee7f56" id="r_a8f5a3b63a243a620d7ce34eaa4ee7f56"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a8f5a3b63a243a620d7ce34eaa4ee7f56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f5a3b63a243a620d7ce34eaa4ee7f56">operator&lt;</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a8f5a3b63a243a620d7ce34eaa4ee7f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a8f5a3b63a243a620d7ce34eaa4ee7f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed935697439744871c76c8536cb1d01" id="r_aeed935697439744871c76c8536cb1d01"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:aeed935697439744871c76c8536cb1d01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeed935697439744871c76c8536cb1d01">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:aeed935697439744871c76c8536cb1d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:aeed935697439744871c76c8536cb1d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48f8017b5a3a8a04d5c706b19e6ac99" id="r_af48f8017b5a3a8a04d5c706b19e6ac99"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:af48f8017b5a3a8a04d5c706b19e6ac99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af48f8017b5a3a8a04d5c706b19e6ac99">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af48f8017b5a3a8a04d5c706b19e6ac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:af48f8017b5a3a8a04d5c706b19e6ac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00c4e35ae6e4d61386d41307c25c0cf" id="r_af00c4e35ae6e4d61386d41307c25c0cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:af00c4e35ae6e4d61386d41307c25c0cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af00c4e35ae6e4d61386d41307c25c0cf">operator&lt;=</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af00c4e35ae6e4d61386d41307c25c0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:af00c4e35ae6e4d61386d41307c25c0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757c5d2256d4a511fd553f05eee89739" id="r_a757c5d2256d4a511fd553f05eee89739"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a757c5d2256d4a511fd553f05eee89739"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a757c5d2256d4a511fd553f05eee89739">operator&gt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a757c5d2256d4a511fd553f05eee89739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a757c5d2256d4a511fd553f05eee89739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe815d462766008278375f8739f30833" id="r_abe815d462766008278375f8739f30833"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:abe815d462766008278375f8739f30833"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe815d462766008278375f8739f30833">operator&gt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:abe815d462766008278375f8739f30833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:abe815d462766008278375f8739f30833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9fbb4031f6f62174c87a48d8f27675" id="r_a8b9fbb4031f6f62174c87a48d8f27675"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a8b9fbb4031f6f62174c87a48d8f27675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b9fbb4031f6f62174c87a48d8f27675">operator&gt;</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a8b9fbb4031f6f62174c87a48d8f27675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a8b9fbb4031f6f62174c87a48d8f27675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d79749a41aa9a490b7306ce7df8d8a4" id="r_a3d79749a41aa9a490b7306ce7df8d8a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a3d79749a41aa9a490b7306ce7df8d8a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d79749a41aa9a490b7306ce7df8d8a4">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a3d79749a41aa9a490b7306ce7df8d8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a3d79749a41aa9a490b7306ce7df8d8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21871672f9ecaaf87d537d49942e1b02" id="r_a21871672f9ecaaf87d537d49942e1b02"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a21871672f9ecaaf87d537d49942e1b02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21871672f9ecaaf87d537d49942e1b02">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a21871672f9ecaaf87d537d49942e1b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a21871672f9ecaaf87d537d49942e1b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45672d31c7b9193d9774241e5caf8b2" id="r_af45672d31c7b9193d9774241e5caf8b2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:af45672d31c7b9193d9774241e5caf8b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af45672d31c7b9193d9774241e5caf8b2">operator&gt;=</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af45672d31c7b9193d9774241e5caf8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:af45672d31c7b9193d9774241e5caf8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cbe62578fbdffe49a59de4dda507e4" id="r_ac6cbe62578fbdffe49a59de4dda507e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ac6cbe62578fbdffe49a59de4dda507e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6cbe62578fbdffe49a59de4dda507e4">swap</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ac6cbe62578fbdffe49a59de4dda507e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">etl::basic_static_string</a>. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:ac6cbe62578fbdffe49a59de4dda507e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6036904dcb2247ec2dbf4bc784d460" id="r_add6036904dcb2247ec2dbf4bc784d460"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:add6036904dcb2247ec2dbf4bc784d460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add6036904dcb2247ec2dbf4bc784d460">erase</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;c, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;::size_type</td></tr>
<tr class="memdesc:add6036904dcb2247ec2dbf4bc784d460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that compare equal to value from the container.  <br /></td></tr>
<tr class="separator:add6036904dcb2247ec2dbf4bc784d460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713c02c496b3a3e3d246868add007065" id="r_a713c02c496b3a3e3d246868add007065"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a713c02c496b3a3e3d246868add007065"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a713c02c496b3a3e3d246868add007065">erase_if</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;c, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;::size_type</td></tr>
<tr class="memdesc:a713c02c496b3a3e3d246868add007065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container.  <br /></td></tr>
<tr class="separator:a713c02c496b3a3e3d246868add007065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcdf80e4775ce92aea72f99207d7016" id="r_aedcdf80e4775ce92aea72f99207d7016"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:aedcdf80e4775ce92aea72f99207d7016"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aedcdf80e4775ce92aea72f99207d7016">stof</a> (<a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:aedcdf80e4775ce92aea72f99207d7016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:aedcdf80e4775ce92aea72f99207d7016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3514bcb3ddf3fc6f3e11325dd82d75ed" id="r_a3514bcb3ddf3fc6f3e11325dd82d75ed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a3514bcb3ddf3fc6f3e11325dd82d75ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3514bcb3ddf3fc6f3e11325dd82d75ed">stod</a> (<a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a3514bcb3ddf3fc6f3e11325dd82d75ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:a3514bcb3ddf3fc6f3e11325dd82d75ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a865d89ba1b49d2c7cdf4b4cf3f5d3" id="r_af8a865d89ba1b49d2c7cdf4b4cf3f5d3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:af8a865d89ba1b49d2c7cdf4b4cf3f5d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8a865d89ba1b49d2c7cdf4b4cf3f5d3">stold</a> (<a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:af8a865d89ba1b49d2c7cdf4b4cf3f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:af8a865d89ba1b49d2c7cdf4b4cf3f5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a292e75d88b4e3619e2654b8f6f8660" id="r_a1a292e75d88b4e3619e2654b8f6f8660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a292e75d88b4e3619e2654b8f6f8660">stoi</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a1a292e75d88b4e3619e2654b8f6f8660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a1a292e75d88b4e3619e2654b8f6f8660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bfd356983e8d8a730538cd6b5f7cd" id="r_a634bfd356983e8d8a730538cd6b5f7cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a634bfd356983e8d8a730538cd6b5f7cd">stol</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a634bfd356983e8d8a730538cd6b5f7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a634bfd356983e8d8a730538cd6b5f7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b844e6e1102e2efe7b9f7ad9ef4fff6" id="r_a8b844e6e1102e2efe7b9f7ad9ef4fff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b844e6e1102e2efe7b9f7ad9ef4fff6">stoll</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a8b844e6e1102e2efe7b9f7ad9ef4fff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a8b844e6e1102e2efe7b9f7ad9ef4fff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c74f60fe53545b60e1c1404719b84e6" id="r_a0c74f60fe53545b60e1c1404719b84e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c74f60fe53545b60e1c1404719b84e6">stoul</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a0c74f60fe53545b60e1c1404719b84e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a0c74f60fe53545b60e1c1404719b84e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d870cb89861489715e34bf225feb213" id="r_a3d870cb89861489715e34bf225feb213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d870cb89861489715e34bf225feb213">stoull</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a3d870cb89861489715e34bf225feb213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a3d870cb89861489715e34bf225feb213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a46d2610263aec2af4e9c49c94519ae" id="r_a9a46d2610263aec2af4e9c49c94519ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , CharT... Chars&gt; </td></tr>
<tr class="memitem:a9a46d2610263aec2af4e9c49c94519ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a46d2610263aec2af4e9c49c94519ae">operator==</a> (<a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, Chars... &gt;, <a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, Chars... &gt;) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a9a46d2610263aec2af4e9c49c94519ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9202f4500faf2a0dfeb6d39233517e" id="r_a2d9202f4500faf2a0dfeb6d39233517e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , CharT... CharsL, CharT... CharsR&gt; </td></tr>
<tr class="memitem:a2d9202f4500faf2a0dfeb6d39233517e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d9202f4500faf2a0dfeb6d39233517e">operator==</a> (<a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, CharsL... &gt;, <a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, CharsR... &gt;) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a2d9202f4500faf2a0dfeb6d39233517e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab437ae2f4b539e25a05115f96175a00e" id="r_ab437ae2f4b539e25a05115f96175a00e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ab437ae2f4b539e25a05115f96175a00e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab437ae2f4b539e25a05115f96175a00e">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:ab437ae2f4b539e25a05115f96175a00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:ab437ae2f4b539e25a05115f96175a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2786883ed50708aa10cbeabe8247c604" id="r_a2786883ed50708aa10cbeabe8247c604"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a2786883ed50708aa10cbeabe8247c604"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2786883ed50708aa10cbeabe8247c604">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a2786883ed50708aa10cbeabe8247c604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a2786883ed50708aa10cbeabe8247c604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d59427c9432cc7ee1d2f06bed99f251" id="r_a2d59427c9432cc7ee1d2f06bed99f251"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a2d59427c9432cc7ee1d2f06bed99f251"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d59427c9432cc7ee1d2f06bed99f251">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a2d59427c9432cc7ee1d2f06bed99f251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a2d59427c9432cc7ee1d2f06bed99f251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fa3d013b6f9f9526fa2c22105a229d" id="r_ae8fa3d013b6f9f9526fa2c22105a229d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ae8fa3d013b6f9f9526fa2c22105a229d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8fa3d013b6f9f9526fa2c22105a229d">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:ae8fa3d013b6f9f9526fa2c22105a229d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:ae8fa3d013b6f9f9526fa2c22105a229d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f5c59473c3078b1b135ff3b37b788b" id="r_af5f5c59473c3078b1b135ff3b37b788b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:af5f5c59473c3078b1b135ff3b37b788b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5f5c59473c3078b1b135ff3b37b788b">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:af5f5c59473c3078b1b135ff3b37b788b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:af5f5c59473c3078b1b135ff3b37b788b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2920ef72ba2dcfa7edaf48ac9a8f7e" id="r_a6a2920ef72ba2dcfa7edaf48ac9a8f7e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a6a2920ef72ba2dcfa7edaf48ac9a8f7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a2920ef72ba2dcfa7edaf48ac9a8f7e">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a6a2920ef72ba2dcfa7edaf48ac9a8f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a6a2920ef72ba2dcfa7edaf48ac9a8f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e864c1efccb08ca482ae4e47e01c66" id="r_a47e864c1efccb08ca482ae4e47e01c66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a47e864c1efccb08ca482ae4e47e01c66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47e864c1efccb08ca482ae4e47e01c66">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a47e864c1efccb08ca482ae4e47e01c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a47e864c1efccb08ca482ae4e47e01c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeefc6128abb677e96133e15926cd60a" id="r_afeefc6128abb677e96133e15926cd60a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:afeefc6128abb677e96133e15926cd60a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afeefc6128abb677e96133e15926cd60a">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:afeefc6128abb677e96133e15926cd60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:afeefc6128abb677e96133e15926cd60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b760f0d1dfec7f0dcdc9bcade7cd710" id="r_a8b760f0d1dfec7f0dcdc9bcade7cd710"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a8b760f0d1dfec7f0dcdc9bcade7cd710"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b760f0d1dfec7f0dcdc9bcade7cd710">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> value) noexcept -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a8b760f0d1dfec7f0dcdc9bcade7cd710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a8b760f0d1dfec7f0dcdc9bcade7cd710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e09260a37734d83638e79666d5638a5" id="r_a1e09260a37734d83638e79666d5638a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a1e09260a37734d83638e79666d5638a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e09260a37734d83638e79666d5638a5">operator==</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1e09260a37734d83638e79666d5638a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a1e09260a37734d83638e79666d5638a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfb42090a7af37c4e01eed960522a0d" id="r_a2dfb42090a7af37c4e01eed960522a0d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a2dfb42090a7af37c4e01eed960522a0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2dfb42090a7af37c4e01eed960522a0d">operator==</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a2dfb42090a7af37c4e01eed960522a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d879ae8d357e68c5b61a7d0f3c33473" id="r_a4d879ae8d357e68c5b61a7d0f3c33473"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a4d879ae8d357e68c5b61a7d0f3c33473"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d879ae8d357e68c5b61a7d0f3c33473">operator==</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a4d879ae8d357e68c5b61a7d0f3c33473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b858b9a9207ba5fe533d11e76f3ca1b" id="r_a4b858b9a9207ba5fe533d11e76f3ca1b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a4b858b9a9207ba5fe533d11e76f3ca1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b858b9a9207ba5fe533d11e76f3ca1b">operator!=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a4b858b9a9207ba5fe533d11e76f3ca1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a4b858b9a9207ba5fe533d11e76f3ca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d3249f7e27fcfa91639f72eb53dc75" id="r_a56d3249f7e27fcfa91639f72eb53dc75"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a56d3249f7e27fcfa91639f72eb53dc75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56d3249f7e27fcfa91639f72eb53dc75">operator!=</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a56d3249f7e27fcfa91639f72eb53dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87635e670e27f474bff7714a7bbe558" id="r_af87635e670e27f474bff7714a7bbe558"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:af87635e670e27f474bff7714a7bbe558"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af87635e670e27f474bff7714a7bbe558">operator!=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:af87635e670e27f474bff7714a7bbe558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af437446fcc1e53640c10980cfd99616e" id="r_af437446fcc1e53640c10980cfd99616e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:af437446fcc1e53640c10980cfd99616e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af437446fcc1e53640c10980cfd99616e">operator&lt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af437446fcc1e53640c10980cfd99616e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:af437446fcc1e53640c10980cfd99616e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3409e7cab3e6c13e3d748566971e05e" id="r_ae3409e7cab3e6c13e3d748566971e05e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:ae3409e7cab3e6c13e3d748566971e05e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3409e7cab3e6c13e3d748566971e05e">operator&lt;</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ae3409e7cab3e6c13e3d748566971e05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3293c8c6e37d2b24c05f95baa58aef" id="r_a2c3293c8c6e37d2b24c05f95baa58aef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a2c3293c8c6e37d2b24c05f95baa58aef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c3293c8c6e37d2b24c05f95baa58aef">operator&lt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a2c3293c8c6e37d2b24c05f95baa58aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6911622913c358aa6c9a69533740656e" id="r_a6911622913c358aa6c9a69533740656e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a6911622913c358aa6c9a69533740656e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6911622913c358aa6c9a69533740656e">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6911622913c358aa6c9a69533740656e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a6911622913c358aa6c9a69533740656e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2166e999595123c9283e1d8b743f4d37" id="r_a2166e999595123c9283e1d8b743f4d37"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a2166e999595123c9283e1d8b743f4d37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2166e999595123c9283e1d8b743f4d37">operator&lt;=</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a2166e999595123c9283e1d8b743f4d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2e96c99f7d8223e682d299d15a63a1" id="r_a4f2e96c99f7d8223e682d299d15a63a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a4f2e96c99f7d8223e682d299d15a63a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f2e96c99f7d8223e682d299d15a63a1">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a4f2e96c99f7d8223e682d299d15a63a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282dab84234297d94efc2b6326190a55" id="r_a282dab84234297d94efc2b6326190a55"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a282dab84234297d94efc2b6326190a55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a282dab84234297d94efc2b6326190a55">operator&gt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a282dab84234297d94efc2b6326190a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a282dab84234297d94efc2b6326190a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767725b8e1034844aa4c3245f940832f" id="r_a767725b8e1034844aa4c3245f940832f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a767725b8e1034844aa4c3245f940832f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a767725b8e1034844aa4c3245f940832f">operator&gt;</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a767725b8e1034844aa4c3245f940832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e34f2ca4ffdc8cf580ee55405dbd50" id="r_a77e34f2ca4ffdc8cf580ee55405dbd50"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a77e34f2ca4ffdc8cf580ee55405dbd50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77e34f2ca4ffdc8cf580ee55405dbd50">operator&gt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a77e34f2ca4ffdc8cf580ee55405dbd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06acbb7e9de53f5357b8a05ff2b81346" id="r_a06acbb7e9de53f5357b8a05ff2b81346"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a06acbb7e9de53f5357b8a05ff2b81346"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06acbb7e9de53f5357b8a05ff2b81346">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a06acbb7e9de53f5357b8a05ff2b81346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a06acbb7e9de53f5357b8a05ff2b81346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf977200588526eee94f7bfe90d02a9" id="r_abbf977200588526eee94f7bfe90d02a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:abbf977200588526eee94f7bfe90d02a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abbf977200588526eee94f7bfe90d02a9">operator&gt;=</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:abbf977200588526eee94f7bfe90d02a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7456ec6ff542660d9777cf19081a2cac" id="r_a7456ec6ff542660d9777cf19081a2cac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a7456ec6ff542660d9777cf19081a2cac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7456ec6ff542660d9777cf19081a2cac">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a7456ec6ff542660d9777cf19081a2cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2624a1c2bc9ae10e7e77dddbc403bf22" id="r_a2624a1c2bc9ae10e7e77dddbc403bf22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1string__view__literals.html#a2624a1c2bc9ae10e7e77dddbc403bf22">operator&quot;&quot;_sv</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">len</a>) noexcept -&gt; <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td></tr>
<tr class="memdesc:a2624a1c2bc9ae10e7e77dddbc403bf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a string view of a character literal. Returns <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f" title="Typedefs for common character type.">etl::string_view</a>{str, len}.  <br /></td></tr>
<tr class="separator:a2624a1c2bc9ae10e7e77dddbc403bf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7d8fa4cd29bfaa5efc2ced210dd105" id="r_a0f7d8fa4cd29bfaa5efc2ced210dd105"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &gt; </td></tr>
<tr class="memitem:a0f7d8fa4cd29bfaa5efc2ced210dd105"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f7d8fa4cd29bfaa5efc2ced210dd105">apply</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">auto</a>)</td></tr>
<tr class="separator:a0f7d8fa4cd29bfaa5efc2ced210dd105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5f5e3e00087ff6ca8916d9e69d2cec" id="r_a1b5f5e3e00087ff6ca8916d9e69d2cec"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a1b5f5e3e00087ff6ca8916d9e69d2cec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b5f5e3e00087ff6ca8916d9e69d2cec">forward_as_tuple</a> (<a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;... args) noexcept -&gt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;... &gt;</td></tr>
<tr class="memdesc:a1b5f5e3e00087ff6ca8916d9e69d2cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members.  <br /></td></tr>
<tr class="separator:a1b5f5e3e00087ff6ca8916d9e69d2cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae0d54a117c055337810c0829b22eaf" id="r_a1ae0d54a117c055337810c0829b22eaf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &gt; </td></tr>
<tr class="memitem:a1ae0d54a117c055337810c0829b22eaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ae0d54a117c055337810c0829b22eaf">make_from_tuple</a> (<a class="el" href="structetl_1_1static__vector.html">Tuple</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; T</td></tr>
<tr class="separator:a1ae0d54a117c055337810c0829b22eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb3851a71aca6a0520f250a368a49f6" id="r_adfb3851a71aca6a0520f250a368a49f6"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:adfb3851a71aca6a0520f250a368a49f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfb3851a71aca6a0520f250a368a49f6">make_tuple</a> (<a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:adfb3851a71aca6a0520f250a368a49f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tuple object, deducing the target type from the types of arguments.  <br /></td></tr>
<tr class="separator:adfb3851a71aca6a0520f250a368a49f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1ede89bcd679cdd58f45d98b785cd8" id="r_a0d1ede89bcd679cdd58f45d98b785cd8"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0d1ede89bcd679cdd58f45d98b785cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d1ede89bcd679cdd58f45d98b785cd8">tie</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;... args) noexcept -&gt; <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;... &gt;</td></tr>
<tr class="separator:a0d1ede89bcd679cdd58f45d98b785cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8214f25116b3dd5ee4ecd4605b8e5cf8" id="r_a8214f25116b3dd5ee4ecd4605b8e5cf8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a8214f25116b3dd5ee4ecd4605b8e5cf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8214f25116b3dd5ee4ecd4605b8e5cf8">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td></tr>
<tr class="separator:a8214f25116b3dd5ee4ecd4605b8e5cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05f6f308ed4004eec8f0b4559371a0f" id="r_aa05f6f308ed4004eec8f0b4559371a0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:aa05f6f308ed4004eec8f0b4559371a0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa05f6f308ed4004eec8f0b4559371a0f">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:aa05f6f308ed4004eec8f0b4559371a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bc2983c6b858933480a19a9f6ca6f6" id="r_ae2bc2983c6b858933480a19a9f6ca6f6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:ae2bc2983c6b858933480a19a9f6ca6f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2bc2983c6b858933480a19a9f6ca6f6">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:ae2bc2983c6b858933480a19a9f6ca6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da5e04ad6238c60c904e4c9ac6bc5e9" id="r_a6da5e04ad6238c60c904e4c9ac6bc5e9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a6da5e04ad6238c60c904e4c9ac6bc5e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6da5e04ad6238c60c904e4c9ac6bc5e9">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="separator:a6da5e04ad6238c60c904e4c9ac6bc5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbffd4a8b5d0838ecc6a3f36cad3e3c6" id="r_abbffd4a8b5d0838ecc6a3f36cad3e3c6"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Us&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1static__vector.html">Ts</a>) == sizeof...(<a class="el" href="structetl_1_1static__vector.html">Us</a>))</td></tr>
<tr class="memitem:abbffd4a8b5d0838ecc6a3f36cad3e3c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abbffd4a8b5d0838ecc6a3f36cad3e3c6">operator==</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Us... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:abbffd4a8b5d0838ecc6a3f36cad3e3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95e50e7b2dda0a7a7fd3b1b3a37dc9" id="r_a4c95e50e7b2dda0a7a7fd3b1b3a37dc9"><td class="memTemplParams" colspan="2">template&lt;etl::tuple_like... Tuples&gt; </td></tr>
<tr class="memitem:a4c95e50e7b2dda0a7a7fd3b1b3a37dc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c95e50e7b2dda0a7a7fd3b1b3a37dc9">tuple_cat</a> (<a class="el" href="structetl_1_1static__vector.html">Tuples</a> &amp;&amp;... <a class="el" href="structetl_1_1static__vector.html">ts</a>)</td></tr>
<tr class="separator:a4c95e50e7b2dda0a7a7fd3b1b3a37dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885a42e965c6251995730e67ba6d09eb" id="r_a885a42e965c6251995730e67ba6d09eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a885a42e965c6251995730e67ba6d09eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a885a42e965c6251995730e67ba6d09eb">swap</a> (T &amp;a, T &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a885a42e965c6251995730e67ba6d09eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:a885a42e965c6251995730e67ba6d09eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fe16af1fc0c146d690634a5b2da600" id="r_af8fe16af1fc0c146d690634a5b2da600"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af8fe16af1fc0c146d690634a5b2da600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">declval</a> () noexcept -&gt; etl::add_rvalue_reference_t&lt; T &gt;</td></tr>
<tr class="separator:af8fe16af1fc0c146d690634a5b2da600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab218217c542cbcae689d277e927d360a" id="r_ab218217c542cbcae689d277e927d360a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:ab218217c542cbcae689d277e927d360a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab218217c542cbcae689d277e927d360a">operator+</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">L</a>+<a class="el" href="structetl_1_1static__vector.html">R</a>), <a class="el" href="structetl_1_1static__vector.html">L</a>+<a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td></tr>
<tr class="separator:ab218217c542cbcae689d277e927d360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d3cf9c4f58fa9982c28bfa20adb0cb" id="r_a49d3cf9c4f58fa9982c28bfa20adb0cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:a49d3cf9c4f58fa9982c28bfa20adb0cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49d3cf9c4f58fa9982c28bfa20adb0cb">operator==</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">L</a>==<a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td></tr>
<tr class="separator:a49d3cf9c4f58fa9982c28bfa20adb0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677b4c86284624fe83dc36333e3d4212" id="r_a677b4c86284624fe83dc36333e3d4212"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:a677b4c86284624fe83dc36333e3d4212"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a677b4c86284624fe83dc36333e3d4212">operator!=</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> !=<a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td></tr>
<tr class="separator:a677b4c86284624fe83dc36333e3d4212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ea1c61ce77c9bf27e83df6a1fec64" id="r_a135ea1c61ce77c9bf27e83df6a1fec64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a135ea1c61ce77c9bf27e83df6a1fec64">is_constant_evaluated</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a135ea1c61ce77c9bf27e83df6a1fec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false.  <br /></td></tr>
<tr class="separator:a135ea1c61ce77c9bf27e83df6a1fec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3408c1dae71c214e0b2b360f5fcba723" id="r_a3408c1dae71c214e0b2b360f5fcba723"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3408c1dae71c214e0b2b360f5fcba723"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3408c1dae71c214e0b2b360f5fcba723">test_implicit_default_constructible</a> (T)</td></tr>
<tr class="separator:a3408c1dae71c214e0b2b360f5fcba723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f797628671cf0d4b35a9858fd9a0455" id="r_a9f797628671cf0d4b35a9858fd9a0455"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a9f797628671cf0d4b35a9858fd9a0455"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f797628671cf0d4b35a9858fd9a0455">swap</a> (T &amp;a, T &amp;b) noexcept(<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="#ad26f59ba1b8a873f9d8374f72a4002c4">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a9f797628671cf0d4b35a9858fd9a0455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:a9f797628671cf0d4b35a9858fd9a0455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5273f679984445be5233596370b7a15" id="r_af5273f679984445be5233596370b7a15"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="structetl_1_1is__swappable.html">etl::is_swappable</a>&lt;T&gt;::value)</td></tr>
<tr class="memitem:af5273f679984445be5233596370b7a15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5273f679984445be5233596370b7a15">swap</a> (T(&amp;a)[<a class="el" href="structetl_1_1static__vector.html">N</a>], T(&amp;b)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept(<a class="el" href="structetl_1_1is__nothrow__swappable.html">etl::is_nothrow_swappable</a>&lt; T &gt;::value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:af5273f679984445be5233596370b7a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087e608dcade676ed1707b2780820b4b" id="r_a087e608dcade676ed1707b2780820b4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a087e608dcade676ed1707b2780820b4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a087e608dcade676ed1707b2780820b4b">as_const</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; add_const_t&lt; T &gt; &amp;</td></tr>
<tr class="memdesc:a087e608dcade676ed1707b2780820b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms lvalue reference to const type of t.  <br /></td></tr>
<tr class="separator:a087e608dcade676ed1707b2780820b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fcc8395221077570ae4d49d16fdfb5" id="r_a73fcc8395221077570ae4d49d16fdfb5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a73fcc8395221077570ae4d49d16fdfb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73fcc8395221077570ae4d49d16fdfb5">as_const</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a73fcc8395221077570ae4d49d16fdfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc67214aa9016de19ce8c56cacf050f" id="r_affc67214aa9016de19ce8c56cacf050f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:affc67214aa9016de19ce8c56cacf050f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affc67214aa9016de19ce8c56cacf050f">cmp_equal</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:affc67214aa9016de19ce8c56cacf050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:affc67214aa9016de19ce8c56cacf050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f8a2ce45cfed83d620b12d6271272f" id="r_ad7f8a2ce45cfed83d620b12d6271272f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:ad7f8a2ce45cfed83d620b12d6271272f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7f8a2ce45cfed83d620b12d6271272f">cmp_greater</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad7f8a2ce45cfed83d620b12d6271272f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:ad7f8a2ce45cfed83d620b12d6271272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdcd304a94bdadbaa2c7d6fb267e05b" id="r_a6fdcd304a94bdadbaa2c7d6fb267e05b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:a6fdcd304a94bdadbaa2c7d6fb267e05b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fdcd304a94bdadbaa2c7d6fb267e05b">cmp_greater_equal</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6fdcd304a94bdadbaa2c7d6fb267e05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:a6fdcd304a94bdadbaa2c7d6fb267e05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af465587d2f32a80939be1fad202d81a8" id="r_af465587d2f32a80939be1fad202d81a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:af465587d2f32a80939be1fad202d81a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af465587d2f32a80939be1fad202d81a8">cmp_less</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af465587d2f32a80939be1fad202d81a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:af465587d2f32a80939be1fad202d81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae910ff92e0c20546b3798e7acf0f62a4" id="r_ae910ff92e0c20546b3798e7acf0f62a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:ae910ff92e0c20546b3798e7acf0f62a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae910ff92e0c20546b3798e7acf0f62a4">cmp_less_equal</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae910ff92e0c20546b3798e7acf0f62a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:ae910ff92e0c20546b3798e7acf0f62a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693945b83d4561846bbf0b5944d0296e" id="r_a693945b83d4561846bbf0b5944d0296e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:a693945b83d4561846bbf0b5944d0296e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a693945b83d4561846bbf0b5944d0296e">cmp_not_equal</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a693945b83d4561846bbf0b5944d0296e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:a693945b83d4561846bbf0b5944d0296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1576e57ae3b113a38b8a9793bb4074" id="r_a7c1576e57ae3b113a38b8a9793bb4074"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U  = T&gt; </td></tr>
<tr class="memitem:a7c1576e57ae3b113a38b8a9793bb4074"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c1576e57ae3b113a38b8a9793bb4074">exchange</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">obj</a>, U &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">newValue</a>) noexcept(<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#ac0c249b3afd84019ec11170a1e06d267">etl::is_nothrow_assignable_v</a>&lt; T &amp;, U &gt;) -&gt; T</td></tr>
<tr class="memdesc:a7c1576e57ae3b113a38b8a9793bb4074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the value of obj with new_value and returns the old value of obj.  <br /></td></tr>
<tr class="separator:a7c1576e57ae3b113a38b8a9793bb4074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea04c6a544a650bcf6a7f88ff623c80f" id="r_aea04c6a544a650bcf6a7f88ff623c80f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aea04c6a544a650bcf6a7f88ff623c80f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea04c6a544a650bcf6a7f88ff623c80f">forward</a> (<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a>&lt; T &gt; &amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="memdesc:aea04c6a544a650bcf6a7f88ff623c80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards lvalues as either lvalues or as rvalues, depending on T. When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function.  <br /></td></tr>
<tr class="separator:aea04c6a544a650bcf6a7f88ff623c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7e67893a6b3c341ea0624e30e1d89d" id="r_a6a7e67893a6b3c341ea0624e30e1d89d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6a7e67893a6b3c341ea0624e30e1d89d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a7e67893a6b3c341ea0624e30e1d89d">forward</a> (<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a>&lt; T &gt; &amp;&amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="separator:a6a7e67893a6b3c341ea0624e30e1d89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881439150ce3ae249968cc8b15d6e31d" id="r_a881439150ce3ae249968cc8b15d6e31d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a881439150ce3ae249968cc8b15d6e31d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a881439150ce3ae249968cc8b15d6e31d">forward_like</a> (U &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:a881439150ce3ae249968cc8b15d6e31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27e213c027bfb11ed648fb543842995" id="r_ad27e213c027bfb11ed648fb543842995"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ad27e213c027bfb11ed648fb543842995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad27e213c027bfb11ed648fb543842995">ignore_unused</a> (<a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;...) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ad27e213c027bfb11ed648fb543842995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly ignore arguments or variables.  <br /></td></tr>
<tr class="separator:ad27e213c027bfb11ed648fb543842995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06254a010da20091fb04d67702c29da3" id="r_a06254a010da20091fb04d67702c29da3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires etl::detail::integer_and_not_char&lt;T&gt;</td></tr>
<tr class="memitem:a06254a010da20091fb04d67702c29da3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06254a010da20091fb04d67702c29da3">in_range</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a06254a010da20091fb04d67702c29da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss.  <br /></td></tr>
<tr class="separator:a06254a010da20091fb04d67702c29da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb87647bd4c378500cd694ccc0e4608" id="r_adeb87647bd4c378500cd694ccc0e4608"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adeb87647bd4c378500cd694ccc0e4608"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adeb87647bd4c378500cd694ccc0e4608">move</a> (T &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t</a>&lt; T &gt; &amp;&amp;</td></tr>
<tr class="memdesc:adeb87647bd4c378500cd694ccc0e4608"><td class="mdescLeft">&#160;</td><td class="mdescRight">move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.  <br /></td></tr>
<tr class="separator:adeb87647bd4c378500cd694ccc0e4608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae197a91f87223433229090889ab96734" id="r_ae197a91f87223433229090889ab96734"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae197a91f87223433229090889ab96734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae197a91f87223433229090889ab96734">move_if_noexcept</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="#a4ccf02556580259044928051b1689171">etl::conditional_t</a>&lt;!<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#a03f5da2852be4424089f4235ef44dec2">etl::is_copy_constructible_v</a>&lt; T &gt;, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, T &amp;&amp; &gt;</td></tr>
<tr class="memdesc:ae197a91f87223433229090889ab96734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally convert a value to an rvalue.  <br /></td></tr>
<tr class="separator:ae197a91f87223433229090889ab96734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1145f95a262f79865247b6744e474069" id="r_a1145f95a262f79865247b6744e474069"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a1145f95a262f79865247b6744e474069"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1145f95a262f79865247b6744e474069">pair</a> (<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>) -&gt; pair&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt;</td></tr>
<tr class="separator:a1145f95a262f79865247b6744e474069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74587901a0df261ba728e5fab73273de" id="r_a74587901a0df261ba728e5fab73273de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a74587901a0df261ba728e5fab73273de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74587901a0df261ba728e5fab73273de">swap</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a74587901a0df261ba728e5fab73273de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of x and y. Equivalent to x.swap(y).  <br /></td></tr>
<tr class="separator:a74587901a0df261ba728e5fab73273de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944300e491e850f5e82717c7a66b5463" id="r_a944300e491e850f5e82717c7a66b5463"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a944300e491e850f5e82717c7a66b5463"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a944300e491e850f5e82717c7a66b5463">make_pair</a> (<a class="el" href="structetl_1_1static__vector.html">T1</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">u</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a> &gt;, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt;</td></tr>
<tr class="memdesc:a944300e491e850f5e82717c7a66b5463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments.  <br /></td></tr>
<tr class="separator:a944300e491e850f5e82717c7a66b5463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb99a045aef160b997eab5178610a6a" id="r_a4eb99a045aef160b997eab5178610a6a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a4eb99a045aef160b997eab5178610a6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4eb99a045aef160b997eab5178610a6a">operator==</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a4eb99a045aef160b997eab5178610a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second.  <br /></td></tr>
<tr class="separator:a4eb99a045aef160b997eab5178610a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4f1579948c0050989b6bc4d56f0862" id="r_a1e4f1579948c0050989b6bc4d56f0862"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a1e4f1579948c0050989b6bc4d56f0862"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e4f1579948c0050989b6bc4d56f0862">operator&lt;</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1e4f1579948c0050989b6bc4d56f0862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a1e4f1579948c0050989b6bc4d56f0862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a36c94057cb8199ed38d8d08fd67ef5" id="r_a5a36c94057cb8199ed38d8d08fd67ef5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a5a36c94057cb8199ed38d8d08fd67ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a36c94057cb8199ed38d8d08fd67ef5">operator&lt;=</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5a36c94057cb8199ed38d8d08fd67ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a5a36c94057cb8199ed38d8d08fd67ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba18e7582c10621006e4e0cbc7ad4e4a" id="r_aba18e7582c10621006e4e0cbc7ad4e4a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:aba18e7582c10621006e4e0cbc7ad4e4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba18e7582c10621006e4e0cbc7ad4e4a">operator&gt;</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aba18e7582c10621006e4e0cbc7ad4e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:aba18e7582c10621006e4e0cbc7ad4e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f52394fdd7dcf3de62c6201ba727716" id="r_a8f52394fdd7dcf3de62c6201ba727716"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a8f52394fdd7dcf3de62c6201ba727716"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f52394fdd7dcf3de62c6201ba727716">operator&gt;=</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a8f52394fdd7dcf3de62c6201ba727716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a8f52394fdd7dcf3de62c6201ba727716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab277e7f8a028602ec26923ca3a4efe8e" id="r_ab277e7f8a028602ec26923ca3a4efe8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:ab277e7f8a028602ec26923ca3a4efe8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab277e7f8a028602ec26923ca3a4efe8e">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;p) noexcept -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt; &amp;</td></tr>
<tr class="memdesc:ab277e7f8a028602ec26923ca3a4efe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:ab277e7f8a028602ec26923ca3a4efe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2437363ad77d75596d13cf069467823c" id="r_a2437363ad77d75596d13cf069467823c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a2437363ad77d75596d13cf069467823c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2437363ad77d75596d13cf069467823c">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;p) noexcept -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a2437363ad77d75596d13cf069467823c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:a2437363ad77d75596d13cf069467823c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2afb17c2e9b1ec115692dd31cdf6574" id="r_af2afb17c2e9b1ec115692dd31cdf6574"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:af2afb17c2e9b1ec115692dd31cdf6574"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af2afb17c2e9b1ec115692dd31cdf6574">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;&amp;p) noexcept -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt; &amp;&amp;</td></tr>
<tr class="memdesc:af2afb17c2e9b1ec115692dd31cdf6574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:af2afb17c2e9b1ec115692dd31cdf6574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf3dcd4caaf2ac0322f3ee3dd4d5123" id="r_a8cf3dcd4caaf2ac0322f3ee3dd4d5123"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a8cf3dcd4caaf2ac0322f3ee3dd4d5123"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8cf3dcd4caaf2ac0322f3ee3dd4d5123">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;p) noexcept -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a8cf3dcd4caaf2ac0322f3ee3dd4d5123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:a8cf3dcd4caaf2ac0322f3ee3dd4d5123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad539af8c81b36e27d721d3df81ffe277" id="r_ad539af8c81b36e27d721d3df81ffe277"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:ad539af8c81b36e27d721d3df81ffe277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad539af8c81b36e27d721d3df81ffe277">swap</a> (T &amp;a, T &amp;b) noexcept(<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#ad26f59ba1b8a873f9d8374f72a4002c4">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ad539af8c81b36e27d721d3df81ffe277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:ad539af8c81b36e27d721d3df81ffe277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ff5eb0624cb9e7995b622dc0c7e7c4" id="r_a23ff5eb0624cb9e7995b622dc0c7e7c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="#a6a08681ad0c17b00662bfd185a081335">etl::is_swappable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a23ff5eb0624cb9e7995b622dc0c7e7c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23ff5eb0624cb9e7995b622dc0c7e7c4">swap</a> (T(&amp;a)[<a class="el" href="structetl_1_1static__vector.html">N</a>], T(&amp;b)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept(<a class="el" href="structetl_1_1is__nothrow__swappable.html">etl::is_nothrow_swappable</a>&lt; T &gt;::value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a23ff5eb0624cb9e7995b622dc0c7e7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4b8c890cb36df65940f4a0e4a65c11" id="r_abd4b8c890cb36df65940f4a0e4a65c11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Enum</a> &gt; </td></tr>
<tr class="memitem:abd4b8c890cb36df65940f4a0e4a65c11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd4b8c890cb36df65940f4a0e4a65c11">to_underlying</a> (<a class="el" href="structetl_1_1static__vector.html">Enum</a> e) noexcept -&gt; <a class="el" href="#aa68cdd3b170a7e28ceeb562ad04c2853">underlying_type_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Enum</a> &gt;</td></tr>
<tr class="memdesc:abd4b8c890cb36df65940f4a0e4a65c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an enumeration to its underlying type.  <br /></td></tr>
<tr class="separator:abd4b8c890cb36df65940f4a0e4a65c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb16b244632f4ab5f6fd117e5a75473e" id="r_abb16b244632f4ab5f6fd117e5a75473e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb16b244632f4ab5f6fd117e5a75473e">unreachable</a> () -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:abb16b244632f4ab5f6fd117e5a75473e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabca2e2f91841c82fb5ef20995a618bb" id="r_aabca2e2f91841c82fb5ef20995a618bb"><td class="memTemplParams" colspan="2">template&lt;typename... Functor&gt; </td></tr>
<tr class="memitem:aabca2e2f91841c82fb5ef20995a618bb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aabca2e2f91841c82fb5ef20995a618bb">overload</a> (Functor...) -&gt; overload&lt; Functor... &gt;</td></tr>
<tr class="separator:aabca2e2f91841c82fb5ef20995a618bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e628f780bfbbf89e9f0da6cf5618119" id="r_a3e628f780bfbbf89e9f0da6cf5618119"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; <br />
requires (detail::enable_variant_swap&lt;Ts...&gt;)</td></tr>
<tr class="memitem:a3e628f780bfbbf89e9f0da6cf5618119"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e628f780bfbbf89e9f0da6cf5618119">swap</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a3e628f780bfbbf89e9f0da6cf5618119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the swap algorithm for variant. Effectively calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:a3e628f780bfbbf89e9f0da6cf5618119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d7bafd4ecb42d30d7d36e365f682be" id="r_a45d7bafd4ecb42d30d7d36e365f682be"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a45d7bafd4ecb42d30d7d36e365f682be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45d7bafd4ecb42d30d7d36e365f682be">operator==</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a45d7bafd4ecb42d30d7d36e365f682be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for variants:  <br /></td></tr>
<tr class="separator:a45d7bafd4ecb42d30d7d36e365f682be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55affb9576fb30baf867b77b555ede5" id="r_af55affb9576fb30baf867b77b555ede5"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:af55affb9576fb30baf867b77b555ede5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af55affb9576fb30baf867b77b555ede5">operator!=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af55affb9576fb30baf867b77b555ede5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for variants:  <br /></td></tr>
<tr class="separator:af55affb9576fb30baf867b77b555ede5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4b49e8a7cdad02ea4b40262696823b" id="r_a5c4b49e8a7cdad02ea4b40262696823b"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a5c4b49e8a7cdad02ea4b40262696823b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c4b49e8a7cdad02ea4b40262696823b">operator&lt;</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5c4b49e8a7cdad02ea4b40262696823b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator for variants:  <br /></td></tr>
<tr class="separator:a5c4b49e8a7cdad02ea4b40262696823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19fbbd41ee93e65de08e2fb612fcc68" id="r_ae19fbbd41ee93e65de08e2fb612fcc68"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ae19fbbd41ee93e65de08e2fb612fcc68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae19fbbd41ee93e65de08e2fb612fcc68">operator&lt;=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae19fbbd41ee93e65de08e2fb612fcc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-equal operator for variants:  <br /></td></tr>
<tr class="separator:ae19fbbd41ee93e65de08e2fb612fcc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf3e8f7f74e37975ead5180217c9f2d" id="r_a5bf3e8f7f74e37975ead5180217c9f2d"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a5bf3e8f7f74e37975ead5180217c9f2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5bf3e8f7f74e37975ead5180217c9f2d">operator&gt;</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5bf3e8f7f74e37975ead5180217c9f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator for variants:  <br /></td></tr>
<tr class="separator:a5bf3e8f7f74e37975ead5180217c9f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfa9331f97be0eee2c56c17b53ac6ef" id="r_a6bfa9331f97be0eee2c56c17b53ac6ef"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a6bfa9331f97be0eee2c56c17b53ac6ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6bfa9331f97be0eee2c56c17b53ac6ef">operator&gt;=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6bfa9331f97be0eee2c56c17b53ac6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-equal operator for variants:  <br /></td></tr>
<tr class="separator:a6bfa9331f97be0eee2c56c17b53ac6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab330d47780e2692b931342bfaefe1223" id="r_ab330d47780e2692b931342bfaefe1223"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Ts&gt; </td></tr>
<tr class="memitem:ab330d47780e2692b931342bfaefe1223"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab330d47780e2692b931342bfaefe1223">holds_alternative</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab330d47780e2692b931342bfaefe1223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Ts...  <br /></td></tr>
<tr class="separator:ab330d47780e2692b931342bfaefe1223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9def1cedb7034b01e6cffb68531adbd3" id="r_a9def1cedb7034b01e6cffb68531adbd3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a9def1cedb7034b01e6cffb68531adbd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9def1cedb7034b01e6cffb68531adbd3">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td></tr>
<tr class="memdesc:a9def1cedb7034b01e6cffb68531adbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <br /></td></tr>
<tr class="separator:a9def1cedb7034b01e6cffb68531adbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac615a5375ea02af1dee73be6ba9c605c" id="r_ac615a5375ea02af1dee73be6ba9c605c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:ac615a5375ea02af1dee73be6ba9c605c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac615a5375ea02af1dee73be6ba9c605c">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:ac615a5375ea02af1dee73be6ba9c605c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <br /></td></tr>
<tr class="separator:ac615a5375ea02af1dee73be6ba9c605c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a93d951b4c9c54a4e94d4380874a4f" id="r_aa4a93d951b4c9c54a4e94d4380874a4f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:aa4a93d951b4c9c54a4e94d4380874a4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4a93d951b4c9c54a4e94d4380874a4f">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td></tr>
<tr class="memdesc:aa4a93d951b4c9c54a4e94d4380874a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <br /></td></tr>
<tr class="separator:aa4a93d951b4c9c54a4e94d4380874a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcf60de77d9b1ad3d568505f3916fe2" id="r_a5dcf60de77d9b1ad3d568505f3916fe2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a5dcf60de77d9b1ad3d568505f3916fe2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5dcf60de77d9b1ad3d568505f3916fe2">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a5dcf60de77d9b1ad3d568505f3916fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <br /></td></tr>
<tr class="separator:a5dcf60de77d9b1ad3d568505f3916fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2481ba64051d1ccdbcef2661bdd51e" id="r_a0f2481ba64051d1ccdbcef2661bdd51e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a0f2481ba64051d1ccdbcef2661bdd51e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f2481ba64051d1ccdbcef2661bdd51e">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; *<a class="el" href="structetl_1_1static__vector.html">pv</a>) noexcept -&gt; add_pointer_t&lt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a0f2481ba64051d1ccdbcef2661bdd51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant.  <br /></td></tr>
<tr class="separator:a0f2481ba64051d1ccdbcef2661bdd51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f5dc629dca8570d215cdbae7b9b5b6" id="r_af4f5dc629dca8570d215cdbae7b9b5b6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:af4f5dc629dca8570d215cdbae7b9b5b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4f5dc629dca8570d215cdbae7b9b5b6">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">pv</a>) noexcept -&gt; add_pointer_t&lt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td></tr>
<tr class="memdesc:af4f5dc629dca8570d215cdbae7b9b5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant.  <br /></td></tr>
<tr class="separator:af4f5dc629dca8570d215cdbae7b9b5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f52b9d8c7ffe776affe797a23d8e891" id="r_a6f52b9d8c7ffe776affe797a23d8e891"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a6f52b9d8c7ffe776affe797a23d8e891"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f52b9d8c7ffe776affe797a23d8e891">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; &amp;</td></tr>
<tr class="memdesc:a6f52b9d8c7ffe776affe797a23d8e891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <br /></td></tr>
<tr class="separator:a6f52b9d8c7ffe776affe797a23d8e891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc3bfdddd4c9eb6b16837669c20bcf9" id="r_a7dc3bfdddd4c9eb6b16837669c20bcf9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a7dc3bfdddd4c9eb6b16837669c20bcf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7dc3bfdddd4c9eb6b16837669c20bcf9">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; &amp;&amp;</td></tr>
<tr class="memdesc:a7dc3bfdddd4c9eb6b16837669c20bcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <br /></td></tr>
<tr class="separator:a7dc3bfdddd4c9eb6b16837669c20bcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037eb5fb1f902ba9d35e91b47d543769" id="r_a037eb5fb1f902ba9d35e91b47d543769"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a037eb5fb1f902ba9d35e91b47d543769"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a037eb5fb1f902ba9d35e91b47d543769">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a037eb5fb1f902ba9d35e91b47d543769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <br /></td></tr>
<tr class="separator:a037eb5fb1f902ba9d35e91b47d543769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a1d9307c3f9941d2b8a832e99f1545" id="r_af3a1d9307c3f9941d2b8a832e99f1545"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:af3a1d9307c3f9941d2b8a832e99f1545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3a1d9307c3f9941d2b8a832e99f1545">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:af3a1d9307c3f9941d2b8a832e99f1545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <br /></td></tr>
<tr class="separator:af3a1d9307c3f9941d2b8a832e99f1545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab593d0e7f5e1e82da5a98d921d487" id="r_a78ab593d0e7f5e1e82da5a98d921d487"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a78ab593d0e7f5e1e82da5a98d921d487"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78ab593d0e7f5e1e82da5a98d921d487">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td></tr>
<tr class="separator:a78ab593d0e7f5e1e82da5a98d921d487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff941f61a7e71248259c33337096242" id="r_abff941f61a7e71248259c33337096242"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:abff941f61a7e71248259c33337096242"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abff941f61a7e71248259c33337096242">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:abff941f61a7e71248259c33337096242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab304b469a80b085a06f00b3500925f1" id="r_aab304b469a80b085a06f00b3500925f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:aab304b469a80b085a06f00b3500925f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab304b469a80b085a06f00b3500925f1">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:aab304b469a80b085a06f00b3500925f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac24a4d3cd8d624ac5ff2bc055f2e85" id="r_abac24a4d3cd8d624ac5ff2bc055f2e85"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:abac24a4d3cd8d624ac5ff2bc055f2e85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abac24a4d3cd8d624ac5ff2bc055f2e85">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="separator:abac24a4d3cd8d624ac5ff2bc055f2e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade109c386a760b9572261c6afe7dbdf8" id="r_ade109c386a760b9572261c6afe7dbdf8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </td></tr>
<tr class="memitem:ade109c386a760b9572261c6afe7dbdf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade109c386a760b9572261c6afe7dbdf8">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; *<a class="el" href="structetl_1_1static__vector.html">pv</a>) noexcept -&gt; add_pointer_t&lt; T &gt;</td></tr>
<tr class="separator:ade109c386a760b9572261c6afe7dbdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2d2fedb0567e3c7742e87fd799b82c" id="r_ade2d2fedb0567e3c7742e87fd799b82c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </td></tr>
<tr class="memitem:ade2d2fedb0567e3c7742e87fd799b82c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade2d2fedb0567e3c7742e87fd799b82c">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">pv</a>) noexcept -&gt; add_pointer_t&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td></tr>
<tr class="separator:ade2d2fedb0567e3c7742e87fd799b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f45e7a98a49bac4a0e8006a9c784f8a" id="r_a2f45e7a98a49bac4a0e8006a9c784f8a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Vs&gt; </td></tr>
<tr class="memitem:a2f45e7a98a49bac4a0e8006a9c784f8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f45e7a98a49bac4a0e8006a9c784f8a">visit</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1static__vector.html">Vs</a> &amp;&amp;... <a class="el" href="structetl_1_1static__vector.html">vs</a>)</td></tr>
<tr class="memdesc:a2f45e7a98a49bac4a0e8006a9c784f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the visitor vis (Callable that can be called with any combination of types from variants) to the variants vars.  <br /></td></tr>
<tr class="separator:a2f45e7a98a49bac4a0e8006a9c784f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1059d0a7b563d13c9d599eea27ca489e" id="r_a1059d0a7b563d13c9d599eea27ca489e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a1059d0a7b563d13c9d599eea27ca489e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1059d0a7b563d13c9d599eea27ca489e">swap</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a1059d0a7b563d13c9d599eea27ca489e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">static_vector</a>. Swaps the contents of lhs and rhs.  <br /></td></tr>
<tr class="separator:a1059d0a7b563d13c9d599eea27ca489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287ee2e9239c563f862cb177ec7d5792" id="r_a287ee2e9239c563f862cb177ec7d5792"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a287ee2e9239c563f862cb177ec7d5792"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a287ee2e9239c563f862cb177ec7d5792">operator==</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a287ee2e9239c563f862cb177ec7d5792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors.  <br /></td></tr>
<tr class="separator:a287ee2e9239c563f862cb177ec7d5792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473df8e3ace08ad49d812cd57fcc5f90" id="r_a473df8e3ace08ad49d812cd57fcc5f90"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a473df8e3ace08ad49d812cd57fcc5f90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a473df8e3ace08ad49d812cd57fcc5f90">operator!=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a473df8e3ace08ad49d812cd57fcc5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab892f9c1b557a16dd61daa9664feafda" id="r_ab892f9c1b557a16dd61daa9664feafda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ab892f9c1b557a16dd61daa9664feafda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab892f9c1b557a16dd61daa9664feafda">operator&lt;</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab892f9c1b557a16dd61daa9664feafda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors.  <br /></td></tr>
<tr class="separator:ab892f9c1b557a16dd61daa9664feafda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894460b393d2ac20c8b8f033322ff230" id="r_a894460b393d2ac20c8b8f033322ff230"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a894460b393d2ac20c8b8f033322ff230"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a894460b393d2ac20c8b8f033322ff230">operator&lt;=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a894460b393d2ac20c8b8f033322ff230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab897f8f3641b27de2e08d2d16563a2c2" id="r_ab897f8f3641b27de2e08d2d16563a2c2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ab897f8f3641b27de2e08d2d16563a2c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab897f8f3641b27de2e08d2d16563a2c2">operator&gt;</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ab897f8f3641b27de2e08d2d16563a2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5beff690dcaa87cb11a10e760c1d0211" id="r_a5beff690dcaa87cb11a10e760c1d0211"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a5beff690dcaa87cb11a10e760c1d0211"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5beff690dcaa87cb11a10e760c1d0211">operator&gt;=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a5beff690dcaa87cb11a10e760c1d0211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae66b21dd10f996a2782e6e8b604593" id="r_a9ae66b21dd10f996a2782e6e8b604593"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a9ae66b21dd10f996a2782e6e8b604593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ae66b21dd10f996a2782e6e8b604593">erase_if</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;c, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;::size_type</td></tr>
<tr class="memdesc:a9ae66b21dd10f996a2782e6e8b604593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container.  <br /></td></tr>
<tr class="separator:a9ae66b21dd10f996a2782e6e8b604593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e72fc74a7231310049a5cb0790c765" id="r_ab2e72fc74a7231310049a5cb0790c765"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ab2e72fc74a7231310049a5cb0790c765"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2e72fc74a7231310049a5cb0790c765">erase</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;c, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;::size_type</td></tr>
<tr class="separator:ab2e72fc74a7231310049a5cb0790c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5914a0a90f9a279328bcadc57b7ce090" id="r_a5914a0a90f9a279328bcadc57b7ce090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">consteval</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5914a0a90f9a279328bcadc57b7ce090">is_hosted</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a5914a0a90f9a279328bcadc57b7ce090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf6fdfc0878be3154d7671edc95de7f" id="r_adcf6fdfc0878be3154d7671edc95de7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">consteval</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf6fdfc0878be3154d7671edc95de7f">is_freestanding</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:adcf6fdfc0878be3154d7671edc95de7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1ef9857ea2d2e84bd3c311d0ccc92f" id="r_aaf1ef9857ea2d2e84bd3c311d0ccc92f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf1ef9857ea2d2e84bd3c311d0ccc92f">operator==</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aaf1ef9857ea2d2e84bd3c311d0ccc92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares language_standards.  <br /></td></tr>
<tr class="separator:aaf1ef9857ea2d2e84bd3c311d0ccc92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7d0d2c778d8ba04d8b73a77fec5d83" id="r_afd7d0d2c778d8ba04d8b73a77fec5d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd7d0d2c778d8ba04d8b73a77fec5d83">operator!=</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:afd7d0d2c778d8ba04d8b73a77fec5d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3d8b9402fd47ee81c43ca9621035b7" id="r_acc3d8b9402fd47ee81c43ca9621035b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc3d8b9402fd47ee81c43ca9621035b7">operator&lt;</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:acc3d8b9402fd47ee81c43ca9621035b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8fec49a7e24b2cb1f6dc5b738b1daa" id="r_a4e8fec49a7e24b2cb1f6dc5b738b1daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e8fec49a7e24b2cb1f6dc5b738b1daa">operator&lt;=</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a4e8fec49a7e24b2cb1f6dc5b738b1daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f071a704146a7adbb1dc8186e6cd184" id="r_a5f071a704146a7adbb1dc8186e6cd184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f071a704146a7adbb1dc8186e6cd184">operator&gt;</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a5f071a704146a7adbb1dc8186e6cd184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a11fea942b05530889b9e1944f07147" id="r_a9a11fea942b05530889b9e1944f07147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a11fea942b05530889b9e1944f07147">operator&gt;=</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a9a11fea942b05530889b9e1944f07147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga6643f5ca84c6579040caeeb9079e0c3a" id="r_ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga6643f5ca84c6579040caeeb9079e0c3a">adjacent_find</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf6853a6729fd97ca2688e2ce192273" id="r_ga5bf6853a6729fd97ca2688e2ce192273"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga5bf6853a6729fd97ca2688e2ce192273"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5bf6853a6729fd97ca2688e2ce192273">adjacent_find</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:ga5bf6853a6729fd97ca2688e2ce192273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga068d12997d2db7789f5feeee67ba6632" id="r_ga068d12997d2db7789f5feeee67ba6632"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga068d12997d2db7789f5feeee67ba6632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga068d12997d2db7789f5feeee67ba6632">all_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga068d12997d2db7789f5feeee67ba6632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga068d12997d2db7789f5feeee67ba6632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaeab7423807619552d4187d28ced39b9a" id="r_gaeab7423807619552d4187d28ced39b9a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gaeab7423807619552d4187d28ced39b9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaeab7423807619552d4187d28ced39b9a">any_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gaeab7423807619552d4187d28ced39b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gaeab7423807619552d4187d28ced39b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga518c4f26f6b475c9ba5b742ca6202a05" id="r_ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga518c4f26f6b475c9ba5b742ca6202a05">binary_search</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga518c4f26f6b475c9ba5b742ca6202a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>.  <br /></td></tr>
<tr class="separator:ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd7d82f1e1253083d060c08049cb64b" id="r_ga5bd7d82f1e1253083d060c08049cb64b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga5bd7d82f1e1253083d060c08049cb64b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5bd7d82f1e1253083d060c08049cb64b">binary_search</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ga5bd7d82f1e1253083d060c08049cb64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga11d3f8f2170e346ec527e33ba981a2ae" id="r_ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga11d3f8f2170e346ec527e33ba981a2ae">bubble_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aaad8ffc58779f75d6ce3d017dd3cb4" id="r_ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1aaad8ffc58779f75d6ce3d017dd3cb4">bubble_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga72ad3fc1cb6d967df6a52c8e61030f75" id="r_ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga72ad3fc1cb6d967df6a52c8e61030f75">clamp</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lo</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">hi</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <br /></td></tr>
<tr class="separator:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e0d6f4937eef794486e125996b6ce1" id="r_gac2e0d6f4937eef794486e125996b6ce1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:gac2e0d6f4937eef794486e125996b6ce1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gac2e0d6f4937eef794486e125996b6ce1">clamp</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lo</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">hi</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:gac2e0d6f4937eef794486e125996b6ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga9f9b625e56c5ddcc87c1b813687215cd" id="r_ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga9f9b625e56c5ddcc87c1b813687215cd">copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga3807f7eadedf61cbd5fcbed1fd59d087" id="r_ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> &gt; </td></tr>
<tr class="memitem:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga3807f7eadedf61cbd5fcbed1fd59d087">copy_backward</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> <a class="el" href="structetl_1_1static__vector.html">dLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a></td></tr>
<tr class="memdesc:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga0ed613dd207fcb8dad486fd471d90af0" id="r_ga0ed613dd207fcb8dad486fd471d90af0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Pred</a> &gt; </td></tr>
<tr class="memitem:ga0ed613dd207fcb8dad486fd471d90af0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga0ed613dd207fcb8dad486fd471d90af0">copy_if</a> (<a class="el" href="structetl_1_1static__vector.html">InIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutIt</a> <a class="el" href="structetl_1_1static__vector.html">dFirst</a>, <a class="el" href="structetl_1_1static__vector.html">Pred</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutIt</a></td></tr>
<tr class="memdesc:ga0ed613dd207fcb8dad486fd471d90af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:ga0ed613dd207fcb8dad486fd471d90af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gae848a2fb9566a7471c52d02d108a87e6" id="r_gae848a2fb9566a7471c52d02d108a87e6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:gae848a2fb9566a7471c52d02d108a87e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gae848a2fb9566a7471c52d02d108a87e6">copy_n</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="#acf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">result</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:gae848a2fb9566a7471c52d02d108a87e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <br /></td></tr>
<tr class="separator:gae848a2fb9566a7471c52d02d108a87e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gadf36ef6fdcb46c9ad8060d4520016096" id="r_gadf36ef6fdcb46c9ad8060d4520016096"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gadf36ef6fdcb46c9ad8060d4520016096"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gadf36ef6fdcb46c9ad8060d4520016096">count_if</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type</td></tr>
<tr class="memdesc:gadf36ef6fdcb46c9ad8060d4520016096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:gadf36ef6fdcb46c9ad8060d4520016096"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad6cb779fe6050798f469e14a06f4412e" id="r_ad6cb779fe6050798f469e14a06f4412e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad6cb779fe6050798f469e14a06f4412e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6cb779fe6050798f469e14a06f4412e">is_bitmask_type_v</a> = <a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad6cb779fe6050798f469e14a06f4412e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb794742f9815f88d6c2291181dc2501" id="r_abb794742f9815f88d6c2291181dc2501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb794742f9815f88d6c2291181dc2501">binary</a> = <a class="el" href="structetl_1_1binary__t.html">binary_t</a>{}</td></tr>
<tr class="separator:abb794742f9815f88d6c2291181dc2501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88c83d30ae1d2a54dd8438da2038aab" id="r_ae88c83d30ae1d2a54dd8438da2038aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="attributes_8hpp.html#a6cf990edeb7f9f6f1b5928471cef5e56">TETL_MAY_ALIAS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">byte</a></td></tr>
<tr class="memdesc:ae88c83d30ae1d2a54dd8438da2038aab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a> is a distinct type that implements the concept of byte as specified in the C++ language definition.  <br /></td></tr>
<tr class="separator:ae88c83d30ae1d2a54dd8438da2038aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba873a97be10ad8146b06a01a9694b9c" id="r_aba873a97be10ad8146b06a01a9694b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba873a97be10ad8146b06a01a9694b9c">sorted_unique</a> = <a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a>{}</td></tr>
<tr class="separator:aba873a97be10ad8146b06a01a9694b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e287e878604ddef97548a69df3bb24" id="r_af6e287e878604ddef97548a69df3bb24"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af6e287e878604ddef97548a69df3bb24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6e287e878604ddef97548a69df3bb24">is_placeholder_v</a> = <a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af6e287e878604ddef97548a69df3bb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1903f5208bf0e496f112e85dd1915de8" id="r_a1903f5208bf0e496f112e85dd1915de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1903f5208bf0e496f112e85dd1915de8">allocator_arg</a> {}</td></tr>
<tr class="memdesc:a1903f5208bf0e496f112e85dd1915de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator_arg is a constant of type <a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects.  <br /></td></tr>
<tr class="separator:a1903f5208bf0e496f112e85dd1915de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb779f5e8046c7d141522c238bc2764" id="r_a2eb779f5e8046c7d141522c238bc2764"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Alloc</a> &gt; </td></tr>
<tr class="memitem:a2eb779f5e8046c7d141522c238bc2764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2eb779f5e8046c7d141522c238bc2764">uses_allocator_v</a> = <a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Alloc</a>&gt;::value</td></tr>
<tr class="memdesc:a2eb779f5e8046c7d141522c238bc2764"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false.  <br /></td></tr>
<tr class="separator:a2eb779f5e8046c7d141522c238bc2764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49e3304c1cd20a376c9bd1758dd13bd" id="r_ac49e3304c1cd20a376c9bd1758dd13bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac49e3304c1cd20a376c9bd1758dd13bd">destroying_delete</a> = <a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a>{}</td></tr>
<tr class="memdesc:ac49e3304c1cd20a376c9bd1758dd13bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to identify the destroying delete form of operator delete.  <br /></td></tr>
<tr class="separator:ac49e3304c1cd20a376c9bd1758dd13bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968338cd15fb1036406d2b3c8cb5b591" id="r_a968338cd15fb1036406d2b3c8cb5b591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a968338cd15fb1036406d2b3c8cb5b591">hardware_constructive_interference_size</a> = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td></tr>
<tr class="memdesc:a968338cd15fb1036406d2b3c8cb5b591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum offset between two objects to avoid false sharing. Guaranteed to be at least alignof(max_align_t).  <br /></td></tr>
<tr class="separator:a968338cd15fb1036406d2b3c8cb5b591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9464e19a95c1baba9554e5ae2c2af6" id="r_acf9464e19a95c1baba9554e5ae2c2af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9464e19a95c1baba9554e5ae2c2af6">hardware_destructive_interference_size</a> = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td></tr>
<tr class="memdesc:acf9464e19a95c1baba9554e5ae2c2af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least alignof(max_align_t).  <br /></td></tr>
<tr class="separator:acf9464e19a95c1baba9554e5ae2c2af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9706e5f8dbc47772797c3f13cfd73517" id="r_a9706e5f8dbc47772797c3f13cfd73517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9706e5f8dbc47772797c3f13cfd73517">nothrow</a> = <a class="el" href="structetl_1_1nothrow__t.html">etl::nothrow_t</a>{}</td></tr>
<tr class="memdesc:a9706e5f8dbc47772797c3f13cfd73517"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a9706e5f8dbc47772797c3f13cfd73517" title="etl::nothrow is a constant of type etl::nothrow_t used to disambiguate the overloads of throwing and ...">etl::nothrow</a> is a constant of type <a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> used to disambiguate the overloads of throwing and non-throwing allocation functions.  <br /></td></tr>
<tr class="separator:a9706e5f8dbc47772797c3f13cfd73517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd293644b847dc4549de80a090d66625" id="r_acd293644b847dc4549de80a090d66625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd293644b847dc4549de80a090d66625">nullopt</a> = <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>{{}}</td></tr>
<tr class="memdesc:acd293644b847dc4549de80a090d66625"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#acd293644b847dc4549de80a090d66625" title="etl::nullopt is a constant of type etl::nullopt_t that is used to indicate optional type with uniniti...">etl::nullopt</a> is a constant of type <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> that is used to indicate optional type with uninitialized state.  <br /></td></tr>
<tr class="separator:acd293644b847dc4549de80a090d66625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad13c7dc384ea307cfe91df7962930245" id="r_gad13c7dc384ea307cfe91df7962930245"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:gad13c7dc384ea307cfe91df7962930245"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#gad13c7dc384ea307cfe91df7962930245">ratio_greater_v</a> = <a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R1</a>, <a class="el" href="structetl_1_1static__vector.html">R2</a>&gt;::value</td></tr>
<tr class="separator:gad13c7dc384ea307cfe91df7962930245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5454788945776aa1ad4dffd76424c4" id="r_ga3a5454788945776aa1ad4dffd76424c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga3a5454788945776aa1ad4dffd76424c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga3a5454788945776aa1ad4dffd76424c4">ratio_less_v</a> = <a class="el" href="structetl_1_1ratio__less.html">ratio_less</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R1</a>, <a class="el" href="structetl_1_1static__vector.html">R2</a>&gt;::value</td></tr>
<tr class="separator:ga3a5454788945776aa1ad4dffd76424c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99eac87936526440c95e617b0e50ce24" id="r_ga99eac87936526440c95e617b0e50ce24"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga99eac87936526440c95e617b0e50ce24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga99eac87936526440c95e617b0e50ce24">ratio_less_equal_v</a> = <a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R1</a>, <a class="el" href="structetl_1_1static__vector.html">R2</a>&gt;::value</td></tr>
<tr class="separator:ga99eac87936526440c95e617b0e50ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b36293d12b31aee914984591aa28e3" id="r_ga87b36293d12b31aee914984591aa28e3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga87b36293d12b31aee914984591aa28e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga87b36293d12b31aee914984591aa28e3">ratio_not_equal_v</a> = <a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R1</a>, <a class="el" href="structetl_1_1static__vector.html">R2</a>&gt;::value</td></tr>
<tr class="separator:ga87b36293d12b31aee914984591aa28e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dd54e001e852c457b3b78bec3f9439" id="r_a12dd54e001e852c457b3b78bec3f9439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12dd54e001e852c457b3b78bec3f9439">element_aligned</a> {}</td></tr>
<tr class="separator:a12dd54e001e852c457b3b78bec3f9439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b3f0cc9d6b62d223bde4e4ce670e9f" id="r_a47b3f0cc9d6b62d223bde4e4ce670e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b3f0cc9d6b62d223bde4e4ce670e9f">vector_aligned</a> {}</td></tr>
<tr class="separator:a47b3f0cc9d6b62d223bde4e4ce670e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94295cec56b880883c5b127dbf8dacd9" id="r_a94295cec56b880883c5b127dbf8dacd9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:a94295cec56b880883c5b127dbf8dacd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94295cec56b880883c5b127dbf8dacd9">overaligned</a> {}</td></tr>
<tr class="separator:a94295cec56b880883c5b127dbf8dacd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e7be40fea564f0c1fe3d11229ef0f8" id="r_ga22e7be40fea564f0c1fe3d11229ef0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__span.html#ga22e7be40fea564f0c1fe3d11229ef0f8">dynamic_extent</a> = <a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&gt;<a class="el" href="#a5f3eca1793f7f38aeb756464984eb194">::max</a>()</td></tr>
<tr class="memdesc:ga22e7be40fea564f0c1fe3d11229ef0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__span.html#ga22e7be40fea564f0c1fe3d11229ef0f8" title="etl::dynamic_extent is a constant of type etl::size_t that is used to differentiate etl::span of stat...">etl::dynamic_extent</a> is a constant of type <a class="el" href="#aee50235c04ef643cb7502785393220fe" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> that is used to differentiate <a class="el" href="structetl_1_1span.html" title="A non-owning view over a contiguous sequence of objects.">etl::span</a> of static and dynamic extent.  <br /></td></tr>
<tr class="separator:ga22e7be40fea564f0c1fe3d11229ef0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5895291aecd11c1e854ea1cdaac5d7c9" id="r_a5895291aecd11c1e854ea1cdaac5d7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> etl::ignore&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5895291aecd11c1e854ea1cdaac5d7c9">ignore</a></td></tr>
<tr class="separator:a5895291aecd11c1e854ea1cdaac5d7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad99d6adeb2c1d8530bf9204f34aab4" id="r_a5ad99d6adeb2c1d8530bf9204f34aab4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5ad99d6adeb2c1d8530bf9204f34aab4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ad99d6adeb2c1d8530bf9204f34aab4">is_tuple_like</a> = <a class="el" href="structetl_1_1static__vector.html">false</a></td></tr>
<tr class="separator:a5ad99d6adeb2c1d8530bf9204f34aab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bccb49e0b1f811bb51be4f782a5b6c6" id="r_a4bccb49e0b1f811bb51be4f782a5b6c6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4bccb49e0b1f811bb51be4f782a5b6c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4bccb49e0b1f811bb51be4f782a5b6c6">tuple_size_v</a> = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4bccb49e0b1f811bb51be4f782a5b6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0319c290d41e45e5190db6169c188724" id="r_a0319c290d41e45e5190db6169c188724"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0319c290d41e45e5190db6169c188724"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0319c290d41e45e5190db6169c188724">alignment_of_v</a> = <a class="el" href="structetl_1_1alignment__of.html">etl::alignment_of</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0319c290d41e45e5190db6169c188724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b52772010dec87f8867320a8b03dfc" id="r_a92b52772010dec87f8867320a8b03dfc"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a92b52772010dec87f8867320a8b03dfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92b52772010dec87f8867320a8b03dfc">always_false</a> = <a class="el" href="structetl_1_1static__vector.html">false</a></td></tr>
<tr class="separator:a92b52772010dec87f8867320a8b03dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5672914b2f1f9c1c4c50ded53a8db2e3" id="r_a5672914b2f1f9c1c4c50ded53a8db2e3"><td class="memTemplParams" colspan="2">template&lt;typename... B&gt; </td></tr>
<tr class="memitem:a5672914b2f1f9c1c4c50ded53a8db2e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5672914b2f1f9c1c4c50ded53a8db2e3">conjunction_v</a> = (B::value &amp;&amp; ...)</td></tr>
<tr class="separator:a5672914b2f1f9c1c4c50ded53a8db2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3abcd15bf9ea4a0629b7e03498e1e1" id="r_abb3abcd15bf9ea4a0629b7e03498e1e1"><td class="memTemplParams" colspan="2">template&lt;typename... B&gt; </td></tr>
<tr class="memitem:abb3abcd15bf9ea4a0629b7e03498e1e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb3abcd15bf9ea4a0629b7e03498e1e1">disjunction_v</a> = (B::value || ...)</td></tr>
<tr class="separator:abb3abcd15bf9ea4a0629b7e03498e1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06332dc22e85765f2c195c703cc49068" id="r_a06332dc22e85765f2c195c703cc49068"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">unsigned</a> N = 0&gt; </td></tr>
<tr class="memitem:a06332dc22e85765f2c195c703cc49068"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06332dc22e85765f2c195c703cc49068">extent_v</a> = <a class="el" href="structetl_1_1static__vector.html">static_cast</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt;(<a class="el" href="structetl_1_1extent.html">extent</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">N</a>&gt;::value)</td></tr>
<tr class="separator:a06332dc22e85765f2c195c703cc49068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a77036b20d94554de76a0879573e1" id="r_a4c5a77036b20d94554de76a0879573e1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4c5a77036b20d94554de76a0879573e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c5a77036b20d94554de76a0879573e1">has_unique_object_representations_v</a> = <a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4c5a77036b20d94554de76a0879573e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e997395a99be7b3ac747230c82b51d2" id="r_a7e997395a99be7b3ac747230c82b51d2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7e997395a99be7b3ac747230c82b51d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e997395a99be7b3ac747230c82b51d2">has_virtual_destructor_v</a> = <a class="el" href="structetl_1_1static__vector.html">__has_virtual_destructor</a>(T)</td></tr>
<tr class="memdesc:a7e997395a99be7b3ac747230c82b51d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <br /></td></tr>
<tr class="separator:a7e997395a99be7b3ac747230c82b51d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6eea4e711c17c5bb6f7e8af9c7effc" id="r_a0a6eea4e711c17c5bb6f7e8af9c7effc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I&gt; </td></tr>
<tr class="memitem:a0a6eea4e711c17c5bb6f7e8af9c7effc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a6eea4e711c17c5bb6f7e8af9c7effc">index_c</a> = <a class="el" href="#aaa543888abe1d65f79e9b1a62b95dc55">etl::index_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>&gt;{}</td></tr>
<tr class="separator:a0a6eea4e711c17c5bb6f7e8af9c7effc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10afef86eafa806bb7142657cfa37f79" id="r_a10afef86eafa806bb7142657cfa37f79"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a10afef86eafa806bb7142657cfa37f79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10afef86eafa806bb7142657cfa37f79">is_abstract_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_abstract</a>(T)</td></tr>
<tr class="separator:a10afef86eafa806bb7142657cfa37f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e64aa57f60e45754ac20ba126bbe3" id="r_adb0e64aa57f60e45754ac20ba126bbe3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adb0e64aa57f60e45754ac20ba126bbe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb0e64aa57f60e45754ac20ba126bbe3">is_aggregate_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_aggregate</a>(<a class="el" href="#a9629a84441c7647c5374e5f1ada63df5">remove_cv_t</a>&lt;T&gt;)</td></tr>
<tr class="separator:adb0e64aa57f60e45754ac20ba126bbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97300837e35e483d3cf7b20dd724250b" id="r_a97300837e35e483d3cf7b20dd724250b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </td></tr>
<tr class="memitem:a97300837e35e483d3cf7b20dd724250b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97300837e35e483d3cf7b20dd724250b">is_any_of_v</a> = <a class="el" href="#abb3abcd15bf9ea4a0629b7e03498e1e1">disjunction_v</a>&lt;<a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">Types</a>&gt;...&gt;</td></tr>
<tr class="separator:a97300837e35e483d3cf7b20dd724250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2224be65b8fb8794372d049a1d37d9" id="r_abf2224be65b8fb8794372d049a1d37d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abf2224be65b8fb8794372d049a1d37d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf2224be65b8fb8794372d049a1d37d9">is_arithmetic_v</a> = <a class="el" href="#a396e4b8c756441b942c1619de108e56a">etl::is_integral_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">or</a> <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">etl::is_floating_point_v</a>&lt;T&gt;</td></tr>
<tr class="separator:abf2224be65b8fb8794372d049a1d37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0e44222b6a1dc103286f3c5225ad93" id="r_a8b0e44222b6a1dc103286f3c5225ad93"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8b0e44222b6a1dc103286f3c5225ad93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b0e44222b6a1dc103286f3c5225ad93">is_array_v</a> = <a class="el" href="structetl_1_1is__array.html">etl::is_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8b0e44222b6a1dc103286f3c5225ad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762a8e8750c01c04403086076b7bab1e" id="r_a762a8e8750c01c04403086076b7bab1e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a762a8e8750c01c04403086076b7bab1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a762a8e8750c01c04403086076b7bab1e">is_assignable_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_assignable</a>(T, U)</td></tr>
<tr class="separator:a762a8e8750c01c04403086076b7bab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096bf5b121d9f427c8027f2949e8198e" id="r_a096bf5b121d9f427c8027f2949e8198e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Base</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Derived</a> &gt; </td></tr>
<tr class="memitem:a096bf5b121d9f427c8027f2949e8198e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a096bf5b121d9f427c8027f2949e8198e">is_base_of_v</a> = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Base</a>, <a class="el" href="structetl_1_1static__vector.html">Derived</a>&gt;::value</td></tr>
<tr class="separator:a096bf5b121d9f427c8027f2949e8198e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a699f9a94f5d0c71c5e85e84f7baeb4" id="r_a7a699f9a94f5d0c71c5e85e84f7baeb4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7a699f9a94f5d0c71c5e85e84f7baeb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a699f9a94f5d0c71c5e85e84f7baeb4">is_bounded_array_v</a> = <a class="el" href="structetl_1_1is__bounded__array.html">etl::is_bounded_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a7a699f9a94f5d0c71c5e85e84f7baeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca38abc104326427a46bccfd27cbfe28" id="r_aca38abc104326427a46bccfd27cbfe28"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aca38abc104326427a46bccfd27cbfe28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca38abc104326427a46bccfd27cbfe28">is_class_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_class</a>(T)</td></tr>
<tr class="separator:aca38abc104326427a46bccfd27cbfe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2d62ca306fe828c5b72d7ebd4bf357" id="r_aad2d62ca306fe828c5b72d7ebd4bf357"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aad2d62ca306fe828c5b72d7ebd4bf357"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad2d62ca306fe828c5b72d7ebd4bf357">is_compound_v</a> = !<a class="el" href="#aec01da22051322819e36fdfa6c5514a5">etl::is_fundamental_v</a>&lt;T&gt;</td></tr>
<tr class="separator:aad2d62ca306fe828c5b72d7ebd4bf357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf567b7866a96e4005d64743e0859b0" id="r_a0bf567b7866a96e4005d64743e0859b0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0bf567b7866a96e4005d64743e0859b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bf567b7866a96e4005d64743e0859b0">is_const_v</a> = <a class="el" href="structetl_1_1is__const.html">etl::is_const</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0bf567b7866a96e4005d64743e0859b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123009e89543c37bab698abc5f4221a0" id="r_a123009e89543c37bab698abc5f4221a0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a123009e89543c37bab698abc5f4221a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a123009e89543c37bab698abc5f4221a0">is_constructible_v</a> = <a class="el" href="#ab130b8cdd79b1e59a593d4cb1c6ffe13">is_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a123009e89543c37bab698abc5f4221a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5e75c4b12aa7982c5a97a14510ab35" id="r_adf5e75c4b12aa7982c5a97a14510ab35"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> &gt; </td></tr>
<tr class="memitem:adf5e75c4b12aa7982c5a97a14510ab35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">is_convertible_v</a> = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;<a class="el" href="structetl_1_1static__vector.html">From</a>, <a class="el" href="structetl_1_1static__vector.html">To</a>&gt;::value</td></tr>
<tr class="separator:adf5e75c4b12aa7982c5a97a14510ab35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8a0fd8e07b2a2b0d62816c2958722a" id="r_afe8a0fd8e07b2a2b0d62816c2958722a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afe8a0fd8e07b2a2b0d62816c2958722a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe8a0fd8e07b2a2b0d62816c2958722a">is_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afe8a0fd8e07b2a2b0d62816c2958722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f5da2852be4424089f4235ef44dec2" id="r_a03f5da2852be4424089f4235ef44dec2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a03f5da2852be4424089f4235ef44dec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03f5da2852be4424089f4235ef44dec2">is_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a03f5da2852be4424089f4235ef44dec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1a93c5d7a09590573ceccfb239a590" id="r_a5d1a93c5d7a09590573ceccfb239a590"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5d1a93c5d7a09590573ceccfb239a590"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d1a93c5d7a09590573ceccfb239a590">is_default_constructible_v</a> = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5d1a93c5d7a09590573ceccfb239a590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b3cd3fa2118be96d3b81105df490f8" id="r_ad9b3cd3fa2118be96d3b81105df490f8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad9b3cd3fa2118be96d3b81105df490f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9b3cd3fa2118be96d3b81105df490f8">is_destructible_v</a> = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad9b3cd3fa2118be96d3b81105df490f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd4405b77f18a1a21a5b886c3e335d" id="r_a91bd4405b77f18a1a21a5b886c3e335d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a91bd4405b77f18a1a21a5b886c3e335d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91bd4405b77f18a1a21a5b886c3e335d">is_empty_v</a> = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a91bd4405b77f18a1a21a5b886c3e335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b43ce4d692cabf9e9e569bc813f910e" id="r_a4b43ce4d692cabf9e9e569bc813f910e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4b43ce4d692cabf9e9e569bc813f910e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b43ce4d692cabf9e9e569bc813f910e">is_enum_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_enum</a>(T)</td></tr>
<tr class="separator:a4b43ce4d692cabf9e9e569bc813f910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c97574ef59ab15ea9cff1856487d66" id="r_a98c97574ef59ab15ea9cff1856487d66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a98c97574ef59ab15ea9cff1856487d66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a98c97574ef59ab15ea9cff1856487d66">is_final_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_final</a>(T)</td></tr>
<tr class="separator:a98c97574ef59ab15ea9cff1856487d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a70da46bf8635132fd3757deb2fff94" id="r_a8a70da46bf8635132fd3757deb2fff94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8a70da46bf8635132fd3757deb2fff94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a> = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8a70da46bf8635132fd3757deb2fff94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc77cc5069dfe2c648737671e340d9" id="r_abffc77cc5069dfe2c648737671e340d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abffc77cc5069dfe2c648737671e340d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abffc77cc5069dfe2c648737671e340d9">is_function_v</a> = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:abffc77cc5069dfe2c648737671e340d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a function type. Types like etl::function, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false.  <br /></td></tr>
<tr class="separator:abffc77cc5069dfe2c648737671e340d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec01da22051322819e36fdfa6c5514a5" id="r_aec01da22051322819e36fdfa6c5514a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aec01da22051322819e36fdfa6c5514a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec01da22051322819e36fdfa6c5514a5">is_fundamental_v</a> = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aec01da22051322819e36fdfa6c5514a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8014fcd9664b5608f77c514246ceafa8" id="r_a8014fcd9664b5608f77c514246ceafa8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8014fcd9664b5608f77c514246ceafa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8014fcd9664b5608f77c514246ceafa8">is_implicit_default_constructible_v</a> = <a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8014fcd9664b5608f77c514246ceafa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396e4b8c756441b942c1619de108e56a" id="r_a396e4b8c756441b942c1619de108e56a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a396e4b8c756441b942c1619de108e56a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a></td></tr>
<tr class="separator:a396e4b8c756441b942c1619de108e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65073ba479a098a622312ecaaa89fa64" id="r_a65073ba479a098a622312ecaaa89fa64"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Fn</a> , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a65073ba479a098a622312ecaaa89fa64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65073ba479a098a622312ecaaa89fa64">is_invocable_v</a> = <a class="el" href="structetl_1_1is__invocable.html">is_invocable</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Fn</a>, ArgTypes...&gt;::value</td></tr>
<tr class="separator:a65073ba479a098a622312ecaaa89fa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bb140a0b590bb8a6eadea52d880d17" id="r_a79bb140a0b590bb8a6eadea52d880d17"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Fn</a> , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a79bb140a0b590bb8a6eadea52d880d17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79bb140a0b590bb8a6eadea52d880d17">is_invocable_r_v</a> = <a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R</a>, <a class="el" href="structetl_1_1static__vector.html">Fn</a>, ArgTypes...&gt;::value</td></tr>
<tr class="separator:a79bb140a0b590bb8a6eadea52d880d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3172a26a55cf95dbe3c85e6611ebc0" id="r_a0a3172a26a55cf95dbe3c85e6611ebc0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0a3172a26a55cf95dbe3c85e6611ebc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a3172a26a55cf95dbe3c85e6611ebc0">is_lvalue_reference_v</a> = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0a3172a26a55cf95dbe3c85e6611ebc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241c086fc3e628de919419dd7772e345" id="r_a241c086fc3e628de919419dd7772e345"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a241c086fc3e628de919419dd7772e345"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a241c086fc3e628de919419dd7772e345">is_member_function_pointer_v</a> = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a241c086fc3e628de919419dd7772e345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868fe6017d6496b38fe1f2a58a879f14" id="r_a868fe6017d6496b38fe1f2a58a879f14"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a868fe6017d6496b38fe1f2a58a879f14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a868fe6017d6496b38fe1f2a58a879f14">is_member_object_pointer_v</a> = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a868fe6017d6496b38fe1f2a58a879f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f351ba579310d9228dc77b84bdf10b6" id="r_a8f351ba579310d9228dc77b84bdf10b6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8f351ba579310d9228dc77b84bdf10b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f351ba579310d9228dc77b84bdf10b6">is_member_pointer_v</a> = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8f351ba579310d9228dc77b84bdf10b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf52ca54b0d508bfc6b9bbe916faf18" id="r_afbf52ca54b0d508bfc6b9bbe916faf18"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afbf52ca54b0d508bfc6b9bbe916faf18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">is_move_assignable_v</a> = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afbf52ca54b0d508bfc6b9bbe916faf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5181d927278f40a6a97e90944d673c0a" id="r_a5181d927278f40a6a97e90944d673c0a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5181d927278f40a6a97e90944d673c0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5181d927278f40a6a97e90944d673c0a">is_move_constructible_v</a> = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5181d927278f40a6a97e90944d673c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c249b3afd84019ec11170a1e06d267" id="r_ac0c249b3afd84019ec11170a1e06d267"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ac0c249b3afd84019ec11170a1e06d267"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0c249b3afd84019ec11170a1e06d267">is_nothrow_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:ac0c249b3afd84019ec11170a1e06d267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00c953e4e3f962b130f431bc25d6101" id="r_ac00c953e4e3f962b130f431bc25d6101"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:ac00c953e4e3f962b130f431bc25d6101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac00c953e4e3f962b130f431bc25d6101">is_nothrow_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:ac00c953e4e3f962b130f431bc25d6101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70f6258c3e925eeb2d27b652374660d" id="r_af70f6258c3e925eeb2d27b652374660d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> &gt; </td></tr>
<tr class="memitem:af70f6258c3e925eeb2d27b652374660d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af70f6258c3e925eeb2d27b652374660d">is_nothrow_convertible_v</a> = <a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a>&lt;<a class="el" href="structetl_1_1static__vector.html">From</a>, <a class="el" href="structetl_1_1static__vector.html">To</a>&gt;::value</td></tr>
<tr class="separator:af70f6258c3e925eeb2d27b652374660d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3322351bf5068346b84b6b19717f525c" id="r_a3322351bf5068346b84b6b19717f525c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3322351bf5068346b84b6b19717f525c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3322351bf5068346b84b6b19717f525c">is_nothrow_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3322351bf5068346b84b6b19717f525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a08255d43824dc23e14e09d4f9a3d22" id="r_a1a08255d43824dc23e14e09d4f9a3d22"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1a08255d43824dc23e14e09d4f9a3d22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a08255d43824dc23e14e09d4f9a3d22">is_nothrow_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a1a08255d43824dc23e14e09d4f9a3d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d84124b3f5c4c4fab97253443d07a56" id="r_a2d84124b3f5c4c4fab97253443d07a56"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a2d84124b3f5c4c4fab97253443d07a56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d84124b3f5c4c4fab97253443d07a56">is_nothrow_default_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a2d84124b3f5c4c4fab97253443d07a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6b378d80292ae38acd1f467e10dd49" id="r_adf6b378d80292ae38acd1f467e10dd49"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adf6b378d80292ae38acd1f467e10dd49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf6b378d80292ae38acd1f467e10dd49">is_nothrow_destructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:adf6b378d80292ae38acd1f467e10dd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26f59ba1b8a873f9d8374f72a4002c4" id="r_ad26f59ba1b8a873f9d8374f72a4002c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad26f59ba1b8a873f9d8374f72a4002c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad26f59ba1b8a873f9d8374f72a4002c4">is_nothrow_move_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad26f59ba1b8a873f9d8374f72a4002c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e3584e54b63fd9e6a35fffd41080bd" id="r_a34e3584e54b63fd9e6a35fffd41080bd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a34e3584e54b63fd9e6a35fffd41080bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">is_nothrow_move_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a34e3584e54b63fd9e6a35fffd41080bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740a9b650d7a3063e9414c3c50ffdb5" id="r_af740a9b650d7a3063e9414c3c50ffdb5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af740a9b650d7a3063e9414c3c50ffdb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af740a9b650d7a3063e9414c3c50ffdb5">is_nothrow_swappable_v</a> = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af740a9b650d7a3063e9414c3c50ffdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10bae03ee2ee7efc954c5553dfb34dd" id="r_aa10bae03ee2ee7efc954c5553dfb34dd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:aa10bae03ee2ee7efc954c5553dfb34dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa10bae03ee2ee7efc954c5553dfb34dd">is_nothrow_swappable_with_v</a> = <a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:aa10bae03ee2ee7efc954c5553dfb34dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284cbaff17633b620e43bf4c4a5b9c66" id="r_a284cbaff17633b620e43bf4c4a5b9c66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a284cbaff17633b620e43bf4c4a5b9c66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a284cbaff17633b620e43bf4c4a5b9c66">is_null_pointer_v</a> = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a284cbaff17633b620e43bf4c4a5b9c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0edf4d9cccfbffc3b8744b2c7bcfe9" id="r_a6e0edf4d9cccfbffc3b8744b2c7bcfe9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6e0edf4d9cccfbffc3b8744b2c7bcfe9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a> = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6e0edf4d9cccfbffc3b8744b2c7bcfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d8a43ca3d5d473f1651ef5114c2628" id="r_a60d8a43ca3d5d473f1651ef5114c2628"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a60d8a43ca3d5d473f1651ef5114c2628"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">is_pointer_v</a> = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a60d8a43ca3d5d473f1651ef5114c2628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a143b8d7f44dff4fa25a08864799234" id="r_a7a143b8d7f44dff4fa25a08864799234"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7a143b8d7f44dff4fa25a08864799234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a143b8d7f44dff4fa25a08864799234">is_polymorphic_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_polymorphic</a>(T)</td></tr>
<tr class="separator:a7a143b8d7f44dff4fa25a08864799234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8301cd1745fa1701a4f9d6045f15a2e0" id="r_a8301cd1745fa1701a4f9d6045f15a2e0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8301cd1745fa1701a4f9d6045f15a2e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8301cd1745fa1701a4f9d6045f15a2e0">is_reference_v</a> = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8301cd1745fa1701a4f9d6045f15a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e51e4e96e7f9909244d577e730f80cf" id="r_a0e51e4e96e7f9909244d577e730f80cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0e51e4e96e7f9909244d577e730f80cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e51e4e96e7f9909244d577e730f80cf">is_reference_wrapper_v</a> = <a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0e51e4e96e7f9909244d577e730f80cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76f1e4408116211d60d33934f2241ec" id="r_ae76f1e4408116211d60d33934f2241ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae76f1e4408116211d60d33934f2241ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae76f1e4408116211d60d33934f2241ec">is_rvalue_reference_v</a> = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ae76f1e4408116211d60d33934f2241ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c6bde5fd020a928e6d7b5fe8db7bb0" id="r_aa6c6bde5fd020a928e6d7b5fe8db7bb0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:aa6c6bde5fd020a928e6d7b5fe8db7bb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a> = <a class="el" href="structetl_1_1static__vector.html">false</a></td></tr>
<tr class="separator:aa6c6bde5fd020a928e6d7b5fe8db7bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4cca5d1a81afdeb0354d88b58554a1" id="r_abd4cca5d1a81afdeb0354d88b58554a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abd4cca5d1a81afdeb0354d88b58554a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd4cca5d1a81afdeb0354d88b58554a1">is_same_v&lt; T, T &gt;</a> = <a class="el" href="structetl_1_1static__vector.html">true</a></td></tr>
<tr class="separator:abd4cca5d1a81afdeb0354d88b58554a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030808462771bbdd627d73c92a98565f" id="r_a030808462771bbdd627d73c92a98565f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a030808462771bbdd627d73c92a98565f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a030808462771bbdd627d73c92a98565f">is_scalar_v</a> = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a030808462771bbdd627d73c92a98565f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78db0060aa04a75ce5b8a07e7ece59de" id="r_a78db0060aa04a75ce5b8a07e7ece59de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a78db0060aa04a75ce5b8a07e7ece59de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78db0060aa04a75ce5b8a07e7ece59de">is_scoped_enum_v</a> = <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a78db0060aa04a75ce5b8a07e7ece59de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an scoped enumeration type. Provides the member constant value which is equal to true, if T is an scoped enumeration type. Otherwise, value is equal to false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a> or is_scoped_enum_v is undefined.  <br /></td></tr>
<tr class="separator:a78db0060aa04a75ce5b8a07e7ece59de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c78609bb9e06b42e0a4c0c4409b0a1" id="r_a05c78609bb9e06b42e0a4c0c4409b0a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a05c78609bb9e06b42e0a4c0c4409b0a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05c78609bb9e06b42e0a4c0c4409b0a1">is_signed_v</a> = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a05c78609bb9e06b42e0a4c0c4409b0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28194dad7a848538b478ff8c18abafed" id="r_a28194dad7a848538b478ff8c18abafed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">template</a>&lt; typename... &gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> Template, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tag</a>  = void&gt; </td></tr>
<tr class="memitem:a28194dad7a848538b478ff8c18abafed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28194dad7a848538b478ff8c18abafed">is_specialized_v</a> = <a class="el" href="structetl_1_1is__specialized.html">etl::is_specialized</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Template</a>, T, <a class="el" href="structetl_1_1static__vector.html">Tag</a>&gt;::value</td></tr>
<tr class="separator:a28194dad7a848538b478ff8c18abafed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87eee4459ff69343253626fdfad870b1" id="r_a87eee4459ff69343253626fdfad870b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a87eee4459ff69343253626fdfad870b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a87eee4459ff69343253626fdfad870b1">is_standard_layout_v</a> = <a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a87eee4459ff69343253626fdfad870b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a08681ad0c17b00662bfd185a081335" id="r_a6a08681ad0c17b00662bfd185a081335"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6a08681ad0c17b00662bfd185a081335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a08681ad0c17b00662bfd185a081335">is_swappable_v</a> = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6a08681ad0c17b00662bfd185a081335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c3e504b08a7a017cf1fafdf4435eff" id="r_ac1c3e504b08a7a017cf1fafdf4435eff"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ac1c3e504b08a7a017cf1fafdf4435eff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1c3e504b08a7a017cf1fafdf4435eff">is_swappable_with_v</a> = <a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:ac1c3e504b08a7a017cf1fafdf4435eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328d1a7de791585957bddf38501d3965" id="r_a328d1a7de791585957bddf38501d3965"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a328d1a7de791585957bddf38501d3965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a328d1a7de791585957bddf38501d3965">is_trivial_v</a> = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a328d1a7de791585957bddf38501d3965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5575d88dd9e2ccdec94f3e0221bd93" id="r_a3e5575d88dd9e2ccdec94f3e0221bd93"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a3e5575d88dd9e2ccdec94f3e0221bd93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e5575d88dd9e2ccdec94f3e0221bd93">is_trivially_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:a3e5575d88dd9e2ccdec94f3e0221bd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396c0b78998702552df9f3f40bc88982" id="r_a396c0b78998702552df9f3f40bc88982"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a396c0b78998702552df9f3f40bc88982"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a396c0b78998702552df9f3f40bc88982">is_trivially_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a396c0b78998702552df9f3f40bc88982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b0a04cc2a51f7a14f9c7a02c44aecc" id="r_a57b0a04cc2a51f7a14f9c7a02c44aecc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a57b0a04cc2a51f7a14f9c7a02c44aecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57b0a04cc2a51f7a14f9c7a02c44aecc">is_trivially_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a57b0a04cc2a51f7a14f9c7a02c44aecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa380d2993e2d74ca6ec925404947169c" id="r_aa380d2993e2d74ca6ec925404947169c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa380d2993e2d74ca6ec925404947169c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa380d2993e2d74ca6ec925404947169c">is_trivially_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa380d2993e2d74ca6ec925404947169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94b442e8b9fb5a0de351b1b84d6f703" id="r_af94b442e8b9fb5a0de351b1b84d6f703"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af94b442e8b9fb5a0de351b1b84d6f703"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af94b442e8b9fb5a0de351b1b84d6f703">is_trivially_copyable_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_trivially_copyable</a>(T)</td></tr>
<tr class="separator:af94b442e8b9fb5a0de351b1b84d6f703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf6d7f246062eff8288873db7382e49" id="r_aadf6d7f246062eff8288873db7382e49"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aadf6d7f246062eff8288873db7382e49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aadf6d7f246062eff8288873db7382e49">is_trivially_default_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aadf6d7f246062eff8288873db7382e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c5a91c590beb77cbc056cb9327956f" id="r_a63c5a91c590beb77cbc056cb9327956f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a63c5a91c590beb77cbc056cb9327956f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63c5a91c590beb77cbc056cb9327956f">is_trivially_destructible_v</a> = <a class="el" href="structetl_1_1static__vector.html">__has_trivial_destructor</a>(T)</td></tr>
<tr class="separator:a63c5a91c590beb77cbc056cb9327956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57849835554ed7e24b739e5ad635cc5d" id="r_a57849835554ed7e24b739e5ad635cc5d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a57849835554ed7e24b739e5ad635cc5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57849835554ed7e24b739e5ad635cc5d">is_trivially_move_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a57849835554ed7e24b739e5ad635cc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d1caff81b5bd6a9266da221ee4a2f5" id="r_aa7d1caff81b5bd6a9266da221ee4a2f5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa7d1caff81b5bd6a9266da221ee4a2f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7d1caff81b5bd6a9266da221ee4a2f5">is_trivially_move_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">etl::is_trivially_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa7d1caff81b5bd6a9266da221ee4a2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687f368c330615460df7f61947e88279" id="r_a687f368c330615460df7f61947e88279"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a687f368c330615460df7f61947e88279"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a687f368c330615460df7f61947e88279">is_unbounded_array_v</a> = <a class="el" href="structetl_1_1is__unbounded__array.html">etl::is_unbounded_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a687f368c330615460df7f61947e88279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d7414e06afd624ccd66acee3873b11" id="r_a39d7414e06afd624ccd66acee3873b11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a39d7414e06afd624ccd66acee3873b11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39d7414e06afd624ccd66acee3873b11">is_union_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_union</a>(T)</td></tr>
<tr class="separator:a39d7414e06afd624ccd66acee3873b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22b0b8d8faeebf7b2eb8d80ccdb03ba" id="r_ac22b0b8d8faeebf7b2eb8d80ccdb03ba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac22b0b8d8faeebf7b2eb8d80ccdb03ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac22b0b8d8faeebf7b2eb8d80ccdb03ba">is_unsigned_v</a> = <a class="el" href="structetl_1_1is__unsigned.html">etl::is_unsigned</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac22b0b8d8faeebf7b2eb8d80ccdb03ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4414ccc8655262f0522dc640003d64b7" id="r_a4414ccc8655262f0522dc640003d64b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4414ccc8655262f0522dc640003d64b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4414ccc8655262f0522dc640003d64b7">is_void_v</a> = <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">etl::is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">void</a>, <a class="el" href="#a9629a84441c7647c5374e5f1ada63df5">etl::remove_cv_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a4414ccc8655262f0522dc640003d64b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fd8976091aa72c12d7a7e5ee986400" id="r_af3fd8976091aa72c12d7a7e5ee986400"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af3fd8976091aa72c12d7a7e5ee986400"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3fd8976091aa72c12d7a7e5ee986400">is_volatile_v</a> = <a class="el" href="structetl_1_1is__volatile.html">etl::is_volatile</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af3fd8976091aa72c12d7a7e5ee986400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bef7b75bd1375e11a158bc94cbc4fa3" id="r_a3bef7b75bd1375e11a158bc94cbc4fa3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">B</a> &gt; </td></tr>
<tr class="memitem:a3bef7b75bd1375e11a158bc94cbc4fa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bef7b75bd1375e11a158bc94cbc4fa3">negation_v</a> = !<a class="el" href="structetl_1_1static__vector.html">bool</a>(B::value)</td></tr>
<tr class="separator:a3bef7b75bd1375e11a158bc94cbc4fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66bceba9ac1596666a40596ddf9b62" id="r_a3c66bceba9ac1596666a40596ddf9b62"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:a3c66bceba9ac1596666a40596ddf9b62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c66bceba9ac1596666a40596ddf9b62">rank_v</a> = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Type</a>&gt;::value</td></tr>
<tr class="separator:a3c66bceba9ac1596666a40596ddf9b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb090c3e2bd7b58f70ddb151d426d84c" id="r_afb090c3e2bd7b58f70ddb151d426d84c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> V&gt; </td></tr>
<tr class="memitem:afb090c3e2bd7b58f70ddb151d426d84c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb090c3e2bd7b58f70ddb151d426d84c">nontype</a> = <a class="el" href="structetl_1_1nontype__t.html">etl::nontype_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">V</a>&gt;{}</td></tr>
<tr class="separator:afb090c3e2bd7b58f70ddb151d426d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773a2a7547427bfc26b4ff3b8c2cebe3" id="r_a773a2a7547427bfc26b4ff3b8c2cebe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a773a2a7547427bfc26b4ff3b8c2cebe3">piecewise_construct</a> = <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>{}</td></tr>
<tr class="memdesc:a773a2a7547427bfc26b4ff3b8c2cebe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant <a class="el" href="#a773a2a7547427bfc26b4ff3b8c2cebe3" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>.  <br /></td></tr>
<tr class="separator:a773a2a7547427bfc26b4ff3b8c2cebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2627e58d7c15ca89a458ad54eba558" id="r_a8c2627e58d7c15ca89a458ad54eba558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c2627e58d7c15ca89a458ad54eba558">variant_npos</a> = <a class="el" href="structetl_1_1numeric__limits.html">etl::numeric_limits</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&gt;<a class="el" href="#a5f3eca1793f7f38aeb756464984eb194">::max</a>()</td></tr>
<tr class="memdesc:a8c2627e58d7c15ca89a458ad54eba558"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the largest value representable by the type size_t, used as the return value of index() when valueless_by_exception() is true.  <br /></td></tr>
<tr class="separator:a8c2627e58d7c15ca89a458ad54eba558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048867192f342c93436216b7b1ed601b" id="r_a048867192f342c93436216b7b1ed601b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a048867192f342c93436216b7b1ed601b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a048867192f342c93436216b7b1ed601b">variant_size_v</a> = <a class="el" href="structetl_1_1variant__size.html">variant_size</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a048867192f342c93436216b7b1ed601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9683edd538ff0cc668fb5a823604223" id="r_ac9683edd538ff0cc668fb5a823604223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9683edd538ff0cc668fb5a823604223">current_implementation</a> = <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1">implementation::freestanding</a></td></tr>
<tr class="separator:ac9683edd538ff0cc668fb5a823604223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a32ab1ee4dc1bf7a3e86e713a4d6cbf" id="r_a6a32ab1ee4dc1bf7a3e86e713a4d6cbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a32ab1ee4dc1bf7a3e86e713a4d6cbf">current_standard</a> = <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff">language_standard::cpp_26</a></td></tr>
<tr class="memdesc:a6a32ab1ee4dc1bf7a3e86e713a4d6cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently configured C++ standard.  <br /></td></tr>
<tr class="separator:a6a32ab1ee4dc1bf7a3e86e713a4d6cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab8152600ad2707187b2826f06f7b489a" name="ab8152600ad2707187b2826f06f7b489a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8152600ad2707187b2826f06f7b489a">&#9670;&#160;</a></span>common_comparison_category_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ab8152600ad2707187b2826f06f7b489a">common_comparison_category_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08b715f3a9d55a158e1659f797689b0c" name="a08b715f3a9d55a158e1659f797689b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b715f3a9d55a158e1659f797689b0c">&#9670;&#160;</a></span>compare_three_way_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a08b715f3a9d55a158e1659f797689b0c">compare_three_way_result_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;() &lt;=&gt; <a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t</a>&lt;U&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb2c9350d32e78a0e4c960b9859ccb40" name="afb2c9350d32e78a0e4c960b9859ccb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2c9350d32e78a0e4c960b9859ccb40">&#9670;&#160;</a></span>nullptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">nullptr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/nullptr_t">https://en.cppreference.com/w/cpp/types/nullptr_t</a> </p>

</div>
</div>
<a id="aac63559b08846022abfeabda8583ed87" name="aac63559b08846022abfeabda8583ed87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac63559b08846022abfeabda8583ed87">&#9670;&#160;</a></span>ptrdiff_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a> = <a class="el" href="builtin__types_8hpp.html#a19bfe4995271e67306bab6dc974ed002">TETL_BUILTIN_PTRDIFF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aac63559b08846022abfeabda8583ed87" title="etl::ptrdiff_t is the signed integer type of the result of subtracting two pointers.">etl::ptrdiff_t</a> is the signed integer type of the result of subtracting two pointers. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/ptrdiff_t">https://en.cppreference.com/w/cpp/types/ptrdiff_t</a> </p>

</div>
</div>
<a id="aee50235c04ef643cb7502785393220fe" name="aee50235c04ef643cb7502785393220fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee50235c04ef643cb7502785393220fe">&#9670;&#160;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> = <a class="el" href="builtin__types_8hpp.html#ab236bea848bc390350ba3fc38ae07819">TETL_BUILTIN_SIZET</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aee50235c04ef643cb7502785393220fe" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> is the unsigned integer type of the result of the sizeof operator. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/size_t">https://en.cppreference.com/w/cpp/types/size_t</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a0">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a711e8ca666d23e897fd1d9f8411c6ca8" name="a711e8ca666d23e897fd1d9f8411c6ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711e8ca666d23e897fd1d9f8411c6ca8">&#9670;&#160;</a></span>int_fast8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a711e8ca666d23e897fd1d9f8411c6ca8">int_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a4b4c952a1c7a141ed7115060bf4c22b0" name="a4b4c952a1c7a141ed7115060bf4c22b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4c952a1c7a141ed7115060bf4c22b0">&#9670;&#160;</a></span>int_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a4b4c952a1c7a141ed7115060bf4c22b0">int_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="a32de47c4408fa865e1b8b99eb992d458" name="a32de47c4408fa865e1b8b99eb992d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32de47c4408fa865e1b8b99eb992d458">&#9670;&#160;</a></span>int_fast32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a32de47c4408fa865e1b8b99eb992d458">int_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="abff54514318ff648eb363a442f171c06" name="abff54514318ff648eb363a442f171c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff54514318ff648eb363a442f171c06">&#9670;&#160;</a></span>int_fast64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#abff54514318ff648eb363a442f171c06">int_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="aff47f46aff9c632e1283854fda8dc0e1" name="aff47f46aff9c632e1283854fda8dc0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff47f46aff9c632e1283854fda8dc0e1">&#9670;&#160;</a></span>int_least8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aff47f46aff9c632e1283854fda8dc0e1">int_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a5cb2df1d7cc3d4d2c87221169156614f" name="a5cb2df1d7cc3d4d2c87221169156614f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb2df1d7cc3d4d2c87221169156614f">&#9670;&#160;</a></span>int_least16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a5cb2df1d7cc3d4d2c87221169156614f">int_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="ae2ce02c549a43d9c5f85a2b39b7c8c4b" name="ae2ce02c549a43d9c5f85a2b39b7c8c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ce02c549a43d9c5f85a2b39b7c8c4b">&#9670;&#160;</a></span>int_least32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae2ce02c549a43d9c5f85a2b39b7c8c4b">int_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a85a53a2f96f40b0aeddf74828d71712e" name="a85a53a2f96f40b0aeddf74828d71712e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a53a2f96f40b0aeddf74828d71712e">&#9670;&#160;</a></span>int_least64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a85a53a2f96f40b0aeddf74828d71712e">int_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="a52ed057e79c7de5d1451928e10dcf46d" name="a52ed057e79c7de5d1451928e10dcf46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ed057e79c7de5d1451928e10dcf46d">&#9670;&#160;</a></span>int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a52ed057e79c7de5d1451928e10dcf46d">int8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 8 bits. </p>

</div>
</div>
<a id="a962db76b841f05bb03ac61766d75d791" name="a962db76b841f05bb03ac61766d75d791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962db76b841f05bb03ac61766d75d791">&#9670;&#160;</a></span>int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a962db76b841f05bb03ac61766d75d791">int16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 16 bits. </p>

</div>
</div>
<a id="a07e2791ab5c84359b03776662eb994b6" name="a07e2791ab5c84359b03776662eb994b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e2791ab5c84359b03776662eb994b6">&#9670;&#160;</a></span>int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a07e2791ab5c84359b03776662eb994b6">int32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 32 bits. </p>

</div>
</div>
<a id="a3bed93ea1d934540fd05d361a6fc7c5e" name="a3bed93ea1d934540fd05d361a6fc7c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bed93ea1d934540fd05d361a6fc7c5e">&#9670;&#160;</a></span>int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3bed93ea1d934540fd05d361a6fc7c5e">int64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 64 bits. </p>

</div>
</div>
<a id="a64887361e0411caef7d81a411f3a6868" name="a64887361e0411caef7d81a411f3a6868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64887361e0411caef7d81a411f3a6868">&#9670;&#160;</a></span>intmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a64887361e0411caef7d81a411f3a6868">intmax_t</a> = <a class="el" href="builtin__types_8hpp.html#ad8678dda9c4b939fee5244864c53ada1">TETL_BUILTIN_INTMAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum-width signed integer type. </p>

</div>
</div>
<a id="a3fd46e49593ca8eb7a2a60667662abf4" name="a3fd46e49593ca8eb7a2a60667662abf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd46e49593ca8eb7a2a60667662abf4">&#9670;&#160;</a></span>intptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3fd46e49593ca8eb7a2a60667662abf4">intptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a021098c463419df8b156d80c9153387e">TETL_BUILTIN_INTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type capable of holding a pointer. </p>

</div>
</div>
<a id="aba8e71ca66f676d88d4bfc4023421cd9" name="aba8e71ca66f676d88d4bfc4023421cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8e71ca66f676d88d4bfc4023421cd9">&#9670;&#160;</a></span>uint_fast8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aba8e71ca66f676d88d4bfc4023421cd9">uint_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a516df22f1e6a839bc251cc699c90ab56" name="a516df22f1e6a839bc251cc699c90ab56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516df22f1e6a839bc251cc699c90ab56">&#9670;&#160;</a></span>uint_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a516df22f1e6a839bc251cc699c90ab56">uint_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="a39ae5542021173d59890b67e0f5dcd20" name="a39ae5542021173d59890b67e0f5dcd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ae5542021173d59890b67e0f5dcd20">&#9670;&#160;</a></span>uint_fast32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a39ae5542021173d59890b67e0f5dcd20">uint_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a49b174a549a84b470b20998da935f674" name="a49b174a549a84b470b20998da935f674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b174a549a84b470b20998da935f674">&#9670;&#160;</a></span>uint_fast64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a49b174a549a84b470b20998da935f674">uint_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="a3e9da1f87db9cd7b9d1f76ade9b44c94" name="a3e9da1f87db9cd7b9d1f76ade9b44c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9da1f87db9cd7b9d1f76ade9b44c94">&#9670;&#160;</a></span>uint_least8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3e9da1f87db9cd7b9d1f76ade9b44c94">uint_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="acce3c5bd0ff2f44caabd1b4d707887fc" name="acce3c5bd0ff2f44caabd1b4d707887fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce3c5bd0ff2f44caabd1b4d707887fc">&#9670;&#160;</a></span>uint_least16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#acce3c5bd0ff2f44caabd1b4d707887fc">uint_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="ad35f8b747d163b033b7d4bf5b18b2f61" name="ad35f8b747d163b033b7d4bf5b18b2f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35f8b747d163b033b7d4bf5b18b2f61">&#9670;&#160;</a></span>uint_least32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad35f8b747d163b033b7d4bf5b18b2f61">uint_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="ace30aa068da2786e3178c001a9dcb45f" name="ace30aa068da2786e3178c001a9dcb45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace30aa068da2786e3178c001a9dcb45f">&#9670;&#160;</a></span>uint_least64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ace30aa068da2786e3178c001a9dcb45f">uint_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="a71924434159564bc3aa4bd2930947053" name="a71924434159564bc3aa4bd2930947053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71924434159564bc3aa4bd2930947053">&#9670;&#160;</a></span>uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a71924434159564bc3aa4bd2930947053">uint8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 8 bits. </p>

</div>
</div>
<a id="a46518a317507676ba5887e53ca4bf5bd" name="a46518a317507676ba5887e53ca4bf5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46518a317507676ba5887e53ca4bf5bd">&#9670;&#160;</a></span>uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a46518a317507676ba5887e53ca4bf5bd">uint16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 16 bits. </p>

</div>
</div>
<a id="ac524e3389ea120063f493b23ce5ba2a6" name="ac524e3389ea120063f493b23ce5ba2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac524e3389ea120063f493b23ce5ba2a6">&#9670;&#160;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac524e3389ea120063f493b23ce5ba2a6">uint32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 32 bits. </p>

</div>
</div>
<a id="a5bbbc3f006120acc1de719e7d8ee6f40" name="a5bbbc3f006120acc1de719e7d8ee6f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbbc3f006120acc1de719e7d8ee6f40">&#9670;&#160;</a></span>uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a5bbbc3f006120acc1de719e7d8ee6f40">uint64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 64 bits. </p>

</div>
</div>
<a id="a05138bec421765330b01b925aae5d89f" name="a05138bec421765330b01b925aae5d89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05138bec421765330b01b925aae5d89f">&#9670;&#160;</a></span>uintmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a05138bec421765330b01b925aae5d89f">uintmax_t</a> = <a class="el" href="builtin__types_8hpp.html#a64175350ea04c19125422816cd6184e1">TETL_BUILTIN_UINTMAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum-width unsigned integer type. </p>

</div>
</div>
<a id="a1d944a371245d51e3b9ea011f7b97f43" name="a1d944a371245d51e3b9ea011f7b97f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d944a371245d51e3b9ea011f7b97f43">&#9670;&#160;</a></span>uintptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1d944a371245d51e3b9ea011f7b97f43">uintptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a3b013e093af0767d757a3606463295d9">TETL_BUILTIN_UINTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type capable of holding a pointer. </p>

</div>
</div>
<a id="a78cb041233ab00ef4358f99afedca8d0" name="a78cb041233ab00ef4358f99afedca8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cb041233ab00ef4358f99afedca8d0">&#9670;&#160;</a></span>clock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a78cb041233ab00ef4358f99afedca8d0">clock_t</a> = <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62da72e20fc89d790a5f88420496d0d7" name="a62da72e20fc89d790a5f88420496d0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62da72e20fc89d790a5f88420496d0d7">&#9670;&#160;</a></span>time_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a62da72e20fc89d790a5f88420496d0d7">time_t</a> = <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic type capable of representing times. </p>
<p>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to POSIX time. </p>

</div>
</div>
<a id="afb4e6bc2deecad0fb678bfe7c838df5e" name="afb4e6bc2deecad0fb678bfe7c838df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4e6bc2deecad0fb678bfe7c838df5e">&#9670;&#160;</a></span>wint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> = <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">int</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd8c737296655b44480da4fb422add24" name="abd8c737296655b44480da4fb422add24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8c737296655b44480da4fb422add24">&#9670;&#160;</a></span>format_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#abd8c737296655b44480da4fb422add24">format_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">format_context</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afff8faaf423d40e312921ee1506eaf5b" name="afff8faaf423d40e312921ee1506eaf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff8faaf423d40e312921ee1506eaf5b">&#9670;&#160;</a></span>wformat_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afff8faaf423d40e312921ee1506eaf5b">wformat_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afadb6bf7ddccdb7fc0a95da5b0b911ef" name="afadb6bf7ddccdb7fc0a95da5b0b911ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">&#9670;&#160;</a></span>format_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">format_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;&gt;, <a class="el" href="structetl_1_1static__vector.html">char</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to formatting state consisting of the formatting arguments and the output iterator. </p>
<p>The first template argument is an output iterator that appends to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>, such as etl::back_insert_iterator&lt;etl::static_string&gt;. Implementations are encouraged to use an iterator to type-erased buffer type that supports appending to any contiguous and resizable container.</p>
<p>The behavior is undefined if OutputIt does not model output_iterator&lt;const CharT&amp;&gt;.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/basic_format_context">https://en.cppreference.com/w/cpp/utility/format/basic_format_context</a> </p>

</div>
</div>
<a id="a03b255764cde83db44d0e61eebc55d36" name="a03b255764cde83db44d0e61eebc55d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b255764cde83db44d0e61eebc55d36">&#9670;&#160;</a></span>wformat_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;&gt;, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f31f076b2eb408741895533f9222baa" name="a7f31f076b2eb408741895533f9222baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f31f076b2eb408741895533f9222baa">&#9670;&#160;</a></span>format_parse_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a7f31f076b2eb408741895533f9222baa">format_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a60587ace165efab2fc40bddf69c89c" name="a9a60587ace165efab2fc40bddf69c89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a60587ace165efab2fc40bddf69c89c">&#9670;&#160;</a></span>wformat_parse_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a9a60587ace165efab2fc40bddf69c89c">wformat_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56a828fb91283babdb0eef8e0d9010cb" name="a56a828fb91283babdb0eef8e0d9010cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a828fb91283babdb0eef8e0d9010cb">&#9670;&#160;</a></span>format_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a56a828fb91283babdb0eef8e0d9010cb">format_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="#ae7cfb52ab2d82ff12cd2e0340315447f">type_identity_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69c1b057042c87184f2220c79696ef73" name="a69c1b057042c87184f2220c79696ef73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c1b057042c87184f2220c79696ef73">&#9670;&#160;</a></span>wformat_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a69c1b057042c87184f2220c79696ef73">wformat_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>, <a class="el" href="#ae7cfb52ab2d82ff12cd2e0340315447f">type_identity_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05dfe0d6b5c463f72f72a6bf14e21b0f" name="a05dfe0d6b5c463f72f72a6bf14e21b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">&#9670;&#160;</a></span>diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">diff_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;<a class="el" href="#a2d55d5d88d171bb347117b67a8741b65">etl::remove_cvref_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>&gt;&gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a636c37daca18857edd92e6fa8ebb6627" name="a636c37daca18857edd92e6fa8ebb6627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636c37daca18857edd92e6fa8ebb6627">&#9670;&#160;</a></span>stringbuf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a636c37daca18857edd92e6fa8ebb6627">stringbuf</a> = <a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66b66173615e2c5f0568adb2cae8739f" name="a66b66173615e2c5f0568adb2cae8739f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b66173615e2c5f0568adb2cae8739f">&#9670;&#160;</a></span>streamoff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a66b66173615e2c5f0568adb2cae8739f">streamoff</a> = <a class="el" href="structetl_1_1static__vector.html">long</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcecc45ff4539025dd0eb1cea84021f9" name="afcecc45ff4539025dd0eb1cea84021f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcecc45ff4539025dd0eb1cea84021f9">&#9670;&#160;</a></span>streamsize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afcecc45ff4539025dd0eb1cea84021f9">streamsize</a> = <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad753b7ec242604e8139a352b4d049398" name="ad753b7ec242604e8139a352b4d049398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad753b7ec242604e8139a352b4d049398">&#9670;&#160;</a></span>indirect_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Iters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad753b7ec242604e8139a352b4d049398">indirect_result_t</a> = <a class="el" href="#a601366c5cf97ac29c08fc7b51db875a9">etl::invoke_result_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, <a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">etl::iter_reference_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iters</a>&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7aa4cba4e97f7e0ff2dbb2f8238d5734" name="a7aa4cba4e97f7e0ff2dbb2f8238d5734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa4cba4e97f7e0ff2dbb2f8238d5734">&#9670;&#160;</a></span>iter_common_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a7aa4cba4e97f7e0ff2dbb2f8238d5734">iter_common_reference_t</a> = <a class="el" href="#afe1164daef675b01dddc89c2b7c28d80">etl::common_reference_t</a>&lt;<a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">etl::iter_reference_t</a>&lt;T&gt;, <a class="el" href="#afe275d17dd765cd278253e72900c895f">etl::iter_value_t</a>&lt;T&gt;&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89bccf0617839402578ce56ea06409b5" name="a89bccf0617839402578ce56ea06409b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bccf0617839402578ce56ea06409b5">&#9670;&#160;</a></span>iter_difference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a89bccf0617839402578ce56ea06409b5">iter_difference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::iter_difference&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad39c2555dd1910c170ae137cc8cdceb7" name="ad39c2555dd1910c170ae137cc8cdceb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39c2555dd1910c170ae137cc8cdceb7">&#9670;&#160;</a></span>iter_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::detail::dereferenceable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">iter_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(*<a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;T&amp;&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0bec1ad7f12ec0170c07608d82af228" name="ac0bec1ad7f12ec0170c07608d82af228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bec1ad7f12ec0170c07608d82af228">&#9670;&#160;</a></span>iter_rvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::detail::dereferenceable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac0bec1ad7f12ec0170c07608d82af228">iter_rvalue_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="namespaceetl_1_1ranges_1_1cpo.html#a78d082ea4928d84830a8184d72aedca6">etl::ranges::iter_move</a>(<a class="el" href="#af8fe16af1fc0c146d690634a5b2da600">etl::declval</a>&lt;T&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe275d17dd765cd278253e72900c895f" name="afe275d17dd765cd278253e72900c895f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe275d17dd765cd278253e72900c895f">&#9670;&#160;</a></span>iter_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afe275d17dd765cd278253e72900c895f">iter_value_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::iter_value&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6729ebb98236f93b98f0492cb3415fb7" name="a6729ebb98236f93b98f0492cb3415fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6729ebb98236f93b98f0492cb3415fb7">&#9670;&#160;</a></span>projected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> Iter, <a class="el" href="conceptetl_1_1indirectly__regular__unary__invocable.html">etl::indirectly_regular_unary_invocable</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; Proj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a6729ebb98236f93b98f0492cb3415fb7">projected</a> = etl::detail::projected_impl&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>, <a class="el" href="structetl_1_1static__vector.html">Proj</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac53bcc0a66170293af1f9319d4663d1a" name="ac53bcc0a66170293af1f9319d4663d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53bcc0a66170293af1f9319d4663d1a">&#9670;&#160;</a></span>dextents</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexType</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac53bcc0a66170293af1f9319d4663d1a">dextents</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::dextents_impl&lt;<a class="el" href="structetl_1_1static__vector.html">IndexType</a>, <a class="el" href="#a3c526d8179a55ec15611d7627272e067">etl::make_index_sequence</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Rank</a>&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2f26afef63b527bf205bb01455a515b" name="aa2f26afef63b527bf205bb01455a515b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f26afef63b527bf205bb01455a515b">&#9670;&#160;</a></span>new_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa2f26afef63b527bf205bb01455a515b">new_handler</a> = <a class="el" href="structetl_1_1static__vector.html">void</a> (*)()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aa2f26afef63b527bf205bb01455a515b" title="etl::new_handler is the function pointer type (pointer to function that takes no arguments and return...">etl::new_handler</a> is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions etl::set_new_handler and etl::get_new_handler </p>

</div>
</div>
<a id="ac437d8206f0e17da3a896c5f4d17f95a" name="ac437d8206f0e17da3a896c5f4d17f95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac437d8206f0e17da3a896c5f4d17f95a">&#9670;&#160;</a></span>atto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac437d8206f0e17da3a896c5f4d17f95a">atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a626e7a2087ed63adf28928bc61505210" name="a626e7a2087ed63adf28928bc61505210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626e7a2087ed63adf28928bc61505210">&#9670;&#160;</a></span>femto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a626e7a2087ed63adf28928bc61505210">femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1999fbf9a32aa8544e0ffa747d47518d" name="a1999fbf9a32aa8544e0ffa747d47518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1999fbf9a32aa8544e0ffa747d47518d">&#9670;&#160;</a></span>pico</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1999fbf9a32aa8544e0ffa747d47518d">pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1718104bd02150cc3a553b7289ea2d2d" name="a1718104bd02150cc3a553b7289ea2d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1718104bd02150cc3a553b7289ea2d2d">&#9670;&#160;</a></span>nano</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1718104bd02150cc3a553b7289ea2d2d">nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af06b69df89587850ded6209b864e7569" name="af06b69df89587850ded6209b864e7569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b69df89587850ded6209b864e7569">&#9670;&#160;</a></span>micro</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af06b69df89587850ded6209b864e7569">micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab10931e9eceef3f81bae9ea43bdd8e89" name="ab10931e9eceef3f81bae9ea43bdd8e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10931e9eceef3f81bae9ea43bdd8e89">&#9670;&#160;</a></span>milli</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ab10931e9eceef3f81bae9ea43bdd8e89">milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a037ed5d2bc56f378210678d84bcc854b" name="a037ed5d2bc56f378210678d84bcc854b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037ed5d2bc56f378210678d84bcc854b">&#9670;&#160;</a></span>centi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a037ed5d2bc56f378210678d84bcc854b">centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1c874769f867849c115ae2d1867a02" name="a5e1c874769f867849c115ae2d1867a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1c874769f867849c115ae2d1867a02">&#9670;&#160;</a></span>deci</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a5e1c874769f867849c115ae2d1867a02">deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb47ecbe72de3b6984811c6a1c8c6d5b" name="aeb47ecbe72de3b6984811c6a1c8c6d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb47ecbe72de3b6984811c6a1c8c6d5b">&#9670;&#160;</a></span>deca</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aeb47ecbe72de3b6984811c6a1c8c6d5b">deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee06e415331cdede5a5e81a37ae91014" name="aee06e415331cdede5a5e81a37ae91014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee06e415331cdede5a5e81a37ae91014">&#9670;&#160;</a></span>hecto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aee06e415331cdede5a5e81a37ae91014">hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a118ab5d9112082a698afa3512c99a46e" name="a118ab5d9112082a698afa3512c99a46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118ab5d9112082a698afa3512c99a46e">&#9670;&#160;</a></span>kilo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a118ab5d9112082a698afa3512c99a46e">kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b7fbb2fd3099cd6e2bb5a712becf41c" name="a8b7fbb2fd3099cd6e2bb5a712becf41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7fbb2fd3099cd6e2bb5a712becf41c">&#9670;&#160;</a></span>mega</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a8b7fbb2fd3099cd6e2bb5a712becf41c">mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0782f438fdf0a5e815bb88d8116543a" name="aa0782f438fdf0a5e815bb88d8116543a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0782f438fdf0a5e815bb88d8116543a">&#9670;&#160;</a></span>giga</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa0782f438fdf0a5e815bb88d8116543a">giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb0850018459aaecf06435ee5eb9f0d8" name="abb0850018459aaecf06435ee5eb9f0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0850018459aaecf06435ee5eb9f0d8">&#9670;&#160;</a></span>tera</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#abb0850018459aaecf06435ee5eb9f0d8">tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e47bd1a852d56651ef8b41a86a86fa8" name="a8e47bd1a852d56651ef8b41a86a86fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e47bd1a852d56651ef8b41a86a86fa8">&#9670;&#160;</a></span>peta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a8e47bd1a852d56651ef8b41a86a86fa8">peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabe49b8885eb17fdade12acd5f37acad" name="aabe49b8885eb17fdade12acd5f37acad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe49b8885eb17fdade12acd5f37acad">&#9670;&#160;</a></span>exa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aabe49b8885eb17fdade12acd5f37acad">exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cac3d2bc7e91527aa7422b304a2c3b9" name="a2cac3d2bc7e91527aa7422b304a2c3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cac3d2bc7e91527aa7422b304a2c3b9">&#9670;&#160;</a></span>static_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">static_string</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'char'. </p>

</div>
</div>
<a id="a1ddab558c296b52627438267301b1976" name="a1ddab558c296b52627438267301b1976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddab558c296b52627438267301b1976">&#9670;&#160;</a></span>static_wstring</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1ddab558c296b52627438267301b1976">static_wstring</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'wchar_t'. </p>

</div>
</div>
<a id="a6f7f02db9e66eaec8dccdca2f4e98a2f" name="a6f7f02db9e66eaec8dccdca2f4e98a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">&#9670;&#160;</a></span>string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">string_view</a> = <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedefs for common character type. </p>

</div>
</div>
<a id="ae88df1a5f5c335cb6cf4909b47882e53" name="ae88df1a5f5c335cb6cf4909b47882e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88df1a5f5c335cb6cf4909b47882e53">&#9670;&#160;</a></span>tuple_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9600db38eaa1a27a206f9fb90b1dedb7" name="a9600db38eaa1a27a206f9fb90b1dedb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9600db38eaa1a27a206f9fb90b1dedb7">&#9670;&#160;</a></span>aligned_storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Len, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Align = alignof(detail::aligned_storage_impl&lt;Len&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a9600db38eaa1a27a206f9fb90b1dedb7">aligned_storage_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1aligned__storage.html">etl::aligned_storage</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Len</a>, <a class="el" href="structetl_1_1static__vector.html">Align</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9513446f02808e2f74f025a795d894c2" name="a9513446f02808e2f74f025a795d894c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9513446f02808e2f74f025a795d894c2">&#9670;&#160;</a></span>aligned_union_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Len, typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a9513446f02808e2f74f025a795d894c2">aligned_union_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1aligned__union.html">etl::aligned_union</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Len</a>, Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5c90336c94cb0db8abdd10603a3c7cc" name="ac5c90336c94cb0db8abdd10603a3c7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c90336c94cb0db8abdd10603a3c7cc">&#9670;&#160;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">B</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4e9c28fa52ab73ef48e5cbed20c66fd" name="aa4e9c28fa52ab73ef48e5cbed20c66fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e9c28fa52ab73ef48e5cbed20c66fd">&#9670;&#160;</a></span>true_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa4e9c28fa52ab73ef48e5cbed20c66fd">true_type</a> = <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad15d3ff5d80b8c8c22e9ce862353ba55" name="ad15d3ff5d80b8c8c22e9ce862353ba55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15d3ff5d80b8c8c22e9ce862353ba55">&#9670;&#160;</a></span>false_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad15d3ff5d80b8c8c22e9ce862353ba55">false_type</a> = <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">false</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe1164daef675b01dddc89c2b7c28d80" name="afe1164daef675b01dddc89c2b7c28d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1164daef675b01dddc89c2b7c28d80">&#9670;&#160;</a></span>common_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afe1164daef675b01dddc89c2b7c28d80">common_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__reference.html">common_reference</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29d6d310a0bc8bcb40b024f5259088a6" name="a29d6d310a0bc8bcb40b024f5259088a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d6d310a0bc8bcb40b024f5259088a6">&#9670;&#160;</a></span>common_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a29d6d310a0bc8bcb40b024f5259088a6">common_type_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__type.html">etl::common_type</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ccf02556580259044928051b1689171" name="a4ccf02556580259044928051b1689171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccf02556580259044928051b1689171">&#9670;&#160;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a4ccf02556580259044928051b1689171">conditional_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1conditional.html">etl::conditional</a>&lt;<a class="el" href="structetl_1_1static__vector.html">B</a>, T, <a class="el" href="structetl_1_1static__vector.html">F</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24f3c9ab2c53f9192c2899fc8efb263d" name="a24f3c9ab2c53f9192c2899fc8efb263d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f3c9ab2c53f9192c2899fc8efb263d">&#9670;&#160;</a></span>decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e9cb7fadbcfaa2afb5b94058b8e34c" name="a93e9cb7fadbcfaa2afb5b94058b8e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">&#9670;&#160;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B, <a class="el" href="structetl_1_1static__vector.html">typename</a> T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structetl_1_1static__vector.html">B</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa543888abe1d65f79e9b1a62b95dc55" name="aaa543888abe1d65f79e9b1a62b95dc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa543888abe1d65f79e9b1a62b95dc55">&#9670;&#160;</a></span>index_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aaa543888abe1d65f79e9b1a62b95dc55">index_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">etl::integral_constant</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="structetl_1_1static__vector.html">I</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a601366c5cf97ac29c08fc7b51db875a9" name="a601366c5cf97ac29c08fc7b51db875a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601366c5cf97ac29c08fc7b51db875a9">&#9670;&#160;</a></span>invoke_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... ArgTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a601366c5cf97ac29c08fc7b51db875a9">invoke_result_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1invoke__result.html">etl::invoke_result</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, ArgTypes...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab130b8cdd79b1e59a593d4cb1c6ffe13" name="ab130b8cdd79b1e59a593d4cb1c6ffe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab130b8cdd79b1e59a593d4cb1c6ffe13">&#9670;&#160;</a></span>is_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ab130b8cdd79b1e59a593d4cb1c6ffe13">is_constructible</a> = detail::is_constructible_helper&lt;<a class="el" href="#ab8ddf9531fc4ac7ce28574db20c8f20e">etl::void_t</a>&lt;&gt;, T, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafd5f69b53391404e954cf610afa6c54" name="aafd5f69b53391404e954cf610afa6c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd5f69b53391404e954cf610afa6c54">&#9670;&#160;</a></span>make_signed_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabeda2fce2dea6fa29533488400dd386" name="aabeda2fce2dea6fa29533488400dd386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabeda2fce2dea6fa29533488400dd386">&#9670;&#160;</a></span>make_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aabeda2fce2dea6fa29533488400dd386">make_unsigned_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ffde65d0200b12233a0dff1979cc210" name="a0ffde65d0200b12233a0dff1979cc210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffde65d0200b12233a0dff1979cc210">&#9670;&#160;</a></span>remove_all_extents_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a0ffde65d0200b12233a0dff1979cc210">remove_all_extents_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7ac8d2d02fd6d54092f32339587b6ed" name="ae7ac8d2d02fd6d54092f32339587b6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ac8d2d02fd6d54092f32339587b6ed">&#9670;&#160;</a></span>remove_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae7ac8d2d02fd6d54092f32339587b6ed">remove_const_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__const.html">etl::remove_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9629a84441c7647c5374e5f1ada63df5" name="a9629a84441c7647c5374e5f1ada63df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9629a84441c7647c5374e5f1ada63df5">&#9670;&#160;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a9629a84441c7647c5374e5f1ada63df5">remove_cv_t</a> = <a class="el" href="#ae7ac8d2d02fd6d54092f32339587b6ed">etl::remove_const_t</a>&lt;<a class="el" href="#ad8be2e70b3b5f54ad08dcfc5af63c9da">etl::remove_volatile_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d55d5d88d171bb347117b67a8741b65" name="a2d55d5d88d171bb347117b67a8741b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d55d5d88d171bb347117b67a8741b65">&#9670;&#160;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2d55d5d88d171bb347117b67a8741b65">remove_cvref_t</a> = <a class="el" href="#a9629a84441c7647c5374e5f1ada63df5">etl::remove_cv_t</a>&lt;<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a0303895778ee0a3f41e112cb7553ef" name="a3a0303895778ee0a3f41e112cb7553ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0303895778ee0a3f41e112cb7553ef">&#9670;&#160;</a></span>remove_extent_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3a0303895778ee0a3f41e112cb7553ef">remove_extent_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__extent.html">etl::remove_extent</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af65c39ad5cff999e37c5009b047655a4" name="af65c39ad5cff999e37c5009b047655a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65c39ad5cff999e37c5009b047655a4">&#9670;&#160;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af65c39ad5cff999e37c5009b047655a4">remove_pointer_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__pointer.html">etl::remove_pointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9319953b536fc8279d2a105b02d1a938" name="a9319953b536fc8279d2a105b02d1a938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9319953b536fc8279d2a105b02d1a938">&#9670;&#160;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8be2e70b3b5f54ad08dcfc5af63c9da" name="ad8be2e70b3b5f54ad08dcfc5af63c9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8be2e70b3b5f54ad08dcfc5af63c9da">&#9670;&#160;</a></span>remove_volatile_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad8be2e70b3b5f54ad08dcfc5af63c9da">remove_volatile_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__volatile.html">etl::remove_volatile</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a3d3a54ac48d364dc4b3a06a7522126" name="a2a3d3a54ac48d364dc4b3a06a7522126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3d3a54ac48d364dc4b3a06a7522126">&#9670;&#160;</a></span>smallest_size_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2a3d3a54ac48d364dc4b3a06a7522126">smallest_size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">            <a class="code hl_struct" href="structetl_1_1static__vector.html">etl::conditional_t&lt;(N &lt; static_cast&lt;unsigned char&gt;</a>(-1)),     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>,</div>
<div class="line">            <a class="code hl_typedef" href="#a4ccf02556580259044928051b1689171">etl::conditional_t</a>&lt;(N &lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span><span class="keyword">&gt;</span>(-1)),    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>,</div>
<div class="line">            <a class="code hl_typedef" href="#a4ccf02556580259044928051b1689171">etl::conditional_t</a>&lt;(N &lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(-1)),      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,</div>
<div class="line">            <a class="code hl_typedef" href="#a4ccf02556580259044928051b1689171">etl::conditional_t</a>&lt;(N &lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(-1)),     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,</div>
<div class="line">                                                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>&gt;&gt;&gt;&gt;</div>
<div class="ttc" id="anamespaceetl_html_a4ccf02556580259044928051b1689171"><div class="ttname"><a href="#a4ccf02556580259044928051b1689171">etl::conditional_t</a></div><div class="ttdeci">typename etl::conditional&lt; B, T, F &gt;::type conditional_t</div><div class="ttdef"><b>Definition</b> conditional.hpp:21</div></div>
<div class="ttc" id="astructetl_1_1static__vector_html"><div class="ttname"><a href="structetl_1_1static__vector.html">etl::static_vector</a></div><div class="ttdoc">Dynamically-resizable fixed-capacity vector.</div><div class="ttdef"><b>Definition</b> static_vector.hpp:326</div></div>
</div><!-- fragment -->
<p>Smallest fixed-width unsigned integer type that can represent values in the range [0, N]. </p>

</div>
</div>
<a id="ae7cfb52ab2d82ff12cd2e0340315447f" name="ae7cfb52ab2d82ff12cd2e0340315447f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cfb52ab2d82ff12cd2e0340315447f">&#9670;&#160;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae7cfb52ab2d82ff12cd2e0340315447f">type_identity_t</a> = T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa68cdd3b170a7e28ceeb562ad04c2853" name="aa68cdd3b170a7e28ceeb562ad04c2853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68cdd3b170a7e28ceeb562ad04c2853">&#9670;&#160;</a></span>underlying_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa68cdd3b170a7e28ceeb562ad04c2853">underlying_type_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1underlying__type.html">etl::underlying_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadfe1ea88386619b73c8642aaac66548" name="aadfe1ea88386619b73c8642aaac66548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfe1ea88386619b73c8642aaac66548">&#9670;&#160;</a></span>unwrap_ref_decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aadfe1ea88386619b73c8642aaac66548">unwrap_ref_decay_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1unwrap__ref__decay.html">etl::unwrap_ref_decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8ddf9531fc4ac7ce28574db20c8f20e" name="ab8ddf9531fc4ac7ce28574db20c8f20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ddf9531fc4ac7ce28574db20c8f20e">&#9670;&#160;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ab8ddf9531fc4ac7ce28574db20c8f20e">void_t</a> = <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c41ad6b9af06544b52833e235bb14dd" name="a6c41ad6b9af06544b52833e235bb14dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c41ad6b9af06544b52833e235bb14dd">&#9670;&#160;</a></span>index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t... Ints&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a6c41ad6b9af06544b52833e235bb14dd">index_sequence</a> = <a class="el" href="structetl_1_1integer__sequence.html">etl::integer_sequence</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, Ints...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c526d8179a55ec15611d7627272e067" name="a3c526d8179a55ec15611d7627272e067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c526d8179a55ec15611d7627272e067">&#9670;&#160;</a></span>make_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3c526d8179a55ec15611d7627272e067">make_index_sequence</a> = <a class="el" href="#a4c97ecfe358afc1b3c226c0d7036da95">etl::make_integer_sequence</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26496b89801597f0e24f146bc25bb3ca" name="a26496b89801597f0e24f146bc25bb3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26496b89801597f0e24f146bc25bb3ca">&#9670;&#160;</a></span>index_sequence_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a26496b89801597f0e24f146bc25bb3ca">index_sequence_for</a> = <a class="el" href="#a3c526d8179a55ec15611d7627272e067">etl::make_index_sequence</a>&lt;sizeof...(T)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c97ecfe358afc1b3c226c0d7036da95" name="a4c97ecfe358afc1b3c226c0d7036da95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c97ecfe358afc1b3c226c0d7036da95">&#9670;&#160;</a></span>make_integer_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , T Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a4c97ecfe358afc1b3c226c0d7036da95">make_integer_sequence</a> = <a class="el" href="builtin__functions_8hpp.html#a303c6144751de3e45c44990112e8b1cb">TETL_BUILTIN_INT_SEQ</a>(T, <a class="el" href="structetl_1_1static__vector.html">Size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b611e97373f7c9c739f58a942f9de05" name="a7b611e97373f7c9c739f58a942f9de05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b611e97373f7c9c739f58a942f9de05">&#9670;&#160;</a></span>variant_alternative_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abc55212e09044ea8a258cd3a53d90dde" name="abc55212e09044ea8a258cd3a53d90dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc55212e09044ea8a258cd3a53d90dde">&#9670;&#160;</a></span>chars_format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#abc55212e09044ea8a258cd3a53d90dde">chars_format</a> : <a class="el" href="#a71924434159564bc3aa4bd2930947053">etl::uint8_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A BitmaskType used to specify floating-point formatting for to_chars and from_chars. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc55212e09044ea8a258cd3a53d90ddea55a95650a66b53ecbb960b53d985b964" name="abc55212e09044ea8a258cd3a53d90ddea55a95650a66b53ecbb960b53d985b964"></a>scientific&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abc55212e09044ea8a258cd3a53d90ddeacec315e3d0975e5cc2811d5d8725f149" name="abc55212e09044ea8a258cd3a53d90ddeacec315e3d0975e5cc2811d5d8725f149"></a>fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abc55212e09044ea8a258cd3a53d90ddeab8d1b43eae73587ba56baef574709ecb" name="abc55212e09044ea8a258cd3a53d90ddeab8d1b43eae73587ba56baef574709ecb"></a>hex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abc55212e09044ea8a258cd3a53d90ddea958153f1b8b96ec4c4eb2147429105d9" name="abc55212e09044ea8a258cd3a53d90ddea958153f1b8b96ec4c4eb2147429105d9"></a>general&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a592fe78d9bf66455d12aa075f36313b6" name="a592fe78d9bf66455d12aa075f36313b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592fe78d9bf66455d12aa075f36313b6">&#9670;&#160;</a></span>float_denorm_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="#a592fe78d9bf66455d12aa075f36313b6">float_denorm_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a592fe78d9bf66455d12aa075f36313b6ae6e5a92659b76e353da685746ec7a715" name="a592fe78d9bf66455d12aa075f36313b6ae6e5a92659b76e353da685746ec7a715"></a>denorm_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a592fe78d9bf66455d12aa075f36313b6ae1126f121e8e78fad4c2ea93b9154f70" name="a592fe78d9bf66455d12aa075f36313b6ae1126f121e8e78fad4c2ea93b9154f70"></a>denorm_absent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a592fe78d9bf66455d12aa075f36313b6ace9911a51bfc23dca58b86c67b0adfac" name="a592fe78d9bf66455d12aa075f36313b6ace9911a51bfc23dca58b86c67b0adfac"></a>denorm_present&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3bdaf6c7e8a65859bf550443989c5a66" name="a3bdaf6c7e8a65859bf550443989c5a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdaf6c7e8a65859bf550443989c5a66">&#9670;&#160;</a></span>float_round_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66">float_round_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66aef8e73dd0b0f1899790b6ba2bb47be7d" name="a3bdaf6c7e8a65859bf550443989c5a66aef8e73dd0b0f1899790b6ba2bb47be7d"></a>round_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66a2378935a2849c4d049d5e5a01324e827" name="a3bdaf6c7e8a65859bf550443989c5a66a2378935a2849c4d049d5e5a01324e827"></a>round_toward_zero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66aae97e229f8502c244371d7f7e3105afc" name="a3bdaf6c7e8a65859bf550443989c5a66aae97e229f8502c244371d7f7e3105afc"></a>round_to_nearest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66a33f65225750a8f3edc0b6601fa7bcd52" name="a3bdaf6c7e8a65859bf550443989c5a66a33f65225750a8f3edc0b6601fa7bcd52"></a>round_toward_infinity&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66ad9c511acb4735515f2402087641e9725" name="a3bdaf6c7e8a65859bf550443989c5a66ad9c511acb4735515f2402087641e9725"></a>round_toward_neg_infinity&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a8c9590e0d8ba5b7b8a2d709113c3e7bb" name="a8c9590e0d8ba5b7b8a2d709113c3e7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9590e0d8ba5b7b8a2d709113c3e7bb">&#9670;&#160;</a></span>align_val_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#a8c9590e0d8ba5b7b8a2d709113c3e7bb">align_val_t</a> : <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than the default, pass that alignment requirement as an argument of type align_val_t to the selected allocation/deallocation function. </p>

</div>
</div>
<a id="aa31f743d6273b64f3e8a3121813ea243" name="aa31f743d6273b64f3e8a3121813ea243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31f743d6273b64f3e8a3121813ea243">&#9670;&#160;</a></span>errc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243">errc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scoped enumeration <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a8ab69162f060cc46b805b3265ad1cdf1" name="aa31f743d6273b64f3e8a3121813ea243a8ab69162f060cc46b805b3265ad1cdf1"></a>address_family_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a8e2bc80599069d337b43dff6edfb6891" name="aa31f743d6273b64f3e8a3121813ea243a8e2bc80599069d337b43dff6edfb6891"></a>address_in_use&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a20abf2ffbf6e82e36405843f269d6438" name="aa31f743d6273b64f3e8a3121813ea243a20abf2ffbf6e82e36405843f269d6438"></a>address_not_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ab5580b198f691ab2df12f5e2ab974373" name="aa31f743d6273b64f3e8a3121813ea243ab5580b198f691ab2df12f5e2ab974373"></a>already_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a1b245b26b5ea3428c050d7f1503d7715" name="aa31f743d6273b64f3e8a3121813ea243a1b245b26b5ea3428c050d7f1503d7715"></a>argument_list_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a4b82222a0895b538d0597092b3ceab3e" name="aa31f743d6273b64f3e8a3121813ea243a4b82222a0895b538d0597092b3ceab3e"></a>argument_out_of_domain&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aaf169f73a82794128aa491c4b4f1c071" name="aa31f743d6273b64f3e8a3121813ea243aaf169f73a82794128aa491c4b4f1c071"></a>bad_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a9941c5c8c58ff058b870e94e96ac38e1" name="aa31f743d6273b64f3e8a3121813ea243a9941c5c8c58ff058b870e94e96ac38e1"></a>bad_file_descriptor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ac7944ab5d2e25bf75b267d070b506d1c" name="aa31f743d6273b64f3e8a3121813ea243ac7944ab5d2e25bf75b267d070b506d1c"></a>bad_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a2f0338eed54503152be1d31c93c9c2f1" name="aa31f743d6273b64f3e8a3121813ea243a2f0338eed54503152be1d31c93c9c2f1"></a>broken_pipe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a2f8f27a7eef1ad585c7ab6f25a6c2c79" name="aa31f743d6273b64f3e8a3121813ea243a2f8f27a7eef1ad585c7ab6f25a6c2c79"></a>connection_aborted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a81cf222a9b1530171fdfd66c3f734989" name="aa31f743d6273b64f3e8a3121813ea243a81cf222a9b1530171fdfd66c3f734989"></a>connection_already_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a53793ee58fc24168a0d6549c3cb2df8e" name="aa31f743d6273b64f3e8a3121813ea243a53793ee58fc24168a0d6549c3cb2df8e"></a>connection_refused&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243abf39bfc8665384194e343c08ab344405" name="aa31f743d6273b64f3e8a3121813ea243abf39bfc8665384194e343c08ab344405"></a>connection_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6177070a517d51a4382ab0d7c88e5b58" name="aa31f743d6273b64f3e8a3121813ea243a6177070a517d51a4382ab0d7c88e5b58"></a>cross_device_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a326032e01f2a5e14c7f730f4d03d753a" name="aa31f743d6273b64f3e8a3121813ea243a326032e01f2a5e14c7f730f4d03d753a"></a>destination_address_required&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ab3ab5338a00f49c4451851cc5442f370" name="aa31f743d6273b64f3e8a3121813ea243ab3ab5338a00f49c4451851cc5442f370"></a>device_or_resource_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6a336135d33e62f49edc55f29354e12e" name="aa31f743d6273b64f3e8a3121813ea243a6a336135d33e62f49edc55f29354e12e"></a>directory_not_empty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a4dfaf9c996cf045f32d17edc9754fc95" name="aa31f743d6273b64f3e8a3121813ea243a4dfaf9c996cf045f32d17edc9754fc95"></a>executable_format_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a41edf636e3c7b59f797348fc58472258" name="aa31f743d6273b64f3e8a3121813ea243a41edf636e3c7b59f797348fc58472258"></a>file_exists&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aa1e14bfb89b41ddf654b1772c8fd2e74" name="aa31f743d6273b64f3e8a3121813ea243aa1e14bfb89b41ddf654b1772c8fd2e74"></a>file_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6e56e6ed055b9771b8192a4f229fee27" name="aa31f743d6273b64f3e8a3121813ea243a6e56e6ed055b9771b8192a4f229fee27"></a>filename_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aa33c516bbdfb179cef733c8daeb97bed" name="aa31f743d6273b64f3e8a3121813ea243aa33c516bbdfb179cef733c8daeb97bed"></a>function_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243afe2377fbd16d7f335474e1df7d6376bf" name="aa31f743d6273b64f3e8a3121813ea243afe2377fbd16d7f335474e1df7d6376bf"></a>host_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a054e5b4ff59331386872de744d661719" name="aa31f743d6273b64f3e8a3121813ea243a054e5b4ff59331386872de744d661719"></a>identifier_removed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a53a9e57a679708b2d8ff0ccd8ec96b18" name="aa31f743d6273b64f3e8a3121813ea243a53a9e57a679708b2d8ff0ccd8ec96b18"></a>illegal_byte_sequence&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a45fe7da1767194b580aeba752d7b44ae" name="aa31f743d6273b64f3e8a3121813ea243a45fe7da1767194b580aeba752d7b44ae"></a>inappropriate_io_control_operation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243afadb76763385627e57ec386c9b6038f0" name="aa31f743d6273b64f3e8a3121813ea243afadb76763385627e57ec386c9b6038f0"></a>interrupted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ae55d43eabeefe5a8271b4a3c898bd18f" name="aa31f743d6273b64f3e8a3121813ea243ae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243abd86a2c65caf6a270b916234ab321ce3" name="aa31f743d6273b64f3e8a3121813ea243abd86a2c65caf6a270b916234ab321ce3"></a>invalid_seek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243acccc32f2a5f7dc7b87d2f85daea66789" name="aa31f743d6273b64f3e8a3121813ea243acccc32f2a5f7dc7b87d2f85daea66789"></a>io_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243af3c51d7ea75a76f26c0a2bdc00c4e006" name="aa31f743d6273b64f3e8a3121813ea243af3c51d7ea75a76f26c0a2bdc00c4e006"></a>is_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ade5f4bc2f8a4690176e22e83196b9fd3" name="aa31f743d6273b64f3e8a3121813ea243ade5f4bc2f8a4690176e22e83196b9fd3"></a>message_size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a93b16d34b1689f66f0cfed60e99c0009" name="aa31f743d6273b64f3e8a3121813ea243a93b16d34b1689f66f0cfed60e99c0009"></a>network_down&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a0e1d200ae35ede416bf85f84093ce37a" name="aa31f743d6273b64f3e8a3121813ea243a0e1d200ae35ede416bf85f84093ce37a"></a>network_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a608a68344b4eb1fe0690861a83828816" name="aa31f743d6273b64f3e8a3121813ea243a608a68344b4eb1fe0690861a83828816"></a>network_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a618ead44397b73cf0baa08b460b66c39" name="aa31f743d6273b64f3e8a3121813ea243a618ead44397b73cf0baa08b460b66c39"></a>no_buffer_space&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ad08d4c854a6810cebd2a8ab61876f919" name="aa31f743d6273b64f3e8a3121813ea243ad08d4c854a6810cebd2a8ab61876f919"></a>no_child_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243add431dfaf61ea842693dca8be1ebcaf7" name="aa31f743d6273b64f3e8a3121813ea243add431dfaf61ea842693dca8be1ebcaf7"></a>no_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a58688487c3e24313637a76bd29881e64" name="aa31f743d6273b64f3e8a3121813ea243a58688487c3e24313637a76bd29881e64"></a>no_lock_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aeec0f03ad92584c78835c10ab79d7f42" name="aa31f743d6273b64f3e8a3121813ea243aeec0f03ad92584c78835c10ab79d7f42"></a>no_message_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243acec935db07cfc57caafa37e98eafb213" name="aa31f743d6273b64f3e8a3121813ea243acec935db07cfc57caafa37e98eafb213"></a>no_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243abed8a9032d9366c28582a0ad59a31525" name="aa31f743d6273b64f3e8a3121813ea243abed8a9032d9366c28582a0ad59a31525"></a>no_protocol_option&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a1a5334dd8d1ca56e33887bd44630641b" name="aa31f743d6273b64f3e8a3121813ea243a1a5334dd8d1ca56e33887bd44630641b"></a>no_space_on_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ad8b1d94a0ac09c6d55b2ed68f0836142" name="aa31f743d6273b64f3e8a3121813ea243ad8b1d94a0ac09c6d55b2ed68f0836142"></a>no_stream_resources&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a5c83a012eac17bbf458df5804801e373" name="aa31f743d6273b64f3e8a3121813ea243a5c83a012eac17bbf458df5804801e373"></a>no_such_device_or_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243af42b2e58729e2783b683c8610977fc22" name="aa31f743d6273b64f3e8a3121813ea243af42b2e58729e2783b683c8610977fc22"></a>no_such_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a2e70fc89b08f26fa3fc77694c91e8f7a" name="aa31f743d6273b64f3e8a3121813ea243a2e70fc89b08f26fa3fc77694c91e8f7a"></a>no_such_file_or_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ad91a9b8a734f2bef4b778f89806cbab7" name="aa31f743d6273b64f3e8a3121813ea243ad91a9b8a734f2bef4b778f89806cbab7"></a>no_such_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a21e867ca95e1dfecff4701863547dcec" name="aa31f743d6273b64f3e8a3121813ea243a21e867ca95e1dfecff4701863547dcec"></a>not_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a22ac64bb14c46bcbc338a21950b6e722" name="aa31f743d6273b64f3e8a3121813ea243a22ac64bb14c46bcbc338a21950b6e722"></a>not_a_socket&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6e752b7a04543e5052b2d0dd05eca0fa" name="aa31f743d6273b64f3e8a3121813ea243a6e752b7a04543e5052b2d0dd05eca0fa"></a>not_a_stream&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a69c2dbb5917ca550a862e9c1c839bca1" name="aa31f743d6273b64f3e8a3121813ea243a69c2dbb5917ca550a862e9c1c839bca1"></a>not_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aafdb5594dc3e484fc1bfd7c564d550c1" name="aa31f743d6273b64f3e8a3121813ea243aafdb5594dc3e484fc1bfd7c564d550c1"></a>not_enough_memory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aa55e82356e9721946aa9ba954733c6f0" name="aa31f743d6273b64f3e8a3121813ea243aa55e82356e9721946aa9ba954733c6f0"></a>not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243afd3d0bdcc9eb9e68534b7d055c5fe586" name="aa31f743d6273b64f3e8a3121813ea243afd3d0bdcc9eb9e68534b7d055c5fe586"></a>operation_canceled&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a4c7eb50b6d86ac8a130ebebc18dbe263" name="aa31f743d6273b64f3e8a3121813ea243a4c7eb50b6d86ac8a130ebebc18dbe263"></a>operation_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a8344b3d509942f035d5e303022f9b986" name="aa31f743d6273b64f3e8a3121813ea243a8344b3d509942f035d5e303022f9b986"></a>operation_not_permitted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a69bf074bf052ee4c9047b62fe7c24569" name="aa31f743d6273b64f3e8a3121813ea243a69bf074bf052ee4c9047b62fe7c24569"></a>operation_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a738abdaead9cd7b2e2ea19a34764b385" name="aa31f743d6273b64f3e8a3121813ea243a738abdaead9cd7b2e2ea19a34764b385"></a>operation_would_block&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a2abac2fa6722c56b2ea17ac6c4097f68" name="aa31f743d6273b64f3e8a3121813ea243a2abac2fa6722c56b2ea17ac6c4097f68"></a>owner_dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ae8ee838822072f02738dbd7d97ea03fc" name="aa31f743d6273b64f3e8a3121813ea243ae8ee838822072f02738dbd7d97ea03fc"></a>permission_denied&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a9665c745d0a9132d8da6ed55e89a0564" name="aa31f743d6273b64f3e8a3121813ea243a9665c745d0a9132d8da6ed55e89a0564"></a>protocol_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aa2635acef8b9a3e1c40923829722d472" name="aa31f743d6273b64f3e8a3121813ea243aa2635acef8b9a3e1c40923829722d472"></a>protocol_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a06108efce8ef1cd8aa4cc440f8b4317f" name="aa31f743d6273b64f3e8a3121813ea243a06108efce8ef1cd8aa4cc440f8b4317f"></a>read_only_file_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aed65f7649c6f0e365673d65a9d8119d8" name="aa31f743d6273b64f3e8a3121813ea243aed65f7649c6f0e365673d65a9d8119d8"></a>resource_deadlock_would_occur&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ae46a97ea2906921c8c626890bde832cf" name="aa31f743d6273b64f3e8a3121813ea243ae46a97ea2906921c8c626890bde832cf"></a>resource_unavailable_try_again&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a8e0fafb181567cc468e1ee81983d739d" name="aa31f743d6273b64f3e8a3121813ea243a8e0fafb181567cc468e1ee81983d739d"></a>result_out_of_range&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6805059549401365b824b54573a6f46e" name="aa31f743d6273b64f3e8a3121813ea243a6805059549401365b824b54573a6f46e"></a>state_not_recoverable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ac1a620a30954dc9402a811453c2c3e3f" name="aa31f743d6273b64f3e8a3121813ea243ac1a620a30954dc9402a811453c2c3e3f"></a>stream_timeout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ad2f80f12d22bb099fcf1062db660b567" name="aa31f743d6273b64f3e8a3121813ea243ad2f80f12d22bb099fcf1062db660b567"></a>text_file_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a56c27b1ab1a5a5a0eae853cabb4dc0c1" name="aa31f743d6273b64f3e8a3121813ea243a56c27b1ab1a5a5a0eae853cabb4dc0c1"></a>timed_out&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a3130d1d4e000cdc1e7c47013e313c10e" name="aa31f743d6273b64f3e8a3121813ea243a3130d1d4e000cdc1e7c47013e313c10e"></a>too_many_files_open_in_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aed2c33c8fe874cfeba6f4a7747c62d05" name="aa31f743d6273b64f3e8a3121813ea243aed2c33c8fe874cfeba6f4a7747c62d05"></a>too_many_files_open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243abfe22fc9b27a8ff13186aba60b6bc5c8" name="aa31f743d6273b64f3e8a3121813ea243abfe22fc9b27a8ff13186aba60b6bc5c8"></a>too_many_links&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a33c78baca1480479c88aa4d50cb68206" name="aa31f743d6273b64f3e8a3121813ea243a33c78baca1480479c88aa4d50cb68206"></a>too_many_symbolic_link_levels&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a143653b075bff946193644ba6d97fa5d" name="aa31f743d6273b64f3e8a3121813ea243a143653b075bff946193644ba6d97fa5d"></a>value_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a81cac28a38438710de9856af4a8bcd0b" name="aa31f743d6273b64f3e8a3121813ea243a81cac28a38438710de9856af4a8bcd0b"></a>wrong_protocol_type&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a6a5c92ae723acdba8ce0f48be8530154" name="a6a5c92ae723acdba8ce0f48be8530154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5c92ae723acdba8ce0f48be8530154">&#9670;&#160;</a></span>implementation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154">implementation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1" name="a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1"></a>freestanding&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a5c92ae723acdba8ce0f48be8530154a734d3030ff72ad8d9678efa82b1db7d2" name="a6a5c92ae723acdba8ce0f48be8530154a734d3030ff72ad8d9678efa82b1db7d2"></a>hosted&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a72411d869deb28d3d6a0f7d0d77dd1de" name="a72411d869deb28d3d6a0f7d0d77dd1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72411d869deb28d3d6a0f7d0d77dd1de">&#9670;&#160;</a></span>language_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> : <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">char</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for the currently selected C++ standard version. Unlike the official macro <code>__cplusplus</code>, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a72411d869deb28d3d6a0f7d0d77dd1dea6289bbfa378818f7066ccad5847da5a2" name="a72411d869deb28d3d6a0f7d0d77dd1dea6289bbfa378818f7066ccad5847da5a2"></a>cpp_17&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a72411d869deb28d3d6a0f7d0d77dd1dea4c7aabdc3eb0d845c62edfb822b0fe5a" name="a72411d869deb28d3d6a0f7d0d77dd1dea4c7aabdc3eb0d845c62edfb822b0fe5a"></a>cpp_20&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a72411d869deb28d3d6a0f7d0d77dd1deaf7d98f68372c9de30cc2d571b75b19d7" name="a72411d869deb28d3d6a0f7d0d77dd1deaf7d98f68372c9de30cc2d571b75b19d7"></a>cpp_23&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff" name="a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff"></a>cpp_26&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acf27092e22460faafdb958cac56c6fec" name="acf27092e22460faafdb958cac56c6fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf27092e22460faafdb958cac56c6fec">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt</a>&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">value</td><td>The value to search for.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a> </p>

</div>
</div>
<a id="ad2a8919c2c9cca7f4eb38f2199797c37" name="ad2a8919c2c9cca7f4eb38f2199797c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a8919c2c9cca7f4eb38f2199797c37">&#9670;&#160;</a></span>equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise. </p>

</div>
</div>
<a id="a13fb0dac9928f1cf33cc07f069cac971" name="a13fb0dac9928f1cf33cc07f069cac971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fb0dac9928f1cf33cc07f069cac971">&#9670;&#160;</a></span>equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab79340eb0330b4f112afc47f71e3d844" name="ab79340eb0330b4f112afc47f71e3d844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79340eb0330b4f112afc47f71e3d844">&#9670;&#160;</a></span>equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cb7da13869cc2911d1dd3ebfbc49681" name="a8cb7da13869cc2911d1dd3ebfbc49681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb7da13869cc2911d1dd3ebfbc49681">&#9670;&#160;</a></span>equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0065deb93b945a04f6875db16eba3fd3" name="a0065deb93b945a04f6875db16eba3fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0065deb93b945a04f6875db16eba3fd3">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a> </p>

</div>
</div>
<a id="a7225526a11c7ee4454afce37e9bfd031" name="a7225526a11c7ee4454afce37e9bfd031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7225526a11c7ee4454afce37e9bfd031">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7166349fd110372de5c865fe5767f97" name="ad7166349fd110372de5c865fe5767f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7166349fd110372de5c865fe5767f97">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value to the elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ae52b4d387889126b64b88ca2150c6ddc" name="ae52b4d387889126b64b88ca2150c6ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52b4d387889126b64b88ca2150c6ddc">&#9670;&#160;</a></span>fill_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> fill_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator one past the last element assigned if <code>count &gt; 0</code>, <code>first</code> otherwise. </dd></dl>

</div>
</div>
<a id="af123f494fccf3d1e9420928c32915189" name="af123f494fccf3d1e9420928c32915189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af123f494fccf3d1e9420928c32915189">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">value</td><td>Value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a0">algorithm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a99ba00834faefda2a3d9b112d053f889" name="a99ba00834faefda2a3d9b112d053f889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ba00834faefda2a3d9b112d053f889">&#9670;&#160;</a></span>find_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for </td></tr>
    <tr><td class="paramname">p</td><td>Binary predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the beginning of last occurrence of the sequence [sFirst, sLast) in range <code>[first, last)</code>. If [sFirst, sLast) is empty or if no such sequence is found, last is returned. </dd></dl>

</div>
</div>
<a id="a3668f0480d1f8d6976de08b3658eb97e" name="a3668f0480d1f8d6976de08b3658eb97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3668f0480d1f8d6976de08b3658eb97e">&#9670;&#160;</a></span>find_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac49fa522ef832adfa9ebb8c4592ca60" name="aac49fa522ef832adfa9ebb8c4592ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac49fa522ef832adfa9ebb8c4592ca60">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of">https://en.cppreference.com/w/cpp/algorithm/find_first_of</a> </p>

</div>
</div>
<a id="a74fd28c3677d3bebf66460a3e492f3c0" name="a74fd28c3677d3bebf66460a3e492f3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fd28c3677d3bebf66460a3e492f3c0">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of">https://en.cppreference.com/w/cpp/algorithm/find_first_of</a> </p>

</div>
</div>
<a id="a214a2898fc2820379237f4cc89e3249f" name="a214a2898fc2820379237f4cc89e3249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214a2898fc2820379237f4cc89e3249f">&#9670;&#160;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> find_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate p returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Unary predicate which returns true for the required element.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>

</div>
</div>
<a id="abd10eb98eb927ed2e7efb96bbbebac30" name="abd10eb98eb927ed2e7efb96bbbebac30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd10eb98eb927ed2e7efb96bbbebac30">&#9670;&#160;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> find_if_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate q returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Unary predicate which returns true for the required element.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>

</div>
</div>
<a id="a14fe21109f4f9d8ce7a3364bb45e9eae" name="a14fe21109f4f9d8ce7a3364bb45e9eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14fe21109f4f9d8ce7a3364bb45e9eae">&#9670;&#160;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> for_each </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range to apply the function to. </td></tr>
    <tr><td class="paramname">last</td><td>The range to apply the function to. </td></tr>
    <tr><td class="paramname">f</td><td>Function object, to be applied to the result of dereferencing every iterator in the range.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each">https://en.cppreference.com/w/cpp/algorithm/for_each</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a1">algorithm.cpp</a>, and <a class="el" href="set_8cpp-example.html#a1">set.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5ef3395c26e44857cb21437ffbd285e7" name="a5ef3395c26e44857cb21437ffbd285e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef3395c26e44857cb21437ffbd285e7">&#9670;&#160;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> for_each_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to apply the function to. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements to apply the function to. </td></tr>
    <tr><td class="paramname">f</td><td>Function object, to be applied to the result of dereferencing every iterator in the range.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each_n">https://en.cppreference.com/w/cpp/algorithm/for_each_n</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a2">algorithm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a379d8ee0b21dfbdc9b0e5e4d7762eb43" name="a379d8ee0b21dfbdc9b0e5e4d7762eb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379d8ee0b21dfbdc9b0e5e4d7762eb43">&#9670;&#160;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Generator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Generator</a></td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns each element in range <code>[first, last)</code> a value generated by the given function object g. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">g</td><td>Generator function object that will be called.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate">https://en.cppreference.com/w/cpp/algorithm/generate</a> </p>

</div>
</div>
<a id="a12543b4f9ab02e90be68988a60f74dbe" name="a12543b4f9ab02e90be68988a60f74dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12543b4f9ab02e90be68988a60f74dbe">&#9670;&#160;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">SizeT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Generator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> generate_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Generator</a></td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">count</td><td>Number of the elements to generate. </td></tr>
    <tr><td class="paramname">g</td><td>Generator function object that will be called.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate_n">https://en.cppreference.com/w/cpp/algorithm/generate_n</a> </p>

</div>
</div>
<a id="afe96d864c89d47ea3902b6fc8826d2b5" name="afe96d864c89d47ea3902b6fc8826d2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe96d864c89d47ea3902b6fc8826d2b5">&#9670;&#160;</a></span>gnome_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> gnome_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Gnome_sort">https://en.wikipedia.org/wiki/Gnome_sort</a>. </p>

</div>
</div>
<a id="a4ee8f3605b778d70c05a5697ffae6192" name="a4ee8f3605b778d70c05a5697ffae6192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee8f3605b778d70c05a5697ffae6192">&#9670;&#160;</a></span>gnome_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> gnome_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f0d5db89d1e54d2ccb479a559df46aa" name="a5f0d5db89d1e54d2ccb479a559df46aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0d5db89d1e54d2ccb479a559df46aa">&#9670;&#160;</a></span>includes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> includes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted. </p>

</div>
</div>
<a id="ae0d74dfc016d11d54f60ad30618fc276" name="ae0d74dfc016d11d54f60ad30618fc276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d74dfc016d11d54f60ad30618fc276">&#9670;&#160;</a></span>includes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> includes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af90ac00af714eca3a603115a96d226d1" name="af90ac00af714eca3a603115a96d226d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90ac00af714eca3a603115a96d226d1">&#9670;&#160;</a></span>inplace_merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> inplace_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>mid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). </p>
<p>A sequence [first, last) is said to be sorted with respect to a comparator comp if for any iterator it pointing comp(*(it + n), *it) evaluates to false.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/inplace_merge">https://en.cppreference.com/w/cpp/algorithm/inplace_merge</a> </p>

</div>
</div>
<a id="a485ce5c1c0690a9616ba899fe2db7a10" name="a485ce5c1c0690a9616ba899fe2db7a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485ce5c1c0690a9616ba899fe2db7a10">&#9670;&#160;</a></span>inplace_merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> inplace_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>mid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1189f81daa0314d4422781edab8a4e83" name="a1189f81daa0314d4422781edab8a4e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1189f81daa0314d4422781edab8a4e83">&#9670;&#160;</a></span>insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> insertion_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. <a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a>. </p>

</div>
</div>
<a id="a819f2e196782c8f996a7a6d85853564b" name="a819f2e196782c8f996a7a6d85853564b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819f2e196782c8f996a7a6d85853564b">&#9670;&#160;</a></span>insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> insertion_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c3a106198fbf6b07743f082cec761fa" name="a7c3a106198fbf6b07743f082cec761fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3a106198fbf6b07743f082cec761fa">&#9670;&#160;</a></span>is_partitioned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_partitioned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty. <a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned">https://en.cppreference.com/w/cpp/algorithm/is_partitioned</a>. </p>

</div>
</div>
<a id="ab7ca70817d9b940ccd963245edb804e7" name="ab7ca70817d9b940ccd963245edb804e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ca70817d9b940ccd963245edb804e7">&#9670;&#160;</a></span>is_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given. </p>

</div>
</div>
<a id="acebb0727381b2818e6575c43ad064189" name="acebb0727381b2818e6575c43ad064189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebb0727381b2818e6575c43ad064189">&#9670;&#160;</a></span>is_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa25741a63c525afca9eaf8054b7122a9" name="aa25741a63c525afca9eaf8054b7122a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25741a63c525afca9eaf8054b7122a9">&#9670;&#160;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order. </p>

</div>
</div>
<a id="af0a1d40ec7a46d94456bc76abf70910c" name="af0a1d40ec7a46d94456bc76abf70910c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a1d40ec7a46d94456bc76abf70910c">&#9670;&#160;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa76ed3932bcae919d183136bb3dcf658" name="aa76ed3932bcae919d183136bb3dcf658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76ed3932bcae919d183136bb3dcf658">&#9670;&#160;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_sorted_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb2f98e7a5c930b843b813c8885ff0e" name="a1eb2f98e7a5c930b843b813c8885ff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb2f98e7a5c930b843b813c8885ff0e">&#9670;&#160;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_sorted_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order. </p>

</div>
</div>
<a id="a7a1249aee36691133f6b783a82290f8e" name="a7a1249aee36691133f6b783a82290f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1249aee36691133f6b783a82290f8e">&#9670;&#160;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iter_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the values of the elements the given iterators are pointing to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Iterators to the elements to swap. </td></tr>
    <tr><td class="paramname">b</td><td>Iterators to the elements to swap.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/iter_swap">https://en.cppreference.com/w/cpp/algorithm/iter_swap</a> </p>

</div>
</div>
<a id="acb90a196cbc728c59a4f2f16a9a9befd" name="acb90a196cbc728c59a4f2f16a9a9befd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb90a196cbc728c59a4f2f16a9a9befd">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>l1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>f2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>l2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare</a> </p>

</div>
</div>
<a id="a6bbb8794e1a09c00341acc4070284bd3" name="a6bbb8794e1a09c00341acc4070284bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbb8794e1a09c00341acc4070284bd3">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>l1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>f2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>l2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7eac84d4e60cc02ce593a33117a79ba3" name="a7eac84d4e60cc02ce593a33117a79ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eac84d4e60cc02ce593a33117a79ba3">&#9670;&#160;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a> </p>

</div>
</div>
<a id="aeef2815c598ddf680df6562ff413fc89" name="aeef2815c598ddf680df6562ff413fc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef2815c598ddf680df6562ff413fc89">&#9670;&#160;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f3eca1793f7f38aeb756464984eb194" name="a5f3eca1793f7f38aeb756464984eb194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3eca1793f7f38aeb756464984eb194">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b. </p>

</div>
</div>
<a id="ab9b79e7341165c49fa24ea2d66a761a5" name="ab9b79e7341165c49fa24ea2d66a761a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b79e7341165c49fa24ea2d66a761a5">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b, using a compare function. </p>

</div>
</div>
<a id="ac847a74164e6c1a692093c156b35eb30" name="ac847a74164e6c1a692093c156b35eb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac847a74164e6c1a692093c156b35eb30">&#9670;&#160;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> max_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a3b4b38361c7330f3c5996fef40213eed" name="a3b4b38361c7330f3c5996fef40213eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4b38361c7330f3c5996fef40213eed">&#9670;&#160;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> max_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="a390da486f87fc7f5e59fd16cb3015c25" name="a390da486f87fc7f5e59fd16cb3015c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390da486f87fc7f5e59fd16cb3015c25">&#9670;&#160;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>. </p>

</div>
</div>
<a id="a2de3be8fc3e9e834497d00be337e09ea" name="a2de3be8fc3e9e834497d00be337e09ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de3be8fc3e9e834497d00be337e09ea">&#9670;&#160;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d076e41cf7830be44fc5fc1322d9f49" name="a0d076e41cf7830be44fc5fc1322d9f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d076e41cf7830be44fc5fc1322d9f49">&#9670;&#160;</a></span>merge_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> merge_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a>. </p>

</div>
</div>
<a id="a9e07086e339175ad2433a095b9205e87" name="a9e07086e339175ad2433a095b9205e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e07086e339175ad2433a095b9205e87">&#9670;&#160;</a></span>merge_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> merge_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a810b4260b22a58b461be941fa6acb745" name="a810b4260b22a58b461be941fa6acb745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810b4260b22a58b461be941fa6acb745">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b. </p>

</div>
</div>
<a id="a80c60a3adb053935acbf3c8a91a0a035" name="a80c60a3adb053935acbf3c8a91a0a035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c60a3adb053935acbf3c8a91a0a035">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b, using a compare function. </p>

</div>
</div>
<a id="a4fb64c2aeca7185a3fdd03bff27f93f2" name="a4fb64c2aeca7185a3fdd03bff27f93f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb64c2aeca7185a3fdd03bff27f93f2">&#9670;&#160;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> min_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a4b5571b6aa07c8298071d5e43411200c" name="a4b5571b6aa07c8298071d5e43411200c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5571b6aa07c8298071d5e43411200c">&#9670;&#160;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> min_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="a2cf8c00a7d8e6e8c5eff71f1063fad52" name="a2cf8c00a7d8e6e8c5eff71f1063fad52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf8c00a7d8e6e8c5eff71f1063fad52">&#9670;&#160;</a></span>minmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> minmax </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;, T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest and the greatest of the given values. </p>

</div>
</div>
<a id="a8fe7517750d66b576d14d06fd58d74b1" name="a8fe7517750d66b576d14d06fd58d74b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe7517750d66b576d14d06fd58d74b1">&#9670;&#160;</a></span>minmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> minmax </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;, T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest and the greatest of the given values. </p>

</div>
</div>
<a id="aa68fb6c83c244cd496ea25c4f5a9d01f" name="aa68fb6c83c244cd496ea25c4f5a9d01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68fb6c83c244cd496ea25c4f5a9d01f">&#9670;&#160;</a></span>minmax_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> minmax_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest and greatest element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="a26ee575bad4a7b0cecd1869f7ecdc942" name="a26ee575bad4a7b0cecd1869f7ecdc942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ee575bad4a7b0cecd1869f7ecdc942">&#9670;&#160;</a></span>minmax_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> minmax_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest and greatest element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="a272907f42acd772ea50acaa07ffb12aa" name="a272907f42acd772ea50acaa07ffb12aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272907f42acd772ea50acaa07ffb12aa">&#9670;&#160;</a></span>mismatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The first range of the elements. </td></tr>
    <tr><td class="paramname">last1</td><td>The first range of the elements. </td></tr>
    <tr><td class="paramname">first2</td><td>The second range of the elements. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/mismatch">https://en.cppreference.com/w/cpp/algorithm/mismatch</a> </p>

</div>
</div>
<a id="a05cc526e4d807581e208306a999a8a51" name="a05cc526e4d807581e208306a999a8a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cc526e4d807581e208306a999a8a51">&#9670;&#160;</a></span>mismatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1833ff8cfefd00fbce92848e93af31e4" name="a1833ff8cfefd00fbce92848e93af31e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1833ff8cfefd00fbce92848e93af31e4">&#9670;&#160;</a></span>mismatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a371e9767b06eb932a467448a6e8e32fc" name="a371e9767b06eb932a467448a6e8e32fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371e9767b06eb932a467448a6e8e32fc">&#9670;&#160;</a></span>mismatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9060e0931516472a88f4657d835684a9" name="a9060e0931516472a88f4657d835684a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9060e0931516472a88f4657d835684a9">&#9670;&#160;</a></span>move() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">destination</td><td>The beginning of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element past the last element moved.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/move">https://en.cppreference.com/w/cpp/algorithm/move</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a3">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af551d4e71ff0eabb8f92409796fcf33d" name="af551d4e71ff0eabb8f92409796fcf33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af551d4e71ff0eabb8f92409796fcf33d">&#9670;&#160;</a></span>move_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> move_backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt2</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">destination</td><td>End of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator in the destination range, pointing at the last element moved.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/move_backward">https://en.cppreference.com/w/cpp/algorithm/move_backward</a> </p>

</div>
</div>
<a id="a816a532bf04d7e7c0a846b930a571a1d" name="a816a532bf04d7e7c0a846b930a571a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816a532bf04d7e7c0a846b930a571a1d">&#9670;&#160;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> none_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="a8a975e8950c5e7cc4ff7f97638d34a53" name="a8a975e8950c5e7cc4ff7f97638d34a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a975e8950c5e7cc4ff7f97638d34a53">&#9670;&#160;</a></span>nth_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> nth_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>nth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that: </p>
<ul>
<li>The element pointed at by nth is changed to whatever element would occur in that position if <code>[first, last)</code> were sorted.</li>
<li>All of the elements before this new nth element are less than or equal to the elements after the new nth element.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/nth_element">https://en.cppreference.com/w/cpp/algorithm/nth_element</a> </p>

</div>
</div>
<a id="a477060cd9d79c15a82456242a3005517" name="a477060cd9d79c15a82456242a3005517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477060cd9d79c15a82456242a3005517">&#9670;&#160;</a></span>nth_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> nth_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>nth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae05431e1f03b692ae88a58f8629a057" name="aae05431e1f03b692ae88a58f8629a057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae05431e1f03b692ae88a58f8629a057">&#9670;&#160;</a></span>partial_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> partial_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/partial_sort">https://en.cppreference.com/w/cpp/algorithm/partial_sort</a> </p>

</div>
</div>
<a id="a88a3bdc4477493e7bc5c106a53a3a314" name="a88a3bdc4477493e7bc5c106a53a3a314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a3bdc4477493e7bc5c106a53a3a314">&#9670;&#160;</a></span>partial_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> partial_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58dc6d94b5e29f2351debc8dff607246" name="a58dc6d94b5e29f2351debc8dff607246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58dc6d94b5e29f2351debc8dff607246">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved. </p>

</div>
</div>
<a id="ac406ce808473104b511907657832cd92" name="ac406ce808473104b511907657832cd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac406ce808473104b511907657832cd92">&#9670;&#160;</a></span>partition_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> partition_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt1</a></td>          <td class="paramname"><span class="paramname"><em>destinationTrue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt2</a></td>          <td class="paramname"><span class="paramname"><em>destinationFalse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">OutputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false. </p>
<p>The behavior is undefined if the input range overlaps either of the output ranges. </p>

</div>
</div>
<a id="a59eeccfe79ec5ab27f96d577417ca35a" name="a59eeccfe79ec5ab27f96d577417ca35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eeccfe79ec5ab27f96d577417ca35a">&#9670;&#160;</a></span>partition_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> partition_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p. </p>

</div>
</div>
<a id="a1ecba2ecefe71607f67bec456ff072fd" name="a1ecba2ecefe71607f67bec456ff072fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecba2ecefe71607f67bec456ff072fd">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range. </p>

</div>
</div>
<a id="aafdb5717541ddef9974357131dc1d248" name="aafdb5717541ddef9974357131dc1d248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdb5717541ddef9974357131dc1d248">&#9670;&#160;</a></span>remove_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> remove_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element copied. </dd></dl>

</div>
</div>
<a id="a8bdbbf4b495def4cb406f6af3ef25882" name="a8bdbbf4b495def4cb406f6af3ef25882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdbbf4b495def4cb406f6af3ef25882">&#9670;&#160;</a></span>remove_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> remove_copy_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element copied. </dd></dl>

</div>
</div>
<a id="a22cf73ac58ec2b4dd086be384cbbdd7d" name="a22cf73ac58ec2b4dd086be384cbbdd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cf73ac58ec2b4dd086be384cbbdd7d">&#9670;&#160;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> remove_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range. </p>

</div>
</div>
<a id="a7e970687eb65ad36a17922ed1be6764a" name="a7e970687eb65ad36a17922ed1be6764a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e970687eb65ad36a17922ed1be6764a">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>oldValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value. </p>

</div>
</div>
<a id="a13040e3fc5925b1bc966782f36635444" name="a13040e3fc5925b1bc966782f36635444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13040e3fc5925b1bc966782f36635444">&#9670;&#160;</a></span>replace_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> replace_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true. </p>

</div>
</div>
<a id="abf3169a8bd10088a7cf7d65b8aae66bc" name="abf3169a8bd10088a7cf7d65b8aae66bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3169a8bd10088a7cf7d65b8aae66bc">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="a5067524643b55244e12cb5eed183ddae" name="a5067524643b55244e12cb5eed183ddae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5067524643b55244e12cb5eed183ddae">&#9670;&#160;</a></span>reverse_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> reverse_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order. </p>
<p>If the source and destination ranges (that is, <code>[first, last)</code> and [d_first, d_first+(last-first)) respectively) overlap, the behavior is undefined. </p>

</div>
</div>
<a id="a99d4db23a06789c303ee8ec693d84129" name="a99d4db23a06789c303ee8ec693d84129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d4db23a06789c303ee8ec693d84129">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>nFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotation on a range of elements. </p>
<p>Specifically, rotate swaps the elements in the range [first, last) in such a way that the element n_first becomes the first element of the new range and n_first - 1 becomes the last element. A precondition of this function is that [first, n_first) and [n_first, last) are valid ranges. </p>

</div>
</div>
<a id="a8e3ea43eb370058e059c95c0738eb379" name="a8e3ea43eb370058e059c95c0738eb379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3ea43eb370058e059c95c0738eb379">&#9670;&#160;</a></span>rotate_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> rotate_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>nFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element. </p>

</div>
</div>
<a id="aa6b2f5d7fd6a15ab6fc4d30c1a716a6e" name="aa6b2f5d7fd6a15ab6fc4d30c1a716a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b2f5d7fd6a15ab6fc4d30c1a716a6e">&#9670;&#160;</a></span>search() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt2</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt2</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/search">https://en.cppreference.com/w/cpp/algorithm/search</a> </p>

</div>
</div>
<a id="a9fd9a9ec8c617610bf30e92fbaa678cd" name="a9fd9a9ec8c617610bf30e92fbaa678cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd9a9ec8c617610bf30e92fbaa678cd">&#9670;&#160;</a></span>search() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt2</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt2</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ec0297d32d2f51e39c270a715b430d1" name="a8ec0297d32d2f51e39c270a715b430d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec0297d32d2f51e39c270a715b430d1">&#9670;&#160;</a></span>search() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Searcher</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Searcher</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>searcher</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07b828a0b5a5e92873f178d30c4bb9df" name="a07b828a0b5a5e92873f178d30c4bb9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b828a0b5a5e92873f178d30c4bb9df">&#9670;&#160;</a></span>search_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> search_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ValueT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value. </p>

</div>
</div>
<a id="a52038b2431b48b42d039e54647d96493" name="a52038b2431b48b42d039e54647d96493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52038b2431b48b42d039e54647d96493">&#9670;&#160;</a></span>search_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueT</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> search_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ValueT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe32b3c3b80a92b66e5d7f118439492e" name="afe32b3c3b80a92b66e5d7f118439492e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe32b3c3b80a92b66e5d7f118439492e">&#9670;&#160;</a></span>set_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> set_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same. </p>

</div>
</div>
<a id="abf15d37410e2266762deefec2f9552e2" name="abf15d37410e2266762deefec2f9552e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf15d37410e2266762deefec2f9552e2">&#9670;&#160;</a></span>set_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> set_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfa483f6d503afb56bafdb6c73eebdd8" name="acfa483f6d503afb56bafdb6c73eebdd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa483f6d503afb56bafdb6c73eebdd8">&#9670;&#160;</a></span>set_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> set_intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="ac046bcca7d511bae026125e54c1f20e7" name="ac046bcca7d511bae026125e54c1f20e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac046bcca7d511bae026125e54c1f20e7">&#9670;&#160;</a></span>set_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> set_intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4249908e93f7b1367d3605c52b20a842" name="a4249908e93f7b1367d3605c52b20a842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4249908e93f7b1367d3605c52b20a842">&#9670;&#160;</a></span>set_symmetric_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at destination. The resulting range is also sorted. </p>

</div>
</div>
<a id="a5c80d1254a7659943993cacc3498dc38" name="a5c80d1254a7659943993cacc3498dc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c80d1254a7659943993cacc3498dc38">&#9670;&#160;</a></span>set_symmetric_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfd656aa427e48301b6fd14503854ff7" name="acfd656aa427e48301b6fd14503854ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd656aa427e48301b6fd14503854ff7">&#9670;&#160;</a></span>set_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> set_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="a4135eaec81217633145f410048de3cbe" name="a4135eaec81217633145f410048de3cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4135eaec81217633145f410048de3cbe">&#9670;&#160;</a></span>set_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> set_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a6d3457c4b1a845dce8219245bbc31c" name="a2a6d3457c4b1a845dce8219245bbc31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6d3457c4b1a845dce8219245bbc31c">&#9670;&#160;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> shift_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the elements in the range [first, last) by n positions. </p>
<p>Shifts the elements towards the beginning of the range. If n == 0 || n &gt;= last - first, there are no effects. If n &lt; 0, the behavior is undefined. Otherwise, for every integer i in [0, last - first - n), moves the element originally at position first + n + i to position first + i. The moves are performed in increasing order of i starting from 0. </p>

</div>
</div>
<a id="a465e2a36ddbbed9d12ad5403dccbb7b3" name="a465e2a36ddbbed9d12ad5403dccbb7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465e2a36ddbbed9d12ad5403dccbb7b3">&#9670;&#160;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> shift_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidiIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidiIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidiIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the elements in the range [first, last) by n positions. </p>
<p>Shifts the elements towards the end of the range. If n &lt;= 0 || n &gt;= last - first, there are no effects. Otherwise, for every integer i in [0, last - first - n), moves the element originally at position first + i to position first + n + i.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/shift">https://en.cppreference.com/w/cpp/algorithm/shift</a></p>
<dl class="section note"><dt>Note</dt><dd>The standard specifies that this algorithm should also work with legacy forward iterators. I don't know how to implement that without dynamic memory, so forward iterators are not supported. </dd></dl>

</div>
</div>
<a id="ad5ef221b98a814660142c728ce9bac78" name="ad5ef221b98a814660142c728ce9bac78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ef221b98a814660142c728ce9bac78">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is not guaranteed to be preserved. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a> </p>

</div>
</div>
<a id="a9823f4c1911f50c9f7ac3b4a8be9f294" name="a9823f4c1911f50c9f7ac3b4a8be9f294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9823f4c1911f50c9f7ac3b4a8be9f294">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0402fada51d792d7500e9a8f196eb649" name="a0402fada51d792d7500e9a8f196eb649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0402fada51d792d7500e9a8f196eb649">&#9670;&#160;</a></span>stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stable_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved. </p>

</div>
</div>
<a id="a555004d15f48a5bb9b71103bcc3e1555" name="a555004d15f48a5bb9b71103bcc3e1555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555004d15f48a5bb9b71103bcc3e1555">&#9670;&#160;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stable_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved. Elements are compared using the given comparison function comp. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a> </p>

</div>
</div>
<a id="ab57756439702cf72053e29b5c7294d85" name="ab57756439702cf72053e29b5c7294d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57756439702cf72053e29b5c7294d85">&#9670;&#160;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stable_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8e235b7f1654c13232e768201e17f4a" name="aa8e235b7f1654c13232e768201e17f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e235b7f1654c13232e768201e17f4a">&#9670;&#160;</a></span>swap_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The first range of elements to swap. </td></tr>
    <tr><td class="paramname">last1</td><td>The first range of elements to swap. </td></tr>
    <tr><td class="paramname">first2</td><td>Beginning of the second range of elements to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element exchanged in the range beginning with <code>first2</code>.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap_ranges">https://en.cppreference.com/w/cpp/algorithm/swap_ranges</a> </p>

</div>
</div>
<a id="a0d479673068495c0b88dcd93a99dfb57" name="a0d479673068495c0b88dcd93a99dfb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d479673068495c0b88dcd93a99dfb57">&#9670;&#160;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryOp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">UnaryOp</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by <code>[first, last)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">last</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">dest</td><td>The beginning of the destination range, may be equal to first. </td></tr>
    <tr><td class="paramname">op</td><td>Unary operation function object that will be applied.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_8cpp-example.html#a3">string.cpp</a>, and <a class="el" href="vector_8cpp-example.html#a2">vector.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa4f1eb9069005465b67c5d79eaae8bb9" name="aa4f1eb9069005465b67c5d79eaae8bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f1eb9069005465b67c5d79eaae8bb9">&#9670;&#160;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BinaryOp</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99f27339834dd24fea714a4b4ef5b383" name="a99f27339834dd24fea714a4b4ef5b383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f27339834dd24fea714a4b4ef5b383">&#9670;&#160;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="af368b8bc471211756f0fd32f9d2c8968" name="af368b8bc471211756f0fd32f9d2c8968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af368b8bc471211756f0fd32f9d2c8968">&#9670;&#160;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="a6aefae29604dcd0147171f39aa1380be" name="a6aefae29604dcd0147171f39aa1380be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aefae29604dcd0147171f39aa1380be">&#9670;&#160;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unique_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied. </p>
<p>Elements are compared using the given binary predicate pred. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="a18330134b5b5074b665d9e91c994f5e2" name="a18330134b5b5074b665d9e91c994f5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18330134b5b5074b665d9e91c994f5e2">&#9670;&#160;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unique_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied. </p>
<p>Elements are compared using operator==. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="ad3130ebfc35a09b9488d205269fdac86" name="ad3130ebfc35a09b9488d205269fdac86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3130ebfc35a09b9488d205269fdac86">&#9670;&#160;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than <code>value</code>, or last if no such element is found. </p>
<p>The range <code>[first, last)</code> must be partitioned with respect to the expression <code>!(value &lt; element)</code> or <code>!comp(value, element)</code>, i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion. </p>

</div>
</div>
<a id="a25261717b25b3523e4fdb8d6420183d2" name="a25261717b25b3523e4fdb8d6420183d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25261717b25b3523e4fdb8d6420183d2">&#9670;&#160;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99fb7a75a06b494847b855d850a44918" name="a99fb7a75a06b494847b855d850a44918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb7a75a06b494847b855d850a44918">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dbe12aeee105b81dad6ee8d5bf70db5" name="a8dbe12aeee105b81dad6ee8d5bf70db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbe12aeee105b81dad6ee8d5bf70db5">&#9670;&#160;</a></span>operator|() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>| </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a949f06ea9ccea69532ff49532f6cd7c7" name="a949f06ea9ccea69532ff49532f6cd7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949f06ea9ccea69532ff49532f6cd7c7">&#9670;&#160;</a></span>operator^() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>^ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b2bdaacf0312586cd586bd854a7b35a" name="a8b2bdaacf0312586cd586bd854a7b35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2bdaacf0312586cd586bd854a7b35a">&#9670;&#160;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> operator~ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afde4cd3357a82b4fb074755ab815223f" name="afde4cd3357a82b4fb074755ab815223f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde4cd3357a82b4fb074755ab815223f">&#9670;&#160;</a></span>operator|=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>|= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fcea5ac2499171347312a5f20051970" name="a2fcea5ac2499171347312a5f20051970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcea5ac2499171347312a5f20051970">&#9670;&#160;</a></span>operator&amp;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&amp;= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfa9d2eff6d0a0723cccce281bcf5619" name="acfa9d2eff6d0a0723cccce281bcf5619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa9d2eff6d0a0723cccce281bcf5619">&#9670;&#160;</a></span>operator^=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>^= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e91ff1be82212d980d87b1b7eee50ae" name="a3e91ff1be82212d980d87b1b7eee50ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e91ff1be82212d980d87b1b7eee50ae">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary AND between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="afb6dd579fe662e47108bc466e6f4b94a" name="afb6dd579fe662e47108bc466e6f4b94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6dd579fe662e47108bc466e6f4b94a">&#9670;&#160;</a></span>operator|() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary OR between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="a40a15b444153bb6f6f05086c199285cb" name="a40a15b444153bb6f6f05086c199285cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a15b444153bb6f6f05086c199285cb">&#9670;&#160;</a></span>operator^() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary XOR between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="af087d859a13aefa1d1af499478179a59" name="af087d859a13aefa1d1af499478179a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af087d859a13aefa1d1af499478179a59">&#9670;&#160;</a></span>default_assert_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> default_assert_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1assert__msg.html">assert_msg</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default assert handler. This will be called, if an assertion is triggered at runtime. </p>

</div>
</div>
<a id="a59f0c06539ace1da2bddf4e0812b84bb" name="a59f0c06539ace1da2bddf4e0812b84bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f0c06539ace1da2bddf4e0812b84bb">&#9670;&#160;</a></span>isalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isalnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is an alphanumeric character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is an alphanumeric character, 0 otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isalnum">https://en.cppreference.com/w/cpp/string/byte/isalnum</a> </p>

</div>
</div>
<a id="a3971a86a072f5ef420f9446c69f3e9b8" name="a3971a86a072f5ef420f9446c69f3e9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3971a86a072f5ef420f9446c69f3e9b8">&#9670;&#160;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isalpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is an alphabetic character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is an alphabetic character, 0 otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isalpha">https://en.cppreference.com/w/cpp/string/byte/isalpha</a> </p>

</div>
</div>
<a id="a538306563b896d39ab29eb2c13bce86b" name="a538306563b896d39ab29eb2c13bce86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538306563b896d39ab29eb2c13bce86b">&#9670;&#160;</a></span>isblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isblank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a blank character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isblank">https://en.cppreference.com/w/cpp/string/byte/isblank</a> </p>

</div>
</div>
<a id="a368e8ddd21d388ae1504166640a1b80b" name="a368e8ddd21d388ae1504166640a1b80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368e8ddd21d388ae1504166640a1b80b">&#9670;&#160;</a></span>iscntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iscntrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a control character as classified by the currently installed C locale. In the default, "C" locale, the control characters are the characters with the codes 0x00-0x1F and 0x7F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a control character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/iscntrl">https://en.cppreference.com/w/cpp/string/byte/iscntrl</a> </p>

</div>
</div>
<a id="a7ada684f4a3c41f99153164e5465e49c" name="a7ada684f4a3c41f99153164e5465e49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ada684f4a3c41f99153164e5465e49c">&#9670;&#160;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is one of the 10 decimal digits: 0123456789. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a numeric character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isdigit">https://en.cppreference.com/w/cpp/string/byte/isdigit</a> </p>

</div>
</div>
<a id="a3ce765b38ec7d09c9ef4e3424d24ce3b" name="a3ce765b38ec7d09c9ef4e3424d24ce3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce765b38ec7d09c9ef4e3424d24ce3b">&#9670;&#160;</a></span>isgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is graphic (has a graphical representation) as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isgraph">https://en.cppreference.com/w/cpp/string/byte/isgraph</a> </p>

</div>
</div>
<a id="a66b19e10b64e3f368ecdf462fb07b15b" name="a66b19e10b64e3f368ecdf462fb07b15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b19e10b64e3f368ecdf462fb07b15b">&#9670;&#160;</a></span>islower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> islower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is classified as a lowercase character according to the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a lowercase letter, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/islower">https://en.cppreference.com/w/cpp/string/byte/islower</a> </p>

</div>
</div>
<a id="aa48a725052c02bf9e7e2b74019bcb27e" name="aa48a725052c02bf9e7e2b74019bcb27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48a725052c02bf9e7e2b74019bcb27e">&#9670;&#160;</a></span>isprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isprint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if ch is a printable character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isprint">https://en.cppreference.com/w/cpp/string/byte/isprint</a> </p>

</div>
</div>
<a id="a5b14f213f7af1217b2d2cdf65f180738" name="a5b14f213f7af1217b2d2cdf65f180738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b14f213f7af1217b2d2cdf65f180738">&#9670;&#160;</a></span>ispunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ispunct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a punctuation character as classified by the current C locale. </p>
<p>The default C locale classifies the characters !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ as punctuation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/ispunct">https://en.cppreference.com/w/cpp/string/byte/ispunct</a> </p>

</div>
</div>
<a id="a9d797fc03c5126b24a821bd1fc122b3a" name="a9d797fc03c5126b24a821bd1fc122b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d797fc03c5126b24a821bd1fc122b3a">&#9670;&#160;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is whitespace character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a whitespace character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isspace">https://en.cppreference.com/w/cpp/string/byte/isspace</a> </p>

</div>
</div>
<a id="a060875a823b3d041865221eecc9b93de" name="a060875a823b3d041865221eecc9b93de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060875a823b3d041865221eecc9b93de">&#9670;&#160;</a></span>isupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is classified as a uppercase character according to the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a uppercase letter, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isupper">https://en.cppreference.com/w/cpp/string/byte/isupper</a> </p>

</div>
</div>
<a id="ab501c4cabaa10c4b866b9c957ff5e16b" name="ab501c4cabaa10c4b866b9c957ff5e16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab501c4cabaa10c4b866b9c957ff5e16b">&#9670;&#160;</a></span>isxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isxdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a hexadecimal numeric character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isxdigit">https://en.cppreference.com/w/cpp/string/byte/isxdigit</a> </p>

</div>
</div>
<a id="adeee7b085cced6d915305f9ae1bee437" name="adeee7b085cced6d915305f9ae1bee437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeee7b085cced6d915305f9ae1bee437">&#9670;&#160;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> tolower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given character to lowercase according to the character conversion rules defined by the default C locale. </p>
<p>In the default "C" locale, the following uppercase letters <b>ABCDEFGHIJKLMNOPQRSTUVWXYZ</b> are replaced with respective lowercase letters <b>abcdefghijklmnopqrstuvwxyz</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lowercase version of ch or unmodified ch if no lowercase version is listed in the current C locale.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/tolower">https://en.cppreference.com/w/cpp/string/byte/tolower</a> </p>

</div>
</div>
<a id="abf5656409846cdb311fcc37acd590d9a" name="abf5656409846cdb311fcc37acd590d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5656409846cdb311fcc37acd590d9a">&#9670;&#160;</a></span>toupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> toupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given character to uppercase according to the character conversion rules defined by the default C locale. </p>
<p>In the default "C" locale, the following lowercase letters <b>abcdefghijklmnopqrstuvwxyz</b> are replaced with respective uppercase letters <b>ABCDEFGHIJKLMNOPQRSTUVWXYZ</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted character or ch if no uppercase version is defined by the current C locale.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/toupper">https://en.cppreference.com/w/cpp/string/byte/toupper</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_8cpp-example.html#a2">string.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1f7a4153c0b6a56949cfa7691169049b" name="a1f7a4153c0b6a56949cfa7691169049b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7a4153c0b6a56949cfa7691169049b">&#9670;&#160;</a></span>isfinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isfinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a25b70d7be5ca34b77def3ff9950ef1cc" name="a25b70d7be5ca34b77def3ff9950ef1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b70d7be5ca34b77def3ff9950ef1cc">&#9670;&#160;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8986c9bc042cb46d1874b992a453180" name="ab8986c9bc042cb46d1874b992a453180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8986c9bc042cb46d1874b992a453180">&#9670;&#160;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf694dfa4152d5e19dfb263a24d0b3fd" name="aaf694dfa4152d5e19dfb263a24d0b3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf694dfa4152d5e19dfb263a24d0b3fd">&#9670;&#160;</a></span>isnormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> isnormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f4da52394b4be08dc83783c505ddc3a" name="a7f4da52394b4be08dc83783c505ddc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4da52394b4be08dc83783c505ddc3a">&#9670;&#160;</a></span>signbit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> signbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57744d86f1f45347bc48d426591e1ce1" name="a57744d86f1f45347bc48d426591e1ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57744d86f1f45347bc48d426591e1ce1">&#9670;&#160;</a></span>from_chars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> same_as&lt;<a class="el" href="structetl_1_1static__vector.html">Int</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> from_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value. </p>

</div>
</div>
<a id="a6d46a108541ea7e9e622ba37063518f9" name="a6d46a108541ea7e9e622ba37063518f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d46a108541ea7e9e622ba37063518f9">&#9670;&#160;</a></span>to_chars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> same_as&lt;T, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<p>Integer formatters: value is converted to a string of digits in the given base (with no redundant leading zeroes). Digits in the range 10..35 (inclusive) are represented as lowercase characters a..z. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type char as the type of the parameter value. </p>

</div>
</div>
<a id="a76ada873a32749c139721424bd4a122d" name="a76ada873a32749c139721424bd4a122d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ada873a32749c139721424bd4a122d">&#9670;&#160;</a></span>to_chars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">bool</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt;  <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>=<a class="el" href="structetl_1_1static__vector.html">delete</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a982037f958b7b332615a47e0458470a4" name="a982037f958b7b332615a47e0458470a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982037f958b7b332615a47e0458470a4">&#9670;&#160;</a></span>is_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2af0c0f3f06fcc2acc7fb473b8060eab" name="a2af0c0f3f06fcc2acc7fb473b8060eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af0c0f3f06fcc2acc7fb473b8060eab">&#9670;&#160;</a></span>is_neq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_neq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a266a85d1d883c6a4b7c74721dcfa9d3d" name="a266a85d1d883c6a4b7c74721dcfa9d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266a85d1d883c6a4b7c74721dcfa9d3d">&#9670;&#160;</a></span>is_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5180426dd93c0ed7faa85c5b9aaeca8" name="af5180426dd93c0ed7faa85c5b9aaeca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5180426dd93c0ed7faa85c5b9aaeca8">&#9670;&#160;</a></span>is_lteq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_lteq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9aac3f063804059658718a8e9e19195" name="af9aac3f063804059658718a8e9e19195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9aac3f063804059658718a8e9e19195">&#9670;&#160;</a></span>is_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a511c9b1ac1fc84868ea3530a2b2fc111" name="a511c9b1ac1fc84868ea3530a2b2fc111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511c9b1ac1fc84868ea3530a2b2fc111">&#9670;&#160;</a></span>is_gteq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_gteq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f1ea907ad0e2faef6a9dc5daae77f10" name="a8f1ea907ad0e2faef6a9dc5daae77f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1ea907ad0e2faef6a9dc5daae77f10">&#9670;&#160;</a></span>operator+() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8518792aba8f0c6bfdf3518364ab586c" name="a8518792aba8f0c6bfdf3518364ab586c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8518792aba8f0c6bfdf3518364ab586c">&#9670;&#160;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71864baa5b16ae3823bed93daadd854e" name="a71864baa5b16ae3823bed93daadd854e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71864baa5b16ae3823bed93daadd854e">&#9670;&#160;</a></span>operator+() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd2343a7c24574c0a76def77f277d07e" name="afd2343a7c24574c0a76def77f277d07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2343a7c24574c0a76def77f277d07e">&#9670;&#160;</a></span>operator+() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a278c443da9c85213dd35424e55083798" name="a278c443da9c85213dd35424e55083798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278c443da9c85213dd35424e55083798">&#9670;&#160;</a></span>operator+() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a368b52e0bd3a7839fd60d3f5e39cbb0f" name="a368b52e0bd3a7839fd60d3f5e39cbb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368b52e0bd3a7839fd60d3f5e39cbb0f">&#9670;&#160;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af027a8b3ad1bb5ca5f5179ed2206ad66" name="af027a8b3ad1bb5ca5f5179ed2206ad66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af027a8b3ad1bb5ca5f5179ed2206ad66">&#9670;&#160;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa390de4495e3c0ec93c4491c5639143" name="aaa390de4495e3c0ec93c4491c5639143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa390de4495e3c0ec93c4491c5639143">&#9670;&#160;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade01d8f935d63f6d9cba9fbe323f8821" name="ade01d8f935d63f6d9cba9fbe323f8821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade01d8f935d63f6d9cba9fbe323f8821">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9749f0f6e219a2633cc87acdfe48904" name="af9749f0f6e219a2633cc87acdfe48904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9749f0f6e219a2633cc87acdfe48904">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfad387b2163cd13b324a0f466cb12cd" name="acfad387b2163cd13b324a0f466cb12cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfad387b2163cd13b324a0f466cb12cd">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>* </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1b89ab01f9efe7650b6a97888f1e869" name="ac1b89ab01f9efe7650b6a97888f1e869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b89ab01f9efe7650b6a97888f1e869">&#9670;&#160;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafdc7ea9b09001e49518715162e70290" name="aafdc7ea9b09001e49518715162e70290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdc7ea9b09001e49518715162e70290">&#9670;&#160;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9660b9b2b46b561d976ffbf7dbde8d69" name="a9660b9b2b46b561d976ffbf7dbde8d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9660b9b2b46b561d976ffbf7dbde8d69">&#9670;&#160;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>/ </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27742612e6861226707341546907da1e" name="a27742612e6861226707341546907da1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27742612e6861226707341546907da1e">&#9670;&#160;</a></span>operator==() <span class="overload">[1/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af746cebe9104d4847df63754ab19eeb7" name="af746cebe9104d4847df63754ab19eeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af746cebe9104d4847df63754ab19eeb7">&#9670;&#160;</a></span>operator==() <span class="overload">[2/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32bab80e6235274bcc58d29d59d310a0" name="a32bab80e6235274bcc58d29d59d310a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bab80e6235274bcc58d29d59d310a0">&#9670;&#160;</a></span>operator==() <span class="overload">[3/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c27b4cf9bc931994626a2ef5dccdd31" name="a0c27b4cf9bc931994626a2ef5dccdd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c27b4cf9bc931994626a2ef5dccdd31">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21ed7f0af0742e1a5ac4571b8a0cb1f8" name="a21ed7f0af0742e1a5ac4571b8a0cb1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ed7f0af0742e1a5ac4571b8a0cb1f8">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87b2c8e96c56c4b8a13d0a122cf47b17" name="a87b2c8e96c56c4b8a13d0a122cf47b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b2c8e96c56c4b8a13d0a122cf47b17">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02a64d34e50bd46ac7c48f9c3b20ecfe" name="a02a64d34e50bd46ac7c48f9c3b20ecfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a64d34e50bd46ac7c48f9c3b20ecfe">&#9670;&#160;</a></span>to_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return Int(b);</code> </p>

</div>
</div>
<a id="a36eb9271474c81cef432c9a2b4afbee6" name="a36eb9271474c81cef432c9a2b4afbee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36eb9271474c81cef432c9a2b4afbee6">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);</code> </p>

</div>
</div>
<a id="a51eea63a0ce9f777a6682aaf90f48696" name="a51eea63a0ce9f777a6682aaf90f48696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51eea63a0ce9f777a6682aaf90f48696">&#9670;&#160;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);</code> </p>

</div>
</div>
<a id="af1cb2843a224e246ba96818c029d3cbc" name="af1cb2843a224e246ba96818c029d3cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cb2843a224e246ba96818c029d3cbc">&#9670;&#160;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;

</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return b = b &lt;&lt; shift;</code> </p>

</div>
</div>
<a id="a5ec81972434cf41e3465929f46a9d9e4" name="a5ec81972434cf41e3465929f46a9d9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec81972434cf41e3465929f46a9d9e4">&#9670;&#160;</a></span>operator&gt;&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return b = b &gt;&gt; shift;</code> </p>

</div>
</div>
<a id="ae524596905624f411ac531dd57bdc7db" name="ae524596905624f411ac531dd57bdc7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae524596905624f411ac531dd57bdc7db">&#9670;&#160;</a></span>operator|() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) | static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a86219208a90a3dde7323cc44e0df0ef4" name="a86219208a90a3dde7323cc44e0df0ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86219208a90a3dde7323cc44e0df0ef4">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) &amp; static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a0f70d9e6f3612368a7a87afd88db9a49" name="a0f70d9e6f3612368a7a87afd88db9a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f70d9e6f3612368a7a87afd88db9a49">&#9670;&#160;</a></span>operator^() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) ^ static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="aeea255f7742cda95d1dab63279b70687" name="aeea255f7742cda95d1dab63279b70687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea255f7742cda95d1dab63279b70687">&#9670;&#160;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(~static_cast&lt;unsigned int&gt;(b));</code> </p>

</div>
</div>
<a id="aa3816e8de39ecc8a024d86bd10a4f6f0" name="aa3816e8de39ecc8a024d86bd10a4f6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3816e8de39ecc8a024d86bd10a4f6f0">&#9670;&#160;</a></span>operator|=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs | rhs;</code> </p>

</div>
</div>
<a id="a7d19ed615073fb38a2b13da90e273c7c" name="a7d19ed615073fb38a2b13da90e273c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d19ed615073fb38a2b13da90e273c7c">&#9670;&#160;</a></span>operator&amp;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs &amp; rhs;</code> </p>

</div>
</div>
<a id="a71bdb2fbcbe02268c3ef208d91d5b702" name="a71bdb2fbcbe02268c3ef208d91d5b702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bdb2fbcbe02268c3ef208d91d5b702">&#9670;&#160;</a></span>operator^=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs ^ rhs;</code> </p>

</div>
</div>
<a id="a27bf898417a69084f2e08aa12510db7d" name="a27bf898417a69084f2e08aa12510db7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bf898417a69084f2e08aa12510db7d">&#9670;&#160;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> atof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>

</div>
</div>
<a id="ae6b33a1df966c3e01d825b336211e3ef" name="ae6b33a1df966c3e01d825b336211e3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b33a1df966c3e01d825b336211e3ef">&#9670;&#160;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> atoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="a699027607c1a0d56baf456931b915e76" name="a699027607c1a0d56baf456931b915e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699027607c1a0d56baf456931b915e76">&#9670;&#160;</a></span>atol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> atol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="aa7f1052e901c72fde401b3019f9437b1" name="aa7f1052e901c72fde401b3019f9437b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f1052e901c72fde401b3019f9437b1">&#9670;&#160;</a></span>atoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> atoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="a2a2d6bdea1596be40cc1f1965d14d3a7" name="a2a2d6bdea1596be40cc1f1965d14d3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2d6bdea1596be40cc1f1965d14d3a7">&#9670;&#160;</a></span>div() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1div__t.html">div_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a6bafeda54d634206adcb005c3ec87be3" name="a6bafeda54d634206adcb005c3ec87be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bafeda54d634206adcb005c3ec87be3">&#9670;&#160;</a></span>labs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> labs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="afe969af8a9f77fea0bb9e0d7a82c5b3f" name="afe969af8a9f77fea0bb9e0d7a82c5b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe969af8a9f77fea0bb9e0d7a82c5b3f">&#9670;&#160;</a></span>div() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a817f60653f2167239f303e63ec82d4d8" name="a817f60653f2167239f303e63ec82d4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817f60653f2167239f303e63ec82d4d8">&#9670;&#160;</a></span>ldiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ldiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a44d83917d527505e29d3a8d3afb413bc" name="a44d83917d527505e29d3a8d3afb413bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d83917d527505e29d3a8d3afb413bc">&#9670;&#160;</a></span>llabs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> llabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a6482fb76727697ae2e8c3d2da7de28d7" name="a6482fb76727697ae2e8c3d2da7de28d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6482fb76727697ae2e8c3d2da7de28d7">&#9670;&#160;</a></span>div() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a540df0e14af1fb716877eb210bd107b5" name="a540df0e14af1fb716877eb210bd107b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540df0e14af1fb716877eb210bd107b5">&#9670;&#160;</a></span>lldiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> lldiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a908461fb82d1921b7d9d47fefd69808f" name="a908461fb82d1921b7d9d47fefd69808f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908461fb82d1921b7d9d47fefd69808f">&#9670;&#160;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> strtod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a17ff85f301c7ae10d33eb06607976726" name="a17ff85f301c7ae10d33eb06607976726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ff85f301c7ae10d33eb06607976726">&#9670;&#160;</a></span>strtof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> strtof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a1a70d2daad7d58df41e035dc7b7d6ee1" name="a1a70d2daad7d58df41e035dc7b7d6ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a70d2daad7d58df41e035dc7b7d6ee1">&#9670;&#160;</a></span>strtol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> strtol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtol">https://en.cppreference.com/w/cpp/string/byte/strtol</a> </p>

</div>
</div>
<a id="afe6baccbeb60e396a8222d877a5ef28f" name="afe6baccbeb60e396a8222d877a5ef28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6baccbeb60e396a8222d877a5ef28f">&#9670;&#160;</a></span>strtoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> strtoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtol">https://en.cppreference.com/w/cpp/string/byte/strtol</a> </p>

</div>
</div>
<a id="ac30cff1b320a5ca627023644ccb321ef" name="ac30cff1b320a5ca627023644ccb321ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30cff1b320a5ca627023644ccb321ef">&#9670;&#160;</a></span>strtold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> strtold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a11d60e5943db8f44ee5c351c7744db66" name="a11d60e5943db8f44ee5c351c7744db66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d60e5943db8f44ee5c351c7744db66">&#9670;&#160;</a></span>strtoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> strtoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtoul">https://en.cppreference.com/w/cpp/string/byte/strtoul</a> </p>

</div>
</div>
<a id="a4ab96db1ba94415b0dce36ec1327f314" name="a4ab96db1ba94415b0dce36ec1327f314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab96db1ba94415b0dce36ec1327f314">&#9670;&#160;</a></span>strtoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> strtoull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtoul">https://en.cppreference.com/w/cpp/string/byte/strtoul</a> </p>

</div>
</div>
<a id="a95b81f8645cb1474f15eb0afc8297a82" name="a95b81f8645cb1474f15eb0afc8297a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b81f8645cb1474f15eb0afc8297a82">&#9670;&#160;</a></span>wcscat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcscat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated. </p>
<p>The behavior is undefined if the destination array is not large enough for the contents of both src and dest and the terminating null character. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="a48742a27f06adaa943c923168958fffd" name="a48742a27f06adaa943c923168958fffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48742a27f06adaa943c923168958fffd">&#9670;&#160;</a></span>wcschr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcschr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcschr">https://en.cppreference.com/w/cpp/string/wide/wcschr</a> </p>

</div>
</div>
<a id="afa8528d93a4e282441b93ef41355de51" name="afa8528d93a4e282441b93ef41355de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8528d93a4e282441b93ef41355de51">&#9670;&#160;</a></span>wcschr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcschr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcschr">https://en.cppreference.com/w/cpp/string/wide/wcschr</a> </p>

</div>
</div>
<a id="a394989e435a3d8820b9887b0cb6f32d0" name="a394989e435a3d8820b9887b0cb6f32d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394989e435a3d8820b9887b0cb6f32d0">&#9670;&#160;</a></span>wcscmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcscmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two null-terminated wide strings lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</p>
<p>The behavior is undefined if lhs or rhs are not pointers to null-terminated wide strings. </p>

</div>
</div>
<a id="a9c6e17a8ddf3c4fbe89a15f971083a96" name="a9c6e17a8ddf3c4fbe89a15f971083a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6e17a8ddf3c4fbe89a15f971083a96">&#9670;&#160;</a></span>wcscpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcscpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest. </p>
<p>The behavior is undefined if the dest array is not large enough. The behavior is undefined if the strings overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="aa32c98dda497088d03d293fe8e7898f3" name="aa32c98dda497088d03d293fe8e7898f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32c98dda497088d03d293fe8e7898f3">&#9670;&#160;</a></span>wcscspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcscspn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcscspn">https://en.cppreference.com/w/cpp/string/wide/wcscspn</a> </p>

</div>
</div>
<a id="ae76640f48ef8b4a03e9b81fd5ca4209a" name="ae76640f48ef8b4a03e9b81fd5ca4209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76640f48ef8b4a03e9b81fd5ca4209a">&#9670;&#160;</a></span>wcslen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcslen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character. </p>

</div>
</div>
<a id="af7f1acddf72fe1e8ca96d2ba2ce4728a" name="af7f1acddf72fe1e8ca96d2ba2ce4728a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f1acddf72fe1e8ca96d2ba2ce4728a">&#9670;&#160;</a></span>wcsncat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcsncat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1). </p>
<p>The destination byte string must have enough space for the contents of both dest and src plus the terminating null character, except that the size of src is limited to count. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="aeab6f756717b07001aa0cc5ed00d89dd" name="aeab6f756717b07001aa0cc5ed00d89dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab6f756717b07001aa0cc5ed00d89dd">&#9670;&#160;</a></span>wcsncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcsncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</p>
<p>The behavior is undefined if lhs or rhs are not pointers to null-terminated strings. </p>

</div>
</div>
<a id="a075bf5df5b479586668e8dfe6a56d0b7" name="a075bf5df5b479586668e8dfe6a56d0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075bf5df5b479586668e8dfe6a56d0b7">&#9670;&#160;</a></span>wcsncpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcsncpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest. </p>
<p>If count is reached before the entire string src was copied, the resulting character array is not null-terminated. If, after copying the terminating null character from src, count is not reached, additional null characters are written to dest until the total of count characters have been written. If the strings overlap, the behavior is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="a1dcddbba9daed153f19e883e9aea6f8d" name="a1dcddbba9daed153f19e883e9aea6f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcddbba9daed153f19e883e9aea6f8d">&#9670;&#160;</a></span>wcspbrk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcspbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="afa424e61dbe13ba0fa30a5c09f2045ac" name="afa424e61dbe13ba0fa30a5c09f2045ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa424e61dbe13ba0fa30a5c09f2045ac">&#9670;&#160;</a></span>wcspbrk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcspbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="abb75f8bb32c928b359607a41c9f634e5" name="abb75f8bb32c928b359607a41c9f634e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75f8bb32c928b359607a41c9f634e5">&#9670;&#160;</a></span>wcsrchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcsrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsrchr">https://en.cppreference.com/w/cpp/string/wide/wcsrchr</a> </p>

</div>
</div>
<a id="a5ef301df65d76aedef7c3211e00900a2" name="a5ef301df65d76aedef7c3211e00900a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef301df65d76aedef7c3211e00900a2">&#9670;&#160;</a></span>wcsrchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcsrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsrchr">https://en.cppreference.com/w/cpp/string/wide/wcsrchr</a> </p>

</div>
</div>
<a id="a62a3a2cd36229b80bef3fcc819e45291" name="a62a3a2cd36229b80bef3fcc819e45291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a3a2cd36229b80bef3fcc819e45291">&#9670;&#160;</a></span>wcsspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcsspn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsspn">https://en.cppreference.com/w/cpp/string/wide/wcsspn</a> </p>

</div>
</div>
<a id="a74d69c1152ef7e628b1691179fc6f530" name="a74d69c1152ef7e628b1691179fc6f530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d69c1152ef7e628b1691179fc6f530">&#9670;&#160;</a></span>wcsstr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcsstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="ad67cab31ecf7c17b7ea41fbc4c1d0bd5" name="ad67cab31ecf7c17b7ea41fbc4c1d0bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67cab31ecf7c17b7ea41fbc4c1d0bd5">&#9670;&#160;</a></span>wcsstr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wcsstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a5175847a36c688adb123a34e9780ab25" name="a5175847a36c688adb123a34e9780ab25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5175847a36c688adb123a34e9780ab25">&#9670;&#160;</a></span>wmemchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wmemchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr. </p>
<p>If count is zero, the function returns a null pointer.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemchr">https://en.cppreference.com/w/cpp/string/wide/wmemchr</a> </p>

</div>
</div>
<a id="a65747ecf11dff5d8f3be4a0f7793ca69" name="a65747ecf11dff5d8f3be4a0f7793ca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65747ecf11dff5d8f3be4a0f7793ca69">&#9670;&#160;</a></span>wmemchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wmemchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr. </p>
<p>If count is zero, the function returns a null pointer.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemchr">https://en.cppreference.com/w/cpp/string/wide/wmemchr</a> </p>

</div>
</div>
<a id="af171fdc02565644fe46f805df68af177" name="af171fdc02565644fe46f805df68af177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af171fdc02565644fe46f805df68af177">&#9670;&#160;</a></span>wmemcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wmemcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared. If count is zero, the function does nothing.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemcmp">https://en.cppreference.com/w/cpp/string/wide/wmemcmp</a> </p>

</div>
</div>
<a id="af2ebfa659c54260fe5e6e06ee48a906b" name="af2ebfa659c54260fe5e6e06ee48a906b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ebfa659c54260fe5e6e06ee48a906b">&#9670;&#160;</a></span>wmemcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wmemcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemcpy">https://en.cppreference.com/w/cpp/string/wide/wmemcpy</a> </p>

</div>
</div>
<a id="a72695f43a1b04ada99db35bf2396de5a" name="a72695f43a1b04ada99db35bf2396de5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72695f43a1b04ada99db35bf2396de5a">&#9670;&#160;</a></span>wmemmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wmemmove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. </p>
<p>If count is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to dest. This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it copies: nulls as well as invalid characters are copied too.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemmove">https://en.cppreference.com/w/cpp/string/wide/wmemmove</a> </p>

</div>
</div>
<a id="a181b3459989bb776b4fde2be3f0ff339" name="a181b3459989bb776b4fde2be3f0ff339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181b3459989bb776b4fde2be3f0ff339">&#9670;&#160;</a></span>wmemset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> wmemset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest. </p>
<p>If overflow occurs, the behavior is undefined. If count is zero, the function does nothing.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemset">https://en.cppreference.com/w/cpp/string/wide/wmemset</a> </p>

</div>
</div>
<a id="adcd605e16e8fe82cfcbe722d1cc32531" name="adcd605e16e8fe82cfcbe722d1cc32531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd605e16e8fe82cfcbe722d1cc32531">&#9670;&#160;</a></span>iswalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswalnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswalnum">https://en.cppreference.com/w/cpp/string/wide/iswalnum</a> </p>

</div>
</div>
<a id="a26e7f38abfa4626a87a678221210ff20" name="a26e7f38abfa4626a87a678221210ff20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e7f38abfa4626a87a678221210ff20">&#9670;&#160;</a></span>iswalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswalpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswalpha">https://en.cppreference.com/w/cpp/string/wide/iswalpha</a> </p>

</div>
</div>
<a id="af6ddfc9129d96c9d732bd42aae4d2b7e" name="af6ddfc9129d96c9d732bd42aae4d2b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ddfc9129d96c9d732bd42aae4d2b7e">&#9670;&#160;</a></span>iswblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswblank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswblank">https://en.cppreference.com/w/cpp/string/wide/iswblank</a> </p>

</div>
</div>
<a id="abcb4d7527b43f2bf80b6709558ce8751" name="abcb4d7527b43f2bf80b6709558ce8751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb4d7527b43f2bf80b6709558ce8751">&#9670;&#160;</a></span>iswcntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswcntrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/iscntrl">https://en.cppreference.com/w/cpp/string/byte/iscntrl</a> </p>

</div>
</div>
<a id="acd57dd6cbdd4676e575a985b16fc6c73" name="acd57dd6cbdd4676e575a985b16fc6c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd57dd6cbdd4676e575a985b16fc6c73">&#9670;&#160;</a></span>iswdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswdigit">https://en.cppreference.com/w/cpp/string/wide/iswdigit</a> </p>

</div>
</div>
<a id="ae7497aa1630afdaae61880742d859160" name="ae7497aa1630afdaae61880742d859160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7497aa1630afdaae61880742d859160">&#9670;&#160;</a></span>iswgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~) or any graphical character specific to the current C locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswgraph">https://en.cppreference.com/w/cpp/string/wide/iswgraph</a> </p>

</div>
</div>
<a id="acebca8a0e95d8a7c4b7fbe0022762b5c" name="acebca8a0e95d8a7c4b7fbe0022762b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebca8a0e95d8a7c4b7fbe0022762b5c">&#9670;&#160;</a></span>iswlower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswlower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswlower">https://en.cppreference.com/w/cpp/string/wide/iswlower</a> </p>

</div>
</div>
<a id="a9c844b2e79830a5920aef8f6537b691d" name="a9c844b2e79830a5920aef8f6537b691d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c844b2e79830a5920aef8f6537b691d">&#9670;&#160;</a></span>iswprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswprint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~), space or any printable character specific to the current C locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswprint">https://en.cppreference.com/w/cpp/string/wide/iswprint</a> </p>

</div>
</div>
<a id="afeae65f95769adaef057cef1e2072cf2" name="afeae65f95769adaef057cef1e2072cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeae65f95769adaef057cef1e2072cf2">&#9670;&#160;</a></span>iswpunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswpunct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a punctuation character, i.e. it is one of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ or any punctuation character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswpunct">https://en.cppreference.com/w/cpp/string/wide/iswpunct</a> </p>

</div>
</div>
<a id="a08bc2486b7f8fe2d819d038bde3e96dd" name="a08bc2486b7f8fe2d819d038bde3e96dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bc2486b7f8fe2d819d038bde3e96dd">&#9670;&#160;</a></span>iswspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following: </p>
<pre class="fragment">- space (0x20, ' ')
- form feed (0x0c, '\f')
- line feed (0x0a, '\n')
- carriage return (0x0d, '\r')
- horizontal tab (0x09, '\t')
- vertical tab (0x0b, '\v')
</pre><p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswspace">https://en.cppreference.com/w/cpp/string/wide/iswspace</a> </p>

</div>
</div>
<a id="a597b876c6866c7f04154fcc066fd08ba" name="a597b876c6866c7f04154fcc066fd08ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597b876c6866c7f04154fcc066fd08ba">&#9670;&#160;</a></span>iswupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswupper">https://en.cppreference.com/w/cpp/string/wide/iswupper</a> </p>

</div>
</div>
<a id="a49d8adf51dcb6a599f5da613d2e32b5d" name="a49d8adf51dcb6a599f5da613d2e32b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d8adf51dcb6a599f5da613d2e32b5d">&#9670;&#160;</a></span>iswxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> iswxdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswxdigit">https://en.cppreference.com/w/cpp/string/wide/iswxdigit</a> </p>

</div>
</div>
<a id="a9acd9b1a67a38e589ba86c569aac0cb9" name="a9acd9b1a67a38e589ba86c569aac0cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acd9b1a67a38e589ba86c569aac0cb9">&#9670;&#160;</a></span>towlower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> towlower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given wide character to lowercase, if possible. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/towlower">https://en.cppreference.com/w/cpp/string/wide/towlower</a> </p>

</div>
</div>
<a id="aefdb01e19c1c3b047ac3a7586586f2fd" name="aefdb01e19c1c3b047ac3a7586586f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdb01e19c1c3b047ac3a7586586f2fd">&#9670;&#160;</a></span>towupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> towupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given wide character to uppercase, if possible. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/towupper">https://en.cppreference.com/w/cpp/string/wide/towupper</a> </p>

</div>
</div>
<a id="a015016635edaf10f86f54faa5493e625" name="a015016635edaf10f86f54faa5493e625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015016635edaf10f86f54faa5493e625">&#9670;&#160;</a></span>raise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Exception</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#abb156b0e852ad82749ae42934d3b4dbf">TETL_NO_INLINE</a> <a class="el" href="attributes_8hpp.html#af0eb4be3e44a6a8a9235265e12ad89a7">TETL_COLD</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> raise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa14cd5bdeb510c30773c0a14b86d5f8e" name="aa14cd5bdeb510c30773c0a14b86d5f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14cd5bdeb510c30773c0a14b86d5f8e">&#9670;&#160;</a></span>unexpected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">E</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unexpected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">E</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  unexpected&lt; <a class="el" href="structetl_1_1static__vector.html">E</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a142c844e65677a96dcb134681d85e8a2" name="a142c844e65677a96dcb134681d85e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142c844e65677a96dcb134681d85e8a2">&#9670;&#160;</a></span>format_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> format_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format args according to the format string fmt, and write the result to the output iterator out. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/format_to">https://en.cppreference.com/w/cpp/utility/format/format_to</a> </p>

</div>
</div>
<a id="afa2b8092a29056d823a289eb08a11484" name="afa2b8092a29056d823a289eb08a11484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2b8092a29056d823a289eb08a11484">&#9670;&#160;</a></span>format_to_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> format_to_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIter</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">diff_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a>&lt;<a class="el" href="structetl_1_1static__vector.html">OutputIter</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format args according to the format string fmt, and write the result to the output iterator out. At most n characters are written. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/format_to_n">https://en.cppreference.com/w/cpp/utility/format/format_to_n</a> </p>

</div>
</div>
<a id="a0bc7cabf52200c976eb934c6de9399fb" name="a0bc7cabf52200c976eb934c6de9399fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc7cabf52200c976eb934c6de9399fb">&#9670;&#160;</a></span>make_format_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Context</a>  = etl::format_context, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> make_format_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; detail::format_arg_store&lt;<a class="el" href="structetl_1_1static__vector.html">Context</a>, Args...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6a9f575220aa9ab48e4d48b82093698" name="ae6a9f575220aa9ab48e4d48b82093698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a9f575220aa9ab48e4d48b82093698">&#9670;&#160;</a></span>make_wformat_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> make_wformat_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; detail::format_arg_store&lt;<a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a>, Args...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08c2340a69881856d04c55c19bb5c291" name="a08c2340a69881856d04c55c19bb5c291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c2340a69881856d04c55c19bb5c291">&#9670;&#160;</a></span>vformat_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> vformat_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abd8c737296655b44480da4fb422add24">format_args</a></td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa615187d5a248ab9e6493944c709279e" name="aa615187d5a248ab9e6493944c709279e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa615187d5a248ab9e6493944c709279e">&#9670;&#160;</a></span>bind_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Func</a> , typename... BoundArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> bind_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Func</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BoundArgs</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>boundArgs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args. In other words, bind_front(f,
bound_args...)(call_args...) is equivalent to invoke(f, bound_args..., call_args....). </p>
<p>Copied implementation from paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0356r5.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0356r5.html</a> </p>

</div>
</div>
<a id="abdcfb06e9497d99667ce90201fa5c056" name="abdcfb06e9497d99667ce90201fa5c056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcfb06e9497d99667ce90201fa5c056">&#9670;&#160;</a></span>function_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">R</a>(*</td>          <td class="paramname"><span class="paramname"><em>&#160;</em></span>)(Args...)</td><td>)</td>
          <td> -&gt;  function_ref&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac15165afbf59de637ccf27b635458ece" name="ac15165afbf59de637ccf27b635458ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15165afbf59de637ccf27b635458ece">&#9670;&#160;</a></span>swap() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a7">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a06cae3523aef79cbee6d0ad095484749" name="a06cae3523aef79cbee6d0ad095484749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cae3523aef79cbee6d0ad095484749">&#9670;&#160;</a></span>operator==() <span class="overload">[4/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a4874c4f433c6b61ab0bf85023f138b4c" name="a4874c4f433c6b61ab0bf85023f138b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4874c4f433c6b61ab0bf85023f138b4c">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a1d46beb3d8ffc0ea6e9f5157d7f1b299" name="a1d46beb3d8ffc0ea6e9f5157d7f1b299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d46beb3d8ffc0ea6e9f5157d7f1b299">&#9670;&#160;</a></span>operator==() <span class="overload">[5/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="afdfdea32a40caa3a28fb120ded25d66e" name="afdfdea32a40caa3a28fb120ded25d66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfdea32a40caa3a28fb120ded25d66e">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="ab64d857ac492271f013aef7076333c81" name="ab64d857ac492271f013aef7076333c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64d857ac492271f013aef7076333c81">&#9670;&#160;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="#a601366c5cf97ac29c08fc7b51db875a9">etl::invoke_result_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, Args...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo</a></b></dt><dd>Add noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;) </dd></dl>

</div>
</div>
<a id="a4b8b1e57bc5b47496c1898878c7d6916" name="a4b8b1e57bc5b47496c1898878c7d6916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8b1e57bc5b47496c1898878c7d6916">&#9670;&#160;</a></span>invoke_r()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Args&gt; <br />
requires (<a class="el" href="#a79bb140a0b590bb8a6eadea52d880d17">etl::is_invocable_r_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R</a>, <a class="el" href="structetl_1_1static__vector.html">F</a>, Args...&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> invoke_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">R</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo</a></b></dt><dd>Add noexcept(is_nothrow_invocable_r_v&lt;R, F, Args...&gt;) </dd></dl>

</div>
</div>
<a id="aea99b0f54121ebdd09e467ea46f3f865" name="aea99b0f54121ebdd09e467ea46f3f865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea99b0f54121ebdd09e467ea46f3f865">&#9670;&#160;</a></span>not_fn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> not_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> -&gt; detail::not_fn_t&lt;<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">etl::decay_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92780374b4fcf868ff0a7cb7dddaa385" name="a92780374b4fcf868ff0a7cb7dddaa385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92780374b4fcf868ff0a7cb7dddaa385">&#9670;&#160;</a></span>not_fn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> ConstFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> not_fn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; detail::stateless_not_fn&lt;<a class="el" href="structetl_1_1static__vector.html">ConstFn</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ffcd97e84a642fa9f9f3297692d128e" name="a1ffcd97e84a642fa9f9f3297692d128e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffcd97e84a642fa9f9f3297692d128e">&#9670;&#160;</a></span>reference_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference_wrapper </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  reference_wrapper&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11516b369ddf80bc94d2f450200f5d11" name="a11516b369ddf80bc94d2f450200f5d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11516b369ddf80bc94d2f450200f5d11">&#9670;&#160;</a></span>ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ref </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. </p>

</div>
</div>
<a id="adea72996d2287ae1be393a1827dfa5bf" name="adea72996d2287ae1be393a1827dfa5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea72996d2287ae1be393a1827dfa5bf">&#9670;&#160;</a></span>ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. </p>

</div>
</div>
<a id="a09ebab5fc63c081909c10f9255347efb" name="a09ebab5fc63c081909c10f9255347efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ebab5fc63c081909c10f9255347efb">&#9670;&#160;</a></span>cref() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cref </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T <a class="el" href="structetl_1_1static__vector.html">const</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. module Utility. </p>

</div>
</div>
<a id="a3dede0554b7d9e1163a2be7f26702258" name="a3dede0554b7d9e1163a2be7f26702258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dede0554b7d9e1163a2be7f26702258">&#9670;&#160;</a></span>cref() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T <a class="el" href="structetl_1_1static__vector.html">const</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5ad6e6c525e1d3fb61aa60cab9f9dc3" name="af5ad6e6c525e1d3fb61aa60cab9f9dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ad6e6c525e1d3fb61aa60cab9f9dc3">&#9670;&#160;</a></span>cref() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">void</a> cref </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad815b7c902d91f337c10cb8c6876e87" name="aad815b7c902d91f337c10cb8c6876e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad815b7c902d91f337c10cb8c6876e87">&#9670;&#160;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">It</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Distance</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">It</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Distance</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined. </p>
<p><a href="https://en.cppreference.com/w/cpp/iterator/advance">https://en.cppreference.com/w/cpp/iterator/advance</a> </p>

</div>
</div>
<a id="ae80a7746c87d52a34bfff83262802d0d" name="ae80a7746c87d52a34bfff83262802d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80a7746c87d52a34bfff83262802d0d">&#9670;&#160;</a></span>back_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> back_inserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Container</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>back_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">back_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="aeb088ae74a2ec53c8c206de329935df4" name="aeb088ae74a2ec53c8c206de329935df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb088ae74a2ec53c8c206de329935df4">&#9670;&#160;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the given container c or array array. These templates rely on <code>C::begin()</code> having a reasonable implementation. Returns exactly c.begin(), which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns <code>C::iterator</code> when c is not const-qualified, and <code>C::const_iterator</code> otherwise. Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="#aeb088ae74a2ec53c8c206de329935df4" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated. </p>

</div>
</div>
<a id="ae67e324a8e2e3cc38ad6445c05a28ff7" name="ae67e324a8e2e3cc38ad6445c05a28ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67e324a8e2e3cc38ad6445c05a28ff7">&#9670;&#160;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8e8d50b9cb9fdffd5bbaeedcb74d2f1" name="af8e8d50b9cb9fdffd5bbaeedcb74d2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e8d50b9cb9fdffd5bbaeedcb74d2f1">&#9670;&#160;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> begin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8ff9f99fa557857de8d9e6a4829d752" name="ab8ff9f99fa557857de8d9e6a4829d752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ff9f99fa557857de8d9e6a4829d752">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#aeb088ae74a2ec53c8c206de329935df4">begin</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac22f9a30542666ba39fdc715089588b3" name="ac22f9a30542666ba39fdc715089588b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22f9a30542666ba39fdc715089588b3">&#9670;&#160;</a></span>data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.data())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the block of memory containing the elements of the container. </p>

</div>
</div>
<a id="a525de672ed02219aff7c50e11401eb92" name="a525de672ed02219aff7c50e11401eb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525de672ed02219aff7c50e11401eb92">&#9670;&#160;</a></span>data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.data())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae957b7252fd3e8ed42a5ed5e4e745fcd" name="ae957b7252fd3e8ed42a5ed5e4e745fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae957b7252fd3e8ed42a5ed5e4e745fcd">&#9670;&#160;</a></span>data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> data </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba994bcf39b8b428fec5852ea0cc728c" name="aba994bcf39b8b428fec5852ea0cc728c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba994bcf39b8b428fec5852ea0cc728c">&#9670;&#160;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">It</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">It</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">It</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">It</a>&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of hops from first to last. </p>
<p><a href="https://en.cppreference.com/w/cpp/iterator/distance">https://en.cppreference.com/w/cpp/iterator/distance</a> </p>

</div>
</div>
<a id="a314873517bdae4e131a403c322a9763f" name="a314873517bdae4e131a403c322a9763f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314873517bdae4e131a403c322a9763f">&#9670;&#160;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.empty())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given container is empty. </p>

</div>
</div>
<a id="ad7550de636fcc027498049a1d22c7bc9" name="ad7550de636fcc027498049a1d22c7bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7550de636fcc027498049a1d22c7bc9">&#9670;&#160;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> empty </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa26698de685cc42e99c0c560d05ca93c" name="aa26698de685cc42e99c0c560d05ca93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26698de685cc42e99c0c560d05ca93c">&#9670;&#160;</a></span>end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on. </p>

</div>
</div>
<a id="a364b7fbf24361dad9b16ea5968b95c42" name="a364b7fbf24361dad9b16ea5968b95c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364b7fbf24361dad9b16ea5968b95c42">&#9670;&#160;</a></span>end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa7e5135fa0834bba2c1b028850ba144" name="afa7e5135fa0834bba2c1b028850ba144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7e5135fa0834bba2c1b028850ba144">&#9670;&#160;</a></span>end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> end </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab385b9f70c785ceb3a5b986f745ca81d" name="ab385b9f70c785ceb3a5b986f745ca81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab385b9f70c785ceb3a5b986f745ca81d">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#aa26698de685cc42e99c0c560d05ca93c">end</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8cd5fdd90a750ceb082da63058a6816" name="aa8cd5fdd90a750ceb082da63058a6816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cd5fdd90a750ceb082da63058a6816">&#9670;&#160;</a></span>front_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> front_inserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Container</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>front_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="ab6b5eb982170f3879c1af31e1f245e8e" name="ab6b5eb982170f3879c1af31e1f245e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b5eb982170f3879c1af31e1f245e8e">&#9670;&#160;</a></span>full() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.full())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given container is full. </p>

</div>
</div>
<a id="ab6d0a38b0d0530c7cdcea3add44e91d4" name="ab6d0a38b0d0530c7cdcea3add44e91d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d0a38b0d0530c7cdcea3add44e91d4">&#9670;&#160;</a></span>full() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> full </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5e8085c3345374b117c1dc70edf9d9b" name="ab5e8085c3345374b117c1dc70edf9d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e8085c3345374b117c1dc70edf9d9b">&#9670;&#160;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the nth successor of iterator it. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a2">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6d9cd7356c493ca709070e97bf61ed63" name="a6d9cd7356c493ca709070e97bf61ed63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9cd7356c493ca709070e97bf61ed63">&#9670;&#160;</a></span>prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the nth predecessor of iterator it. </p>

</div>
</div>
<a id="aef0e9ff3b7516f90525a93acb5fccc8e" name="aef0e9ff3b7516f90525a93acb5fccc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0e9ff3b7516f90525a93acb5fccc8e">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rbegin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-beginning of the given container. </p>

</div>
</div>
<a id="ad9728314a1814cd3fd1c7beaa6a54271" name="ad9728314a1814cd3fd1c7beaa6a54271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9728314a1814cd3fd1c7beaa6a54271">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rbegin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6b35374c826579acfd588a9e6f8b390" name="aa6b35374c826579acfd588a9e6f8b390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b35374c826579acfd588a9e6f8b390">&#9670;&#160;</a></span>rbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> rbegin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;T*&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a111d4cb9659c433d9702a48913416699" name="a111d4cb9659c433d9702a48913416699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111d4cb9659c433d9702a48913416699">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> crbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#aef0e9ff3b7516f90525a93acb5fccc8e">rbegin</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab55d22696b4d22653a103d0726157a18" name="ab55d22696b4d22653a103d0726157a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55d22696b4d22653a103d0726157a18">&#9670;&#160;</a></span>rend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rend())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-end of the given container. </p>

</div>
</div>
<a id="a286af0157d3f2f88bdd154d26195e29a" name="a286af0157d3f2f88bdd154d26195e29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286af0157d3f2f88bdd154d26195e29a">&#9670;&#160;</a></span>rend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rend())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0d58f51b451013d9255c48b59cdabee" name="ac0d58f51b451013d9255c48b59cdabee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d58f51b451013d9255c48b59cdabee">&#9670;&#160;</a></span>rend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> rend </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;T*&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4853c0824b6cd2040223f031d427fab" name="ac4853c0824b6cd2040223f031d427fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4853c0824b6cd2040223f031d427fab">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> crend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#ab55d22696b4d22653a103d0726157a18">rend</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-end of the given container. </p>

</div>
</div>
<a id="af0773cf088e3cccbce2905050fcdd0eb" name="af0773cf088e3cccbce2905050fcdd0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0773cf088e3cccbce2905050fcdd0eb">&#9670;&#160;</a></span>make_reverse_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> make_reverse_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Iter</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function template that constructs a <a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">etl::reverse_iterator</a> for the given iterator i (which must be a LegacyBidirectionalIterator) with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="a9ac9a7daa4f77fbf1aae7a1b941301cc" name="a9ac9a7daa4f77fbf1aae7a1b941301cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac9a7daa4f77fbf1aae7a1b941301cc">&#9670;&#160;</a></span>operator==() <span class="overload">[6/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="aa42d5ab2b854a73191219d9dd7768be5" name="aa42d5ab2b854a73191219d9dd7768be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42d5ab2b854a73191219d9dd7768be5">&#9670;&#160;</a></span>operator!=() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a86b87a87e119f906f153eb7a9dd4b27f" name="a86b87a87e119f906f153eb7a9dd4b27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b87a87e119f906f153eb7a9dd4b27f">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="ab26706133b16070592575cd905122691" name="ab26706133b16070592575cd905122691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26706133b16070592575cd905122691">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="aca4156f3a7bdd78f42dba049d9cd2a7f" name="aca4156f3a7bdd78f42dba049d9cd2a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4156f3a7bdd78f42dba049d9cd2a7f">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="adada3b76df2e6fc502cf397340f36c22" name="adada3b76df2e6fc502cf397340f36c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adada3b76df2e6fc502cf397340f36c22">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a6132e0e8e9af5871d3647489c0e9ab7f" name="a6132e0e8e9af5871d3647489c0e9ab7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6132e0e8e9af5871d3647489c0e9ab7f">&#9670;&#160;</a></span>operator+() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator it incremented by n. </p>

</div>
</div>
<a id="a2d97b143943fdd5165246151965e6e1a" name="a2d97b143943fdd5165246151965e6e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d97b143943fdd5165246151965e6e1a">&#9670;&#160;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iterator1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iterator2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iterator1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iterator2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(rhs.base() - lhs.base())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between two iterator adaptors. </p>

</div>
</div>
<a id="ae8701f2e299015f92e83f375a604ef61" name="ae8701f2e299015f92e83f375a604ef61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8701f2e299015f92e83f375a604ef61">&#9670;&#160;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.size())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the given container c or array array. Returns c.size(), converted to the return type if necessary. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a8">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a256d0ca03ee6c9127ce2c4baefc0c50b" name="a256d0ca03ee6c9127ce2c4baefc0c50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256d0ca03ee6c9127ce2c4baefc0c50b">&#9670;&#160;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> size </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> (&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67945df65c1fbfa26461032e32b8bd70" name="a67945df65c1fbfa26461032e32b8bd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67945df65c1fbfa26461032e32b8bd70">&#9670;&#160;</a></span>ssize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ssize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a29d6d310a0bc8bcb40b024f5259088a6">common_type_t</a>&lt;<a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a>, <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.size())&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a584fdd298577a7f3d9696eefe3ddac61" name="a584fdd298577a7f3d9696eefe3ddac61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584fdd298577a7f3d9696eefe3ddac61">&#9670;&#160;</a></span>ssize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ssize </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> (&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[static_cast&lt; size_t &gt;(N)]</td><td>)</td>
          <td> -&gt; <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e2bd83e2ec37c5b1298fae188a15607" name="a5e2bd83e2ec37c5b1298fae188a15607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2bd83e2ec37c5b1298fae188a15607">&#9670;&#160;</a></span>abs() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a51e1eb0ffb77caba7f8242da4a5d7470" name="a51e1eb0ffb77caba7f8242da4a5d7470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e1eb0ffb77caba7f8242da4a5d7470">&#9670;&#160;</a></span>abs() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a342a8a68c9a0f5c3ff1b3d5857553906" name="a342a8a68c9a0f5c3ff1b3d5857553906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342a8a68c9a0f5c3ff1b3d5857553906">&#9670;&#160;</a></span>abs() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee6fd8ce3d926357e36de32769335251" name="aee6fd8ce3d926357e36de32769335251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6fd8ce3d926357e36de32769335251">&#9670;&#160;</a></span>abs() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d44cf8dff1d93939ca2e9adeec696a7" name="a5d44cf8dff1d93939ca2e9adeec696a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d44cf8dff1d93939ca2e9adeec696a7">&#9670;&#160;</a></span>abs() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71ed298b66e9f2fdd041b0fa9c5df301" name="a71ed298b66e9f2fdd041b0fa9c5df301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ed298b66e9f2fdd041b0fa9c5df301">&#9670;&#160;</a></span>abs() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad1cf30946e4d50ba41f9328a82e2e62" name="aad1cf30946e4d50ba41f9328a82e2e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1cf30946e4d50ba41f9328a82e2e62">&#9670;&#160;</a></span>fabs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9183bd4ec44e90e6830581cf15f8d165" name="a9183bd4ec44e90e6830581cf15f8d165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9183bd4ec44e90e6830581cf15f8d165">&#9670;&#160;</a></span>fabsf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> fabsf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc2dd0f4e4c727042a49eb7a07534b4d" name="abc2dd0f4e4c727042a49eb7a07534b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2dd0f4e4c727042a49eb7a07534b4d">&#9670;&#160;</a></span>fabs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3fbc2879eaeb897fcaf8de7bd117125" name="af3fbc2879eaeb897fcaf8de7bd117125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fbc2879eaeb897fcaf8de7bd117125">&#9670;&#160;</a></span>fabs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01976f0c02d8a34fad11dff21277f288" name="a01976f0c02d8a34fad11dff21277f288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01976f0c02d8a34fad11dff21277f288">&#9670;&#160;</a></span>fabsl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> fabsl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86319ce6c017b8e0cbaed828b6dad2f7" name="a86319ce6c017b8e0cbaed828b6dad2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86319ce6c017b8e0cbaed828b6dad2f7">&#9670;&#160;</a></span>ilog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ilog2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0af1eade8d7b506ab0a6732e681a803b" name="a0af1eade8d7b506ab0a6732e681a803b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af1eade8d7b506ab0a6732e681a803b">&#9670;&#160;</a></span>ipow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ipow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afabc2a74c91be5a9c6b446824c7d2cee" name="afabc2a74c91be5a9c6b446824c7d2cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabc2a74c91be5a9c6b446824c7d2cee">&#9670;&#160;</a></span>ipow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> Base&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ipow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">Base</a>)</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">Base</a>)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8161915e533ff99801f4017d6737d978" name="a8161915e533ff99801f4017d6737d978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8161915e533ff99801f4017d6737d978">&#9670;&#160;</a></span>extents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Integrals&gt; <br />
requires (<a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">etl::is_convertible_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Integrals</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> ...)</div>
      <table class="memname">
        <tr>
          <td class="memname">extents </td>
          <td>(</td>
          <td class="paramtype">Integrals...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  extents&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>((<a class="el" href="structetl_1_1static__vector.html">Integrals</a>(), <a class="el" href="group__span.html#ga22e7be40fea564f0c1fe3d11229ef0f8">etl::dynamic_extent</a>))... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fe0d774229c098831602663bd591f28" name="a1fe0d774229c098831602663bd591f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe0d774229c098831602663bd591f28">&#9670;&#160;</a></span>mdspan() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CArray</a> &gt; <br />
requires (<a class="el" href="#a8b0e44222b6a1dc103286f3c5225ad93">is_array_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CArray</a>&gt; &amp;&amp; <a class="el" href="#a3c66bceba9ac1596666a40596ddf9b62">rank_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CArray</a>&gt; == 1)</div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  mdspan&lt; <a class="el" href="#a0ffde65d0200b12233a0dff1979cc210">remove_all_extents_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CArray</a> &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, <a class="el" href="#a06332dc22e85765f2c195c703cc49068">extent_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CArray</a>, 0 &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa581bd5419c1b5ce63db2ceefe37b971" name="aa581bd5419c1b5ce63db2ceefe37b971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa581bd5419c1b5ce63db2ceefe37b971">&#9670;&#160;</a></span>mdspan() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Pointer</a> &gt; <br />
requires (<a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">is_pointer_v</a>&lt;<a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Pointer</a>&gt;&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Pointer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  mdspan&lt; <a class="el" href="#af65c39ad5cff999e37c5009b047655a4">remove_pointer_t</a>&lt; <a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Pointer</a> &gt; &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82de4f51577f9cfd914c0f916caf46fc" name="a82de4f51577f9cfd914c0f916caf46fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82de4f51577f9cfd914c0f916caf46fc">&#9670;&#160;</a></span>mdspan() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , typename... Integrals&gt; <br />
requires ((<a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">is_convertible_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Integrals</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt; &amp;&amp; ...) &amp;&amp; sizeof...(<a class="el" href="structetl_1_1static__vector.html">Integrals</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integrals...</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="#ac53bcc0a66170293af1f9319d4663d1a">dextents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, sizeof...(<a class="el" href="structetl_1_1static__vector.html">Integrals</a>)&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc4c4186488804dd6af16be8ffb48af4" name="adc4c4186488804dd6af16be8ffb48af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4c4186488804dd6af16be8ffb48af4">&#9670;&#160;</a></span>mdspan() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexType</a> , size_t... ExtentsPack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexType</a>, ExtentsPack... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexType</a>, ExtentsPack... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc583d3a74b54cf8a1b2f2de409a2b74" name="abc583d3a74b54cf8a1b2f2de409a2b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc583d3a74b54cf8a1b2f2de409a2b74">&#9670;&#160;</a></span>mdspan() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">MappingType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">MappingType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::layout_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f0eace36bd684274a175bbf90c48247" name="a0f0eace36bd684274a175bbf90c48247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0eace36bd684274a175bbf90c48247">&#9670;&#160;</a></span>mdspan() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">MappingType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> AccessorType::data_handle_type <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">MappingType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">AccessorType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">typename</a> AccessorType::element_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::layout_type, <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9406cef0552ac36f0ea11e670081897" name="aa9406cef0552ac36f0ea11e670081897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9406cef0552ac36f0ea11e670081897">&#9670;&#160;</a></span>strided_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OffsetType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ExtentType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">StrideType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">strided_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OffsetType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ExtentType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">StrideType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  strided_slice&lt; <a class="el" href="structetl_1_1static__vector.html">OffsetType</a>, <a class="el" href="structetl_1_1static__vector.html">ExtentType</a>, <a class="el" href="structetl_1_1static__vector.html">StrideType</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af804eb418abea75441ce277a3d8ac9a4" name="af804eb418abea75441ce277a3d8ac9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af804eb418abea75441ce277a3d8ac9a4">&#9670;&#160;</a></span>submdspan_extents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexT</a> , etl::size_t... Extents, typename... SliceSpecifiers&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1static__vector.html">slices</a>) == <a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt;<a class="el" href="structetl_1_1static__vector.html">IndexT</a>, Extents...&gt;::rank())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> submdspan_extents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexT</a>, Extents... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceSpecifiers...</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21ae02f44cb9f415d79d030c8ceb8c16" name="a21ae02f44cb9f415d79d030c8ceb8c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ae02f44cb9f415d79d030c8ceb8c16">&#9670;&#160;</a></span>addressof() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;. </p>

</div>
</div>
<a id="a2b8d9c987fb1214a1989a00c3ac4d175" name="a2b8d9c987fb1214a1989a00c3ac4d175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8d9c987fb1214a1989a00c3ac4d175">&#9670;&#160;</a></span>addressof() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;. </p>

</div>
</div>
<a id="a951855af4ae6cd241993c4f6bde82de5" name="a951855af4ae6cd241993c4f6bde82de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951855af4ae6cd241993c4f6bde82de5">&#9670;&#160;</a></span>addressof() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> addressof </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a410a978255250c24ca74fad8f26910d9" name="a410a978255250c24ca74fad8f26910d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410a978255250c24ca74fad8f26910d9">&#9670;&#160;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>space</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned. </p>
<p>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns nullptr.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if alignment is not a power of two. </dd></dl>

</div>
</div>
<a id="ae867798dd2ddddb86806aa99a0ae9101" name="ae867798dd2ddddb86806aa99a0ae9101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae867798dd2ddddb86806aa99a0ae9101">&#9670;&#160;</a></span>assume_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> assume_aligned </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned. </p>
<p>The program is ill-formed if N is not a power of 2. The behavior is undefined if ptr does not point to an object of type T (ignoring cv-qualification at every level), or if the object's alignment is not at least N.</p>
<p><a href="https://en.cppreference.com/w/cpp/memory/assume_aligned">https://en.cppreference.com/w/cpp/memory/assume_aligned</a> </p>

</div>
</div>
<a id="a7f5ec2df5d7caffa501049e08c135fc1" name="a7f5ec2df5d7caffa501049e08c135fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5ec2df5d7caffa501049e08c135fc1">&#9670;&#160;</a></span>construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args, <a class="el" href="structetl_1_1static__vector.html">typename</a>  = decltype(::new(etl::declval&lt;void*&gt;()) T(etl::declval&lt;Args&gt;()...))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> construct_at </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a T object initialized with arguments args... at given address p. </p>

</div>
</div>
<a id="ad349bf22ae9342501dceb73d04bfcb7e" name="ad349bf22ae9342501dceb73d04bfcb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad349bf22ae9342501dceb73d04bfcb7e">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the objects in the range [first, last). </p>

</div>
</div>
<a id="ae14a8af642cc7dc92cca033c1eff9fad" name="ae14a8af642cc7dc92cca033c1eff9fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14a8af642cc7dc92cca033c1eff9fad">&#9670;&#160;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling destroy(begin(*p), end(*p)). </p>

</div>
</div>
<a id="a6d9f1ed59c6342c3bcd7f4ed746a0dda" name="a6d9f1ed59c6342c3bcd7f4ed746a0dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9f1ed59c6342c3bcd7f4ed746a0dda">&#9670;&#160;</a></span>destroy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> destroy_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the n objects in the range starting at first. </p>

</div>
</div>
<a id="aa171f5d95623a8a1268dc9134a02f972" name="aa171f5d95623a8a1268dc9134a02f972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa171f5d95623a8a1268dc9134a02f972">&#9670;&#160;</a></span>to_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Ptr</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Ptr</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by p without forming a reference to the object pointed to by p. </p>
<p>Fancy pointer overload: If the expression pointer_traits&lt;Ptr&gt;::to_address(p) is well-formed, returns the result of that expression. Otherwise, returns to_address(p.operator-&gt;()). </p>

</div>
</div>
<a id="a9487e53c09efc9a8837a2d074e441b99" name="a9487e53c09efc9a8837a2d074e441b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9487e53c09efc9a8837a2d074e441b99">&#9670;&#160;</a></span>to_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#abffc77cc5069dfe2c648737671e340d9">is_function_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_address </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by p without forming a reference to the object pointed to by p. </p>
<p>Raw pointer overload: If T is a function type, the program is ill-formed. Otherwise, returns p unmodified. </p>

</div>
</div>
<a id="a676f4b08e61c8e7dab3c678610aede5f" name="a676f4b08e61c8e7dab3c678610aede5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676f4b08e61c8e7dab3c678610aede5f">&#9670;&#160;</a></span>uninitialized_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> uninitialized_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac49c48774035c7f282eeaa3e6288dce8" name="ac49c48774035c7f282eeaa3e6288dce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49c48774035c7f282eeaa3e6288dce8">&#9670;&#160;</a></span>make_optional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> make_optional </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt;<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">etl::decay_t</a>&lt;T&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optional object from value. </p>

</div>
</div>
<a id="a676d3a9766e7187541dac0084ca9352d" name="a676d3a9766e7187541dac0084ca9352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676d3a9766e7187541dac0084ca9352d">&#9670;&#160;</a></span>make_optional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> make_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optional object constructed in-place from args... </p>

</div>
</div>
<a id="a2b02cc74f13a05b6e8c659f3a3dccd6e" name="a2b02cc74f13a05b6e8c659f3a3dccd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b02cc74f13a05b6e8c659f3a3dccd6e">&#9670;&#160;</a></span>optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">optional </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  optional&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52f2d4ced352c4bef45044a0a3ad530f" name="a52f2d4ced352c4bef45044a0a3ad530f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f2d4ced352c4bef45044a0a3ad530f">&#9670;&#160;</a></span>swap() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#a6a08681ad0c17b00662bfd185a081335">is_swappable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs). </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/swap2">https://en.cppreference.com/w/cpp/utility/optional/swap2</a> </p>

</div>
</div>
<a id="aaad37d63683a7b7b60b5492a36214150" name="aaad37d63683a7b7b60b5492a36214150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad37d63683a7b7b60b5492a36214150">&#9670;&#160;</a></span>operator==() <span class="overload">[7/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a64d4eb3778aa88f9e5bea0b6f3f235f6" name="a64d4eb3778aa88f9e5bea0b6f3f235f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d4eb3778aa88f9e5bea0b6f3f235f6">&#9670;&#160;</a></span>operator!=() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="aba5293f688437c01e457055d0aa62d29" name="aba5293f688437c01e457055d0aa62d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5293f688437c01e457055d0aa62d29">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a224949455a49cb9684654d95c9682614" name="a224949455a49cb9684654d95c9682614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224949455a49cb9684654d95c9682614">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a86d4cbfad4362cf53ffd250086bee3a2" name="a86d4cbfad4362cf53ffd250086bee3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d4cbfad4362cf53ffd250086bee3a2">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a73784a2e80efe0c148139cde06dba117" name="a73784a2e80efe0c148139cde06dba117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73784a2e80efe0c148139cde06dba117">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="ad60614b8fd0ea8fb929abd91e7c03fcb" name="ad60614b8fd0ea8fb929abd91e7c03fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60614b8fd0ea8fb929abd91e7c03fcb">&#9670;&#160;</a></span>operator==() <span class="overload">[8/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a4b443906f5ac16a642381e94f0883e5c" name="a4b443906f5ac16a642381e94f0883e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b443906f5ac16a642381e94f0883e5c">&#9670;&#160;</a></span>operator==() <span class="overload">[9/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a4f224b8bc7e8e7dbf2e21c2abd61d85b" name="a4f224b8bc7e8e7dbf2e21c2abd61d85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f224b8bc7e8e7dbf2e21c2abd61d85b">&#9670;&#160;</a></span>operator!=() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a2f9854781fbbc0bb6595381d145ffe8a" name="a2f9854781fbbc0bb6595381d145ffe8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9854781fbbc0bb6595381d145ffe8a">&#9670;&#160;</a></span>operator!=() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="aa925845eacf401c23d90a28fb0998458" name="aa925845eacf401c23d90a28fb0998458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa925845eacf401c23d90a28fb0998458">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="ac6d6d7216975fa39b685f0a19a4fa276" name="ac6d6d7216975fa39b685f0a19a4fa276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d6d7216975fa39b685f0a19a4fa276">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="addca89d60d9fd283d993f6b1c1976179" name="addca89d60d9fd283d993f6b1c1976179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addca89d60d9fd283d993f6b1c1976179">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a3ffab0b95544793c992580effd801dee" name="a3ffab0b95544793c992580effd801dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffab0b95544793c992580effd801dee">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="aa2a1952aebcb6d04fc5b5555aa3a7703" name="aa2a1952aebcb6d04fc5b5555aa3a7703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a1952aebcb6d04fc5b5555aa3a7703">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="af1dffe46043b72215a2006c5e9838d83" name="af1dffe46043b72215a2006c5e9838d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dffe46043b72215a2006c5e9838d83">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a6b2c16b034956f35bddb8c67e4494cbb" name="a6b2c16b034956f35bddb8c67e4494cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2c16b034956f35bddb8c67e4494cbb">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a0b3bffc75cabc9b21dd991d66746129c" name="a0b3bffc75cabc9b21dd991d66746129c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3bffc75cabc9b21dd991d66746129c">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a18bd00052399cf9e75e7519c3bf58d51" name="a18bd00052399cf9e75e7519c3bf58d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18bd00052399cf9e75e7519c3bf58d51">&#9670;&#160;</a></span>operator==() <span class="overload">[10/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="ac085d8eb145978f4b6c76ae7fab50571" name="ac085d8eb145978f4b6c76ae7fab50571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac085d8eb145978f4b6c76ae7fab50571">&#9670;&#160;</a></span>operator==() <span class="overload">[11/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="aecc78483ca85630fcbad43a9f41b595f" name="aecc78483ca85630fcbad43a9f41b595f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc78483ca85630fcbad43a9f41b595f">&#9670;&#160;</a></span>operator!=() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a388444660ef75977706dfa713cf2b99e" name="a388444660ef75977706dfa713cf2b99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388444660ef75977706dfa713cf2b99e">&#9670;&#160;</a></span>operator!=() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="ab1791cbc59df111391e3adc533f3c76f" name="ab1791cbc59df111391e3adc533f3c76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1791cbc59df111391e3adc533f3c76f">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="aa3eae96de48f2fd6467855eeba8c22a4" name="aa3eae96de48f2fd6467855eeba8c22a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3eae96de48f2fd6467855eeba8c22a4">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a31acc3ce509ae2930ad2dd4f4008cb3e" name="a31acc3ce509ae2930ad2dd4f4008cb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31acc3ce509ae2930ad2dd4f4008cb3e">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="ae03c024c59f68b73a52401919908d525" name="ae03c024c59f68b73a52401919908d525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03c024c59f68b73a52401919908d525">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a6ea2269a4b47b1b1d90af476759fe39c" name="a6ea2269a4b47b1b1d90af476759fe39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea2269a4b47b1b1d90af476759fe39c">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a58f65b464d8a1f49e75691ea39f79b44" name="a58f65b464d8a1f49e75691ea39f79b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f65b464d8a1f49e75691ea39f79b44">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a07a5203370e6084d1474bf9e4d0cd080" name="a07a5203370e6084d1474bf9e4d0cd080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a5203370e6084d1474bf9e4d0cd080">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a9557503d3e688eaf3ca1fe3ff4056af4" name="a9557503d3e688eaf3ca1fe3ff4056af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9557503d3e688eaf3ca1fe3ff4056af4">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a634128d2b51dd1677291370fa7276399" name="a634128d2b51dd1677291370fa7276399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634128d2b51dd1677291370fa7276399">&#9670;&#160;</a></span>decay_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> decay_copy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e8ae9359da3a0a4cb0573e8cd219638" name="a0e8ae9359da3a0a4cb0573e8cd219638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8ae9359da3a0a4cb0573e8cd219638">&#9670;&#160;</a></span>scope_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FuncT</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scope_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FuncT</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  scope_exit&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">FuncT</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae066ee7e8566233be5ae1d96840d0c27" name="ae066ee7e8566233be5ae1d96840d0c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae066ee7e8566233be5ae1d96840d0c27">&#9670;&#160;</a></span>operator==() <span class="overload">[12/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="a3b524b62bdc9f0a6c515bb44965cb68c" name="a3b524b62bdc9f0a6c515bb44965cb68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b524b62bdc9f0a6c515bb44965cb68c">&#9670;&#160;</a></span>operator!=() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="ad49df96265d6364140d73a8656425763" name="ad49df96265d6364140d73a8656425763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49df96265d6364140d73a8656425763">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="acf24c3b1cefb36e0c44f1cfaf6bf3f61" name="acf24c3b1cefb36e0c44f1cfaf6bf3f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf24c3b1cefb36e0c44f1cfaf6bf3f61">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="a17ccbb17eca7af36ce1a29e8d176f165" name="a17ccbb17eca7af36ce1a29e8d176f165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ccbb17eca7af36ce1a29e8d176f165">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="adb7a5ebdf6dec990fea752e60d99fc2c" name="adb7a5ebdf6dec990fea752e60d99fc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7a5ebdf6dec990fea752e60d99fc2c">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="a10be93498b340088ebf6b854223c733f" name="a10be93498b340088ebf6b854223c733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10be93498b340088ebf6b854223c733f">&#9670;&#160;</a></span>swap() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs). </p>

</div>
</div>
<a id="adeda768ae3894ba5ab71ab85c206b19d" name="adeda768ae3894ba5ab71ab85c206b19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeda768ae3894ba5ab71ab85c206b19d">&#9670;&#160;</a></span>span() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Extent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a>(&amp;)</td>          <td class="paramname"><span class="paramname"><em></em></span>[Extent]</td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Extent</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a971583484d70115eb585a522b3d27c94" name="a971583484d70115eb585a522b3d27c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971583484d70115eb585a522b3d27c94">&#9670;&#160;</a></span>span() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26de73efb9b95ad5ed7a2efee4db36d1" name="a26de73efb9b95ad5ed7a2efee4db36d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26de73efb9b95ad5ed7a2efee4db36d1">&#9670;&#160;</a></span>span() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f81df02edb24d409273f1a4f4ae1da7" name="a0f81df02edb24d409273f1a4f4ae1da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f81df02edb24d409273f1a4f4ae1da7">&#9670;&#160;</a></span>span() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Element</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a929cb3ca520c09729a4166ed8244f76e" name="a929cb3ca520c09729a4166ed8244f76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929cb3ca520c09729a4166ed8244f76e">&#9670;&#160;</a></span>span() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Element</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa1582db8c501fc2a0866681ff10eeef" name="aaa1582db8c501fc2a0866681ff10eeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1582db8c501fc2a0866681ff10eeef">&#9670;&#160;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  stack&lt; <a class="el" href="structetl_1_1static__vector.html">typename</a> Container::value_type, <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49bec9d408f2060c687550beff2bc22a" name="a49bec9d408f2060c687550beff2bc22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bec9d408f2060c687550beff2bc22a">&#9670;&#160;</a></span>swap() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; <br />
requires (<a class="el" href="#a6a08681ad0c17b00662bfd185a081335">is_swappable_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">C</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for stack. Swaps the contents of lhs and rhs. This overload only participates in overload resolution if is_swappable&lt;C&gt;::value is true. </p>

</div>
</div>
<a id="a37282f164092c4575c20cc3eb2be09e8" name="a37282f164092c4575c20cc3eb2be09e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37282f164092c4575c20cc3eb2be09e8">&#9670;&#160;</a></span>operator+() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a44fc09342ced2b7f24ff7651db389574" name="a44fc09342ced2b7f24ff7651db389574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fc09342ced2b7f24ff7651db389574">&#9670;&#160;</a></span>operator+() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="ae7ca62639f3d8a4e4e6ee781c0c9b6a6" name="ae7ca62639f3d8a4e4e6ee781c0c9b6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ca62639f3d8a4e4e6ee781c0c9b6a6">&#9670;&#160;</a></span>operator+() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a75a27933aa122a6a535f3ccebc97f877" name="a75a27933aa122a6a535f3ccebc97f877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a27933aa122a6a535f3ccebc97f877">&#9670;&#160;</a></span>operator+() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a0eb50a33ec4c9a9055ea355c59ea86f5" name="a0eb50a33ec4c9a9055ea355c59ea86f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb50a33ec4c9a9055ea355c59ea86f5">&#9670;&#160;</a></span>operator+() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a8adf17474787513990f234ca72826619" name="a8adf17474787513990f234ca72826619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adf17474787513990f234ca72826619">&#9670;&#160;</a></span>operator==() <span class="overload">[13/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a3f85e21843e35c81f29e31fecc4ea45d" name="a3f85e21843e35c81f29e31fecc4ea45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f85e21843e35c81f29e31fecc4ea45d">&#9670;&#160;</a></span>operator==() <span class="overload">[14/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="af74dff6a048a2b86a6cd9e49f33f2099" name="af74dff6a048a2b86a6cd9e49f33f2099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74dff6a048a2b86a6cd9e49f33f2099">&#9670;&#160;</a></span>operator==() <span class="overload">[15/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a45ff405e190d21367929b8538ffb325b" name="a45ff405e190d21367929b8538ffb325b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ff405e190d21367929b8538ffb325b">&#9670;&#160;</a></span>operator!=() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a17898ce525ba08e9d785effed53ff5ee" name="a17898ce525ba08e9d785effed53ff5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17898ce525ba08e9d785effed53ff5ee">&#9670;&#160;</a></span>operator!=() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="ad9dcc12372f0b690c21d481f7c06e3ad" name="ad9dcc12372f0b690c21d481f7c06e3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dcc12372f0b690c21d481f7c06e3ad">&#9670;&#160;</a></span>operator!=() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a1a42997d8aa7aefa1919f1bcbd257a83" name="a1a42997d8aa7aefa1919f1bcbd257a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a42997d8aa7aefa1919f1bcbd257a83">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ad2aa37862308b3d67c585cd65bad3a21" name="ad2aa37862308b3d67c585cd65bad3a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aa37862308b3d67c585cd65bad3a21">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a8f5a3b63a243a620d7ce34eaa4ee7f56" name="a8f5a3b63a243a620d7ce34eaa4ee7f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5a3b63a243a620d7ce34eaa4ee7f56">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="aeed935697439744871c76c8536cb1d01" name="aeed935697439744871c76c8536cb1d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed935697439744871c76c8536cb1d01">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="af48f8017b5a3a8a04d5c706b19e6ac99" name="af48f8017b5a3a8a04d5c706b19e6ac99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48f8017b5a3a8a04d5c706b19e6ac99">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="af00c4e35ae6e4d61386d41307c25c0cf" name="af00c4e35ae6e4d61386d41307c25c0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00c4e35ae6e4d61386d41307c25c0cf">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a757c5d2256d4a511fd553f05eee89739" name="a757c5d2256d4a511fd553f05eee89739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757c5d2256d4a511fd553f05eee89739">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="abe815d462766008278375f8739f30833" name="abe815d462766008278375f8739f30833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe815d462766008278375f8739f30833">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a8b9fbb4031f6f62174c87a48d8f27675" name="a8b9fbb4031f6f62174c87a48d8f27675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9fbb4031f6f62174c87a48d8f27675">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a3d79749a41aa9a490b7306ce7df8d8a4" name="a3d79749a41aa9a490b7306ce7df8d8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d79749a41aa9a490b7306ce7df8d8a4">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a21871672f9ecaaf87d537d49942e1b02" name="a21871672f9ecaaf87d537d49942e1b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21871672f9ecaaf87d537d49942e1b02">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="af45672d31c7b9193d9774241e5caf8b2" name="af45672d31c7b9193d9774241e5caf8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45672d31c7b9193d9774241e5caf8b2">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ac6cbe62578fbdffe49a59de4dda507e4" name="ac6cbe62578fbdffe49a59de4dda507e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cbe62578fbdffe49a59de4dda507e4">&#9670;&#160;</a></span>swap() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">etl::basic_static_string</a>. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs). </p>

</div>
</div>
<a id="add6036904dcb2247ec2dbf4bc784d460" name="add6036904dcb2247ec2dbf4bc784d460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6036904dcb2247ec2dbf4bc784d460">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that compare equal to value from the container. </p>

</div>
</div>
<a id="a713c02c496b3a3e3d246868add007065" name="a713c02c496b3a3e3d246868add007065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713c02c496b3a3e3d246868add007065">&#9670;&#160;</a></span>erase_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate pred from the container. </p>

</div>
</div>
<a id="aedcdf80e4775ce92aea72f99207d7016" name="aedcdf80e4775ce92aea72f99207d7016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcdf80e4775ce92aea72f99207d7016">&#9670;&#160;</a></span>stof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="a3514bcb3ddf3fc6f3e11325dd82d75ed" name="a3514bcb3ddf3fc6f3e11325dd82d75ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3514bcb3ddf3fc6f3e11325dd82d75ed">&#9670;&#160;</a></span>stod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="af8a865d89ba1b49d2c7cdf4b4cf3f5d3" name="af8a865d89ba1b49d2c7cdf4b4cf3f5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a865d89ba1b49d2c7cdf4b4cf3f5d3">&#9670;&#160;</a></span>stold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="a1a292e75d88b4e3619e2654b8f6f8660" name="a1a292e75d88b4e3619e2654b8f6f8660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a292e75d88b4e3619e2654b8f6f8660">&#9670;&#160;</a></span>stoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a634bfd356983e8d8a730538cd6b5f7cd" name="a634bfd356983e8d8a730538cd6b5f7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634bfd356983e8d8a730538cd6b5f7cd">&#9670;&#160;</a></span>stol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a8b844e6e1102e2efe7b9f7ad9ef4fff6" name="a8b844e6e1102e2efe7b9f7ad9ef4fff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b844e6e1102e2efe7b9f7ad9ef4fff6">&#9670;&#160;</a></span>stoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a0c74f60fe53545b60e1c1404719b84e6" name="a0c74f60fe53545b60e1c1404719b84e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c74f60fe53545b60e1c1404719b84e6">&#9670;&#160;</a></span>stoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a3d870cb89861489715e34bf225feb213" name="a3d870cb89861489715e34bf225feb213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d870cb89861489715e34bf225feb213">&#9670;&#160;</a></span>stoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> stoull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a9a46d2610263aec2af4e9c49c94519ae" name="a9a46d2610263aec2af4e9c49c94519ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a46d2610263aec2af4e9c49c94519ae">&#9670;&#160;</a></span>operator==() <span class="overload">[16/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , CharT... Chars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, Chars... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, Chars... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d9202f4500faf2a0dfeb6d39233517e" name="a2d9202f4500faf2a0dfeb6d39233517e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9202f4500faf2a0dfeb6d39233517e">&#9670;&#160;</a></span>operator==() <span class="overload">[17/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , CharT... CharsL, CharT... CharsR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, CharsL... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, CharsR... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab437ae2f4b539e25a05115f96175a00e" name="ab437ae2f4b539e25a05115f96175a00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab437ae2f4b539e25a05115f96175a00e">&#9670;&#160;</a></span>to_string() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a2786883ed50708aa10cbeabe8247c604" name="a2786883ed50708aa10cbeabe8247c604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2786883ed50708aa10cbeabe8247c604">&#9670;&#160;</a></span>to_string() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a2d59427c9432cc7ee1d2f06bed99f251" name="a2d59427c9432cc7ee1d2f06bed99f251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d59427c9432cc7ee1d2f06bed99f251">&#9670;&#160;</a></span>to_string() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="ae8fa3d013b6f9f9526fa2c22105a229d" name="ae8fa3d013b6f9f9526fa2c22105a229d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fa3d013b6f9f9526fa2c22105a229d">&#9670;&#160;</a></span>to_string() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="af5f5c59473c3078b1b135ff3b37b788b" name="af5f5c59473c3078b1b135ff3b37b788b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f5c59473c3078b1b135ff3b37b788b">&#9670;&#160;</a></span>to_string() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a6a2920ef72ba2dcfa7edaf48ac9a8f7e" name="a6a2920ef72ba2dcfa7edaf48ac9a8f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2920ef72ba2dcfa7edaf48ac9a8f7e">&#9670;&#160;</a></span>to_string() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a47e864c1efccb08ca482ae4e47e01c66" name="a47e864c1efccb08ca482ae4e47e01c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e864c1efccb08ca482ae4e47e01c66">&#9670;&#160;</a></span>to_string() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="afeefc6128abb677e96133e15926cd60a" name="afeefc6128abb677e96133e15926cd60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeefc6128abb677e96133e15926cd60a">&#9670;&#160;</a></span>to_string() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a8b760f0d1dfec7f0dcdc9bcade7cd710" name="a8b760f0d1dfec7f0dcdc9bcade7cd710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b760f0d1dfec7f0dcdc9bcade7cd710">&#9670;&#160;</a></span>to_string() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a2cac3d2bc7e91527aa7422b304a2c3b9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a1e09260a37734d83638e79666d5638a5" name="a1e09260a37734d83638e79666d5638a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e09260a37734d83638e79666d5638a5">&#9670;&#160;</a></span>operator==() <span class="overload">[18/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a2dfb42090a7af37c4e01eed960522a0d" name="a2dfb42090a7af37c4e01eed960522a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfb42090a7af37c4e01eed960522a0d">&#9670;&#160;</a></span>operator==() <span class="overload">[19/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d879ae8d357e68c5b61a7d0f3c33473" name="a4d879ae8d357e68c5b61a7d0f3c33473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d879ae8d357e68c5b61a7d0f3c33473">&#9670;&#160;</a></span>operator==() <span class="overload">[20/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b858b9a9207ba5fe533d11e76f3ca1b" name="a4b858b9a9207ba5fe533d11e76f3ca1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b858b9a9207ba5fe533d11e76f3ca1b">&#9670;&#160;</a></span>operator!=() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a56d3249f7e27fcfa91639f72eb53dc75" name="a56d3249f7e27fcfa91639f72eb53dc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d3249f7e27fcfa91639f72eb53dc75">&#9670;&#160;</a></span>operator!=() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af87635e670e27f474bff7714a7bbe558" name="af87635e670e27f474bff7714a7bbe558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87635e670e27f474bff7714a7bbe558">&#9670;&#160;</a></span>operator!=() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af437446fcc1e53640c10980cfd99616e" name="af437446fcc1e53640c10980cfd99616e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af437446fcc1e53640c10980cfd99616e">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="ae3409e7cab3e6c13e3d748566971e05e" name="ae3409e7cab3e6c13e3d748566971e05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3409e7cab3e6c13e3d748566971e05e">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c3293c8c6e37d2b24c05f95baa58aef" name="a2c3293c8c6e37d2b24c05f95baa58aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3293c8c6e37d2b24c05f95baa58aef">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6911622913c358aa6c9a69533740656e" name="a6911622913c358aa6c9a69533740656e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6911622913c358aa6c9a69533740656e">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a2166e999595123c9283e1d8b743f4d37" name="a2166e999595123c9283e1d8b743f4d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2166e999595123c9283e1d8b743f4d37">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f2e96c99f7d8223e682d299d15a63a1" name="a4f2e96c99f7d8223e682d299d15a63a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2e96c99f7d8223e682d299d15a63a1">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a282dab84234297d94efc2b6326190a55" name="a282dab84234297d94efc2b6326190a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282dab84234297d94efc2b6326190a55">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a767725b8e1034844aa4c3245f940832f" name="a767725b8e1034844aa4c3245f940832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767725b8e1034844aa4c3245f940832f">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77e34f2ca4ffdc8cf580ee55405dbd50" name="a77e34f2ca4ffdc8cf580ee55405dbd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e34f2ca4ffdc8cf580ee55405dbd50">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06acbb7e9de53f5357b8a05ff2b81346" name="a06acbb7e9de53f5357b8a05ff2b81346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06acbb7e9de53f5357b8a05ff2b81346">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="abbf977200588526eee94f7bfe90d02a9" name="abbf977200588526eee94f7bfe90d02a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf977200588526eee94f7bfe90d02a9">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7456ec6ff542660d9777cf19081a2cac" name="a7456ec6ff542660d9777cf19081a2cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7456ec6ff542660d9777cf19081a2cac">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f7d8fa4cd29bfaa5efc2ced210dd105" name="a0f7d8fa4cd29bfaa5efc2ced210dd105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7d8fa4cd29bfaa5efc2ced210dd105">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Tuple</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">auto</a>)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b5f5e3e00087ff6ca8916d9e69d2cec" name="a1b5f5e3e00087ff6ca8916d9e69d2cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5f5e3e00087ff6ca8916d9e69d2cec">&#9670;&#160;</a></span>forward_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> forward_as_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Types</a>&amp;&amp;...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members. </p>

</div>
</div>
<a id="a1ae0d54a117c055337810c0829b22eaf" name="a1ae0d54a117c055337810c0829b22eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae0d54a117c055337810c0829b22eaf">&#9670;&#160;</a></span>make_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> make_from_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Tuple</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adfb3851a71aca6a0520f250a368a49f6" name="adfb3851a71aca6a0520f250a368a49f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb3851a71aca6a0520f250a368a49f6">&#9670;&#160;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> make_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tuple object, deducing the target type from the types of arguments. </p>

</div>
</div>
<a id="a0d1ede89bcd679cdd58f45d98b785cd8" name="a0d1ede89bcd679cdd58f45d98b785cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1ede89bcd679cdd58f45d98b785cd8">&#9670;&#160;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> tie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&amp;...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8214f25116b3dd5ee4ecd4605b8e5cf8" name="a8214f25116b3dd5ee4ecd4605b8e5cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214f25116b3dd5ee4ecd4605b8e5cf8">&#9670;&#160;</a></span>get() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa05f6f308ed4004eec8f0b4559371a0f" name="aa05f6f308ed4004eec8f0b4559371a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05f6f308ed4004eec8f0b4559371a0f">&#9670;&#160;</a></span>get() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2bc2983c6b858933480a19a9f6ca6f6" name="ae2bc2983c6b858933480a19a9f6ca6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bc2983c6b858933480a19a9f6ca6f6">&#9670;&#160;</a></span>get() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6da5e04ad6238c60c904e4c9ac6bc5e9" name="a6da5e04ad6238c60c904e4c9ac6bc5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da5e04ad6238c60c904e4c9ac6bc5e9">&#9670;&#160;</a></span>get() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbffd4a8b5d0838ecc6a3f36cad3e3c6" name="abbffd4a8b5d0838ecc6a3f36cad3e3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbffd4a8b5d0838ecc6a3f36cad3e3c6">&#9670;&#160;</a></span>operator==() <span class="overload">[21/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Us&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1static__vector.html">Ts</a>) == sizeof...(<a class="el" href="structetl_1_1static__vector.html">Us</a>))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Us... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c95e50e7b2dda0a7a7fd3b1b3a37dc9" name="a4c95e50e7b2dda0a7a7fd3b1b3a37dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c95e50e7b2dda0a7a7fd3b1b3a37dc9">&#9670;&#160;</a></span>tuple_cat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::tuple_like... Tuples&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> tuple_cat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Tuples</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a885a42e965c6251995730e67ba6d09eb" name="a885a42e965c6251995730e67ba6d09eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885a42e965c6251995730e67ba6d09eb">&#9670;&#160;</a></span>swap() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const -&gt;  <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="af8fe16af1fc0c146d690634a5b2da600" name="af8fe16af1fc0c146d690634a5b2da600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fe16af1fc0c146d690634a5b2da600">&#9670;&#160;</a></span>declval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> declval </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  etl::add_rvalue_reference_t&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab218217c542cbcae689d277e927d360a" name="ab218217c542cbcae689d277e927d360a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab218217c542cbcae689d277e927d360a">&#9670;&#160;</a></span>operator+() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">L</a> + <a class="el" href="structetl_1_1static__vector.html">R</a>), <a class="el" href="structetl_1_1static__vector.html">L</a> + <a class="el" href="structetl_1_1static__vector.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49d3cf9c4f58fa9982c28bfa20adb0cb" name="a49d3cf9c4f58fa9982c28bfa20adb0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d3cf9c4f58fa9982c28bfa20adb0cb">&#9670;&#160;</a></span>operator==() <span class="overload">[22/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> == <a class="el" href="structetl_1_1static__vector.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a677b4c86284624fe83dc36333e3d4212" name="a677b4c86284624fe83dc36333e3d4212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677b4c86284624fe83dc36333e3d4212">&#9670;&#160;</a></span>operator!=() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> != <a class="el" href="structetl_1_1static__vector.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a135ea1c61ce77c9bf27e83df6a1fec64" name="a135ea1c61ce77c9bf27e83df6a1fec64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135ea1c61ce77c9bf27e83df6a1fec64">&#9670;&#160;</a></span>is_constant_evaluated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_constant_evaluated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_constant_evaluated">https://en.cppreference.com/w/cpp/types/is_constant_evaluated</a> </p>

</div>
</div>
<a id="a3408c1dae71c214e0b2b360f5fcba723" name="a3408c1dae71c214e0b2b360f5fcba723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3408c1dae71c214e0b2b360f5fcba723">&#9670;&#160;</a></span>test_implicit_default_constructible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">void</a> test_implicit_default_constructible </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f797628671cf0d4b35a9858fd9a0455" name="a9f797628671cf0d4b35a9858fd9a0455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f797628671cf0d4b35a9858fd9a0455">&#9670;&#160;</a></span>swap() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const -&gt;  <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="af5273f679984445be5233596370b7a15" name="af5273f679984445be5233596370b7a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5273f679984445be5233596370b7a15">&#9670;&#160;</a></span>swap() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="structetl_1_1is__swappable.html">etl::is_swappable</a>&lt;T&gt;::value)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>a</em></span>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>b</em></span>[N]&#160;) -&gt;  <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a087e608dcade676ed1707b2780820b4b" name="a087e608dcade676ed1707b2780820b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087e608dcade676ed1707b2780820b4b">&#9670;&#160;</a></span>as_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> as_const </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; add_const_t&lt;T&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms lvalue reference to const type of t. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a0">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a73fcc8395221077570ae4d49d16fdfb5" name="a73fcc8395221077570ae4d49d16fdfb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fcc8395221077570ae4d49d16fdfb5">&#9670;&#160;</a></span>as_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> as_const </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">void</a>=<a class="el" href="structetl_1_1static__vector.html">delete</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="affc67214aa9016de19ce8c56cacf050f" name="affc67214aa9016de19ce8c56cacf050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc67214aa9016de19ce8c56cacf050f">&#9670;&#160;</a></span>cmp_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cmp_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a1">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad7f8a2ce45cfed83d620b12d6271272f" name="ad7f8a2ce45cfed83d620b12d6271272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f8a2ce45cfed83d620b12d6271272f">&#9670;&#160;</a></span>cmp_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cmp_greater </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a6fdcd304a94bdadbaa2c7d6fb267e05b" name="a6fdcd304a94bdadbaa2c7d6fb267e05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdcd304a94bdadbaa2c7d6fb267e05b">&#9670;&#160;</a></span>cmp_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cmp_greater_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="af465587d2f32a80939be1fad202d81a8" name="af465587d2f32a80939be1fad202d81a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af465587d2f32a80939be1fad202d81a8">&#9670;&#160;</a></span>cmp_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cmp_less </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type).</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="ae910ff92e0c20546b3798e7acf0f62a4" name="ae910ff92e0c20546b3798e7acf0f62a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae910ff92e0c20546b3798e7acf0f62a4">&#9670;&#160;</a></span>cmp_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cmp_less_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a693945b83d4561846bbf0b5944d0296e" name="a693945b83d4561846bbf0b5944d0296e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693945b83d4561846bbf0b5944d0296e">&#9670;&#160;</a></span>cmp_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> cmp_not_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a2">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7c1576e57ae3b113a38b8a9793bb4074" name="a7c1576e57ae3b113a38b8a9793bb4074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1576e57ae3b113a38b8a9793bb4074">&#9670;&#160;</a></span>exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> exchange </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the value of obj with new_value and returns the old value of obj. </p>
<dl class="section return"><dt>Returns</dt><dd>The old value of obj. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a3">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aea04c6a544a650bcf6a7f88ff623c80f" name="aea04c6a544a650bcf6a7f88ff623c80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea04c6a544a650bcf6a7f88ff623c80f">&#9670;&#160;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards lvalues as either lvalues or as rvalues, depending on T. When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/forward">https://en.cppreference.com/w/cpp/utility/forward</a> </p>

</div>
</div>
<a id="a6a7e67893a6b3c341ea0624e30e1d89d" name="a6a7e67893a6b3c341ea0624e30e1d89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7e67893a6b3c341ea0624e30e1d89d">&#9670;&#160;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9319953b536fc8279d2a105b02d1a938">remove_reference_t</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a881439150ce3ae249968cc8b15d6e31d" name="a881439150ce3ae249968cc8b15d6e31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881439150ce3ae249968cc8b15d6e31d">&#9670;&#160;</a></span>forward_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> forward_like </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad27e213c027bfb11ed648fb543842995" name="ad27e213c027bfb11ed648fb543842995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27e213c027bfb11ed648fb543842995">&#9670;&#160;</a></span>ignore_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> ignore_unused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly ignore arguments or variables. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_struct" href="structetl_1_1static__vector.html">main</a>(<span class="keywordtype">int</span> <a class="code hl_struct" href="structetl_1_1static__vector.html">argc</a>, <span class="keywordtype">char</span>** <a class="code hl_struct" href="structetl_1_1static__vector.html">argv</a>) -&gt; <span class="keywordtype">int</span></div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="#ad27e213c027bfb11ed648fb543842995">etl::ignore_unused</a>(<a class="code hl_struct" href="structetl_1_1static__vector.html">argc</a>, <a class="code hl_struct" href="structetl_1_1static__vector.html">argv</a>);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceetl_html_ad27e213c027bfb11ed648fb543842995"><div class="ttname"><a href="#ad27e213c027bfb11ed648fb543842995">etl::ignore_unused</a></div><div class="ttdeci">constexpr auto ignore_unused(Types &amp;&amp;...) -&gt; void</div><div class="ttdoc">Explicitly ignore arguments or variables.</div><div class="ttdef"><b>Definition</b> ignore_unused.hpp:17</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a06254a010da20091fb04d67702c29da3" name="a06254a010da20091fb04d67702c29da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06254a010da20091fb04d67702c29da3">&#9670;&#160;</a></span>in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires etl::detail::integer_and_not_char&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> in_range </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss. </p>
<p>It is a compile-time error if either T or R is not a signed or unsigned integer type (including standard integer type and extended integer type). This function cannot be used with <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>, char, char8_t, char16_t, char32_t, wchar_t and bool.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/in_range">https://en.cppreference.com/w/cpp/utility/in_range</a> </p>

</div>
</div>
<a id="adeb87647bd4c378500cd694ccc0e4608" name="adeb87647bd4c378500cd694ccc0e4608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb87647bd4c378500cd694ccc0e4608">&#9670;&#160;</a></span>move() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t</a>&lt;T&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type. </p>
<dl class="section return"><dt>Returns</dt><dd><code>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t)</code> </dd></dl>

</div>
</div>
<a id="ae197a91f87223433229090889ab96734" name="ae197a91f87223433229090889ab96734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae197a91f87223433229090889ab96734">&#9670;&#160;</a></span>move_if_noexcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> move_if_noexcept </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a4ccf02556580259044928051b1689171">etl::conditional_t</a>&lt;!<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#a03f5da2852be4424089f4235ef44dec2">etl::is_copy_constructible_v</a>&lt;T&gt;, T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;, T&amp;&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally convert a value to an rvalue. </p>
<p>Same as <a class="el" href="#a9060e0931516472a88f4657d835684a9" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> unless the type's move constructor could throw and the type is copyable, in which case an lvalue-reference is returned instead. </p>

</div>
</div>
<a id="a1145f95a262f79865247b6744e474069" name="a1145f95a262f79865247b6744e474069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1145f95a262f79865247b6744e474069">&#9670;&#160;</a></span>pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">T1</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">T2</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  pair&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74587901a0df261ba728e5fab73273de" name="a74587901a0df261ba728e5fab73273de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74587901a0df261ba728e5fab73273de">&#9670;&#160;</a></span>swap() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of x and y. Equivalent to x.swap(y). </p>

</div>
</div>
<a id="a944300e491e850f5e82717c7a66b5463" name="a944300e491e850f5e82717c7a66b5463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944300e491e850f5e82717c7a66b5463">&#9670;&#160;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> make_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">T1</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">T2</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>&gt;, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments. </p>
<p>The deduced types V1 and V2 are <a class="el" href="structetl_1_1decay.html#a5a1d7f99fe830ad314cbe8a5bef6b2a0">etl::decay&lt;T1&gt;::type</a> and <a class="el" href="structetl_1_1decay.html#a5a1d7f99fe830ad314cbe8a5bef6b2a0">etl::decay&lt;T2&gt;::type</a> (the usual type transformations applied to arguments of functions passed by value).</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/pair/make_pair">https://en.cppreference.com/w/cpp/utility/pair/make_pair</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a5">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a4eb99a045aef160b997eab5178610a6a" name="a4eb99a045aef160b997eab5178610a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb99a045aef160b997eab5178610a6a">&#9670;&#160;</a></span>operator==() <span class="overload">[23/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second. </p>

</div>
</div>
<a id="a1e4f1579948c0050989b6bc4d56f0862" name="a1e4f1579948c0050989b6bc4d56f0862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4f1579948c0050989b6bc4d56f0862">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a5a36c94057cb8199ed38d8d08fd67ef5" name="a5a36c94057cb8199ed38d8d08fd67ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a36c94057cb8199ed38d8d08fd67ef5">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="aba18e7582c10621006e4e0cbc7ad4e4a" name="aba18e7582c10621006e4e0cbc7ad4e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba18e7582c10621006e4e0cbc7ad4e4a">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a8f52394fdd7dcf3de62c6201ba727716" name="a8f52394fdd7dcf3de62c6201ba727716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f52394fdd7dcf3de62c6201ba727716">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="ab277e7f8a028602ec26923ca3a4efe8e" name="ab277e7f8a028602ec26923ca3a4efe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab277e7f8a028602ec26923ca3a4efe8e">&#9670;&#160;</a></span>get() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="a2437363ad77d75596d13cf069467823c" name="a2437363ad77d75596d13cf069467823c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2437363ad77d75596d13cf069467823c">&#9670;&#160;</a></span>get() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="af2afb17c2e9b1ec115692dd31cdf6574" name="af2afb17c2e9b1ec115692dd31cdf6574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2afb17c2e9b1ec115692dd31cdf6574">&#9670;&#160;</a></span>get() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="a8cf3dcd4caaf2ac0322f3ee3dd4d5123" name="a8cf3dcd4caaf2ac0322f3ee3dd4d5123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf3dcd4caaf2ac0322f3ee3dd4d5123">&#9670;&#160;</a></span>get() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="ad539af8c81b36e27d721d3df81ffe277" name="ad539af8c81b36e27d721d3df81ffe277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad539af8c81b36e27d721d3df81ffe277">&#9670;&#160;</a></span>swap() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="a23ff5eb0624cb9e7995b622dc0c7e7c4" name="a23ff5eb0624cb9e7995b622dc0c7e7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ff5eb0624cb9e7995b622dc0c7e7c4">&#9670;&#160;</a></span>swap() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="#a6a08681ad0c17b00662bfd185a081335">etl::is_swappable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>a</em></span>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>b</em></span>[N]&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd4b8c890cb36df65940f4a0e4a65c11" name="abd4b8c890cb36df65940f4a0e4a65c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4b8c890cb36df65940f4a0e4a65c11">&#9670;&#160;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Enum</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> to_underlying </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Enum</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aa68cdd3b170a7e28ceeb562ad04c2853">underlying_type_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Enum</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an enumeration to its underlying type. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/to_underlying">https://en.cppreference.com/w/cpp/utility/to_underlying</a> </p>

</div>
</div>
<a id="abb16b244632f4ab5f6fd117e5a75473e" name="abb16b244632f4ab5f6fd117e5a75473e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb16b244632f4ab5f6fd117e5a75473e">&#9670;&#160;</a></span>unreachable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unreachable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabca2e2f91841c82fb5ef20995a618bb" name="aabca2e2f91841c82fb5ef20995a618bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabca2e2f91841c82fb5ef20995a618bb">&#9670;&#160;</a></span>overload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">overload </td>
          <td>(</td>
          <td class="paramtype">Functor...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  overload&lt; Functor... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e628f780bfbbf89e9f0da6cf5618119" name="a3e628f780bfbbf89e9f0da6cf5618119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e628f780bfbbf89e9f0da6cf5618119">&#9670;&#160;</a></span>swap() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; <br />
requires (detail::enable_variant_swap&lt;Ts...&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the swap algorithm for variant. Effectively calls lhs.swap(rhs). </p>
<p>This overload participates in overload resolution only if is_move_constructible_v&lt;T_i&gt; and is_swappable_v&lt;T_i&gt; are both true for all T_i in Ts... </p>

</div>
</div>
<a id="a45d7bafd4ecb42d30d7d36e365f682be" name="a45d7bafd4ecb42d30d7d36e365f682be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d7bafd4ecb42d30d7d36e365f682be">&#9670;&#160;</a></span>operator==() <span class="overload">[24/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for variants: </p>
<ul>
<li>If lhs.index() != rhs.index(), returns false;</li>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(lhs) == get&lt;lhs.index()&gt;(rhs) </li>
</ul>

</div>
</div>
<a id="af55affb9576fb30baf867b77b555ede5" name="af55affb9576fb30baf867b77b555ede5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55affb9576fb30baf867b77b555ede5">&#9670;&#160;</a></span>operator!=() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for variants: </p>
<ul>
<li>If lhs.index() != rhs.index(), returns true;</li>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(lhs) != get&lt;lhs.index()&gt;(rhs) </li>
</ul>

</div>
</div>
<a id="a5c4b49e8a7cdad02ea4b40262696823b" name="a5c4b49e8a7cdad02ea4b40262696823b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4b49e8a7cdad02ea4b40262696823b">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator for variants: </p>
<ul>
<li>If rhs.valueless_by_exception(), returns false;</li>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &lt; get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="ae19fbbd41ee93e65de08e2fb612fcc68" name="ae19fbbd41ee93e65de08e2fb612fcc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19fbbd41ee93e65de08e2fb612fcc68">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-equal operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>If rhs.valueless_by_exception(), returns false;</li>
<li>If lhs.index() &lt; rhs.index(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &lt;= get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="a5bf3e8f7f74e37975ead5180217c9f2d" name="a5bf3e8f7f74e37975ead5180217c9f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf3e8f7f74e37975ead5180217c9f2d">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>If rhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &gt; get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="a6bfa9331f97be0eee2c56c17b53ac6ef" name="a6bfa9331f97be0eee2c56c17b53ac6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfa9331f97be0eee2c56c17b53ac6ef">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-equal operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>If rhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &gt;= get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="ab330d47780e2692b931342bfaefe1223" name="ab330d47780e2692b931342bfaefe1223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab330d47780e2692b931342bfaefe1223">&#9670;&#160;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> holds_alternative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Ts... </p>

</div>
</div>
<a id="a9def1cedb7034b01e6cffb68531adbd3" name="a9def1cedb7034b01e6cffb68531adbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9def1cedb7034b01e6cffb68531adbd3">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="ac615a5375ea02af1dee73be6ba9c605c" name="ac615a5375ea02af1dee73be6ba9c605c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac615a5375ea02af1dee73be6ba9c605c">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="aa4a93d951b4c9c54a4e94d4380874a4f" name="aa4a93d951b4c9c54a4e94d4380874a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a93d951b4c9c54a4e94d4380874a4f">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="a5dcf60de77d9b1ad3d568505f3916fe2" name="a5dcf60de77d9b1ad3d568505f3916fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcf60de77d9b1ad3d568505f3916fe2">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="a0f2481ba64051d1ccdbcef2661bdd51e" name="a0f2481ba64051d1ccdbcef2661bdd51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2481ba64051d1ccdbcef2661bdd51e">&#9670;&#160;</a></span>get_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt; add_pointer_t&lt;<a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant. </p>
<p>Type-based non-throwing accessor: The call is ill-formed if T is not a unique element of Ts.... </p>

</div>
</div>
<a id="af4f5dc629dca8570d215cdbae7b9b5b6" name="af4f5dc629dca8570d215cdbae7b9b5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f5dc629dca8570d215cdbae7b9b5b6">&#9670;&#160;</a></span>get_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt; add_pointer_t&lt;<a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant. </p>
<p>Type-based non-throwing accessor: The call is ill-formed if T is not a unique element of Ts.... </p>

</div>
</div>
<a id="a6f52b9d8c7ffe776affe797a23d8e891" name="a6f52b9d8c7ffe776affe797a23d8e891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f52b9d8c7ffe776affe797a23d8e891">&#9670;&#160;</a></span>get() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a7dc3bfdddd4c9eb6b16837669c20bcf9" name="a7dc3bfdddd4c9eb6b16837669c20bcf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc3bfdddd4c9eb6b16837669c20bcf9">&#9670;&#160;</a></span>get() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a037eb5fb1f902ba9d35e91b47d543769" name="a037eb5fb1f902ba9d35e91b47d543769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037eb5fb1f902ba9d35e91b47d543769">&#9670;&#160;</a></span>get() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="af3a1d9307c3f9941d2b8a832e99f1545" name="af3a1d9307c3f9941d2b8a832e99f1545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a1d9307c3f9941d2b8a832e99f1545">&#9670;&#160;</a></span>get() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a78ab593d0e7f5e1e82da5a98d921d487" name="a78ab593d0e7f5e1e82da5a98d921d487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ab593d0e7f5e1e82da5a98d921d487">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abff941f61a7e71248259c33337096242" name="abff941f61a7e71248259c33337096242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff941f61a7e71248259c33337096242">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab304b469a80b085a06f00b3500925f1" name="aab304b469a80b085a06f00b3500925f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab304b469a80b085a06f00b3500925f1">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abac24a4d3cd8d624ac5ff2bc055f2e85" name="abac24a4d3cd8d624ac5ff2bc055f2e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac24a4d3cd8d624ac5ff2bc055f2e85">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade109c386a760b9572261c6afe7dbdf8" name="ade109c386a760b9572261c6afe7dbdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade109c386a760b9572261c6afe7dbdf8">&#9670;&#160;</a></span>get_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt;  add_pointer_t&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade2d2fedb0567e3c7742e87fd799b82c" name="ade2d2fedb0567e3c7742e87fd799b82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2d2fedb0567e3c7742e87fd799b82c">&#9670;&#160;</a></span>get_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt;  add_pointer_t&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f45e7a98a49bac4a0e8006a9c784f8a" name="a2f45e7a98a49bac4a0e8006a9c784f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f45e7a98a49bac4a0e8006a9c784f8a">&#9670;&#160;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Vs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Vs</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>vs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the visitor vis (Callable that can be called with any combination of types from variants) to the variants vars. </p>
<p>Every type in <a class="el" href="#a9319953b536fc8279d2a105b02d1a938">etl::remove_reference_t&lt;Variants&gt;</a>... may be a (possibly const-qualified) specialization of <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>. It is unspecified whether other argument types, e.g. a class derived from a <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, are supported.</p>
<p>Copied from <a href="https://github.com/rollbear/visit">https://github.com/rollbear/visit</a> <a href="https://github.com/rollbear/visit/blob/master/LICENSE.txt">https://github.com/rollbear/visit/blob/master/LICENSE.txt</a> </p>

</div>
</div>
<a id="a1059d0a7b563d13c9d599eea27ca489e" name="a1059d0a7b563d13c9d599eea27ca489e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1059d0a7b563d13c9d599eea27ca489e">&#9670;&#160;</a></span>swap() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">static_vector</a>. Swaps the contents of lhs and rhs. </p>

</div>
</div>
<a id="a287ee2e9239c563f862cb177ec7d5792" name="a287ee2e9239c563f862cb177ec7d5792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287ee2e9239c563f862cb177ec7d5792">&#9670;&#160;</a></span>operator==() <span class="overload">[25/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="a473df8e3ace08ad49d812cd57fcc5f90" name="a473df8e3ace08ad49d812cd57fcc5f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473df8e3ace08ad49d812cd57fcc5f90">&#9670;&#160;</a></span>operator!=() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab892f9c1b557a16dd61daa9664feafda" name="ab892f9c1b557a16dd61daa9664feafda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab892f9c1b557a16dd61daa9664feafda">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a894460b393d2ac20c8b8f033322ff230" name="a894460b393d2ac20c8b8f033322ff230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894460b393d2ac20c8b8f033322ff230">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab897f8f3641b27de2e08d2d16563a2c2" name="ab897f8f3641b27de2e08d2d16563a2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab897f8f3641b27de2e08d2d16563a2c2">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5beff690dcaa87cb11a10e760c1d0211" name="a5beff690dcaa87cb11a10e760c1d0211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5beff690dcaa87cb11a10e760c1d0211">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ae66b21dd10f996a2782e6e8b604593" name="a9ae66b21dd10f996a2782e6e8b604593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae66b21dd10f996a2782e6e8b604593">&#9670;&#160;</a></span>erase_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate pred from the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of erased elements.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/erase2">https://en.cppreference.com/w/cpp/container/vector/erase2</a> </p>

</div>
</div>
<a id="ab2e72fc74a7231310049a5cb0790c765" name="ab2e72fc74a7231310049a5cb0790c765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e72fc74a7231310049a5cb0790c765">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5914a0a90f9a279328bcadc57b7ce090" name="a5914a0a90f9a279328bcadc57b7ce090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5914a0a90f9a279328bcadc57b7ce090">&#9670;&#160;</a></span>is_hosted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_hosted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">consteval</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcf6fdfc0878be3154d7671edc95de7f" name="adcf6fdfc0878be3154d7671edc95de7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf6fdfc0878be3154d7671edc95de7f">&#9670;&#160;</a></span>is_freestanding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_freestanding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">consteval</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf1ef9857ea2d2e84bd3c311d0ccc92f" name="aaf1ef9857ea2d2e84bd3c311d0ccc92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1ef9857ea2d2e84bd3c311d0ccc92f">&#9670;&#160;</a></span>operator==() <span class="overload">[26/26]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares language_standards. </p>

</div>
</div>
<a id="afd7d0d2c778d8ba04d8b73a77fec5d83" name="afd7d0d2c778d8ba04d8b73a77fec5d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7d0d2c778d8ba04d8b73a77fec5d83">&#9670;&#160;</a></span>operator!=() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc3d8b9402fd47ee81c43ca9621035b7" name="acc3d8b9402fd47ee81c43ca9621035b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3d8b9402fd47ee81c43ca9621035b7">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e8fec49a7e24b2cb1f6dc5b738b1daa" name="a4e8fec49a7e24b2cb1f6dc5b738b1daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8fec49a7e24b2cb1f6dc5b738b1daa">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f071a704146a7adbb1dc8186e6cd184" name="a5f071a704146a7adbb1dc8186e6cd184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f071a704146a7adbb1dc8186e6cd184">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a11fea942b05530889b9e1944f07147" name="a9a11fea942b05530889b9e1944f07147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a11fea942b05530889b9e1944f07147">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad6cb779fe6050798f469e14a06f4412e" name="ad6cb779fe6050798f469e14a06f4412e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cb779fe6050798f469e14a06f4412e">&#9670;&#160;</a></span>is_bitmask_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_bitmask_type_v = <a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb794742f9815f88d6c2291181dc2501" name="abb794742f9815f88d6c2291181dc2501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb794742f9815f88d6c2291181dc2501">&#9670;&#160;</a></span>binary</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> binary = <a class="el" href="structetl_1_1binary__t.html">binary_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae88c83d30ae1d2a54dd8438da2038aab" name="ae88c83d30ae1d2a54dd8438da2038aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88c83d30ae1d2a54dd8438da2038aab">&#9670;&#160;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="attributes_8hpp.html#a6cf990edeb7f9f6f1b5928471cef5e56">TETL_MAY_ALIAS</a> byte</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a> is a distinct type that implements the concept of byte as specified in the C++ language definition. </p>
<p>Like char and unsigned char, it can be used to access raw memory occupied by other objects, but unlike those types, it is not a character type and is not an arithmetic type. A byte is only a collection of bits, and the only operators defined for it are the bitwise ones.</p>
<p><a href="https://en.cppreference.com/w/cpp/types/byte">https://en.cppreference.com/w/cpp/types/byte</a> </p>

</div>
</div>
<a id="aba873a97be10ad8146b06a01a9694b9c" name="aba873a97be10ad8146b06a01a9694b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba873a97be10ad8146b06a01a9694b9c">&#9670;&#160;</a></span>sorted_unique</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> sorted_unique = <a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6e287e878604ddef97548a69df3bb24" name="af6e287e878604ddef97548a69df3bb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e287e878604ddef97548a69df3bb24">&#9670;&#160;</a></span>is_placeholder_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">int</a> is_placeholder_v = <a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1903f5208bf0e496f112e85dd1915de8" name="a1903f5208bf0e496f112e85dd1915de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1903f5208bf0e496f112e85dd1915de8">&#9670;&#160;</a></span>allocator_arg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a> allocator_arg {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocator_arg is a constant of type <a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects. </p>

</div>
</div>
<a id="a2eb779f5e8046c7d141522c238bc2764" name="a2eb779f5e8046c7d141522c238bc2764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb779f5e8046c7d141522c238bc2764">&#9670;&#160;</a></span>uses_allocator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> uses_allocator_v = <a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Alloc</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false. </p>

</div>
</div>
<a id="ac49e3304c1cd20a376c9bd1758dd13bd" name="ac49e3304c1cd20a376c9bd1758dd13bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49e3304c1cd20a376c9bd1758dd13bd">&#9670;&#160;</a></span>destroying_delete</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> destroying_delete = <a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag type used to identify the destroying delete form of operator delete. </p>

</div>
</div>
<a id="a968338cd15fb1036406d2b3c8cb5b591" name="a968338cd15fb1036406d2b3c8cb5b591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968338cd15fb1036406d2b3c8cb5b591">&#9670;&#160;</a></span>hardware_constructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> hardware_constructive_interference_size = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum offset between two objects to avoid false sharing. Guaranteed to be at least alignof(max_align_t). </p>

</div>
</div>
<a id="acf9464e19a95c1baba9554e5ae2c2af6" name="acf9464e19a95c1baba9554e5ae2c2af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9464e19a95c1baba9554e5ae2c2af6">&#9670;&#160;</a></span>hardware_destructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> hardware_destructive_interference_size = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least alignof(max_align_t). </p>

</div>
</div>
<a id="a9706e5f8dbc47772797c3f13cfd73517" name="a9706e5f8dbc47772797c3f13cfd73517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9706e5f8dbc47772797c3f13cfd73517">&#9670;&#160;</a></span>nothrow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> nothrow = <a class="el" href="structetl_1_1nothrow__t.html">etl::nothrow_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#a9706e5f8dbc47772797c3f13cfd73517" title="etl::nothrow is a constant of type etl::nothrow_t used to disambiguate the overloads of throwing and ...">etl::nothrow</a> is a constant of type <a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> used to disambiguate the overloads of throwing and non-throwing allocation functions. </p>

</div>
</div>
<a id="acd293644b847dc4549de80a090d66625" name="acd293644b847dc4549de80a090d66625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd293644b847dc4549de80a090d66625">&#9670;&#160;</a></span>nullopt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> nullopt = <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>{{}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#acd293644b847dc4549de80a090d66625" title="etl::nullopt is a constant of type etl::nullopt_t that is used to indicate optional type with uniniti...">etl::nullopt</a> is a constant of type <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> that is used to indicate optional type with uninitialized state. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a0">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a12dd54e001e852c457b3b78bec3f9439" name="a12dd54e001e852c457b3b78bec3f9439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dd54e001e852c457b3b78bec3f9439">&#9670;&#160;</a></span>element_aligned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a> element_aligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47b3f0cc9d6b62d223bde4e4ce670e9f" name="a47b3f0cc9d6b62d223bde4e4ce670e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b3f0cc9d6b62d223bde4e4ce670e9f">&#9670;&#160;</a></span>vector_aligned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a> vector_aligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94295cec56b880883c5b127dbf8dacd9" name="a94295cec56b880883c5b127dbf8dacd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94295cec56b880883c5b127dbf8dacd9">&#9670;&#160;</a></span>overaligned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt; overaligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5895291aecd11c1e854ea1cdaac5d7c9" name="a5895291aecd11c1e854ea1cdaac5d7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5895291aecd11c1e854ea1cdaac5d7c9">&#9670;&#160;</a></span>ignore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">struct</a> etl::ignore ignore</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ad99d6adeb2c1d8530bf9204f34aab4" name="a5ad99d6adeb2c1d8530bf9204f34aab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad99d6adeb2c1d8530bf9204f34aab4">&#9670;&#160;</a></span>is_tuple_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_tuple_like&lt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt; Ts... &gt; &gt; = <a class="el" href="structetl_1_1static__vector.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bccb49e0b1f811bb51be4f782a5b6c6" name="a4bccb49e0b1f811bb51be4f782a5b6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bccb49e0b1f811bb51be4f782a5b6c6">&#9670;&#160;</a></span>tuple_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> tuple_size_v = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0319c290d41e45e5190db6169c188724" name="a0319c290d41e45e5190db6169c188724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0319c290d41e45e5190db6169c188724">&#9670;&#160;</a></span>alignment_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> alignment_of_v = <a class="el" href="structetl_1_1alignment__of.html">etl::alignment_of</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92b52772010dec87f8867320a8b03dfc" name="a92b52772010dec87f8867320a8b03dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b52772010dec87f8867320a8b03dfc">&#9670;&#160;</a></span>always_false</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> always_false = <a class="el" href="structetl_1_1static__vector.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5672914b2f1f9c1c4c50ded53a8db2e3" name="a5672914b2f1f9c1c4c50ded53a8db2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5672914b2f1f9c1c4c50ded53a8db2e3">&#9670;&#160;</a></span>conjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> conjunction_v = (B::value &amp;&amp; ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb3abcd15bf9ea4a0629b7e03498e1e1" name="abb3abcd15bf9ea4a0629b7e03498e1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3abcd15bf9ea4a0629b7e03498e1e1">&#9670;&#160;</a></span>disjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> disjunction_v = (B::value || ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06332dc22e85765f2c195c703cc49068" name="a06332dc22e85765f2c195c703cc49068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06332dc22e85765f2c195c703cc49068">&#9670;&#160;</a></span>extent_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">unsigned</a> N = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> extent_v = <a class="el" href="structetl_1_1static__vector.html">static_cast</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt;(<a class="el" href="structetl_1_1extent.html">extent</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">N</a>&gt;::value)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c5a77036b20d94554de76a0879573e1" name="a4c5a77036b20d94554de76a0879573e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5a77036b20d94554de76a0879573e1">&#9670;&#160;</a></span>has_unique_object_representations_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> has_unique_object_representations_v = <a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e997395a99be7b3ac747230c82b51d2" name="a7e997395a99be7b3ac747230c82b51d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e997395a99be7b3ac747230c82b51d2">&#9670;&#160;</a></span>has_virtual_destructor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> has_virtual_destructor_v = <a class="el" href="structetl_1_1static__vector.html">__has_virtual_destructor</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a> </p>

</div>
</div>
<a id="a0a6eea4e711c17c5bb6f7e8af9c7effc" name="a0a6eea4e711c17c5bb6f7e8af9c7effc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6eea4e711c17c5bb6f7e8af9c7effc">&#9670;&#160;</a></span>index_c</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> index_c = <a class="el" href="#aaa543888abe1d65f79e9b1a62b95dc55">etl::index_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10afef86eafa806bb7142657cfa37f79" name="a10afef86eafa806bb7142657cfa37f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10afef86eafa806bb7142657cfa37f79">&#9670;&#160;</a></span>is_abstract_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_abstract_v = <a class="el" href="structetl_1_1static__vector.html">__is_abstract</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb0e64aa57f60e45754ac20ba126bbe3" name="adb0e64aa57f60e45754ac20ba126bbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0e64aa57f60e45754ac20ba126bbe3">&#9670;&#160;</a></span>is_aggregate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_aggregate_v = <a class="el" href="structetl_1_1static__vector.html">__is_aggregate</a>(<a class="el" href="#a9629a84441c7647c5374e5f1ada63df5">remove_cv_t</a>&lt;T&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97300837e35e483d3cf7b20dd724250b" name="a97300837e35e483d3cf7b20dd724250b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97300837e35e483d3cf7b20dd724250b">&#9670;&#160;</a></span>is_any_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_any_of_v = <a class="el" href="#abb3abcd15bf9ea4a0629b7e03498e1e1">disjunction_v</a>&lt;<a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">Types</a>&gt;...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf2224be65b8fb8794372d049a1d37d9" name="abf2224be65b8fb8794372d049a1d37d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2224be65b8fb8794372d049a1d37d9">&#9670;&#160;</a></span>is_arithmetic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_arithmetic_v = <a class="el" href="#a396e4b8c756441b942c1619de108e56a">etl::is_integral_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">or</a> <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">etl::is_floating_point_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b0e44222b6a1dc103286f3c5225ad93" name="a8b0e44222b6a1dc103286f3c5225ad93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0e44222b6a1dc103286f3c5225ad93">&#9670;&#160;</a></span>is_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_array_v = <a class="el" href="structetl_1_1is__array.html">etl::is_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a762a8e8750c01c04403086076b7bab1e" name="a762a8e8750c01c04403086076b7bab1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762a8e8750c01c04403086076b7bab1e">&#9670;&#160;</a></span>is_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_assignable_v = <a class="el" href="structetl_1_1static__vector.html">__is_assignable</a>(T, U)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a096bf5b121d9f427c8027f2949e8198e" name="a096bf5b121d9f427c8027f2949e8198e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096bf5b121d9f427c8027f2949e8198e">&#9670;&#160;</a></span>is_base_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Base</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Derived</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_base_of_v = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Base</a>, <a class="el" href="structetl_1_1static__vector.html">Derived</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a699f9a94f5d0c71c5e85e84f7baeb4" name="a7a699f9a94f5d0c71c5e85e84f7baeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a699f9a94f5d0c71c5e85e84f7baeb4">&#9670;&#160;</a></span>is_bounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_bounded_array_v = <a class="el" href="structetl_1_1is__bounded__array.html">etl::is_bounded_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca38abc104326427a46bccfd27cbfe28" name="aca38abc104326427a46bccfd27cbfe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca38abc104326427a46bccfd27cbfe28">&#9670;&#160;</a></span>is_class_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_class_v = <a class="el" href="structetl_1_1static__vector.html">__is_class</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad2d62ca306fe828c5b72d7ebd4bf357" name="aad2d62ca306fe828c5b72d7ebd4bf357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2d62ca306fe828c5b72d7ebd4bf357">&#9670;&#160;</a></span>is_compound_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_compound_v = !<a class="el" href="#aec01da22051322819e36fdfa6c5514a5">etl::is_fundamental_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bf567b7866a96e4005d64743e0859b0" name="a0bf567b7866a96e4005d64743e0859b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf567b7866a96e4005d64743e0859b0">&#9670;&#160;</a></span>is_const_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_const_v = <a class="el" href="structetl_1_1is__const.html">etl::is_const</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a4">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a123009e89543c37bab698abc5f4221a0" name="a123009e89543c37bab698abc5f4221a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123009e89543c37bab698abc5f4221a0">&#9670;&#160;</a></span>is_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_constructible_v = <a class="el" href="#ab130b8cdd79b1e59a593d4cb1c6ffe13">is_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf5e75c4b12aa7982c5a97a14510ab35" name="adf5e75c4b12aa7982c5a97a14510ab35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5e75c4b12aa7982c5a97a14510ab35">&#9670;&#160;</a></span>is_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_convertible_v = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;<a class="el" href="structetl_1_1static__vector.html">From</a>, <a class="el" href="structetl_1_1static__vector.html">To</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe8a0fd8e07b2a2b0d62816c2958722a" name="afe8a0fd8e07b2a2b0d62816c2958722a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8a0fd8e07b2a2b0d62816c2958722a">&#9670;&#160;</a></span>is_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_copy_assignable_v = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f5da2852be4424089f4235ef44dec2" name="a03f5da2852be4424089f4235ef44dec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f5da2852be4424089f4235ef44dec2">&#9670;&#160;</a></span>is_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_copy_constructible_v = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1a93c5d7a09590573ceccfb239a590" name="a5d1a93c5d7a09590573ceccfb239a590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1a93c5d7a09590573ceccfb239a590">&#9670;&#160;</a></span>is_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_default_constructible_v = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9b3cd3fa2118be96d3b81105df490f8" name="ad9b3cd3fa2118be96d3b81105df490f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b3cd3fa2118be96d3b81105df490f8">&#9670;&#160;</a></span>is_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_destructible_v = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91bd4405b77f18a1a21a5b886c3e335d" name="a91bd4405b77f18a1a21a5b886c3e335d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bd4405b77f18a1a21a5b886c3e335d">&#9670;&#160;</a></span>is_empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_empty_v = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b43ce4d692cabf9e9e569bc813f910e" name="a4b43ce4d692cabf9e9e569bc813f910e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b43ce4d692cabf9e9e569bc813f910e">&#9670;&#160;</a></span>is_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_enum_v = <a class="el" href="structetl_1_1static__vector.html">__is_enum</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98c97574ef59ab15ea9cff1856487d66" name="a98c97574ef59ab15ea9cff1856487d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c97574ef59ab15ea9cff1856487d66">&#9670;&#160;</a></span>is_final_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_final_v = <a class="el" href="structetl_1_1static__vector.html">__is_final</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a70da46bf8635132fd3757deb2fff94" name="a8a70da46bf8635132fd3757deb2fff94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a70da46bf8635132fd3757deb2fff94">&#9670;&#160;</a></span>is_floating_point_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_floating_point_v = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abffc77cc5069dfe2c648737671e340d9" name="abffc77cc5069dfe2c648737671e340d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffc77cc5069dfe2c648737671e340d9">&#9670;&#160;</a></span>is_function_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_function_v = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether T is a function type. Types like etl::function, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false. </p>
<p>The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__function.html">is_function</a> or is_function_v is undefined. </p>

</div>
</div>
<a id="aec01da22051322819e36fdfa6c5514a5" name="aec01da22051322819e36fdfa6c5514a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec01da22051322819e36fdfa6c5514a5">&#9670;&#160;</a></span>is_fundamental_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_fundamental_v = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8014fcd9664b5608f77c514246ceafa8" name="a8014fcd9664b5608f77c514246ceafa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8014fcd9664b5608f77c514246ceafa8">&#9670;&#160;</a></span>is_implicit_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_implicit_default_constructible_v = <a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a396e4b8c756441b942c1619de108e56a" name="a396e4b8c756441b942c1619de108e56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396e4b8c756441b942c1619de108e56a">&#9670;&#160;</a></span>is_integral_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_integral_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= is_any_of_v&lt;remove_cv_t&lt;T&gt;,</div>
<div class="line">        bool,</div>
<div class="line">        char,</div>
<div class="line">        <span class="keywordtype">signed</span> char,</div>
<div class="line">        <span class="keywordtype">unsigned</span> char,</div>
<div class="line">        wchar_t,</div>
<div class="line">        char8_t,</div>
<div class="line">        char16_t,</div>
<div class="line">        char32_t,</div>
<div class="line">        short,</div>
<div class="line">        <span class="keywordtype">unsigned</span> short,</div>
<div class="line">        int,</div>
<div class="line">        <span class="keywordtype">unsigned</span> int,</div>
<div class="line">        long,</div>
<div class="line">        <span class="keywordtype">unsigned</span> long,</div>
<div class="line">        <span class="keywordtype">long</span> long,</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span></div>
<div class="line">    &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a65073ba479a098a622312ecaaa89fa64" name="a65073ba479a098a622312ecaaa89fa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65073ba479a098a622312ecaaa89fa64">&#9670;&#160;</a></span>is_invocable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Fn</a> , typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_invocable_v = <a class="el" href="structetl_1_1is__invocable.html">is_invocable</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Fn</a>, ArgTypes...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79bb140a0b590bb8a6eadea52d880d17" name="a79bb140a0b590bb8a6eadea52d880d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bb140a0b590bb8a6eadea52d880d17">&#9670;&#160;</a></span>is_invocable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Fn</a> , typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_invocable_r_v = <a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R</a>, <a class="el" href="structetl_1_1static__vector.html">Fn</a>, ArgTypes...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a3172a26a55cf95dbe3c85e6611ebc0" name="a0a3172a26a55cf95dbe3c85e6611ebc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3172a26a55cf95dbe3c85e6611ebc0">&#9670;&#160;</a></span>is_lvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_lvalue_reference_v = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a241c086fc3e628de919419dd7772e345" name="a241c086fc3e628de919419dd7772e345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241c086fc3e628de919419dd7772e345">&#9670;&#160;</a></span>is_member_function_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_member_function_pointer_v = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a868fe6017d6496b38fe1f2a58a879f14" name="a868fe6017d6496b38fe1f2a58a879f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868fe6017d6496b38fe1f2a58a879f14">&#9670;&#160;</a></span>is_member_object_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_member_object_pointer_v = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f351ba579310d9228dc77b84bdf10b6" name="a8f351ba579310d9228dc77b84bdf10b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f351ba579310d9228dc77b84bdf10b6">&#9670;&#160;</a></span>is_member_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_member_pointer_v = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf52ca54b0d508bfc6b9bbe916faf18" name="afbf52ca54b0d508bfc6b9bbe916faf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf52ca54b0d508bfc6b9bbe916faf18">&#9670;&#160;</a></span>is_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_move_assignable_v = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5181d927278f40a6a97e90944d673c0a" name="a5181d927278f40a6a97e90944d673c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5181d927278f40a6a97e90944d673c0a">&#9670;&#160;</a></span>is_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_move_constructible_v = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0c249b3afd84019ec11170a1e06d267" name="ac0c249b3afd84019ec11170a1e06d267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c249b3afd84019ec11170a1e06d267">&#9670;&#160;</a></span>is_nothrow_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_assignable_v = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00c953e4e3f962b130f431bc25d6101" name="ac00c953e4e3f962b130f431bc25d6101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00c953e4e3f962b130f431bc25d6101">&#9670;&#160;</a></span>is_nothrow_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_constructible_v = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af70f6258c3e925eeb2d27b652374660d" name="af70f6258c3e925eeb2d27b652374660d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70f6258c3e925eeb2d27b652374660d">&#9670;&#160;</a></span>is_nothrow_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_convertible_v = <a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a>&lt;<a class="el" href="structetl_1_1static__vector.html">From</a>, <a class="el" href="structetl_1_1static__vector.html">To</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3322351bf5068346b84b6b19717f525c" name="a3322351bf5068346b84b6b19717f525c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3322351bf5068346b84b6b19717f525c">&#9670;&#160;</a></span>is_nothrow_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_copy_assignable_v = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a08255d43824dc23e14e09d4f9a3d22" name="a1a08255d43824dc23e14e09d4f9a3d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a08255d43824dc23e14e09d4f9a3d22">&#9670;&#160;</a></span>is_nothrow_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_copy_constructible_v = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d84124b3f5c4c4fab97253443d07a56" name="a2d84124b3f5c4c4fab97253443d07a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d84124b3f5c4c4fab97253443d07a56">&#9670;&#160;</a></span>is_nothrow_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_default_constructible_v = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf6b378d80292ae38acd1f467e10dd49" name="adf6b378d80292ae38acd1f467e10dd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6b378d80292ae38acd1f467e10dd49">&#9670;&#160;</a></span>is_nothrow_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_destructible_v = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad26f59ba1b8a873f9d8374f72a4002c4" name="ad26f59ba1b8a873f9d8374f72a4002c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26f59ba1b8a873f9d8374f72a4002c4">&#9670;&#160;</a></span>is_nothrow_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_move_assignable_v = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34e3584e54b63fd9e6a35fffd41080bd" name="a34e3584e54b63fd9e6a35fffd41080bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e3584e54b63fd9e6a35fffd41080bd">&#9670;&#160;</a></span>is_nothrow_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_move_constructible_v = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af740a9b650d7a3063e9414c3c50ffdb5" name="af740a9b650d7a3063e9414c3c50ffdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af740a9b650d7a3063e9414c3c50ffdb5">&#9670;&#160;</a></span>is_nothrow_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_swappable_v = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa10bae03ee2ee7efc954c5553dfb34dd" name="aa10bae03ee2ee7efc954c5553dfb34dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10bae03ee2ee7efc954c5553dfb34dd">&#9670;&#160;</a></span>is_nothrow_swappable_with_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_nothrow_swappable_with_v = <a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a284cbaff17633b620e43bf4c4a5b9c66" name="a284cbaff17633b620e43bf4c4a5b9c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284cbaff17633b620e43bf4c4a5b9c66">&#9670;&#160;</a></span>is_null_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_null_pointer_v = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e0edf4d9cccfbffc3b8744b2c7bcfe9" name="a6e0edf4d9cccfbffc3b8744b2c7bcfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">&#9670;&#160;</a></span>is_object_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_object_v = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d8a43ca3d5d473f1651ef5114c2628" name="a60d8a43ca3d5d473f1651ef5114c2628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d8a43ca3d5d473f1651ef5114c2628">&#9670;&#160;</a></span>is_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_pointer_v = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a143b8d7f44dff4fa25a08864799234" name="a7a143b8d7f44dff4fa25a08864799234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a143b8d7f44dff4fa25a08864799234">&#9670;&#160;</a></span>is_polymorphic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_polymorphic_v = <a class="el" href="structetl_1_1static__vector.html">__is_polymorphic</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8301cd1745fa1701a4f9d6045f15a2e0" name="a8301cd1745fa1701a4f9d6045f15a2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8301cd1745fa1701a4f9d6045f15a2e0">&#9670;&#160;</a></span>is_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_reference_v = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e51e4e96e7f9909244d577e730f80cf" name="a0e51e4e96e7f9909244d577e730f80cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e51e4e96e7f9909244d577e730f80cf">&#9670;&#160;</a></span>is_reference_wrapper_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_reference_wrapper_v = <a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae76f1e4408116211d60d33934f2241ec" name="ae76f1e4408116211d60d33934f2241ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76f1e4408116211d60d33934f2241ec">&#9670;&#160;</a></span>is_rvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_rvalue_reference_v = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6c6bde5fd020a928e6d7b5fe8db7bb0" name="aa6c6bde5fd020a928e6d7b5fe8db7bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">&#9670;&#160;</a></span>is_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_same_v = <a class="el" href="structetl_1_1static__vector.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd4cca5d1a81afdeb0354d88b58554a1" name="abd4cca5d1a81afdeb0354d88b58554a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4cca5d1a81afdeb0354d88b58554a1">&#9670;&#160;</a></span>is_same_v&lt; T, T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a>&lt; T, T &gt; = <a class="el" href="structetl_1_1static__vector.html">true</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a030808462771bbdd627d73c92a98565f" name="a030808462771bbdd627d73c92a98565f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030808462771bbdd627d73c92a98565f">&#9670;&#160;</a></span>is_scalar_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_scalar_v = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78db0060aa04a75ce5b8a07e7ece59de" name="a78db0060aa04a75ce5b8a07e7ece59de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78db0060aa04a75ce5b8a07e7ece59de">&#9670;&#160;</a></span>is_scoped_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_scoped_enum_v = <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether T is an scoped enumeration type. Provides the member constant value which is equal to true, if T is an scoped enumeration type. Otherwise, value is equal to false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a> or is_scoped_enum_v is undefined. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_scoped_enum">https://en.cppreference.com/w/cpp/types/is_scoped_enum</a> </p>

</div>
</div>
<a id="a05c78609bb9e06b42e0a4c0c4409b0a1" name="a05c78609bb9e06b42e0a4c0c4409b0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c78609bb9e06b42e0a4c0c4409b0a1">&#9670;&#160;</a></span>is_signed_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_signed_v = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28194dad7a848538b478ff8c18abafed" name="a28194dad7a848538b478ff8c18abafed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28194dad7a848538b478ff8c18abafed">&#9670;&#160;</a></span>is_specialized_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">template</a>&lt; typename... &gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> Template, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tag</a>  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_specialized_v = <a class="el" href="structetl_1_1is__specialized.html">etl::is_specialized</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Template</a>, T, <a class="el" href="structetl_1_1static__vector.html">Tag</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87eee4459ff69343253626fdfad870b1" name="a87eee4459ff69343253626fdfad870b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87eee4459ff69343253626fdfad870b1">&#9670;&#160;</a></span>is_standard_layout_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_standard_layout_v = <a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a08681ad0c17b00662bfd185a081335" name="a6a08681ad0c17b00662bfd185a081335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a08681ad0c17b00662bfd185a081335">&#9670;&#160;</a></span>is_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_swappable_v = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1c3e504b08a7a017cf1fafdf4435eff" name="ac1c3e504b08a7a017cf1fafdf4435eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c3e504b08a7a017cf1fafdf4435eff">&#9670;&#160;</a></span>is_swappable_with_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_swappable_with_v = <a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a328d1a7de791585957bddf38501d3965" name="a328d1a7de791585957bddf38501d3965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328d1a7de791585957bddf38501d3965">&#9670;&#160;</a></span>is_trivial_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivial_v = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e5575d88dd9e2ccdec94f3e0221bd93" name="a3e5575d88dd9e2ccdec94f3e0221bd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5575d88dd9e2ccdec94f3e0221bd93">&#9670;&#160;</a></span>is_trivially_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivially_assignable_v = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a396c0b78998702552df9f3f40bc88982" name="a396c0b78998702552df9f3f40bc88982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396c0b78998702552df9f3f40bc88982">&#9670;&#160;</a></span>is_trivially_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivially_constructible_v = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57b0a04cc2a51f7a14f9c7a02c44aecc" name="a57b0a04cc2a51f7a14f9c7a02c44aecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b0a04cc2a51f7a14f9c7a02c44aecc">&#9670;&#160;</a></span>is_trivially_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivially_copy_assignable_v = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa380d2993e2d74ca6ec925404947169c" name="aa380d2993e2d74ca6ec925404947169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa380d2993e2d74ca6ec925404947169c">&#9670;&#160;</a></span>is_trivially_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivially_copy_constructible_v = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af94b442e8b9fb5a0de351b1b84d6f703" name="af94b442e8b9fb5a0de351b1b84d6f703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94b442e8b9fb5a0de351b1b84d6f703">&#9670;&#160;</a></span>is_trivially_copyable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivially_copyable_v = <a class="el" href="structetl_1_1static__vector.html">__is_trivially_copyable</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadf6d7f246062eff8288873db7382e49" name="aadf6d7f246062eff8288873db7382e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf6d7f246062eff8288873db7382e49">&#9670;&#160;</a></span>is_trivially_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivially_default_constructible_v = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63c5a91c590beb77cbc056cb9327956f" name="a63c5a91c590beb77cbc056cb9327956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c5a91c590beb77cbc056cb9327956f">&#9670;&#160;</a></span>is_trivially_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivially_destructible_v = <a class="el" href="structetl_1_1static__vector.html">__has_trivial_destructor</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57849835554ed7e24b739e5ad635cc5d" name="a57849835554ed7e24b739e5ad635cc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57849835554ed7e24b739e5ad635cc5d">&#9670;&#160;</a></span>is_trivially_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_trivially_move_assignable_v = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7d1caff81b5bd6a9266da221ee4a2f5" name="aa7d1caff81b5bd6a9266da221ee4a2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d1caff81b5bd6a9266da221ee4a2f5">&#9670;&#160;</a></span>is_trivially_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> is_trivially_move_constructible_v = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">etl::is_trivially_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a687f368c330615460df7f61947e88279" name="a687f368c330615460df7f61947e88279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687f368c330615460df7f61947e88279">&#9670;&#160;</a></span>is_unbounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_unbounded_array_v = <a class="el" href="structetl_1_1is__unbounded__array.html">etl::is_unbounded_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39d7414e06afd624ccd66acee3873b11" name="a39d7414e06afd624ccd66acee3873b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d7414e06afd624ccd66acee3873b11">&#9670;&#160;</a></span>is_union_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_union_v = <a class="el" href="structetl_1_1static__vector.html">__is_union</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac22b0b8d8faeebf7b2eb8d80ccdb03ba" name="ac22b0b8d8faeebf7b2eb8d80ccdb03ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22b0b8d8faeebf7b2eb8d80ccdb03ba">&#9670;&#160;</a></span>is_unsigned_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_unsigned_v = <a class="el" href="structetl_1_1is__unsigned.html">etl::is_unsigned</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4414ccc8655262f0522dc640003d64b7" name="a4414ccc8655262f0522dc640003d64b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4414ccc8655262f0522dc640003d64b7">&#9670;&#160;</a></span>is_void_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_void_v = <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">etl::is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">void</a>, <a class="el" href="#a9629a84441c7647c5374e5f1ada63df5">etl::remove_cv_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3fd8976091aa72c12d7a7e5ee986400" name="af3fd8976091aa72c12d7a7e5ee986400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fd8976091aa72c12d7a7e5ee986400">&#9670;&#160;</a></span>is_volatile_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> is_volatile_v = <a class="el" href="structetl_1_1is__volatile.html">etl::is_volatile</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bef7b75bd1375e11a158bc94cbc4fa3" name="a3bef7b75bd1375e11a158bc94cbc4fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bef7b75bd1375e11a158bc94cbc4fa3">&#9670;&#160;</a></span>negation_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">B</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> negation_v = !<a class="el" href="structetl_1_1static__vector.html">bool</a>(B::value)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c66bceba9ac1596666a40596ddf9b62" name="a3c66bceba9ac1596666a40596ddf9b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c66bceba9ac1596666a40596ddf9b62">&#9670;&#160;</a></span>rank_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> rank_v = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Type</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb090c3e2bd7b58f70ddb151d426d84c" name="afb090c3e2bd7b58f70ddb151d426d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb090c3e2bd7b58f70ddb151d426d84c">&#9670;&#160;</a></span>nontype</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> nontype = <a class="el" href="structetl_1_1nontype__t.html">etl::nontype_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">V</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a773a2a7547427bfc26b4ff3b8c2cebe3" name="a773a2a7547427bfc26b4ff3b8c2cebe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773a2a7547427bfc26b4ff3b8c2cebe3">&#9670;&#160;</a></span>piecewise_construct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> piecewise_construct = <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constant <a class="el" href="#a773a2a7547427bfc26b4ff3b8c2cebe3" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>. </p>

</div>
</div>
<a id="a8c2627e58d7c15ca89a458ad54eba558" name="a8c2627e58d7c15ca89a458ad54eba558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2627e58d7c15ca89a458ad54eba558">&#9670;&#160;</a></span>variant_npos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> variant_npos = <a class="el" href="structetl_1_1numeric__limits.html">etl::numeric_limits</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&gt;<a class="el" href="#a5f3eca1793f7f38aeb756464984eb194">::max</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a special value equal to the largest value representable by the type size_t, used as the return value of index() when valueless_by_exception() is true. </p>

</div>
</div>
<a id="a048867192f342c93436216b7b1ed601b" name="a048867192f342c93436216b7b1ed601b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048867192f342c93436216b7b1ed601b">&#9670;&#160;</a></span>variant_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> variant_size_v = <a class="el" href="structetl_1_1variant__size.html">variant_size</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9683edd538ff0cc668fb5a823604223" name="ac9683edd538ff0cc668fb5a823604223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9683edd538ff0cc668fb5a823604223">&#9670;&#160;</a></span>current_implementation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> current_implementation = <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1">implementation::freestanding</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a32ab1ee4dc1bf7a3e86e713a4d6cbf" name="a6a32ab1ee4dc1bf7a3e86e713a4d6cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a32ab1ee4dc1bf7a3e86e713a4d6cbf">&#9670;&#160;</a></span>current_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> current_standard = <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff">language_standard::cpp_26</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently configured C++ standard. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li>
    <li class="footer">Generated on Tue Apr 2 2024 17:58:04 for tetl by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
