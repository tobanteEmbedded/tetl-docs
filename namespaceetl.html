<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceetl.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">etl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1chrono.html">chrono</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html">chrono_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html">complex_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1meta.html">meta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1numbers.html">numbers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1ranges.html">ranges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1simd__abi.html">simd_abi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1string__view__literals.html">string_view_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swap__no__throw.html">_swap_no_throw</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swappable__with__helper.html">_swappable_with_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swappable__with__helper_3_01T_00_01U_00_01void__t_3_01decltype_07swap_07declval_3a85b88c6bbfa63467fd799de16a3d15b.html">_swappable_with_helper&lt; T, U, void_t&lt; decltype(swap(declval&lt; T &gt;(), declval&lt; U &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__const.html">add_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const.  <a href="structetl_1_1add__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__cv.html">add_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile.  <a href="structetl_1_1add__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a lvalue reference type of T.  <a href="structetl_1_1add__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__pointer.html">add_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined.  <a href="structetl_1_1add__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rvalue reference type of T.  <a href="structetl_1_1add__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__volatile.html">add_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile.  <a href="structetl_1_1add__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1adopt__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align. The default value of Align is the most stringent (the largest) alignment requirement for any object whose size is at most Len. If the default value is not used, Align must be the value of alignof(T) for some type T, or the behavior is undefined.  <a href="structetl_1_1aligned__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__union.html">aligned_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitable for use as uninitialized storage for an object of any of the types listed in Types. The size of the storage is at least Len. <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> also determines the strictest (largest) alignment requirement among all Types and makes it available as the constant alignment_value. If sizeof...(Types) == 0 or if any of the types in Types is not a complete object type, the behavior is undefined. It is implementation-defined whether any extended alignment is supported. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> is undefined.  <a href="structetl_1_1aligned__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1alignment__of.html">alignment_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1alignment__of.html" title="alignment_of">alignment_of</a>  <a href="structetl_1_1alignment__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects.  <a href="structetl_1_1allocator__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that encapsulates fixed size arrays.  <a href="structetl_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1assert__msg.html">assert_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Payload for an assertion.  <a href="structetl_1_1assert__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a LegacyOutputIterator that appends to a container for which it was constructed. The container's push_back() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a no-op.  <a href="structetl_1_1back__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__function__call.html">bad_function_call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__optional__access.html">bad_optional_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a type of object to be thrown by etl::optional::value when accessing an optional object that does not contain a value.  <a href="structetl_1_1bad__optional__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__variant__access.html">bad_variant_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">etl::bad_variant_access</a> is the type of the exception thrown in the following situations: (1) etl::get(etl::variant) called with an index or type that does not match the currently active alternative. (2) <a class="el" href="#aa43fcb4942d4cec1824f6e38edce9981" title="Applies the visitor vis (Callable that can be called with any combination of types from variants) to ...">etl::visit</a> called to visit a variant that is valueless_by_exception  <a href="structetl_1_1bad__variant__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__common__reference.html">basic_common_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="structetl_1_1basic__common__reference.html" title="The class template basic_common_reference is a customization point that allows users to influence the...">basic_common_reference</a> is a customization point that allows users to influence the result of <a class="el" href="structetl_1_1common__reference.html" title="Determines the common reference type of the types T..., that is, the type to which all the types in T...">common_reference</a> for user-defined types (typically proxy references). The primary template is empty.  <a href="structetl_1_1basic__common__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__common__reference_3_01pair_3_01T1_00_01T2_01_4_00_01pair_3_01U1_00_01U2_01_4_00_01TQual_00_01UQual_01_4.html">basic_common_reference&lt; pair&lt; T1, T2 &gt;, pair&lt; U1, U2 &gt;, TQual, UQual &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__arg.html">basic_format_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to formatting state consisting of the formatting arguments and the output iterator.  <a href="structetl_1_1basic__format__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> class with fixed size capacity.  <a href="structetl_1_1basic__static__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__streambuf.html">basic_streambuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="structetl_1_1basic__string__view.html" title="The class template basic_string_view describes an object that can refer to a constant contiguous sequ...">basic_string_view</a> describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. A typical implementation holds only two members: a pointer to constant CharType and a size.  <a href="structetl_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bernoulli__distribution.html">bernoulli_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1bidirectional__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1binary__t.html">binary_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and.html">bit_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise AND. Effectively calls operator&amp; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/bit_and">https://en.cppreference.com/w/cpp/utility/functional/bit_and</a>.  <a href="structetl_1_1bit__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and_3_01void_01_4.html">bit_and&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not.html">bit_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise NOT. Effectively calls operator~ on type T.  <a href="structetl_1_1bit__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not_3_01void_01_4.html">bit_not&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or.html">bit_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise OR. Effectively calls operator| on type T.  <a href="structetl_1_1bit__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or_3_01void_01_4.html">bit_or&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor.html">bit_xor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise XOR. Effectively calls operator^ on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/bit_xor">https://en.cppreference.com/w/cpp/utility/functional/bit_xor</a>.  <a href="structetl_1_1bit__xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor_3_01void_01_4.html">bit_xor&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators.  <a href="structetl_1_1bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits.html">char_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class. The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types. If an operation on traits emits an exception, the behavior is undefined.  <a href="structetl_1_1char__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html">char_traits&lt; char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char.  <a href="structetl_1_1char__traits_3_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01wchar__t_01_4.html">char_traits&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference.html">common_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common reference type of the types T..., that is, the type to which all the types in T... can be converted or bound. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. The behavior is undefined if any of the types in T... is an incomplete type other than (possibly cv-qualified) void.  <a href="structetl_1_1common__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_01T_01_4.html">common_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_01T_00_01U_01_4.html">common_reference&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_4.html">common_reference&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type.html">common_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common type among all types <code>T...</code>, that is the type all <code>T...</code> can be implicitly converted to. If such a type exists, the member type names that type. Otherwise, there is no member type.  <a href="structetl_1_1common__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html">common_type&lt; chrono::duration&lt; Rep1, Period1 &gt;, chrono::duration&lt; Rep2, Period2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two etl::chrono::durations, whose period is the greatest common divisor of Period1 and Period2.  <a href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html">common_type&lt; chrono::time_point&lt; Clock, Duration1 &gt;, chrono::time_point&lt; Clock, Duration2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two chrono::time_points.  <a href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T_01_4.html">common_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html">common_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html">common_type&lt; T1, T2, R... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1compare__three__way__result.html">compare_three_way_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1compare__three__way__result_3_01T_00_01U_01_4.html">compare_three_way_result&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A complex number.  <a href="structetl_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional.html">conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.  <a href="structetl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html">conditional&lt; false, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits.  <a href="structetl_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1const__where__expression.html">const_where_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1contiguous__iterator__tag.html">contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1contiguous__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1decay.html">decay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type.  <a href="structetl_1_1decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__accessor.html">default_accessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__delete.html">default_delete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__delete_3_01T_0f_0e_4.html">default_delete&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__searcher.html">default_searcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default searcher. A class suitable for use with Searcher overload of <a class="el" href="#af39a57bc56c6f3c0bf94045777e9f274" title="Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range [first,...">etl::search</a> that delegates the search operation to the pre-C++17 standard library's <a class="el" href="#af39a57bc56c6f3c0bf94045777e9f274" title="Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range [first,...">etl::search</a>.  <a href="structetl_1_1default__searcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1defer__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to identify the destroying delete form of operator delete.  <a href="structetl_1_1destroying__delete__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits.  <a href="structetl_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1div__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides.html">divides</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing division. Effectively calls operator/ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/divides">https://en.cppreference.com/w/cpp/utility/functional/divides</a>.  <a href="structetl_1_1divides.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides_3_01void_01_4.html">divides&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1domain__error.html">domain_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1dynamic__array.html">dynamic_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1empty__c__array.html">empty_c_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html">enable_if&lt; true, Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator== on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/equal_to">https://en.cppreference.com/w/cpp/utility/functional/equal_to</a>.  <a href="structetl_1_1equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to_3_01void_01_4.html">equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1exception.html">exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1expected.html">expected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent.html">extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array type, provides the member constant value equal to the number of elements along the Nth dimension of the array, if N is in [0, rank_v&lt;T&gt;). For any other type, or if T is an array of unknown bound along its first dimension and N is 0, value is 0.  <a href="structetl_1_1extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_010_01_4.html">extent&lt; T[], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_01N_01_4.html">extent&lt; T[], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_010_01_4.html">extent&lt; T[I], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_01N_01_4.html">extent&lt; T[I], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extents.html">extents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1flat__set.html">flat_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> is a container adaptor that provides an associative container interface that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves. <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> supports random access iterators. Any sequence container supporting random access iteration can be used to instantiate <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a>.  <a href="structetl_1_1flat__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1format__to__n__result.html" title="etl::format_to_n_result has no base classes, or members other than out, size and implicitly declared ...">etl::format_to_n_result</a> has no base classes, or members other than out, size and implicitly declared special member functions.  <a href="structetl_1_1format__to__n__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter.html">formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enabled specializations of formatter define formatting rules for a given type. Enabled specializations meet the Formatter requirements.  <a href="structetl_1_1formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_01const_01_5_00_01char_01_4.html">formatter&lt; char const *, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_00_01char_01_4.html">formatter&lt; char, char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard specializations for basic type char.  <a href="structetl_1_1formatter_3_01char_00_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_0fN_0e_00_01char_01_4.html">formatter&lt; char[N], char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01etl_1_1static__string_3_01Capacity_01_4_00_01char_01_4.html">formatter&lt; etl::static_string&lt; Capacity &gt;, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01etl_1_1string__view_00_01char_01_4.html">formatter&lt; etl::string_view, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01int_00_01char_01_4.html">formatter&lt; int, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01long_01long_00_01char_01_4.html">formatter&lt; long long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01long_00_01char_01_4.html">formatter&lt; long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01short_00_01char_01_4.html">formatter&lt; short, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_01long_00_01char_01_4.html">formatter&lt; unsigned long long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_00_01char_01_4.html">formatter&lt; unsigned long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01short_00_01char_01_4.html">formatter&lt; unsigned short, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_00_01char_01_4.html">formatter&lt; unsigned, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1forward__iterator__tag.html">forward_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1forward__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive numerical input conversion.  <a href="structetl_1_1from__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is an LegacyOutputIterator that prepends elements to a container for which it was constructed. The container's push_front() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is a no-op.  <a href="structetl_1_1front__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1full__extent__t.html">full_extent_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning view of a callable.  <a href="structetl_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_01noexcept_01_4.html">function_ref&lt; R(Args...) noexcept &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater.html">greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater">https://en.cppreference.com/w/cpp/utility/functional/greater</a>.  <a href="structetl_1_1greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater_3_01void_01_4.html">greater&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal.html">greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater_equal">https://en.cppreference.com/w/cpp/utility/functional/greater_equal</a>.  <a href="structetl_1_1greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal_3_01void_01_4.html">greater_equal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1half.html">half</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TriviallyCopyable and if any two objects of type T with the same value have the same object representation, provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1has__unique__object__representations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__virtual__destructor.html">has_virtual_destructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <a href="structetl_1_1has__virtual__destructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash  <a href="structetl_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01bool_01_4.html">hash&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char_01_4.html">hash&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char16__t_01_4.html">hash&lt; char16_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char32__t_01_4.html">hash&lt; char32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char8__t_01_4.html">hash&lt; char8_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01double_01_4.html">hash&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01etl_1_1nullptr__t_01_4.html">hash&lt; etl::nullptr_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html">hash&lt; etl::optional&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template specialization of <a class="el" href="structetl_1_1hash.html" title="hash">etl::hash</a> for the <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> class allows users to obtain hashes of the values contained in optional objects.  <a href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01float_01_4.html">hash&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01int_01_4.html">hash&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01_4.html">hash&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01double_01_4.html">hash&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01long_01_4.html">hash&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01short_01_4.html">hash&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01signed_01char_01_4.html">hash&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01T_01_5_01_4.html">hash&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01char_01_4.html">hash&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01int_01_4.html">hash&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01_4.html">hash&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01long_01_4.html">hash&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01short_01_4.html">hash&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01wchar__t_01_4.html">hash&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1identity.html" title="etl::identity is a function object type whose operator() returns its argument unchanged.">etl::identity</a> is a function object type whose operator() returns its argument unchanged.  <a href="structetl_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ignore.html">ignore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with <a class="el" href="#ada3ddae955d45b6a63298906227f2f60">etl::tie</a> when unpacking a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>, as a placeholder for the arguments that are not used.  <a href="structetl_1_1ignore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1imaxdiv__t.html">imaxdiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1imaxdiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <code>optional</code>, <code>variant</code>, and <code>any</code> to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits.html">incrementable_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_5_01_4.html">incrementable_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_4.html">incrementable_traits&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01const_01_4.html">incrementable_traits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits.html">indirectly_readable_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01I_01_4.html">indirectly_readable_traits&lt; I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_5_01_4.html">indirectly_readable_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_4.html">indirectly_readable_traits&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01const_01_4.html">indirectly_readable_traits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__function_3_01R_07Args_8_8_8_08_00_01Capacity_00_01Alignment_01_4.html">inplace_function&lt; R(Args...), Capacity, Alignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__vector.html">inplace_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__vector_3_01T_00_010_01_4.html">inplace_vector&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1input__iterator__tag.html">input_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1input__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1invalid__argument.html">invalid_argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1invoke__result.html">invoke_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the return type of an INVOKE expression at compile time. F and all types in ArgTypes can be any complete type, array of unknown bound, or (possibly cv-qualified) void. The behavior of a program that adds specializations for any of the templates described on this page is undefined. This implementation is copied from <b>cppreference.com</b>.  <a href="structetl_1_1invoke__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ios__base.html">ios_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__abstract.html">is_abstract</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__aggregate.html">is_aggregate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__any__of.html">is_any_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined.  <a href="structetl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false.  <a href="structetl_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T_0f_0e_4.html">is_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T_0fN_0e_4.html">is_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__assignable.html">is_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__base__of.html">is_base_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::fmtflags_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::iostate_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bitmask_type&lt; detail::openmode_type &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of known bound. Provides the member constant value which is equal to true, if T is an array type of known bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__bounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array_3_01T_0fN_0e_4.html">is_bounded_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__integer.html">is_builtin_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__signed__integer.html">is_builtin_signed_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__unsigned__integer.html">is_builtin_unsigned_integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if T is <code>unsigned char</code> or <code>unsigned short</code> or <code>unsigned int</code> or <code>unsigned long</code> or <code>unsigned long long</code>  <a href="structetl_1_1is__builtin__unsigned__integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__class.html">is_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__compound.html">is_compound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__compound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const.html">is_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const_3_01T_01const_01_4.html">is_const&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the imaginary function definition <code>To test() { return <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;From&gt;(); }</code> is well-formed, (that is, either <code><a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;From&gt;()</code> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <code><a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a></code> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered.  <a href="structetl_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_constructible&lt;T, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible.html">is_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.  <a href="structetl_1_1is__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01Type_0f_0e_4.html">is_destructible&lt; Type[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01void_01_4.html">is_destructible&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__empty.html">is_empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f T is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__enum.html">is_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum.html">is_error_condition_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum_3_01errc_01_4.html">is_error_condition_enum&lt; errc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__final.html">is_final</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a final class (that is, a class declared with the final specifier), provides the member constant value equal true. For any other type, value is false. If T is a class type, T shall be a complete type; otherwise, the behavior is undefined.  <a href="structetl_1_1is__final.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false.  <a href="structetl_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__function.html">is_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a fundamental type (that is, arithmetic type, void, or nullptr_t), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__fundamental.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_374fbed591f2848368bdbdd39f8c8e31.html">is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), false_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_63505ad1d5845f9b40fca2dabe8d3bef.html">is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__integral.html">is_integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a lvalue reference type. Provides the member constant value which is equal to true, if T is a lvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference_3_01T_01_6_01_4.html">is_lvalue_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__object__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function,...">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined.  <a href="structetl_1_1is__member__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__nothrow__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable_3_01T_00_01U_01_4.html">is_nothrow_assignable&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__nothrow__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__convertible_3_01From_00_01To_01_4.html">is_nothrow_convertible&lt; From, To &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_nothrow_constructible&lt;T, T const&amp;&gt;.  <a href="structetl_1_1is__nothrow__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__nothrow__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__nothrow__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_01_4.html">is_nothrow_destructible&lt; Type &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_6_01_4.html">is_nothrow_destructible&lt; Type &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_0fN_0e_4.html">is_nothrow_destructible&lt; Type[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__object.html">is_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_placeholder&lt; detail::placeholder_type&lt; N &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01_4.html">is_placeholder&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01volatile_01_4.html">is_placeholder&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01volatile_01_4.html">is_placeholder&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__polymorphic.html">is_polymorphic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference.html">is_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type (lvalue reference or rvalue reference), provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__reference.html" title="If T is a reference type (lvalue reference or rvalue reference), provides the member constant value e...">is_reference</a> or is_reference_v is undefined.  <a href="structetl_1_1is__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html">is_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html">is_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference__wrapper_3_01reference__wrapper_3_01U_01_4_01_4.html">is_reference_wrapper&lt; reference_wrapper&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a rvalue reference type. Provides the member constant value which is equal to true, if T is a rvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference_3_01T_01_6_6_01_4.html">is_rvalue_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scoped__enum_3_01T_00_01true_01_4.html">is_scoped_enum&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__signed.html">is_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false.  <a href="structetl_1_1is__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__specialized.html">is_specialized</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__specialized_3_01Template_00_01T_00_01etl_1_1void__t_3_01decltype_07Template_3_01T_01_4_02_03_08_4_01_4.html">is_specialized&lt; Template, T, etl::void_t&lt; decltype(Template&lt; T &gt;{})&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__standard__layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable.html">is_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_swappable_with&lt;T&amp;, T&amp;&gt;::value</a>.  <a href="structetl_1_1is__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivial.html">is_trivial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TrivialType (that is, a scalar type, a trivially copyable class with a trivial default constructor, or array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__trivial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;T&gt;()</a> = <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__trivially__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__trivially__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_trivially_constructible&lt;T, T const&amp;&gt;.  <a href="structetl_1_1is__trivially__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copyable.html">is_trivially_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a TriviallyCopyable type, provides the member constant value equal to true. For any other type, value is false. The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly cv-qualified). group is_trivial_copyable.  <a href="structetl_1_1is__trivially__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__trivially__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__destructible.html">is_trivially_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage occupied by trivially destructible objects may be reused without calling the destructor.  <a href="structetl_1_1is__trivially__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a7598b525dfc19840d951832acd8b4cf6">etl::is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__typename.html">is_typename</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of unknown bound. Provides the member constant value which is equal to true, if T is an array type of unknown bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__unbounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array_3_01T_0f_0e_4.html">is_unbounded_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__union.html">is_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined.  <a href="structetl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01const_01_4.html">is_unsigned&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01const_01volatile_01_4.html">is_unsigned&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned_3_01T_01volatile_01_4.html">is_unsigned&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__void.html">is_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile.html">is_volatile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile_3_01T_01volatile_01_4.html">is_volatile&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1iterator__traits.html" title="iterator_traits is the type trait class that provides uniform interface to the properties of LegacyIt...">iterator_traits</a> is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators.  <a href="structetl_1_1iterator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits_3_01T_01_5_01_4.html">iterator_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__left.html">layout_left</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__right.html">layout_right</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__stride.html">layout_stride</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1ldiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1length__error.html">length_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less.html">less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less">https://en.cppreference.com/w/cpp/utility/functional/less</a>.  <a href="structetl_1_1less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less_3_01void_01_4.html">less&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal.html">less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less_equal">https://en.cppreference.com/w/cpp/utility/functional/less_equal</a>.  <a href="structetl_1_1less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal_3_01void_01_4.html">less_equal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1lldiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1lock__guard.html">lock_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block. When a <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object was created, the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is destructed and the mutex is released. The <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> struct is non-copyable.  <a href="structetl_1_1lock__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logic__error.html">logic_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and.html">logical_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_and">https://en.cppreference.com/w/cpp/utility/functional/logical_and</a>.  <a href="structetl_1_1logical__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and_3_01void_01_4.html">logical_and&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not.html">logical_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_not">https://en.cppreference.com/w/cpp/utility/functional/logical_not</a>.  <a href="structetl_1_1logical__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not_3_01void_01_4.html">logical_not&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or.html">logical_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_or">https://en.cppreference.com/w/cpp/utility/functional/logical_or</a>.  <a href="structetl_1_1logical__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or_3_01void_01_4.html">logical_or&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__signed.html">make_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__signed.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_signed</a> is undefined.  <a href="structetl_1_1make__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined.  <a href="structetl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1max__align__t.html">max_align_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1max__align__t.html" title="etl::max_align_t is a trivial standard-layout type whose alignment requirement is at least as strict ...">etl::max_align_t</a> is a trivial standard-layout type whose alignment requirement is at least as strict (as large) as that of every scalar type.  <a href="structetl_1_1max__align__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1mdarray.html">mdarray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1mdspan.html">mdspan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus.html">minus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing subtraction. Effectively calls operator- on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/minus">https://en.cppreference.com/w/cpp/utility/functional/minus</a>.  <a href="structetl_1_1minus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus_3_01void_01_4.html">minus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus.html">modulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for computing remainders of divisions. Implements operator% for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/modulus">https://en.cppreference.com/w/cpp/utility/functional/modulus</a>.  <a href="structetl_1_1modulus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus_3_01void_01_4.html">modulus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit type intended for use as a well-behaved empty alternative in <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>. In particular, a variant of non-default-constructible types may list <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> as its first alternative: this makes the variant itself default-constructible.  <a href="structetl_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monotonic__allocator.html">monotonic_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies.html">multiplies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing multiplication. Effectively calls operator* on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/multiplies">https://en.cppreference.com/w/cpp/utility/functional/multiplies</a>.  <a href="structetl_1_1multiplies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies_3_01void_01_4.html">multiplies&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate.html">negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing negation. Effectively calls operator- on an instance of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/negate">https://en.cppreference.com/w/cpp/utility/functional/negate</a>.  <a href="structetl_1_1negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate_3_01void_01_4.html">negate&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical negation of the type trait B.  <a href="structetl_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nontype__t.html">nontype_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to.html">not_equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator!= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/not_equal_to">https://en.cppreference.com/w/cpp/utility/functional/not_equal_to</a>.  <a href="structetl_1_1not__equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to_3_01void_01_4.html">not_equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nothrow__t.html">nothrow_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> is an empty class type used to disambiguate the overloads of throwing and non-throwing allocation functions.  <a href="structetl_1_1nothrow__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> is an empty class type used to indicate optional type with uninitialized state. In particular, <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> has a constructor with <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">nullopt_t</a> as a single argument, which creates an optional that does not contain a value.  <a href="structetl_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01bool_01_4.html">numeric_limits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01char_01_4.html">numeric_limits&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01char8__t_01_4.html">numeric_limits&lt; char8_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01double_01_4.html">numeric_limits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01float_01_4.html">numeric_limits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01int_01_4.html">numeric_limits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01_4.html">numeric_limits&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01double_01_4.html">numeric_limits&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01short_01_4.html">numeric_limits&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01signed_01char_01_4.html">numeric_limits&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01_4.html">numeric_limits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01volatile_01_4.html">numeric_limits&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01volatile_01_4.html">numeric_limits&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01char_01_4.html">numeric_limits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01int_01_4.html">numeric_limits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01long_01_4.html">numeric_limits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01short_01_4.html">numeric_limits&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template optional manages an optional contained value, i.e. a value that may or may not be present.  <a href="structetl_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1optional_3_01T_01_6_01_4.html">optional&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1out__of__range.html">out_of_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1output__iterator__tag.html">output_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1output__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overflow__error.html">overflow_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overload.html">overload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a> with two elements. If neither T1 nor T2 is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of pair is trivial.  <a href="structetl_1_1pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a> is an empty class tag type used to disambiguate between different functions that take two tuple arguments.  <a href="structetl_1_1piecewise__construct__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus.html">plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing addition. Effectively calls operator+ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/plus">https://en.cppreference.com/w/cpp/utility/functional/plus</a>.  <a href="structetl_1_1plus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus_3_01void_01_4.html">plus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__int__pair.html">pointer_int_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct implements a pair of a pointer and small integer. It is designed to represent this in the space required by one pointer by bitmangling the integer into the low part of the pointer. This can only be done for small integers: typically up to 3 bits, but it depends on the number of bits available according to <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for the type.  <a href="structetl_1_1pointer__int__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__int__pair__info.html">pointer_int_pair_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits.html">pointer_like_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits type that is used to handle pointer types and things that are just wrappers for pointers as a uniform entity.  <a href="structetl_1_1pointer__like__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01pointer__int__pair_3_01PtrT_00_01IntBits_00_01IntT_00_01PtrTraits_01_4_01_4.html">pointer_like_traits&lt; pointer_int_pair&lt; PtrT, IntBits, IntT, PtrTraits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html">pointer_like_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for non-cvr pointers.  <a href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html">pointer_like_traits&lt; T const * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const pointers.  <a href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html">pointer_like_traits&lt; T const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const things.  <a href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html">pointer_like_traits&lt; uintptr_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for uintptr_t.  <a href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__traits.html">pointer_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types.  <a href="structetl_1_1pointer__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html">pointer_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types. <a href="https://en.cppreference.com/w/cpp/memory/pointer_traits">https://en.cppreference.com/w/cpp/memory/pointer_traits</a>.  <a href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1random__access__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1range__error.html">range_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank.html">rank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined.  <a href="structetl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T_0f_0e_4.html">rank&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T_0fN_0e_4.html">rank&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The typename template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t.  <a href="structetl_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less.html">ratio_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__not__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">etl::static_vector</a>) which cannot normally hold references. Specifically, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a CopyConstructible and CopyAssignable wrapper around a reference to object or reference to function of type T. Instances of <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> are objects (they can be copied or stored in containers) but they are implicitly convertible to T&amp;, so that they can be used as arguments with the functions that take the underlying type by reference. If the stored reference is Callable, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is callable with the same arguments.  <a href="structetl_1_1reference__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X,...">remove_all_extents</a> is undefined.  <a href="structetl_1_1remove__all__extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T_0f_0e_4.html">remove_all_extents&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T_0fN_0e_4.html">remove_all_extents&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const.html">remove_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const.  <a href="structetl_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html">remove_const&lt; Type const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present.  <a href="structetl_1_1remove__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type T is a reference type, provides the member typedef type which is the type referred to by T with its topmost cv-qualifiers removed. Otherwise type is T with its topmost cv-qualifiers removed.  <a href="structetl_1_1remove__cvref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent.html">remove_extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T....">remove_extent</a> is undefined.  <a href="structetl_1_1remove__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T_0f_0e_4.html">remove_extent&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T_0fN_0e_4.html">remove_extent&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer, then type is the same as T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__pointer.html" title="Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer,...">remove_pointer</a> is undefined.  <a href="structetl_1_1remove__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5_01_4.html">remove_pointer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01_4.html">remove_pointer&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01volatile_01_4.html">remove_pointer&lt; T *const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5volatile_01_4.html">remove_pointer&lt; T *volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html">remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html">remove_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile.  <a href="structetl_1_1remove__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html">remove_volatile&lt; Type volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a> is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, <code><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a></code> produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator. This is the iterator returned by member functions <code><a class="el" href="#a31aadf1fc327da2eaac11d7e6e8617a8" title="Returns an iterator to the reverse-beginning of the given container.">rbegin()</a></code> and <code><a class="el" href="#a3db12aaf2a7b1819d28995d635d91954" title="Returns an iterator to the reverse-end of the given container.">rend()</a></code> of the standard library containers.  <a href="structetl_1_1reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1runtime__error.html">runtime_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1scope__exit.html">scope_exit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <code><a class="el" href="structetl_1_1scope__exit.html" title="The class template scope_exit is a general-purpose scope guard intended to call its exit function whe...">scope_exit</a></code> is a general-purpose scope guard intended to call its exit function when a scope is exited.  <a href="structetl_1_1scope__exit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1small__ptr.html">small_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed pointer to specified size. Intended to be used as a drop in replacement for native pointers.  <a href="structetl_1_1small__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning view over a contiguous sequence of objects.  <a href="structetl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1stack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stack class is a container adapter that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.  <a href="structetl_1_1stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html">static_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1static__set.html" title="static_set is an associative container that contains a sorted set of unique objects of type Key....">static_set</a> is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare.  <a href="structetl_1_1static__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically-resizable fixed-capacity vector.  <a href="structetl_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1strided__slice.html">strided_slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1string__constant.html">string_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1strong__ordering.html">strong_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1submdspan__mapping__result.html">submdspan_mapping_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1timespec.html">timespec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tm.html">tm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive numerical output conversion.  <a href="structetl_1_1to__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1try__to__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element.html">tuple_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface.  <a href="structetl_1_1tuple__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01array_3_01T_00_01N_01_4_01_4.html">tuple_element&lt; I, array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01etl_1_1complex_3_01T_01_4_01_4.html">tuple_element&lt; I, etl::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_element&lt; I, pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specializations of <a class="el" href="structetl_1_1tuple__element.html" title="Provides compile-time indexed access to the type of the elements of the array using tuple-like interf...">tuple_element</a> for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if I &gt;= 2.  <a href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01_4.html">tuple_element&lt; I, T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01volatile_01_4.html">tuple_element&lt; I, T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01volatile_01_4.html">tuple_element&lt; I, T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01tuple_3_01Ts_8_8_8_01_4_01_4.html">tuple_element&lt; I, tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size.html">tuple_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html">tuple_size&lt; array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the number of elements in an array as a compile-time constant expression.  <a href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1complex_3_01T_01_4_01_4.html">tuple_size&lt; etl::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_size&lt; pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization of <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a> for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.  <a href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01_4.html">tuple_size&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01volatile_01_4.html">tuple_size&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01volatile_01_4.html">tuple_size&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01tuple_3_01Ts_8_8_8_01_4_01_4.html">tuple_size&lt; tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1underflow__error.html">underflow_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1underlying__type.html">underlying_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type of an enum.  <a href="structetl_1_1underlying__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unexpect__t.html">unexpect_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unexpected.html">unexpected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uniform__int__distribution.html">uniform_int_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uniform__real__distribution.html">uniform_real_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__array.html">uninitialized_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__array_3_01T_00_01Size_01_4.html">uninitialized_array&lt; T, Size &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__union.html">uninitialized_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unique__lock.html">unique_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a> is a general-purpose mutex ownership wrapper allowing deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use with condition variables.  <a href="structetl_1_1unique__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__ref__decay.html">unwrap_ref_decay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__reference.html">unwrap_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__reference_3_01etl_1_1reference__wrapper_3_01T_01_4_01_4.html">unwrap_reference&lt; etl::reference_wrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false.  <a href="structetl_1_1uses__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionetl_1_1variadic__union.html">variadic_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionetl_1_1variadic__union_3_01T_00_01Ts_8_8_8_01_4.html">variadic_union&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant.html">variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template variant represents a type-safe union. An instance of variant at any given time either holds a value of one of its alternative types.  <a href="structetl_1_1variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant2.html">variant2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.  <a href="structetl_1_1variant__alternative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01etl_1_1variant2_3_01Ts_8_8_8_01_4_01_4.html">variant_alternative&lt; Idx, etl::variant2&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01etl_1_1variant_3_01Ts_8_8_8_01_4_01_4.html">variant_alternative&lt; Idx, etl::variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01_4.html">variant_alternative&lt; Idx, T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01volatile_01_4.html">variant_alternative&lt; Idx, T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01volatile_01_4.html">variant_alternative&lt; Idx, T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size.html">variant_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01const_01_4.html">variant_size&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01const_01volatile_01_4.html">variant_size&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01volatile_01_4.html">variant_size&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01variant2_3_01Ts_8_8_8_01_4_01_4.html">variant_size&lt; variant2&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01variant_3_01Ts_8_8_8_01_4_01_4.html">variant_size&lt; variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1weak__ordering.html">weak_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1where__expression.html">where_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xorshift.html">xorshift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>  <a href="structetl_1_1xorshift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128plus.html">xoshiro128plus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128plusplus.html">xoshiro128plusplus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128starstar.html">xoshiro128starstar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1bitmask__type.html">bitmask_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1three__way__comparable.html">three_way_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1assignable__from.html">assignable_from</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1boolean__testable.html">boolean_testable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__integer.html">builtin_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__signed__integer.html">builtin_signed_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">builtin_unsigned_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1common__reference__with.html">common_reference_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1common__with.html">common_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1constructible__from.html">constructible_from</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructible_from concept specifies that a variable of type T can be initialized with the given set of argument types Args.... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1convertible__to.html">convertible_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept convertible_to&lt;From, To&gt; specifies that an expression of the same type and value category as those of declval&lt;From&gt;() can be implicitly and explicitly converted to the type To, and the two forms of conversion are equivalent. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1copy__constructible.html">copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept copy_constructible is satisfied if T is an lvalue reference type, or if it is a move_constructible object type where an object of that type can constructed from a (possibly const) lvalue or const rvalue of that type in both direct- and copy-initialization contexts with the usual semantics (a copy is constructed with the source unchanged). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1copyable.html">copyable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1default__initializable.html">default_initializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default_initializable concept checks whether variables of type T can be value-initialized (T() is well-formed); direct-list-initialized from an empty initializer list (T{} is well-formed); and default-initialized (T t; is well-formed). Access checking is performed as if in a context unrelated to T. Only the validity of the immediate context of the variable initialization is considered. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1derived__from.html">derived_from</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept derived_from&lt;Derived, Base&gt; is satisfied if and only if Base is a class type that is either Derived or a public and unambiguous base of Derived, ignoring cv-qualifiers. Note that this behaviour is different to is_base_of when Base is a private or protected base of Derived. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1destructible.html">destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept destructible specifies the concept of all types whose instances can safely be destroyed at the end of their lifetime (including reference types). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1equality__comparable.html">equality_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1equivalence__relation.html">equivalence_relation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1floating__point.html">floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept floating_point&lt;T&gt; is satisfied if and only if T is a floating-point type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1integral.html">integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept integral&lt;T&gt; is satisfied if and only if T is an integral type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1invocable.html">invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__bidirectional__iterator.html">legacy_bidirectional_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__forward__iterator.html">legacy_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__input__iterator.html">legacy_input_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__iterator.html">legacy_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1movable.html">movable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1move__constructible.html">move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept move_constructible is satisfied if T is a reference type, or if it is an object type where an object of that type can be constructed from an rvalue of that type in both direct- and copy-initialization contexts, with the usual semantics. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1predicate.html">predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1referenceable.html">referenceable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1regular.html">regular</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1regular__invocable.html">regular_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1relation.html">relation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1same__as.html">same_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept same_as&lt;T, U&gt; is satisfied if and only if T and U denote the same type. same_as&lt;T, U&gt; subsumes same_as&lt;U, T&gt; and vice versa. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1semiregular.html">semiregular</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1signed__integral.html">signed_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept signed_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_signed_v&lt;T&gt; is true. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1strict__weak__order.html">strict_weak_order</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1swappable.html">swappable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1unsigned__integral.html">unsigned_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept unsigned_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_unsigned_v&lt;T&gt; is true. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1weakly__equality__comparable__with.html">weakly_equality_comparable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1incrementable.html">incrementable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__readable.html">indirectly_readable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__regular__unary__invocable.html">indirectly_regular_unary_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__unary__invocable.html">indirectly_unary_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1input__or__output__iterator.html">input_or_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1sentinel__for.html">sentinel_for</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1weakly__incrementable.html">weakly_incrementable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1pair__like.html">pair_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1tuple__like.html">tuple_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad254b7b5c9ddc7bdb528e97771b71a44" id="r_gad254b7b5c9ddc7bdb528e97771b71a44"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueType</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:gad254b7b5c9ddc7bdb528e97771b71a44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array.html#gad254b7b5c9ddc7bdb528e97771b71a44">c_array</a> = <a class="el" href="structetl_1_1static__vector.html">ValueType</a>[<a class="el" href="structetl_1_1static__vector.html">Size</a>]</td></tr>
<tr class="separator:gad254b7b5c9ddc7bdb528e97771b71a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e36416cdc5e1021c9d5151775e7ec9" id="r_a27e36416cdc5e1021c9d5151775e7ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27e36416cdc5e1021c9d5151775e7ec9">float_t</a> = <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a27e36416cdc5e1021c9d5151775e7ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as float.  <br /></td></tr>
<tr class="separator:a27e36416cdc5e1021c9d5151775e7ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bf8f126e3cdf99b95d6b073210cfe7" id="r_a77bf8f126e3cdf99b95d6b073210cfe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77bf8f126e3cdf99b95d6b073210cfe7">double_t</a> = <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a77bf8f126e3cdf99b95d6b073210cfe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as double.  <br /></td></tr>
<tr class="separator:a77bf8f126e3cdf99b95d6b073210cfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4eb7e1110a660a8bdaba03466cea51" id="r_a9b4eb7e1110a660a8bdaba03466cea51"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9b4eb7e1110a660a8bdaba03466cea51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b4eb7e1110a660a8bdaba03466cea51">common_comparison_category_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a>&lt;Ts...&gt;::type</td></tr>
<tr class="separator:a9b4eb7e1110a660a8bdaba03466cea51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5c3bd3598ac28c038c72211877c543" id="r_ade5c3bd3598ac28c038c72211877c543"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U  = T&gt; </td></tr>
<tr class="memitem:ade5c3bd3598ac28c038c72211877c543"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade5c3bd3598ac28c038c72211877c543">compare_three_way_result_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;() &lt;=&gt; <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a>&lt;U&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;())</td></tr>
<tr class="separator:ade5c3bd3598ac28c038c72211877c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0838d3bb433682c6c13b31dbd1c27f4a" id="r_a0838d3bb433682c6c13b31dbd1c27f4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">nullptr</a>)</td></tr>
<tr class="memdesc:a0838d3bb433682c6c13b31dbd1c27f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type.  <br /></td></tr>
<tr class="separator:a0838d3bb433682c6c13b31dbd1c27f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1630ee9e07d0d32697249d7a63e131c1" id="r_a1630ee9e07d0d32697249d7a63e131c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a> = <a class="el" href="builtin__types_8hpp.html#a19bfe4995271e67306bab6dc974ed002">TETL_BUILTIN_PTRDIFF</a></td></tr>
<tr class="memdesc:a1630ee9e07d0d32697249d7a63e131c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1" title="etl::ptrdiff_t is the signed integer type of the result of subtracting two pointers.">etl::ptrdiff_t</a> is the signed integer type of the result of subtracting two pointers.  <br /></td></tr>
<tr class="separator:a1630ee9e07d0d32697249d7a63e131c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49823583370a499813db70f494111109" id="r_a49823583370a499813db70f494111109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49823583370a499813db70f494111109">size_t</a> = <a class="el" href="builtin__types_8hpp.html#ab236bea848bc390350ba3fc38ae07819">TETL_BUILTIN_SIZET</a></td></tr>
<tr class="memdesc:a49823583370a499813db70f494111109"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a49823583370a499813db70f494111109" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> is the unsigned integer type of the result of the sizeof operator.  <br /></td></tr>
<tr class="separator:a49823583370a499813db70f494111109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a034210e12ea1e1148227df5d391ce" id="r_ac4a034210e12ea1e1148227df5d391ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4a034210e12ea1e1148227df5d391ce">int_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:ac4a034210e12ea1e1148227df5d391ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:ac4a034210e12ea1e1148227df5d391ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac098905947cf95d8ea831ad1531152f5" id="r_ac098905947cf95d8ea831ad1531152f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac098905947cf95d8ea831ad1531152f5">int_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:ac098905947cf95d8ea831ad1531152f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:ac098905947cf95d8ea831ad1531152f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdf87490ddb044e4f5b85c0f11e4db4" id="r_a0fdf87490ddb044e4f5b85c0f11e4db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fdf87490ddb044e4f5b85c0f11e4db4">int_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:a0fdf87490ddb044e4f5b85c0f11e4db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:a0fdf87490ddb044e4f5b85c0f11e4db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf7a7cd9831dd78a5d9d752fbfa4975" id="r_abcf7a7cd9831dd78a5d9d752fbfa4975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcf7a7cd9831dd78a5d9d752fbfa4975">int_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:abcf7a7cd9831dd78a5d9d752fbfa4975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:abcf7a7cd9831dd78a5d9d752fbfa4975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611b1ddc1add76163ef8b3580a251826" id="r_a611b1ddc1add76163ef8b3580a251826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a611b1ddc1add76163ef8b3580a251826">int_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:a611b1ddc1add76163ef8b3580a251826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:a611b1ddc1add76163ef8b3580a251826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cfb600b8fc4fecd1034781659bc3e7" id="r_a00cfb600b8fc4fecd1034781659bc3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00cfb600b8fc4fecd1034781659bc3e7">int_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a00cfb600b8fc4fecd1034781659bc3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a00cfb600b8fc4fecd1034781659bc3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa549fa2d009dc12211e58320777f180d" id="r_aa549fa2d009dc12211e58320777f180d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa549fa2d009dc12211e58320777f180d">int_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:aa549fa2d009dc12211e58320777f180d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:aa549fa2d009dc12211e58320777f180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176e603bb1a7a34edafdf69d14cf6059" id="r_a176e603bb1a7a34edafdf69d14cf6059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a176e603bb1a7a34edafdf69d14cf6059">int_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:a176e603bb1a7a34edafdf69d14cf6059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:a176e603bb1a7a34edafdf69d14cf6059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09572027600fa251a322b4f80ffdccc" id="r_ac09572027600fa251a322b4f80ffdccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac09572027600fa251a322b4f80ffdccc">int8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:ac09572027600fa251a322b4f80ffdccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 8 bits.  <br /></td></tr>
<tr class="separator:ac09572027600fa251a322b4f80ffdccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de4cb652edc81c4cba48d1dc09e78b8" id="r_a8de4cb652edc81c4cba48d1dc09e78b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8de4cb652edc81c4cba48d1dc09e78b8">int16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a8de4cb652edc81c4cba48d1dc09e78b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 16 bits.  <br /></td></tr>
<tr class="separator:a8de4cb652edc81c4cba48d1dc09e78b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf8abffff5f3413df839b52454c989d" id="r_a3bf8abffff5f3413df839b52454c989d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bf8abffff5f3413df839b52454c989d">int32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:a3bf8abffff5f3413df839b52454c989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 32 bits.  <br /></td></tr>
<tr class="separator:a3bf8abffff5f3413df839b52454c989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d07242009a2523b463d707f4ee84822" id="r_a0d07242009a2523b463d707f4ee84822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d07242009a2523b463d707f4ee84822">int64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:a0d07242009a2523b463d707f4ee84822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 64 bits.  <br /></td></tr>
<tr class="separator:a0d07242009a2523b463d707f4ee84822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d3758a68be146a2ff828389077015e" id="r_a14d3758a68be146a2ff828389077015e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14d3758a68be146a2ff828389077015e">intmax_t</a> = <a class="el" href="builtin__types_8hpp.html#ad8678dda9c4b939fee5244864c53ada1">TETL_BUILTIN_INTMAX</a></td></tr>
<tr class="memdesc:a14d3758a68be146a2ff828389077015e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum-width signed integer type.  <br /></td></tr>
<tr class="separator:a14d3758a68be146a2ff828389077015e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416f114fb5e96e069668044817b75e91" id="r_a416f114fb5e96e069668044817b75e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a416f114fb5e96e069668044817b75e91">intptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a021098c463419df8b156d80c9153387e">TETL_BUILTIN_INTPTR</a></td></tr>
<tr class="memdesc:a416f114fb5e96e069668044817b75e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type capable of holding a pointer.  <br /></td></tr>
<tr class="separator:a416f114fb5e96e069668044817b75e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0cdc49e3e364509210f258e92ed7d" id="r_ad2d0cdc49e3e364509210f258e92ed7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2d0cdc49e3e364509210f258e92ed7d">uint_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:ad2d0cdc49e3e364509210f258e92ed7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:ad2d0cdc49e3e364509210f258e92ed7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d06db5bf54290f0c376c5561abbe6b3" id="r_a2d06db5bf54290f0c376c5561abbe6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d06db5bf54290f0c376c5561abbe6b3">uint_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a2d06db5bf54290f0c376c5561abbe6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a2d06db5bf54290f0c376c5561abbe6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97b929c1029e6984db90eda7c13f21" id="r_a8e97b929c1029e6984db90eda7c13f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e97b929c1029e6984db90eda7c13f21">uint_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:a8e97b929c1029e6984db90eda7c13f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:a8e97b929c1029e6984db90eda7c13f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33880814fae54b15cd6b0684319f98b2" id="r_a33880814fae54b15cd6b0684319f98b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33880814fae54b15cd6b0684319f98b2">uint_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a33880814fae54b15cd6b0684319f98b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:a33880814fae54b15cd6b0684319f98b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bcd0adbd229010c6badbb1d5780d65" id="r_af0bcd0adbd229010c6badbb1d5780d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0bcd0adbd229010c6badbb1d5780d65">uint_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:af0bcd0adbd229010c6badbb1d5780d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:af0bcd0adbd229010c6badbb1d5780d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ede9c2d7befd651fb785146cd41474" id="r_a79ede9c2d7befd651fb785146cd41474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79ede9c2d7befd651fb785146cd41474">uint_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a79ede9c2d7befd651fb785146cd41474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a79ede9c2d7befd651fb785146cd41474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad985f8a3fd8c90a9cfef41e7f9809" id="r_aacad985f8a3fd8c90a9cfef41e7f9809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacad985f8a3fd8c90a9cfef41e7f9809">uint_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:aacad985f8a3fd8c90a9cfef41e7f9809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:aacad985f8a3fd8c90a9cfef41e7f9809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f84136e9fa7e12c207d816febd16555" id="r_a2f84136e9fa7e12c207d816febd16555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f84136e9fa7e12c207d816febd16555">uint_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a2f84136e9fa7e12c207d816febd16555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:a2f84136e9fa7e12c207d816febd16555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cb8d6d7baf449891507753e9a62587" id="r_af5cb8d6d7baf449891507753e9a62587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5cb8d6d7baf449891507753e9a62587">uint8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:af5cb8d6d7baf449891507753e9a62587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 8 bits.  <br /></td></tr>
<tr class="separator:af5cb8d6d7baf449891507753e9a62587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732998f95607dc2fe0c03b19dee4e666" id="r_a732998f95607dc2fe0c03b19dee4e666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a732998f95607dc2fe0c03b19dee4e666">uint16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a732998f95607dc2fe0c03b19dee4e666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 16 bits.  <br /></td></tr>
<tr class="separator:a732998f95607dc2fe0c03b19dee4e666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c9e89a742d0f6cc76010445825b70e" id="r_a25c9e89a742d0f6cc76010445825b70e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25c9e89a742d0f6cc76010445825b70e">uint32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:a25c9e89a742d0f6cc76010445825b70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 32 bits.  <br /></td></tr>
<tr class="separator:a25c9e89a742d0f6cc76010445825b70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baaba7bb13a976f75b1cd7aa49dc56b" id="r_a1baaba7bb13a976f75b1cd7aa49dc56b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1baaba7bb13a976f75b1cd7aa49dc56b">uint64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a1baaba7bb13a976f75b1cd7aa49dc56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 64 bits.  <br /></td></tr>
<tr class="separator:a1baaba7bb13a976f75b1cd7aa49dc56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05541f3495353edefb00e00beb38efc" id="r_ae05541f3495353edefb00e00beb38efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae05541f3495353edefb00e00beb38efc">uintmax_t</a> = <a class="el" href="builtin__types_8hpp.html#a64175350ea04c19125422816cd6184e1">TETL_BUILTIN_UINTMAX</a></td></tr>
<tr class="memdesc:ae05541f3495353edefb00e00beb38efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum-width unsigned integer type.  <br /></td></tr>
<tr class="separator:ae05541f3495353edefb00e00beb38efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c906948794adfe5ec093499e436a37" id="r_af7c906948794adfe5ec093499e436a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7c906948794adfe5ec093499e436a37">uintptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a3b013e093af0767d757a3606463295d9">TETL_BUILTIN_UINTPTR</a></td></tr>
<tr class="memdesc:af7c906948794adfe5ec093499e436a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type capable of holding a pointer.  <br /></td></tr>
<tr class="separator:af7c906948794adfe5ec093499e436a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a144275abbc1202be775e01755ac4c" id="r_af3a144275abbc1202be775e01755ac4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3a144275abbc1202be775e01755ac4c">clock_t</a> = <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td></tr>
<tr class="separator:af3a144275abbc1202be775e01755ac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2504f109f893e3cd550112cfc616c42d" id="r_a2504f109f893e3cd550112cfc616c42d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2504f109f893e3cd550112cfc616c42d">time_t</a> = <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td></tr>
<tr class="memdesc:a2504f109f893e3cd550112cfc616c42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic type capable of representing times.  <br /></td></tr>
<tr class="separator:a2504f109f893e3cd550112cfc616c42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2057177bf6f151716e055fc52a2fb9e7" id="r_a2057177bf6f151716e055fc52a2fb9e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> = <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="separator:a2057177bf6f151716e055fc52a2fb9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca9dac165db8a73a0cd16ab2677fabc" id="r_a5ca9dac165db8a73a0cd16ab2677fabc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca9dac165db8a73a0cd16ab2677fabc">format_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#ad867dbf777d0e2fcf904b16ffbbd1ac1">format_context</a>&gt;</td></tr>
<tr class="separator:a5ca9dac165db8a73a0cd16ab2677fabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60d95f2193b80fc48eb339789555fbc" id="r_ae60d95f2193b80fc48eb339789555fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae60d95f2193b80fc48eb339789555fbc">wformat_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#af14a1ebd9061ef0ef02d67e436e4fcd4">wformat_context</a>&gt;</td></tr>
<tr class="separator:ae60d95f2193b80fc48eb339789555fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867dbf777d0e2fcf904b16ffbbd1ac1" id="r_ad867dbf777d0e2fcf904b16ffbbd1ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad867dbf777d0e2fcf904b16ffbbd1ac1">format_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;&gt;, <a class="el" href="structetl_1_1static__vector.html">char</a>&gt;</td></tr>
<tr class="memdesc:ad867dbf777d0e2fcf904b16ffbbd1ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to formatting state consisting of the formatting arguments and the output iterator.  <br /></td></tr>
<tr class="separator:ad867dbf777d0e2fcf904b16ffbbd1ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14a1ebd9061ef0ef02d67e436e4fcd4" id="r_af14a1ebd9061ef0ef02d67e436e4fcd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af14a1ebd9061ef0ef02d67e436e4fcd4">wformat_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;&gt;, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;</td></tr>
<tr class="separator:af14a1ebd9061ef0ef02d67e436e4fcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb586d74437e6af949ebb96b9dd5699" id="r_aefb586d74437e6af949ebb96b9dd5699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb586d74437e6af949ebb96b9dd5699">format_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;</td></tr>
<tr class="separator:aefb586d74437e6af949ebb96b9dd5699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a67767b36e7722169bb853b762ce270" id="r_a3a67767b36e7722169bb853b762ce270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a67767b36e7722169bb853b762ce270">wformat_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;</td></tr>
<tr class="separator:a3a67767b36e7722169bb853b762ce270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1165db7522758e370f2f0505425e997" id="r_ab1165db7522758e370f2f0505425e997"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab1165db7522758e370f2f0505425e997"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1165db7522758e370f2f0505425e997">format_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="#aca5bede918f0a9391b776b0721c80e40">type_identity_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&gt;...&gt;</td></tr>
<tr class="separator:ab1165db7522758e370f2f0505425e997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d54d8ee8d9e9db4ee7a2fae3dfa173" id="r_a88d54d8ee8d9e9db4ee7a2fae3dfa173"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a88d54d8ee8d9e9db4ee7a2fae3dfa173"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88d54d8ee8d9e9db4ee7a2fae3dfa173">wformat_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>, <a class="el" href="#aca5bede918f0a9391b776b0721c80e40">type_identity_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&gt;...&gt;</td></tr>
<tr class="separator:a88d54d8ee8d9e9db4ee7a2fae3dfa173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccda852d9fec850405ea795d8c58e8f" id="r_a1ccda852d9fec850405ea795d8c58e8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </td></tr>
<tr class="memitem:a1ccda852d9fec850405ea795d8c58e8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ccda852d9fec850405ea795d8c58e8f">diff_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;<a class="el" href="#a2fff237ed0afc787415c06ce1315553e">etl::remove_cvref_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>&gt;&gt;::difference_type</td></tr>
<tr class="separator:a1ccda852d9fec850405ea795d8c58e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4017a970d2adc04f09c1389910f70d" id="r_a8a4017a970d2adc04f09c1389910f70d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a8a4017a970d2adc04f09c1389910f70d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a4017a970d2adc04f09c1389910f70d">stringbuf</a> = <a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td></tr>
<tr class="separator:a8a4017a970d2adc04f09c1389910f70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45281465d730bea49ffecd03ac96072" id="r_aa45281465d730bea49ffecd03ac96072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa45281465d730bea49ffecd03ac96072">streamoff</a> = <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="separator:aa45281465d730bea49ffecd03ac96072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d460594ca594c171a5e0ed2934b46f2" id="r_a2d460594ca594c171a5e0ed2934b46f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d460594ca594c171a5e0ed2934b46f2">streamsize</a> = <a class="el" href="#ace93b7d8b1e564390c651a2e9a3a11f0">make_signed_t</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a>&gt;</td></tr>
<tr class="separator:a2d460594ca594c171a5e0ed2934b46f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac263fc338e385e101a2ce83db886dbb" id="r_aac263fc338e385e101a2ce83db886dbb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Iters&gt; </td></tr>
<tr class="memitem:aac263fc338e385e101a2ce83db886dbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac263fc338e385e101a2ce83db886dbb">indirect_result_t</a> = <a class="el" href="#ad47ced64dcc2c2322893df26022403c5">etl::invoke_result_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, <a class="el" href="#afcc6810798d0569072d3d767bf074836">etl::iter_reference_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iters</a>&gt;...&gt;</td></tr>
<tr class="separator:aac263fc338e385e101a2ce83db886dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec6862301fef8edad6700319db71e8f" id="r_a2ec6862301fef8edad6700319db71e8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> T&gt; </td></tr>
<tr class="memitem:a2ec6862301fef8edad6700319db71e8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ec6862301fef8edad6700319db71e8f">iter_common_reference_t</a> = <a class="el" href="#adee609f391eb3188705d52e09cb8fb04">etl::common_reference_t</a>&lt;<a class="el" href="#afcc6810798d0569072d3d767bf074836">etl::iter_reference_t</a>&lt;T&gt;, <a class="el" href="#ac8309531bbf46301417735269d8088b6">etl::iter_value_t</a>&lt;T&gt;&amp;&gt;</td></tr>
<tr class="separator:a2ec6862301fef8edad6700319db71e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedb33aa3223d3aa48257386b72f6db9" id="r_aeedb33aa3223d3aa48257386b72f6db9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aeedb33aa3223d3aa48257386b72f6db9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeedb33aa3223d3aa48257386b72f6db9">iter_difference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::iter_difference&lt;T&gt;::type</td></tr>
<tr class="separator:aeedb33aa3223d3aa48257386b72f6db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc6810798d0569072d3d767bf074836" id="r_afcc6810798d0569072d3d767bf074836"><td class="memTemplParams" colspan="2">template&lt;etl::detail::dereferenceable T&gt; </td></tr>
<tr class="memitem:afcc6810798d0569072d3d767bf074836"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afcc6810798d0569072d3d767bf074836">iter_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(*<a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;T&amp;&gt;())</td></tr>
<tr class="separator:afcc6810798d0569072d3d767bf074836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5662463c2068e9f434f18f4d18380bb" id="r_aa5662463c2068e9f434f18f4d18380bb"><td class="memTemplParams" colspan="2">template&lt;etl::detail::dereferenceable T&gt; </td></tr>
<tr class="memitem:aa5662463c2068e9f434f18f4d18380bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5662463c2068e9f434f18f4d18380bb">iter_rvalue_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="namespaceetl_1_1ranges_1_1cpo.html#adbb4630e362144a441c559ced59ebf86">etl::ranges::iter_move</a>(<a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;T&amp;&gt;()))</td></tr>
<tr class="separator:aa5662463c2068e9f434f18f4d18380bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8309531bbf46301417735269d8088b6" id="r_ac8309531bbf46301417735269d8088b6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac8309531bbf46301417735269d8088b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8309531bbf46301417735269d8088b6">iter_value_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::iter_value&lt;T&gt;::type</td></tr>
<tr class="separator:ac8309531bbf46301417735269d8088b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e1a2b1f3db0980f0ab01630917f72d" id="r_a54e1a2b1f3db0980f0ab01630917f72d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> Iter, <a class="el" href="conceptetl_1_1indirectly__regular__unary__invocable.html">etl::indirectly_regular_unary_invocable</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; Proj&gt; </td></tr>
<tr class="memitem:a54e1a2b1f3db0980f0ab01630917f72d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54e1a2b1f3db0980f0ab01630917f72d">projected</a> = etl::detail::projected_impl&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>, <a class="el" href="structetl_1_1static__vector.html">Proj</a>&gt;::type</td></tr>
<tr class="separator:a54e1a2b1f3db0980f0ab01630917f72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27430ad24df2ec00864b7184d731465" id="r_ad27430ad24df2ec00864b7184d731465"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexType</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Rank&gt; </td></tr>
<tr class="memitem:ad27430ad24df2ec00864b7184d731465"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad27430ad24df2ec00864b7184d731465">dextents</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::dextents_impl&lt;<a class="el" href="structetl_1_1static__vector.html">IndexType</a>, <a class="el" href="#a3aebb59d8745facee9c0002882401c78">etl::make_index_sequence</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Rank</a>&gt;&gt;::type</td></tr>
<tr class="separator:ad27430ad24df2ec00864b7184d731465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9a616880e946c9354707df919cb7bb" id="r_aec9a616880e946c9354707df919cb7bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec9a616880e946c9354707df919cb7bb">new_handler</a> = <a class="el" href="structetl_1_1static__vector.html">void</a> (*)()</td></tr>
<tr class="memdesc:aec9a616880e946c9354707df919cb7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aec9a616880e946c9354707df919cb7bb" title="etl::new_handler is the function pointer type (pointer to function that takes no arguments and return...">etl::new_handler</a> is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions etl::set_new_handler and etl::get_new_handler  <br /></td></tr>
<tr class="separator:aec9a616880e946c9354707df919cb7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2192adc56583289052578ee61ab954c3" id="r_ga2192adc56583289052578ee61ab954c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga2192adc56583289052578ee61ab954c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga2192adc56583289052578ee61ab954c3">ratio_add</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga2192adc56583289052578ee61ab954c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_add denotes the result of adding two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga2192adc56583289052578ee61ab954c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ecb5d7fcdacaf194081c69c3bc9d67c" id="r_ga6ecb5d7fcdacaf194081c69c3bc9d67c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga6ecb5d7fcdacaf194081c69c3bc9d67c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga6ecb5d7fcdacaf194081c69c3bc9d67c">ratio_divide</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den, R1::den * R2::num&gt;</td></tr>
<tr class="memdesc:ga6ecb5d7fcdacaf194081c69c3bc9d67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_divide denotes the result of dividing two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga6ecb5d7fcdacaf194081c69c3bc9d67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcd1623a944fbf37d671004e8a34aa2" id="r_ga6fcd1623a944fbf37d671004e8a34aa2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga6fcd1623a944fbf37d671004e8a34aa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga6fcd1623a944fbf37d671004e8a34aa2">ratio_multiply</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::num, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga6fcd1623a944fbf37d671004e8a34aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_multiply denotes the result of multiplying two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga6fcd1623a944fbf37d671004e8a34aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c622ed1e8b9ddc3e698331ab097170c" id="r_ga1c622ed1e8b9ddc3e698331ab097170c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga1c622ed1e8b9ddc3e698331ab097170c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga1c622ed1e8b9ddc3e698331ab097170c">ratio_subtract</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga1c622ed1e8b9ddc3e698331ab097170c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_subtract denotes the result of subtracting two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga1c622ed1e8b9ddc3e698331ab097170c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6783d01d27625ab2919f8254ad76f9" id="r_a9b6783d01d27625ab2919f8254ad76f9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a9b6783d01d27625ab2919f8254ad76f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">static_string</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td></tr>
<tr class="memdesc:a9b6783d01d27625ab2919f8254ad76f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'char'.  <br /></td></tr>
<tr class="separator:a9b6783d01d27625ab2919f8254ad76f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095186d92f1db9993904799b96af15bb" id="r_a095186d92f1db9993904799b96af15bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a095186d92f1db9993904799b96af15bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a095186d92f1db9993904799b96af15bb">static_wstring</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td></tr>
<tr class="memdesc:a095186d92f1db9993904799b96af15bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'wchar_t'.  <br /></td></tr>
<tr class="separator:a095186d92f1db9993904799b96af15bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbf680e76b153b8a596435b6059846b" id="r_aafbf680e76b153b8a596435b6059846b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">string_view</a> = <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;&gt;</td></tr>
<tr class="memdesc:aafbf680e76b153b8a596435b6059846b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedefs for common character type.  <br /></td></tr>
<tr class="separator:aafbf680e76b153b8a596435b6059846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95a227784ffb2786ffbff1dda6a9935" id="r_ac95a227784ffb2786ffbff1dda6a9935"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac95a227784ffb2786ffbff1dda6a9935"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, T&gt;::type</td></tr>
<tr class="separator:ac95a227784ffb2786ffbff1dda6a9935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bfcfe3186e868223ff85722f343dc0" id="r_aa6bfcfe3186e868223ff85722f343dc0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Len, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Align = alignof(detail::aligned_storage_impl&lt;Len&gt;)&gt; </td></tr>
<tr class="memitem:aa6bfcfe3186e868223ff85722f343dc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6bfcfe3186e868223ff85722f343dc0">aligned_storage_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1aligned__storage.html">etl::aligned_storage</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Len</a>, <a class="el" href="structetl_1_1static__vector.html">Align</a>&gt;::type</td></tr>
<tr class="separator:aa6bfcfe3186e868223ff85722f343dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90b42ca2c97e25ae857469d922a7b17" id="r_ae90b42ca2c97e25ae857469d922a7b17"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Len, typename... Types&gt; </td></tr>
<tr class="memitem:ae90b42ca2c97e25ae857469d922a7b17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae90b42ca2c97e25ae857469d922a7b17">aligned_union_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1aligned__union.html">etl::aligned_union</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Len</a>, Types...&gt;::type</td></tr>
<tr class="separator:ae90b42ca2c97e25ae857469d922a7b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91dc3f8feab79708723b75f54e9cc21" id="r_ae91dc3f8feab79708723b75f54e9cc21"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B&gt; </td></tr>
<tr class="memitem:ae91dc3f8feab79708723b75f54e9cc21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae91dc3f8feab79708723b75f54e9cc21">bool_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">B</a>&gt;</td></tr>
<tr class="separator:ae91dc3f8feab79708723b75f54e9cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251ff8ada16d1b2942679b1cac95a5ed" id="r_a251ff8ada16d1b2942679b1cac95a5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a251ff8ada16d1b2942679b1cac95a5ed">true_type</a> = <a class="el" href="#ae91dc3f8feab79708723b75f54e9cc21">bool_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">true</a>&gt;</td></tr>
<tr class="separator:a251ff8ada16d1b2942679b1cac95a5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4427bfeb098157f5bd5c0dc9d4dca6de" id="r_a4427bfeb098157f5bd5c0dc9d4dca6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4427bfeb098157f5bd5c0dc9d4dca6de">false_type</a> = <a class="el" href="#ae91dc3f8feab79708723b75f54e9cc21">bool_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">false</a>&gt;</td></tr>
<tr class="separator:a4427bfeb098157f5bd5c0dc9d4dca6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee609f391eb3188705d52e09cb8fb04" id="r_adee609f391eb3188705d52e09cb8fb04"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:adee609f391eb3188705d52e09cb8fb04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adee609f391eb3188705d52e09cb8fb04">common_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__reference.html">common_reference</a>&lt;T...&gt;::type</td></tr>
<tr class="separator:adee609f391eb3188705d52e09cb8fb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1049bbee37ab0c1445bcd7f020d6ce0c" id="r_a1049bbee37ab0c1445bcd7f020d6ce0c"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a1049bbee37ab0c1445bcd7f020d6ce0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1049bbee37ab0c1445bcd7f020d6ce0c">common_type_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__type.html">etl::common_type</a>&lt;T...&gt;::type</td></tr>
<tr class="separator:a1049bbee37ab0c1445bcd7f020d6ce0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39305667768a11caaca93abf03c21ce" id="r_ab39305667768a11caaca93abf03c21ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; </td></tr>
<tr class="memitem:ab39305667768a11caaca93abf03c21ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab39305667768a11caaca93abf03c21ce">conditional_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1conditional.html">etl::conditional</a>&lt;<a class="el" href="structetl_1_1static__vector.html">B</a>, T, <a class="el" href="structetl_1_1static__vector.html">F</a>&gt;::type</td></tr>
<tr class="separator:ab39305667768a11caaca93abf03c21ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac731e2d13871fb7848c6f0ccde332949" id="r_ac731e2d13871fb7848c6f0ccde332949"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac731e2d13871fb7848c6f0ccde332949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ac731e2d13871fb7848c6f0ccde332949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7938694f396828f208ccae1688c9c611" id="r_a7938694f396828f208ccae1688c9c611"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B, <a class="el" href="structetl_1_1static__vector.html">typename</a> T  = void&gt; </td></tr>
<tr class="memitem:a7938694f396828f208ccae1688c9c611"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structetl_1_1static__vector.html">B</a>, T&gt;::type</td></tr>
<tr class="separator:a7938694f396828f208ccae1688c9c611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8298a20279ec5d2a5df508272115cc3" id="r_aa8298a20279ec5d2a5df508272115cc3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I&gt; </td></tr>
<tr class="memitem:aa8298a20279ec5d2a5df508272115cc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8298a20279ec5d2a5df508272115cc3">index_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">etl::integral_constant</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>, <a class="el" href="structetl_1_1static__vector.html">I</a>&gt;</td></tr>
<tr class="separator:aa8298a20279ec5d2a5df508272115cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47ced64dcc2c2322893df26022403c5" id="r_ad47ced64dcc2c2322893df26022403c5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:ad47ced64dcc2c2322893df26022403c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad47ced64dcc2c2322893df26022403c5">invoke_result_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1invoke__result.html">etl::invoke_result</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, ArgTypes...&gt;::type</td></tr>
<tr class="separator:ad47ced64dcc2c2322893df26022403c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43743001594f300bde6a116196b1a2b8" id="r_a43743001594f300bde6a116196b1a2b8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a43743001594f300bde6a116196b1a2b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43743001594f300bde6a116196b1a2b8">is_constructible</a> = detail::is_constructible_helper&lt;<a class="el" href="#ab24730cbedd18b7acd975fd5dddadb3e">etl::void_t</a>&lt;&gt;, T, Args...&gt;</td></tr>
<tr class="separator:a43743001594f300bde6a116196b1a2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace93b7d8b1e564390c651a2e9a3a11f0" id="r_ace93b7d8b1e564390c651a2e9a3a11f0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ace93b7d8b1e564390c651a2e9a3a11f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace93b7d8b1e564390c651a2e9a3a11f0">make_signed_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ace93b7d8b1e564390c651a2e9a3a11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3362d26921844abefbea548c78556d1" id="r_af3362d26921844abefbea548c78556d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af3362d26921844abefbea548c78556d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3362d26921844abefbea548c78556d1">make_unsigned_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td></tr>
<tr class="separator:af3362d26921844abefbea548c78556d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a0440e799b90521d5959686b4282fb" id="r_a90a0440e799b90521d5959686b4282fb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a90a0440e799b90521d5959686b4282fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90a0440e799b90521d5959686b4282fb">remove_all_extents_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a90a0440e799b90521d5959686b4282fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a45d5e6c658b2e351cfff1be97d293" id="r_a60a45d5e6c658b2e351cfff1be97d293"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a60a45d5e6c658b2e351cfff1be97d293"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60a45d5e6c658b2e351cfff1be97d293">remove_const_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__const.html">etl::remove_const</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a60a45d5e6c658b2e351cfff1be97d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3ea939d0e932fceedbae01d7a3af90" id="r_a7d3ea939d0e932fceedbae01d7a3af90"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7d3ea939d0e932fceedbae01d7a3af90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d3ea939d0e932fceedbae01d7a3af90">remove_cv_t</a> = <a class="el" href="#a60a45d5e6c658b2e351cfff1be97d293">etl::remove_const_t</a>&lt;<a class="el" href="#a3946b4f225aed94dc2bd43033712b219">etl::remove_volatile_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a7d3ea939d0e932fceedbae01d7a3af90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fff237ed0afc787415c06ce1315553e" id="r_a2fff237ed0afc787415c06ce1315553e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a2fff237ed0afc787415c06ce1315553e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2fff237ed0afc787415c06ce1315553e">remove_cvref_t</a> = <a class="el" href="#a7d3ea939d0e932fceedbae01d7a3af90">etl::remove_cv_t</a>&lt;<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a2fff237ed0afc787415c06ce1315553e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fa88f2463bb67e914b54eb17bc6e64" id="r_a96fa88f2463bb67e914b54eb17bc6e64"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a96fa88f2463bb67e914b54eb17bc6e64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a96fa88f2463bb67e914b54eb17bc6e64">remove_extent_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__extent.html">etl::remove_extent</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a96fa88f2463bb67e914b54eb17bc6e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8897fe2703cfaabd33c46ba2ae13b5e2" id="r_a8897fe2703cfaabd33c46ba2ae13b5e2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8897fe2703cfaabd33c46ba2ae13b5e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8897fe2703cfaabd33c46ba2ae13b5e2">remove_pointer_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__pointer.html">etl::remove_pointer</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a8897fe2703cfaabd33c46ba2ae13b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53ab28b069b34ebab412b775f8999ab" id="r_aa53ab28b069b34ebab412b775f8999ab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa53ab28b069b34ebab412b775f8999ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt;T&gt;::type</td></tr>
<tr class="separator:aa53ab28b069b34ebab412b775f8999ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3946b4f225aed94dc2bd43033712b219" id="r_a3946b4f225aed94dc2bd43033712b219"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3946b4f225aed94dc2bd43033712b219"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3946b4f225aed94dc2bd43033712b219">remove_volatile_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__volatile.html">etl::remove_volatile</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a3946b4f225aed94dc2bd43033712b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5169fe6c7349d18aac6efef76f30f" id="r_a6de5169fe6c7349d18aac6efef76f30f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> N&gt; </td></tr>
<tr class="memitem:a6de5169fe6c7349d18aac6efef76f30f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6de5169fe6c7349d18aac6efef76f30f">smallest_size_t</a></td></tr>
<tr class="memdesc:a6de5169fe6c7349d18aac6efef76f30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest fixed-width unsigned integer type that can represent values in the range [0, N].  <br /></td></tr>
<tr class="separator:a6de5169fe6c7349d18aac6efef76f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5bede918f0a9391b776b0721c80e40" id="r_aca5bede918f0a9391b776b0721c80e40"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aca5bede918f0a9391b776b0721c80e40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca5bede918f0a9391b776b0721c80e40">type_identity_t</a> = T</td></tr>
<tr class="separator:aca5bede918f0a9391b776b0721c80e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73e7dfe08364dfb94ca2fafa560a559" id="r_ac73e7dfe08364dfb94ca2fafa560a559"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac73e7dfe08364dfb94ca2fafa560a559"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac73e7dfe08364dfb94ca2fafa560a559">underlying_type_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1underlying__type.html">etl::underlying_type</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ac73e7dfe08364dfb94ca2fafa560a559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3d889e3a1a2b38c9faf0939d900514" id="r_a1e3d889e3a1a2b38c9faf0939d900514"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1e3d889e3a1a2b38c9faf0939d900514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e3d889e3a1a2b38c9faf0939d900514">unwrap_ref_decay_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1unwrap__ref__decay.html">etl::unwrap_ref_decay</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a1e3d889e3a1a2b38c9faf0939d900514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24730cbedd18b7acd975fd5dddadb3e" id="r_ab24730cbedd18b7acd975fd5dddadb3e"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ab24730cbedd18b7acd975fd5dddadb3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab24730cbedd18b7acd975fd5dddadb3e">void_t</a> = <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:ab24730cbedd18b7acd975fd5dddadb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf82c69e1c6f2ddf23f227a9931b8ca" id="r_afaf82c69e1c6f2ddf23f227a9931b8ca"><td class="memTemplParams" colspan="2">template&lt;etl::size_t... Ints&gt; </td></tr>
<tr class="memitem:afaf82c69e1c6f2ddf23f227a9931b8ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afaf82c69e1c6f2ddf23f227a9931b8ca">index_sequence</a> = <a class="el" href="structetl_1_1integer__sequence.html">etl::integer_sequence</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>, Ints...&gt;</td></tr>
<tr class="separator:afaf82c69e1c6f2ddf23f227a9931b8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aebb59d8745facee9c0002882401c78" id="r_a3aebb59d8745facee9c0002882401c78"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:a3aebb59d8745facee9c0002882401c78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3aebb59d8745facee9c0002882401c78">make_index_sequence</a> = <a class="el" href="#ae3e45bc6e2d57d570b8b026a50c075fb">etl::make_integer_sequence</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a>&gt;</td></tr>
<tr class="separator:a3aebb59d8745facee9c0002882401c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71fc9c72974e4f7f357106bdac43d7a" id="r_af71fc9c72974e4f7f357106bdac43d7a"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:af71fc9c72974e4f7f357106bdac43d7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af71fc9c72974e4f7f357106bdac43d7a">index_sequence_for</a> = <a class="el" href="#a3aebb59d8745facee9c0002882401c78">etl::make_index_sequence</a>&lt;sizeof...(T)&gt;</td></tr>
<tr class="separator:af71fc9c72974e4f7f357106bdac43d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e45bc6e2d57d570b8b026a50c075fb" id="r_ae3e45bc6e2d57d570b8b026a50c075fb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , T Size&gt; </td></tr>
<tr class="memitem:ae3e45bc6e2d57d570b8b026a50c075fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3e45bc6e2d57d570b8b026a50c075fb">make_integer_sequence</a> = <a class="el" href="builtin__functions_8hpp.html#a303c6144751de3e45c44990112e8b1cb">TETL_BUILTIN_INT_SEQ</a>(T, <a class="el" href="structetl_1_1static__vector.html">Size</a>)</td></tr>
<tr class="separator:ae3e45bc6e2d57d570b8b026a50c075fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad029dc8759242c03cbb2d3507ccb0f4e" id="r_ad029dc8759242c03cbb2d3507ccb0f4e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad029dc8759242c03cbb2d3507ccb0f4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, T&gt;::type</td></tr>
<tr class="separator:ad029dc8759242c03cbb2d3507ccb0f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a968a1e0d1e8d9494d021d34bc2e6c82a" id="r_a968a1e0d1e8d9494d021d34bc2e6c82a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a968a1e0d1e8d9494d021d34bc2e6c82a">atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000'000&gt;</td></tr>
<tr class="separator:a968a1e0d1e8d9494d021d34bc2e6c82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b1921a95623fff3a9b8e397eb4a3f7" id="r_a13b1921a95623fff3a9b8e397eb4a3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13b1921a95623fff3a9b8e397eb4a3f7">femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000&gt;</td></tr>
<tr class="separator:a13b1921a95623fff3a9b8e397eb4a3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac489b67384efcc27fe4baeac5893713a" id="r_ac489b67384efcc27fe4baeac5893713a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac489b67384efcc27fe4baeac5893713a">pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000&gt;</td></tr>
<tr class="separator:ac489b67384efcc27fe4baeac5893713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebbaf9de296934c9320b7b32932be3f" id="r_a3ebbaf9de296934c9320b7b32932be3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ebbaf9de296934c9320b7b32932be3f">nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000&gt;</td></tr>
<tr class="separator:a3ebbaf9de296934c9320b7b32932be3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790708917957bff608703092eecec315" id="r_a790708917957bff608703092eecec315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a790708917957bff608703092eecec315">micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000&gt;</td></tr>
<tr class="separator:a790708917957bff608703092eecec315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9927a0f0f2ea2485adb9fe6fc78420" id="r_acd9927a0f0f2ea2485adb9fe6fc78420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd9927a0f0f2ea2485adb9fe6fc78420">milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000&gt;</td></tr>
<tr class="separator:acd9927a0f0f2ea2485adb9fe6fc78420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c3c77e0d8a4219fff42cebc05f122a" id="r_af4c3c77e0d8a4219fff42cebc05f122a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c3c77e0d8a4219fff42cebc05f122a">centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td></tr>
<tr class="separator:af4c3c77e0d8a4219fff42cebc05f122a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3f53d1282340b8092c7e91328b12e8" id="r_a7e3f53d1282340b8092c7e91328b12e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e3f53d1282340b8092c7e91328b12e8">deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td></tr>
<tr class="separator:a7e3f53d1282340b8092c7e91328b12e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abe01140e9514d91cd6057a514321e9" id="r_a4abe01140e9514d91cd6057a514321e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4abe01140e9514d91cd6057a514321e9">deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td></tr>
<tr class="separator:a4abe01140e9514d91cd6057a514321e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fc89aef3b186473e36d98d651fcecc" id="r_ab3fc89aef3b186473e36d98d651fcecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3fc89aef3b186473e36d98d651fcecc">hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td></tr>
<tr class="separator:ab3fc89aef3b186473e36d98d651fcecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56133acde37eca9a5fbe395afee81b71" id="r_a56133acde37eca9a5fbe395afee81b71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56133acde37eca9a5fbe395afee81b71">kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000, 1&gt;</td></tr>
<tr class="separator:a56133acde37eca9a5fbe395afee81b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46b3082c199eb1091a486b255a8fa6a" id="r_ae46b3082c199eb1091a486b255a8fa6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae46b3082c199eb1091a486b255a8fa6a">mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000, 1&gt;</td></tr>
<tr class="separator:ae46b3082c199eb1091a486b255a8fa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae410f2def2ff11d6d3690f6359ecfc51" id="r_ae410f2def2ff11d6d3690f6359ecfc51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae410f2def2ff11d6d3690f6359ecfc51">giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000, 1&gt;</td></tr>
<tr class="separator:ae410f2def2ff11d6d3690f6359ecfc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9a9ad3120ecbe6d32aea31529f2742" id="r_a3a9a9ad3120ecbe6d32aea31529f2742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a9a9ad3120ecbe6d32aea31529f2742">tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:a3a9a9ad3120ecbe6d32aea31529f2742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b2db64fe4fbe00098b99f59227d908" id="r_a79b2db64fe4fbe00098b99f59227d908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79b2db64fe4fbe00098b99f59227d908">peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:a79b2db64fe4fbe00098b99f59227d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0e54567f57499ec5482bfdef64572c" id="r_aee0e54567f57499ec5482bfdef64572c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee0e54567f57499ec5482bfdef64572c">exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:aee0e54567f57499ec5482bfdef64572c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaadba129a7dc760f449b09b7fafeb63a8" id="r_gaadba129a7dc760f449b09b7fafeb63a8"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bit.html#gaadba129a7dc760f449b09b7fafeb63a8">endian</a> { <a class="el" href="group__bit.html#ggaadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114">endian::little</a> = implementation defined
, <a class="el" href="group__bit.html#ggaadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4">endian::big</a> = implementation defined
, <a class="el" href="group__bit.html#ggaadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">endian::native</a> = implementation defined
 }</td></tr>
<tr class="memdesc:gaadba129a7dc760f449b09b7fafeb63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the endianness of all scalar types. If all scalar types are little-endian, <code>endian::native</code> equals <code>endian::little</code>. If all scalar types are big-endian, <code>endian::native</code> equals <code>endian::big</code>.  <a href="group__bit.html#gaadba129a7dc760f449b09b7fafeb63a8">More...</a><br /></td></tr>
<tr class="separator:gaadba129a7dc760f449b09b7fafeb63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af524d0acb625979997f7a2dd1c0ea944" id="r_af524d0acb625979997f7a2dd1c0ea944"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af524d0acb625979997f7a2dd1c0ea944">chars_format</a> : etl::uint8_t { <a class="el" href="#af524d0acb625979997f7a2dd1c0ea944a55a95650a66b53ecbb960b53d985b964">scientific</a> = 0x1
, <a class="el" href="#af524d0acb625979997f7a2dd1c0ea944acec315e3d0975e5cc2811d5d8725f149">fixed</a> = 0x2
, <a class="el" href="#af524d0acb625979997f7a2dd1c0ea944ab8d1b43eae73587ba56baef574709ecb">hex</a> = 0x4
, <a class="el" href="#af524d0acb625979997f7a2dd1c0ea944a958153f1b8b96ec4c4eb2147429105d9">general</a> = fixed | scientific
 }</td></tr>
<tr class="memdesc:af524d0acb625979997f7a2dd1c0ea944"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BitmaskType used to specify floating-point formatting for to_chars and from_chars.  <a href="#af524d0acb625979997f7a2dd1c0ea944">More...</a><br /></td></tr>
<tr class="separator:af524d0acb625979997f7a2dd1c0ea944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4892bd9af0bd3ad759fb95ab241247c" id="r_ad4892bd9af0bd3ad759fb95ab241247c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4892bd9af0bd3ad759fb95ab241247c">float_denorm_style</a> { <a class="el" href="#ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287">denorm_indeterminate</a> = -1
, <a class="el" href="#ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141">denorm_absent</a> = 0
, <a class="el" href="#ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5">denorm_present</a> = 1
 }</td></tr>
<tr class="separator:ad4892bd9af0bd3ad759fb95ab241247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdec522db16c755ade7c7222bf8af92" id="r_a0cdec522db16c755ade7c7222bf8af92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cdec522db16c755ade7c7222bf8af92">float_round_style</a> { <br />
&#160;&#160;<a class="el" href="#a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b">round_indeterminate</a> = -1
, <a class="el" href="#a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d">round_toward_zero</a> = 0
, <a class="el" href="#a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3">round_to_nearest</a> = 1
, <a class="el" href="#a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0">round_toward_infinity</a> = 2
, <br />
&#160;&#160;<a class="el" href="#a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f">round_toward_neg_infinity</a> = 3
<br />
 }</td></tr>
<tr class="separator:a0cdec522db16c755ade7c7222bf8af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91722a64a739818dbac515ddd4ea5387" id="r_a91722a64a739818dbac515ddd4ea5387"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91722a64a739818dbac515ddd4ea5387">align_val_t</a> : etl::size_t </td></tr>
<tr class="memdesc:a91722a64a739818dbac515ddd4ea5387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than the default, pass that alignment requirement as an argument of type align_val_t to the selected allocation/deallocation function.  <a href="#a91722a64a739818dbac515ddd4ea5387">More...</a><br /></td></tr>
<tr class="separator:a91722a64a739818dbac515ddd4ea5387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf855e66ccd0c031e0994ed578f1c170" id="r_abf855e66ccd0c031e0994ed578f1c170"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf855e66ccd0c031e0994ed578f1c170">errc</a> { <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a8ab69162f060cc46b805b3265ad1cdf1">address_family_not_supported</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a8e2bc80599069d337b43dff6edfb6891">address_in_use</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a20abf2ffbf6e82e36405843f269d6438">address_not_available</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ab5580b198f691ab2df12f5e2ab974373">already_connected</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a1b245b26b5ea3428c050d7f1503d7715">argument_list_too_long</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a4b82222a0895b538d0597092b3ceab3e">argument_out_of_domain</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aaf169f73a82794128aa491c4b4f1c071">bad_address</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a9941c5c8c58ff058b870e94e96ac38e1">bad_file_descriptor</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ac7944ab5d2e25bf75b267d070b506d1c">bad_message</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a2f0338eed54503152be1d31c93c9c2f1">broken_pipe</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a2f8f27a7eef1ad585c7ab6f25a6c2c79">connection_aborted</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a81cf222a9b1530171fdfd66c3f734989">connection_already_in_progress</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a53793ee58fc24168a0d6549c3cb2df8e">connection_refused</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170abf39bfc8665384194e343c08ab344405">connection_reset</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a6177070a517d51a4382ab0d7c88e5b58">cross_device_link</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a326032e01f2a5e14c7f730f4d03d753a">destination_address_required</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ab3ab5338a00f49c4451851cc5442f370">device_or_resource_busy</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a6a336135d33e62f49edc55f29354e12e">directory_not_empty</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a4dfaf9c996cf045f32d17edc9754fc95">executable_format_error</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a41edf636e3c7b59f797348fc58472258">file_exists</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aa1e14bfb89b41ddf654b1772c8fd2e74">file_too_large</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a6e56e6ed055b9771b8192a4f229fee27">filename_too_long</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aa33c516bbdfb179cef733c8daeb97bed">function_not_supported</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170afe2377fbd16d7f335474e1df7d6376bf">host_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a054e5b4ff59331386872de744d661719">identifier_removed</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a53a9e57a679708b2d8ff0ccd8ec96b18">illegal_byte_sequence</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a45fe7da1767194b580aeba752d7b44ae">inappropriate_io_control_operation</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170afadb76763385627e57ec386c9b6038f0">interrupted</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ae55d43eabeefe5a8271b4a3c898bd18f">invalid_argument</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170abd86a2c65caf6a270b916234ab321ce3">invalid_seek</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170acccc32f2a5f7dc7b87d2f85daea66789">io_error</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170af3c51d7ea75a76f26c0a2bdc00c4e006">is_a_directory</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ade5f4bc2f8a4690176e22e83196b9fd3">message_size</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a93b16d34b1689f66f0cfed60e99c0009">network_down</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a0e1d200ae35ede416bf85f84093ce37a">network_reset</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a608a68344b4eb1fe0690861a83828816">network_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a618ead44397b73cf0baa08b460b66c39">no_buffer_space</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ad08d4c854a6810cebd2a8ab61876f919">no_child_process</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170add431dfaf61ea842693dca8be1ebcaf7">no_link</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a58688487c3e24313637a76bd29881e64">no_lock_available</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aeec0f03ad92584c78835c10ab79d7f42">no_message_available</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170acec935db07cfc57caafa37e98eafb213">no_message</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170abed8a9032d9366c28582a0ad59a31525">no_protocol_option</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a1a5334dd8d1ca56e33887bd44630641b">no_space_on_device</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ad8b1d94a0ac09c6d55b2ed68f0836142">no_stream_resources</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a5c83a012eac17bbf458df5804801e373">no_such_device_or_address</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170af42b2e58729e2783b683c8610977fc22">no_such_device</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a2e70fc89b08f26fa3fc77694c91e8f7a">no_such_file_or_directory</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ad91a9b8a734f2bef4b778f89806cbab7">no_such_process</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a21e867ca95e1dfecff4701863547dcec">not_a_directory</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a22ac64bb14c46bcbc338a21950b6e722">not_a_socket</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a6e752b7a04543e5052b2d0dd05eca0fa">not_a_stream</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a69c2dbb5917ca550a862e9c1c839bca1">not_connected</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aafdb5594dc3e484fc1bfd7c564d550c1">not_enough_memory</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aa55e82356e9721946aa9ba954733c6f0">not_supported</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170afd3d0bdcc9eb9e68534b7d055c5fe586">operation_canceled</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a4c7eb50b6d86ac8a130ebebc18dbe263">operation_in_progress</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a8344b3d509942f035d5e303022f9b986">operation_not_permitted</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a69bf074bf052ee4c9047b62fe7c24569">operation_not_supported</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a738abdaead9cd7b2e2ea19a34764b385">operation_would_block</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a2abac2fa6722c56b2ea17ac6c4097f68">owner_dead</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ae8ee838822072f02738dbd7d97ea03fc">permission_denied</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a9665c745d0a9132d8da6ed55e89a0564">protocol_error</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aa2635acef8b9a3e1c40923829722d472">protocol_not_supported</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a06108efce8ef1cd8aa4cc440f8b4317f">read_only_file_system</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aed65f7649c6f0e365673d65a9d8119d8">resource_deadlock_would_occur</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ae46a97ea2906921c8c626890bde832cf">resource_unavailable_try_again</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a8e0fafb181567cc468e1ee81983d739d">result_out_of_range</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a6805059549401365b824b54573a6f46e">state_not_recoverable</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ac1a620a30954dc9402a811453c2c3e3f">stream_timeout</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170ad2f80f12d22bb099fcf1062db660b567">text_file_busy</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a56c27b1ab1a5a5a0eae853cabb4dc0c1">timed_out</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a3130d1d4e000cdc1e7c47013e313c10e">too_many_files_open_in_system</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170aed2c33c8fe874cfeba6f4a7747c62d05">too_many_files_open</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170abfe22fc9b27a8ff13186aba60b6bc5c8">too_many_links</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a33c78baca1480479c88aa4d50cb68206">too_many_symbolic_link_levels</a>
, <br />
&#160;&#160;<a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a143653b075bff946193644ba6d97fa5d">value_too_large</a>
, <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170a81cac28a38438710de9856af4a8bcd0b">wrong_protocol_type</a>
<br />
 }</td></tr>
<tr class="memdesc:abf855e66ccd0c031e0994ed578f1c170"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scoped enumeration <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes.  <a href="#abf855e66ccd0c031e0994ed578f1c170">More...</a><br /></td></tr>
<tr class="separator:abf855e66ccd0c031e0994ed578f1c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035e7d2ea0f6aebad724e7fab40495d5" id="r_a035e7d2ea0f6aebad724e7fab40495d5"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a035e7d2ea0f6aebad724e7fab40495d5">implementation</a> { <a class="el" href="#a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1">freestanding</a> = 0
, <a class="el" href="#a035e7d2ea0f6aebad724e7fab40495d5a734d3030ff72ad8d9678efa82b1db7d2">hosted</a> = 1
 }</td></tr>
<tr class="separator:a035e7d2ea0f6aebad724e7fab40495d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f63a594bf7e2b29cb07e1868483ee53" id="r_a2f63a594bf7e2b29cb07e1868483ee53"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> : unsigned char { <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53a6289bbfa378818f7066ccad5847da5a2">cpp_17</a> = 17
, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53a4c7aabdc3eb0d845c62edfb822b0fe5a">cpp_20</a> = 20
, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53af7d98f68372c9de30cc2d571b75b19d7">cpp_23</a> = 23
, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff">cpp_26</a> = 26
 }</td></tr>
<tr class="memdesc:a2f63a594bf7e2b29cb07e1868483ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for the currently selected C++ standard version. Unlike the official macro <code>__cplusplus</code>, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips.  <a href="#a2f63a594bf7e2b29cb07e1868483ee53">More...</a><br /></td></tr>
<tr class="separator:a2f63a594bf7e2b29cb07e1868483ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3f9162720047d01bb438874bf56df5d2" id="r_a3f9162720047d01bb438874bf56df5d2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3f9162720047d01bb438874bf56df5d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type</td></tr>
<tr class="memdesc:a3f9162720047d01bb438874bf56df5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value.  <br /></td></tr>
<tr class="separator:a3f9162720047d01bb438874bf56df5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be834c1a5353b7d9b51d77cd30a9654" id="r_a9be834c1a5353b7d9b51d77cd30a9654"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a9be834c1a5353b7d9b51d77cd30a9654"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9be834c1a5353b7d9b51d77cd30a9654">equal</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a9be834c1a5353b7d9b51d77cd30a9654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise.  <br /></td></tr>
<tr class="separator:a9be834c1a5353b7d9b51d77cd30a9654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934bfc901fe1ed60e93f7f9b9fb34079" id="r_a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a934bfc901fe1ed60e93f7f9b9fb34079">equal</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dda20bb1c4958e2a9ce23f6ebd4fb9c" id="r_a7dda20bb1c4958e2a9ce23f6ebd4fb9c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a7dda20bb1c4958e2a9ce23f6ebd4fb9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7dda20bb1c4958e2a9ce23f6ebd4fb9c">equal</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a7dda20bb1c4958e2a9ce23f6ebd4fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bb44dc832eef8b58d30b1cc70411ff" id="r_a19bb44dc832eef8b58d30b1cc70411ff"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a19bb44dc832eef8b58d30b1cc70411ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19bb44dc832eef8b58d30b1cc70411ff">equal</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a19bb44dc832eef8b58d30b1cc70411ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292ca875d178a8cfb23a5b2f74d5ed33" id="r_a292ca875d178a8cfb23a5b2f74d5ed33"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a292ca875d178a8cfb23a5b2f74d5ed33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a292ca875d178a8cfb23a5b2f74d5ed33">equal_range</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:a292ca875d178a8cfb23a5b2f74d5ed33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a292ca875d178a8cfb23a5b2f74d5ed33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67b5001d764da2ece198e4fc86fde26" id="r_af67b5001d764da2ece198e4fc86fde26"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af67b5001d764da2ece198e4fc86fde26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af67b5001d764da2ece198e4fc86fde26">equal_range</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;</td></tr>
<tr class="separator:af67b5001d764da2ece198e4fc86fde26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086d2ed75d087dea9497d60549d77485" id="r_a086d2ed75d087dea9497d60549d77485"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a086d2ed75d087dea9497d60549d77485"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a086d2ed75d087dea9497d60549d77485">exchange_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a086d2ed75d087dea9497d60549d77485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort">https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort</a>.  <br /></td></tr>
<tr class="separator:a086d2ed75d087dea9497d60549d77485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9635d27783910f84b9a83730f26f2c19" id="r_a9635d27783910f84b9a83730f26f2c19"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a9635d27783910f84b9a83730f26f2c19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9635d27783910f84b9a83730f26f2c19">exchange_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a9635d27783910f84b9a83730f26f2c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11bb84e871a5db6b2a230e5ef065234" id="r_aa11bb84e871a5db6b2a230e5ef065234"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa11bb84e871a5db6b2a230e5ef065234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa11bb84e871a5db6b2a230e5ef065234">fill</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:aa11bb84e871a5db6b2a230e5ef065234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:aa11bb84e871a5db6b2a230e5ef065234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ac240345a96ad39668967bf8bdf76f" id="r_ad5ac240345a96ad39668967bf8bdf76f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad5ac240345a96ad39668967bf8bdf76f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5ac240345a96ad39668967bf8bdf76f">fill_n</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ad5ac240345a96ad39668967bf8bdf76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise.  <br /></td></tr>
<tr class="separator:ad5ac240345a96ad39668967bf8bdf76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074d4da4cb7d3a678c5ae1fce471ddfb" id="r_a074d4da4cb7d3a678c5ae1fce471ddfb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a074d4da4cb7d3a678c5ae1fce471ddfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a074d4da4cb7d3a678c5ae1fce471ddfb">find</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:a074d4da4cb7d3a678c5ae1fce471ddfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element equal to value.  <br /></td></tr>
<tr class="separator:a074d4da4cb7d3a678c5ae1fce471ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8d78c0146673a9463dc7c68540b963" id="r_a7c8d78c0146673a9463dc7c68540b963"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a7c8d78c0146673a9463dc7c68540b963"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c8d78c0146673a9463dc7c68540b963">find_end</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td></tr>
<tr class="memdesc:a7c8d78c0146673a9463dc7c68540b963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:a7c8d78c0146673a9463dc7c68540b963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a3af0f6b1ea2008b53ed21446814f5" id="r_a67a3af0f6b1ea2008b53ed21446814f5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:a67a3af0f6b1ea2008b53ed21446814f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67a3af0f6b1ea2008b53ed21446814f5">find_end</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td></tr>
<tr class="separator:a67a3af0f6b1ea2008b53ed21446814f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea99982a37144ad397257540600269a0" id="r_aea99982a37144ad397257540600269a0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:aea99982a37144ad397257540600269a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea99982a37144ad397257540600269a0">find_first_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:aea99982a37144ad397257540600269a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred.  <br /></td></tr>
<tr class="separator:aea99982a37144ad397257540600269a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4931d3f143272627df883beae8bd9bd5" id="r_a4931d3f143272627df883beae8bd9bd5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a4931d3f143272627df883beae8bd9bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4931d3f143272627df883beae8bd9bd5">find_first_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:a4931d3f143272627df883beae8bd9bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast).  <br /></td></tr>
<tr class="separator:a4931d3f143272627df883beae8bd9bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c802502e6a81c3b77d98dbcaf030c19" id="r_a9c802502e6a81c3b77d98dbcaf030c19"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a9c802502e6a81c3b77d98dbcaf030c19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c802502e6a81c3b77d98dbcaf030c19">find_if</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:a9c802502e6a81c3b77d98dbcaf030c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate p returns true.  <br /></td></tr>
<tr class="separator:a9c802502e6a81c3b77d98dbcaf030c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e68ff6f7166005f9862c8772fa43fd" id="r_a29e68ff6f7166005f9862c8772fa43fd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a29e68ff6f7166005f9862c8772fa43fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29e68ff6f7166005f9862c8772fa43fd">find_if_not</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:a29e68ff6f7166005f9862c8772fa43fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate q returns false.  <br /></td></tr>
<tr class="separator:a29e68ff6f7166005f9862c8772fa43fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad01de69ea01da886464fc3ef1390cc" id="r_a3ad01de69ea01da886464fc3ef1390cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> &gt; </td></tr>
<tr class="memitem:a3ad01de69ea01da886464fc3ef1390cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ad01de69ea01da886464fc3ef1390cc">for_each</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> f) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a></td></tr>
<tr class="memdesc:a3ad01de69ea01da886464fc3ef1390cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order.  <br /></td></tr>
<tr class="separator:a3ad01de69ea01da886464fc3ef1390cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9839f986201c53e618b3435d27ad43a" id="r_ab9839f986201c53e618b3435d27ad43a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> &gt; </td></tr>
<tr class="memitem:ab9839f986201c53e618b3435d27ad43a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9839f986201c53e618b3435d27ad43a">for_each_n</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="structetl_1_1static__vector.html">n</a>, <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> f) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:ab9839f986201c53e618b3435d27ad43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order.  <br /></td></tr>
<tr class="separator:ab9839f986201c53e618b3435d27ad43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b963791bdb1da038a64b23555f245c4" id="r_a0b963791bdb1da038a64b23555f245c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Generator</a> &gt; </td></tr>
<tr class="memitem:a0b963791bdb1da038a64b23555f245c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b963791bdb1da038a64b23555f245c4">generate</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Generator</a> g) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a0b963791bdb1da038a64b23555f245c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns each element in range <code>[first, last)</code> a value generated by the given function object g.  <br /></td></tr>
<tr class="separator:a0b963791bdb1da038a64b23555f245c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984bfa2eb0fd6da7369b629ca3acdc7" id="r_ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">SizeT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Generator</a> &gt; </td></tr>
<tr class="memitem:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab984bfa2eb0fd6da7369b629ca3acdc7">generate_n</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">SizeT</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>, <a class="el" href="structetl_1_1static__vector.html">Generator</a> g) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise.  <br /></td></tr>
<tr class="separator:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d92f2387c738f0636ab8495aa18613" id="r_a72d92f2387c738f0636ab8495aa18613"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a72d92f2387c738f0636ab8495aa18613"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72d92f2387c738f0636ab8495aa18613">gnome_sort</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a72d92f2387c738f0636ab8495aa18613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Gnome_sort">https://en.wikipedia.org/wiki/Gnome_sort</a>.  <br /></td></tr>
<tr class="separator:a72d92f2387c738f0636ab8495aa18613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4a4559a0af0147ebc0d7572dbc142e" id="r_add4a4559a0af0147ebc0d7572dbc142e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:add4a4559a0af0147ebc0d7572dbc142e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add4a4559a0af0147ebc0d7572dbc142e">gnome_sort</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:add4a4559a0af0147ebc0d7572dbc142e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97df033ed5dc7c5458f991078633d9" id="r_a2f97df033ed5dc7c5458f991078633d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a2f97df033ed5dc7c5458f991078633d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f97df033ed5dc7c5458f991078633d9">includes</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a2f97df033ed5dc7c5458f991078633d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted.  <br /></td></tr>
<tr class="separator:a2f97df033ed5dc7c5458f991078633d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7d9a038b385aff889235d470b837e4" id="r_acc7d9a038b385aff889235d470b837e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:acc7d9a038b385aff889235d470b837e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acc7d9a038b385aff889235d470b837e4">includes</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:acc7d9a038b385aff889235d470b837e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a63b710f7e13e8142d025fe5f2ef94" id="r_af8a63b710f7e13e8142d025fe5f2ef94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:af8a63b710f7e13e8142d025fe5f2ef94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8a63b710f7e13e8142d025fe5f2ef94">inplace_merge</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="#a3031e070c39546444bdd5fda57ead3d2">begin</a>, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="structetl_1_1static__vector.html">mid</a>, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="#abf9eb859a31968a9179b29b638cd054b">end</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:af8a63b710f7e13e8142d025fe5f2ef94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last).  <br /></td></tr>
<tr class="separator:af8a63b710f7e13e8142d025fe5f2ef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9e7376359b4a88a505f218d6aa0ddc" id="r_a0e9e7376359b4a88a505f218d6aa0ddc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:a0e9e7376359b4a88a505f218d6aa0ddc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e9e7376359b4a88a505f218d6aa0ddc">inplace_merge</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="structetl_1_1static__vector.html">mid</a>, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a0e9e7376359b4a88a505f218d6aa0ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0080a41003199426077c02b6175ae904" id="r_a0080a41003199426077c02b6175ae904"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a0080a41003199426077c02b6175ae904"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0080a41003199426077c02b6175ae904">insertion_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a0080a41003199426077c02b6175ae904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. <a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a>.  <br /></td></tr>
<tr class="separator:a0080a41003199426077c02b6175ae904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6d5b25a5beae6b886f7eaccb6ccfd2" id="r_a5e6d5b25a5beae6b886f7eaccb6ccfd2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a5e6d5b25a5beae6b886f7eaccb6ccfd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e6d5b25a5beae6b886f7eaccb6ccfd2">insertion_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a5e6d5b25a5beae6b886f7eaccb6ccfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577d3ae817b5678a0a0b91213a403c21" id="r_a577d3ae817b5678a0a0b91213a403c21"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a577d3ae817b5678a0a0b91213a403c21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a577d3ae817b5678a0a0b91213a403c21">is_partitioned</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a577d3ae817b5678a0a0b91213a403c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty. <a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned">https://en.cppreference.com/w/cpp/algorithm/is_partitioned</a>.  <br /></td></tr>
<tr class="separator:a577d3ae817b5678a0a0b91213a403c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01459034f5f84e415ed7c9f73700b54f" id="r_a01459034f5f84e415ed7c9f73700b54f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:a01459034f5f84e415ed7c9f73700b54f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01459034f5f84e415ed7c9f73700b54f">is_permutation</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a01459034f5f84e415ed7c9f73700b54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given.  <br /></td></tr>
<tr class="separator:a01459034f5f84e415ed7c9f73700b54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc05db4110903905f00fc26bb6de03a1" id="r_adc05db4110903905f00fc26bb6de03a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:adc05db4110903905f00fc26bb6de03a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc05db4110903905f00fc26bb6de03a1">is_permutation</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:adc05db4110903905f00fc26bb6de03a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671187bf1a3dd1a99a1acfada1927fcf" id="r_a671187bf1a3dd1a99a1acfada1927fcf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a671187bf1a3dd1a99a1acfada1927fcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a671187bf1a3dd1a99a1acfada1927fcf">is_sorted</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a671187bf1a3dd1a99a1acfada1927fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:a671187bf1a3dd1a99a1acfada1927fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab728b1a920fd45e985ed73b9874fcb7d" id="r_ab728b1a920fd45e985ed73b9874fcb7d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ab728b1a920fd45e985ed73b9874fcb7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab728b1a920fd45e985ed73b9874fcb7d">is_sorted</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ab728b1a920fd45e985ed73b9874fcb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cb4df55d0b061279b599134e294f22" id="r_a26cb4df55d0b061279b599134e294f22"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a26cb4df55d0b061279b599134e294f22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26cb4df55d0b061279b599134e294f22">is_sorted_until</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:a26cb4df55d0b061279b599134e294f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cca9919e02704d1dd11db707e679ee" id="r_a04cca9919e02704d1dd11db707e679ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a04cca9919e02704d1dd11db707e679ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04cca9919e02704d1dd11db707e679ee">is_sorted_until</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a04cca9919e02704d1dd11db707e679ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:a04cca9919e02704d1dd11db707e679ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18b878794474881fce640e7a163abf3" id="r_aa18b878794474881fce640e7a163abf3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:aa18b878794474881fce640e7a163abf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa18b878794474881fce640e7a163abf3">iter_swap</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> a, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> b) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:aa18b878794474881fce640e7a163abf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of the elements the given iterators are pointing to.  <br /></td></tr>
<tr class="separator:aa18b878794474881fce640e7a163abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73951d21be0807534a52bbd26b866f7b" id="r_a73951d21be0807534a52bbd26b866f7b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a73951d21be0807534a52bbd26b866f7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73951d21be0807534a52bbd26b866f7b">lexicographical_compare</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">f1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">l1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">f2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">l2</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a73951d21be0807534a52bbd26b866f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>.  <br /></td></tr>
<tr class="separator:a73951d21be0807534a52bbd26b866f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386a232aa903a5387aa91c4ed5194d9f" id="r_a386a232aa903a5387aa91c4ed5194d9f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a386a232aa903a5387aa91c4ed5194d9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a386a232aa903a5387aa91c4ed5194d9f">lexicographical_compare</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">f1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">l1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">f2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">l2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a386a232aa903a5387aa91c4ed5194d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779ffb051a7e52e4702eb01aa18f167f" id="r_a779ffb051a7e52e4702eb01aa18f167f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a779ffb051a7e52e4702eb01aa18f167f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a779ffb051a7e52e4702eb01aa18f167f">lower_bound</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a779ffb051a7e52e4702eb01aa18f167f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found.  <br /></td></tr>
<tr class="separator:a779ffb051a7e52e4702eb01aa18f167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb1800f39f2305708f67187a3a49993" id="r_a9fb1800f39f2305708f67187a3a49993"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9fb1800f39f2305708f67187a3a49993"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9fb1800f39f2305708f67187a3a49993">lower_bound</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:a9fb1800f39f2305708f67187a3a49993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74" id="r_a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">max</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b.  <br /></td></tr>
<tr class="separator:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8" id="r_a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a220fbd23aca7dbc728c200471ed114c8">max</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a220fbd23aca7dbc728c200471ed114c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b, using a compare function.  <br /></td></tr>
<tr class="separator:a220fbd23aca7dbc728c200471ed114c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcf261d2d7377e2284ab3f5738b34e1" id="r_aedcf261d2d7377e2284ab3f5738b34e1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:aedcf261d2d7377e2284ab3f5738b34e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aedcf261d2d7377e2284ab3f5738b34e1">max_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:aedcf261d2d7377e2284ab3f5738b34e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <br /></td></tr>
<tr class="separator:aedcf261d2d7377e2284ab3f5738b34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc62e1e0c57de79b8b007265bc308ec2" id="r_abc62e1e0c57de79b8b007265bc308ec2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:abc62e1e0c57de79b8b007265bc308ec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc62e1e0c57de79b8b007265bc308ec2">max_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:abc62e1e0c57de79b8b007265bc308ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <br /></td></tr>
<tr class="separator:abc62e1e0c57de79b8b007265bc308ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee09e4768fc381002cd7dc14e8e561b" id="r_a9ee09e4768fc381002cd7dc14e8e561b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a9ee09e4768fc381002cd7dc14e8e561b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ee09e4768fc381002cd7dc14e8e561b">merge</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a9ee09e4768fc381002cd7dc14e8e561b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>.  <br /></td></tr>
<tr class="separator:a9ee09e4768fc381002cd7dc14e8e561b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0face2f5fe06333854b6b120bd6bad" id="r_a6d0face2f5fe06333854b6b120bd6bad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a6d0face2f5fe06333854b6b120bd6bad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d0face2f5fe06333854b6b120bd6bad">merge</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:a6d0face2f5fe06333854b6b120bd6bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bffa34e9bd6075ec150aa9e30153950" id="r_a5bffa34e9bd6075ec150aa9e30153950"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a5bffa34e9bd6075ec150aa9e30153950"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5bffa34e9bd6075ec150aa9e30153950">merge_sort</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a5bffa34e9bd6075ec150aa9e30153950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a>.  <br /></td></tr>
<tr class="separator:a5bffa34e9bd6075ec150aa9e30153950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da0fcb091026bf11e56eb257e9d3bc5" id="r_a4da0fcb091026bf11e56eb257e9d3bc5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:a4da0fcb091026bf11e56eb257e9d3bc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4da0fcb091026bf11e56eb257e9d3bc5">merge_sort</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a4da0fcb091026bf11e56eb257e9d3bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63" id="r_adae1500815312b248e453896d5439b63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adae1500815312b248e453896d5439b63">min</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:adae1500815312b248e453896d5439b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b.  <br /></td></tr>
<tr class="separator:adae1500815312b248e453896d5439b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2" id="r_a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a479c4a8315ae3ef2d1128858d723afc2">min</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a479c4a8315ae3ef2d1128858d723afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b, using a compare function.  <br /></td></tr>
<tr class="separator:a479c4a8315ae3ef2d1128858d723afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4c7706179eef16ba76242c48518a9" id="r_a4af4c7706179eef16ba76242c48518a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a4af4c7706179eef16ba76242c48518a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4af4c7706179eef16ba76242c48518a9">min_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a4af4c7706179eef16ba76242c48518a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <br /></td></tr>
<tr class="separator:a4af4c7706179eef16ba76242c48518a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71878538e0e2b2f8026ed657836382c0" id="r_a71878538e0e2b2f8026ed657836382c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a71878538e0e2b2f8026ed657836382c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71878538e0e2b2f8026ed657836382c0">min_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a71878538e0e2b2f8026ed657836382c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <br /></td></tr>
<tr class="separator:a71878538e0e2b2f8026ed657836382c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81f900b934c83cdb278826ede239e6b" id="r_ae81f900b934c83cdb278826ede239e6b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ae81f900b934c83cdb278826ede239e6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae81f900b934c83cdb278826ede239e6b">minmax</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp; &gt;</td></tr>
<tr class="memdesc:ae81f900b934c83cdb278826ede239e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <br /></td></tr>
<tr class="separator:ae81f900b934c83cdb278826ede239e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85dc58adf499e8f90a9e9c4eb0594a" id="r_a1a85dc58adf499e8f90a9e9c4eb0594a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1a85dc58adf499e8f90a9e9c4eb0594a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a85dc58adf499e8f90a9e9c4eb0594a">minmax</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;a, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;b) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp; &gt;</td></tr>
<tr class="memdesc:a1a85dc58adf499e8f90a9e9c4eb0594a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <br /></td></tr>
<tr class="separator:a1a85dc58adf499e8f90a9e9c4eb0594a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3573e5fccf8f6ff5d8636e23b1ffa0" id="r_adf3573e5fccf8f6ff5d8636e23b1ffa0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:adf3573e5fccf8f6ff5d8636e23b1ffa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf3573e5fccf8f6ff5d8636e23b1ffa0">minmax_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:adf3573e5fccf8f6ff5d8636e23b1ffa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:adf3573e5fccf8f6ff5d8636e23b1ffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3442eebc68bb878d66ab8a37478ff679" id="r_a3442eebc68bb878d66ab8a37478ff679"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a3442eebc68bb878d66ab8a37478ff679"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3442eebc68bb878d66ab8a37478ff679">minmax_element</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:a3442eebc68bb878d66ab8a37478ff679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a3442eebc68bb878d66ab8a37478ff679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674e86a91ac9cb808d365aa09d5d07f" id="r_a5674e86a91ac9cb808d365aa09d5d07f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a5674e86a91ac9cb808d365aa09d5d07f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5674e86a91ac9cb808d365aa09d5d07f">mismatch</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt;</td></tr>
<tr class="memdesc:a5674e86a91ac9cb808d365aa09d5d07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred.  <br /></td></tr>
<tr class="separator:a5674e86a91ac9cb808d365aa09d5d07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae399b1c12f42fcf2365021710f1e1667" id="r_ae399b1c12f42fcf2365021710f1e1667"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:ae399b1c12f42fcf2365021710f1e1667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae399b1c12f42fcf2365021710f1e1667">mismatch</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:ae399b1c12f42fcf2365021710f1e1667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85be5a2493fc37bb07bab46871d7732b" id="r_a85be5a2493fc37bb07bab46871d7732b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a85be5a2493fc37bb07bab46871d7732b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85be5a2493fc37bb07bab46871d7732b">mismatch</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:a85be5a2493fc37bb07bab46871d7732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8936cbbb27640ce6d9411dd5bc4859b3" id="r_a8936cbbb27640ce6d9411dd5bc4859b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a8936cbbb27640ce6d9411dd5bc4859b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8936cbbb27640ce6d9411dd5bc4859b3">mismatch</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:a8936cbbb27640ce6d9411dd5bc4859b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8df3814fc65f04932c2f0d09a56107" id="r_a1b8df3814fc65f04932c2f0d09a56107"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a1b8df3814fc65f04932c2f0d09a56107"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b8df3814fc65f04932c2f0d09a56107">move</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a1b8df3814fc65f04932c2f0d09a56107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.  <br /></td></tr>
<tr class="separator:a1b8df3814fc65f04932c2f0d09a56107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739385d15b43be76e906acbc6e6459a5" id="r_a739385d15b43be76e906acbc6e6459a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> &gt; </td></tr>
<tr class="memitem:a739385d15b43be76e906acbc6e6459a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a739385d15b43be76e906acbc6e6459a5">move_backward</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a></td></tr>
<tr class="memdesc:a739385d15b43be76e906acbc6e6459a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:a739385d15b43be76e906acbc6e6459a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b5fe643bd62734bbb66af22e88544c" id="r_ae2b5fe643bd62734bbb66af22e88544c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ae2b5fe643bd62734bbb66af22e88544c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2b5fe643bd62734bbb66af22e88544c">none_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae2b5fe643bd62734bbb66af22e88544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ae2b5fe643bd62734bbb66af22e88544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade97d95e33160e2176476b303cacc224" id="r_ade97d95e33160e2176476b303cacc224"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ade97d95e33160e2176476b303cacc224"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade97d95e33160e2176476b303cacc224">nth_element</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> <a class="el" href="structetl_1_1static__vector.html">nth</a>, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ade97d95e33160e2176476b303cacc224"><td class="mdescLeft">&#160;</td><td class="mdescRight">nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that:  <br /></td></tr>
<tr class="separator:ade97d95e33160e2176476b303cacc224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31997e04071d6cfa4b887e46783efbf3" id="r_a31997e04071d6cfa4b887e46783efbf3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a31997e04071d6cfa4b887e46783efbf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a31997e04071d6cfa4b887e46783efbf3">nth_element</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> <a class="el" href="structetl_1_1static__vector.html">nth</a>, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a31997e04071d6cfa4b887e46783efbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d1bed984c0aceff254e912cf251c6e" id="r_a61d1bed984c0aceff254e912cf251c6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a61d1bed984c0aceff254e912cf251c6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61d1bed984c0aceff254e912cf251c6e">partial_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> <a class="el" href="structetl_1_1static__vector.html">middle</a>, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a61d1bed984c0aceff254e912cf251c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified.  <br /></td></tr>
<tr class="separator:a61d1bed984c0aceff254e912cf251c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf059ef9f744ed7d731faa69834ddc9a" id="r_adf059ef9f744ed7d731faa69834ddc9a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:adf059ef9f744ed7d731faa69834ddc9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf059ef9f744ed7d731faa69834ddc9a">partial_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> <a class="el" href="structetl_1_1static__vector.html">middle</a>, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:adf059ef9f744ed7d731faa69834ddc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c256595c3b4e99c28c50d5f1c0d73f" id="r_a94c256595c3b4e99c28c50d5f1c0d73f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a94c256595c3b4e99c28c50d5f1c0d73f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94c256595c3b4e99c28c50d5f1c0d73f">partition</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a94c256595c3b4e99c28c50d5f1c0d73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved.  <br /></td></tr>
<tr class="separator:a94c256595c3b4e99c28c50d5f1c0d73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34f1c15b38f8436c5d6dcc1f9f38491" id="r_ad34f1c15b38f8436c5d6dcc1f9f38491"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ad34f1c15b38f8436c5d6dcc1f9f38491"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad34f1c15b38f8436c5d6dcc1f9f38491">partition_copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt1</a> <a class="el" href="structetl_1_1static__vector.html">destinationTrue</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a> <a class="el" href="structetl_1_1static__vector.html">destinationFalse</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">OutputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a> &gt;</td></tr>
<tr class="memdesc:ad34f1c15b38f8436c5d6dcc1f9f38491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false.  <br /></td></tr>
<tr class="separator:ad34f1c15b38f8436c5d6dcc1f9f38491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4c550073b16bc102ef6b2447cc31d6" id="r_a8d4c550073b16bc102ef6b2447cc31d6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a8d4c550073b16bc102ef6b2447cc31d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d4c550073b16bc102ef6b2447cc31d6">partition_point</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a8d4c550073b16bc102ef6b2447cc31d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p.  <br /></td></tr>
<tr class="separator:a8d4c550073b16bc102ef6b2447cc31d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde454dc915d0c4c32bd8041b0bd8ecf" id="r_adde454dc915d0c4c32bd8041b0bd8ecf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adde454dc915d0c4c32bd8041b0bd8ecf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adde454dc915d0c4c32bd8041b0bd8ecf">remove</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:adde454dc915d0c4c32bd8041b0bd8ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <br /></td></tr>
<tr class="separator:adde454dc915d0c4c32bd8041b0bd8ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0bacdf9416ed0db41e5527c7bb1b29" id="r_a7e0bacdf9416ed0db41e5527c7bb1b29"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7e0bacdf9416ed0db41e5527c7bb1b29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e0bacdf9416ed0db41e5527c7bb1b29">remove_copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a7e0bacdf9416ed0db41e5527c7bb1b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value.  <br /></td></tr>
<tr class="separator:a7e0bacdf9416ed0db41e5527c7bb1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dc3e941f0f6b0d00f923fec94b6694" id="r_a68dc3e941f0f6b0d00f923fec94b6694"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a68dc3e941f0f6b0d00f923fec94b6694"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68dc3e941f0f6b0d00f923fec94b6694">remove_copy_if</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a68dc3e941f0f6b0d00f923fec94b6694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:a68dc3e941f0f6b0d00f923fec94b6694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc5f42480a4033b9a58cb5c7236fbee" id="r_a5dc5f42480a4033b9a58cb5c7236fbee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a5dc5f42480a4033b9a58cb5c7236fbee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5dc5f42480a4033b9a58cb5c7236fbee">remove_if</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a5dc5f42480a4033b9a58cb5c7236fbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <br /></td></tr>
<tr class="separator:a5dc5f42480a4033b9a58cb5c7236fbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab115e24caa45f16f79bb770a6e3cbbab" id="r_ab115e24caa45f16f79bb770a6e3cbbab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab115e24caa45f16f79bb770a6e3cbbab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab115e24caa45f16f79bb770a6e3cbbab">replace</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">oldValue</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">newValue</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ab115e24caa45f16f79bb770a6e3cbbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value.  <br /></td></tr>
<tr class="separator:ab115e24caa45f16f79bb770a6e3cbbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290953b933269399f045b7e2b37d97b7" id="r_a290953b933269399f045b7e2b37d97b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a290953b933269399f045b7e2b37d97b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a290953b933269399f045b7e2b37d97b7">replace_if</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">newValue</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a290953b933269399f045b7e2b37d97b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:a290953b933269399f045b7e2b37d97b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa198aa5e9e5759947d51496cede4e6f6" id="r_aa198aa5e9e5759947d51496cede4e6f6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:aa198aa5e9e5759947d51496cede4e6f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa198aa5e9e5759947d51496cede4e6f6">reverse</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:aa198aa5e9e5759947d51496cede4e6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:aa198aa5e9e5759947d51496cede4e6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0246fc85a8996116ecfe4be33cd1495" id="r_ae0246fc85a8996116ecfe4be33cd1495"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ae0246fc85a8996116ecfe4be33cd1495"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0246fc85a8996116ecfe4be33cd1495">reverse_copy</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ae0246fc85a8996116ecfe4be33cd1495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order.  <br /></td></tr>
<tr class="separator:ae0246fc85a8996116ecfe4be33cd1495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0cdef8cb8f1fb054c43f8aadb43d36" id="r_a1c0cdef8cb8f1fb054c43f8aadb43d36"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a1c0cdef8cb8f1fb054c43f8aadb43d36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c0cdef8cb8f1fb054c43f8aadb43d36">rotate</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">nFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a1c0cdef8cb8f1fb054c43f8aadb43d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on a range of elements.  <br /></td></tr>
<tr class="separator:a1c0cdef8cb8f1fb054c43f8aadb43d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d28d5f25cdee05003b4190e57dd519" id="r_ad0d28d5f25cdee05003b4190e57dd519"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ad0d28d5f25cdee05003b4190e57dd519"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0d28d5f25cdee05003b4190e57dd519">rotate_copy</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">nFirst</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ad0d28d5f25cdee05003b4190e57dd519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element.  <br /></td></tr>
<tr class="separator:ad0d28d5f25cdee05003b4190e57dd519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a57bc56c6f3c0bf94045777e9f274" id="r_af39a57bc56c6f3c0bf94045777e9f274"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:af39a57bc56c6f3c0bf94045777e9f274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af39a57bc56c6f3c0bf94045777e9f274">search</a> (<a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td></tr>
<tr class="memdesc:af39a57bc56c6f3c0bf94045777e9f274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:af39a57bc56c6f3c0bf94045777e9f274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8c774a650ce6535a79e6a11dd90fdf" id="r_a5e8c774a650ce6535a79e6a11dd90fdf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> &gt; </td></tr>
<tr class="memitem:a5e8c774a650ce6535a79e6a11dd90fdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e8c774a650ce6535a79e6a11dd90fdf">search</a> (<a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> <a class="el" href="structetl_1_1static__vector.html">sFirst</a>, <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> <a class="el" href="structetl_1_1static__vector.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td></tr>
<tr class="separator:a5e8c774a650ce6535a79e6a11dd90fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a90d9aad4e00eb080d9dce99472a40" id="r_a21a90d9aad4e00eb080d9dce99472a40"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Searcher</a> &gt; </td></tr>
<tr class="memitem:a21a90d9aad4e00eb080d9dce99472a40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21a90d9aad4e00eb080d9dce99472a40">search</a> (<a class="el" href="structetl_1_1static__vector.html">FwdIt</a> first, <a class="el" href="structetl_1_1static__vector.html">FwdIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Searcher</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">searcher</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt</a></td></tr>
<tr class="separator:a21a90d9aad4e00eb080d9dce99472a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047bb8dc9dd92624ad901db1d27e5d83" id="r_a047bb8dc9dd92624ad901db1d27e5d83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a047bb8dc9dd92624ad901db1d27e5d83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a047bb8dc9dd92624ad901db1d27e5d83">search_n</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>, <a class="el" href="structetl_1_1static__vector.html">ValueT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a047bb8dc9dd92624ad901db1d27e5d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value.  <br /></td></tr>
<tr class="separator:a047bb8dc9dd92624ad901db1d27e5d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8fcaf19422ff5c92791797f6373260" id="r_a6c8fcaf19422ff5c92791797f6373260"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueT</a> &gt; </td></tr>
<tr class="memitem:a6c8fcaf19422ff5c92791797f6373260"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c8fcaf19422ff5c92791797f6373260">search_n</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>, <a class="el" href="structetl_1_1static__vector.html">ValueT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:a6c8fcaf19422ff5c92791797f6373260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563244b70e444026e7ddee3ad609b4a5" id="r_a563244b70e444026e7ddee3ad609b4a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a563244b70e444026e7ddee3ad609b4a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a563244b70e444026e7ddee3ad609b4a5">set_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a563244b70e444026e7ddee3ad609b4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same.  <br /></td></tr>
<tr class="separator:a563244b70e444026e7ddee3ad609b4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c804f0766a786779b7c17886e601a2" id="r_a50c804f0766a786779b7c17886e601a2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a50c804f0766a786779b7c17886e601a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a50c804f0766a786779b7c17886e601a2">set_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:a50c804f0766a786779b7c17886e601a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6670fa3cc294c702e9b6245c55a1da4" id="r_ac6670fa3cc294c702e9b6245c55a1da4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ac6670fa3cc294c702e9b6245c55a1da4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6670fa3cc294c702e9b6245c55a1da4">set_intersection</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ac6670fa3cc294c702e9b6245c55a1da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:ac6670fa3cc294c702e9b6245c55a1da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a31828bddd42fb93f6afb491bd4b4f" id="r_a47a31828bddd42fb93f6afb491bd4b4f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a47a31828bddd42fb93f6afb491bd4b4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47a31828bddd42fb93f6afb491bd4b4f">set_intersection</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:a47a31828bddd42fb93f6afb491bd4b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c7a269a772f000cb710d042d7aee20" id="r_a40c7a269a772f000cb710d042d7aee20"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a40c7a269a772f000cb710d042d7aee20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40c7a269a772f000cb710d042d7aee20">set_symmetric_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a40c7a269a772f000cb710d042d7aee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at destination. The resulting range is also sorted.  <br /></td></tr>
<tr class="separator:a40c7a269a772f000cb710d042d7aee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e87148d2ced5612a3f9f09fd4eb941" id="r_ac0e87148d2ced5612a3f9f09fd4eb941"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ac0e87148d2ced5612a3f9f09fd4eb941"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0e87148d2ced5612a3f9f09fd4eb941">set_symmetric_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:ac0e87148d2ced5612a3f9f09fd4eb941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9009346ce6e69bac2a9406592192aef1" id="r_a9009346ce6e69bac2a9406592192aef1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a9009346ce6e69bac2a9406592192aef1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9009346ce6e69bac2a9406592192aef1">set_union</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a9009346ce6e69bac2a9406592192aef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:a9009346ce6e69bac2a9406592192aef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c31225d785d8d6b0702705ce2706c53" id="r_a4c31225d785d8d6b0702705ce2706c53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a4c31225d785d8d6b0702705ce2706c53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c31225d785d8d6b0702705ce2706c53">set_union</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">last2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:a4c31225d785d8d6b0702705ce2706c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df8e5c73b49b744646fa291c63525c1" id="r_a9df8e5c73b49b744646fa291c63525c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a9df8e5c73b49b744646fa291c63525c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9df8e5c73b49b744646fa291c63525c1">shift_left</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">const</a> last, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a9df8e5c73b49b744646fa291c63525c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <br /></td></tr>
<tr class="separator:a9df8e5c73b49b744646fa291c63525c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9ba1876aaa603ff0092cf872376265" id="r_a2a9ba1876aaa603ff0092cf872376265"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> &gt; </td></tr>
<tr class="memitem:a2a9ba1876aaa603ff0092cf872376265"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a9ba1876aaa603ff0092cf872376265">shift_right</a> (<a class="el" href="structetl_1_1static__vector.html">BidiIt</a> first, <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> last, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidiIt</a></td></tr>
<tr class="memdesc:a2a9ba1876aaa603ff0092cf872376265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <br /></td></tr>
<tr class="separator:a2a9ba1876aaa603ff0092cf872376265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda62f64ad31faeb43dab1bbe8b2a664" id="r_adda62f64ad31faeb43dab1bbe8b2a664"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:adda62f64ad31faeb43dab1bbe8b2a664"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adda62f64ad31faeb43dab1bbe8b2a664">sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:adda62f64ad31faeb43dab1bbe8b2a664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is not guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:adda62f64ad31faeb43dab1bbe8b2a664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29031b0fee25653ff42e6fab29670267" id="r_a29031b0fee25653ff42e6fab29670267"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a29031b0fee25653ff42e6fab29670267"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29031b0fee25653ff42e6fab29670267">sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a29031b0fee25653ff42e6fab29670267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04627f836421020d549c77618e404bef" id="r_a04627f836421020d549c77618e404bef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a04627f836421020d549c77618e404bef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04627f836421020d549c77618e404bef">stable_partition</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> f, <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="structetl_1_1static__vector.html">l</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td></tr>
<tr class="memdesc:a04627f836421020d549c77618e404bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved.  <br /></td></tr>
<tr class="separator:a04627f836421020d549c77618e404bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba546db0dc7852f32bae5b43c1cbb973" id="r_aba546db0dc7852f32bae5b43c1cbb973"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:aba546db0dc7852f32bae5b43c1cbb973"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba546db0dc7852f32bae5b43c1cbb973">stable_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:aba546db0dc7852f32bae5b43c1cbb973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved. Elements are compared using the given comparison function comp.  <br /></td></tr>
<tr class="separator:aba546db0dc7852f32bae5b43c1cbb973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018602a1181cba5553c619612ae2bf58" id="r_a018602a1181cba5553c619612ae2bf58"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a018602a1181cba5553c619612ae2bf58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a018602a1181cba5553c619612ae2bf58">stable_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a018602a1181cba5553c619612ae2bf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2864370cd9173ff7ac8fb507dd6779a" id="r_ab2864370cd9173ff7ac8fb507dd6779a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:ab2864370cd9173ff7ac8fb507dd6779a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2864370cd9173ff7ac8fb507dd6779a">swap_ranges</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td></tr>
<tr class="memdesc:ab2864370cd9173ff7ac8fb507dd6779a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>.  <br /></td></tr>
<tr class="separator:ab2864370cd9173ff7ac8fb507dd6779a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4467ebe5b0d985e1661eb04cb65fab6a" id="r_a4467ebe5b0d985e1661eb04cb65fab6a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryOp</a> &gt; </td></tr>
<tr class="memitem:a4467ebe5b0d985e1661eb04cb65fab6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4467ebe5b0d985e1661eb04cb65fab6a">transform</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">UnaryOp</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a4467ebe5b0d985e1661eb04cb65fab6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:a4467ebe5b0d985e1661eb04cb65fab6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2860fb376fc216b93922e036f8ead03" id="r_ab2860fb376fc216b93922e036f8ead03"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> &gt; </td></tr>
<tr class="memitem:ab2860fb376fc216b93922e036f8ead03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2860fb376fc216b93922e036f8ead03">transform</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:ab2860fb376fc216b93922e036f8ead03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9322bfeec8125aeb86d43fee6fade" id="r_a8ff9322bfeec8125aeb86d43fee6fade"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a8ff9322bfeec8125aeb86d43fee6fade"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ff9322bfeec8125aeb86d43fee6fade">unique</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a8ff9322bfeec8125aeb86d43fee6fade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range.  <br /></td></tr>
<tr class="separator:a8ff9322bfeec8125aeb86d43fee6fade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438b893eeeaa7e54c01596344dbc939d" id="r_a438b893eeeaa7e54c01596344dbc939d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:a438b893eeeaa7e54c01596344dbc939d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a438b893eeeaa7e54c01596344dbc939d">unique</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a438b893eeeaa7e54c01596344dbc939d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range.  <br /></td></tr>
<tr class="separator:a438b893eeeaa7e54c01596344dbc939d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e100f1e4a026e9d4789c972b7a4c8d" id="r_ab8e100f1e4a026e9d4789c972b7a4c8d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ab8e100f1e4a026e9d4789c972b7a4c8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8e100f1e4a026e9d4789c972b7a4c8d">unique_copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ab8e100f1e4a026e9d4789c972b7a4c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <br /></td></tr>
<tr class="separator:ab8e100f1e4a026e9d4789c972b7a4c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63f087df9180e1901cc4105a3a0363" id="r_a7c63f087df9180e1901cc4105a3a0363"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a7c63f087df9180e1901cc4105a3a0363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c63f087df9180e1901cc4105a3a0363">unique_copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:a7c63f087df9180e1901cc4105a3a0363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <br /></td></tr>
<tr class="separator:a7c63f087df9180e1901cc4105a3a0363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b32d22be5cb9bbaaf24e21d8b700bcb" id="r_a9b32d22be5cb9bbaaf24e21d8b700bcb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a9b32d22be5cb9bbaaf24e21d8b700bcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b32d22be5cb9bbaaf24e21d8b700bcb">upper_bound</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a9b32d22be5cb9bbaaf24e21d8b700bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than <code>value</code>, or last if no such element is found.  <br /></td></tr>
<tr class="separator:a9b32d22be5cb9bbaaf24e21d8b700bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3448c90cac95ec2e155cf8ac02b6c592" id="r_a3448c90cac95ec2e155cf8ac02b6c592"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3448c90cac95ec2e155cf8ac02b6c592"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3448c90cac95ec2e155cf8ac02b6c592">upper_bound</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:a3448c90cac95ec2e155cf8ac02b6c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4070f4c004b740cd8c1b913db783dfb8" id="r_ga4070f4c004b740cd8c1b913db783dfb8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> &gt; <br />
requires (detail::bit_castable_types&lt;<a class="el" href="structetl_1_1static__vector.html">To</a>, <a class="el" href="structetl_1_1static__vector.html">From</a>&gt;)</td></tr>
<tr class="memitem:ga4070f4c004b740cd8c1b913db783dfb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga4070f4c004b740cd8c1b913db783dfb8">bit_cast</a> (<a class="el" href="structetl_1_1static__vector.html">From</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">To</a></td></tr>
<tr class="memdesc:ga4070f4c004b740cd8c1b913db783dfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from.  <br /></td></tr>
<tr class="separator:ga4070f4c004b740cd8c1b913db783dfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa397d9f8380425b5e72d55d7f7f16b10" id="r_gaa397d9f8380425b5e72d55d7f7f16b10"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa397d9f8380425b5e72d55d7f7f16b10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaa397d9f8380425b5e72d55d7f7f16b10">bit_ceil</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gaa397d9f8380425b5e72d55d7f7f16b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the smallest integral power of two that is not smaller than x. If that value is not representable in UInt, the behavior is undefined. Call to this function is permitted in constant evaluation only if the undefined behavior does not occur.  <br /></td></tr>
<tr class="separator:gaa397d9f8380425b5e72d55d7f7f16b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344157c15560dd640719de8ecf9a311a" id="r_ga344157c15560dd640719de8ecf9a311a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga344157c15560dd640719de8ecf9a311a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga344157c15560dd640719de8ecf9a311a">bit_floor</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga344157c15560dd640719de8ecf9a311a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the largest integral power of two that is not greater than x. If x is zero, returns zero.  <br /></td></tr>
<tr class="separator:ga344157c15560dd640719de8ecf9a311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f9cca4b68917b48f46849a03007d9a9" id="r_ga7f9cca4b68917b48f46849a03007d9a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga7f9cca4b68917b48f46849a03007d9a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga7f9cca4b68917b48f46849a03007d9a9">bit_width</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ga7f9cca4b68917b48f46849a03007d9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the number of bits needed to store the value x, that is, 1+log2(x). If x is zero, returns zero.  <br /></td></tr>
<tr class="separator:ga7f9cca4b68917b48f46849a03007d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4adeee8eaea36f5d0716abfe81148ba" id="r_gad4adeee8eaea36f5d0716abfe81148ba"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gad4adeee8eaea36f5d0716abfe81148ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gad4adeee8eaea36f5d0716abfe81148ba">byteswap</a> (T val) noexcept -&gt; T</td></tr>
<tr class="memdesc:gad4adeee8eaea36f5d0716abfe81148ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the bytes in the given integer value n.  <br /></td></tr>
<tr class="separator:gad4adeee8eaea36f5d0716abfe81148ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce080db93d1da7b7ac5322f3edab4fa" id="r_ga4ce080db93d1da7b7ac5322f3edab4fa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga4ce080db93d1da7b7ac5322f3edab4fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga4ce080db93d1da7b7ac5322f3edab4fa">countl_one</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ga4ce080db93d1da7b7ac5322f3edab4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left").  <br /></td></tr>
<tr class="separator:ga4ce080db93d1da7b7ac5322f3edab4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6df380fce74364ad8da2b39c516c24e" id="r_gac6df380fce74364ad8da2b39c516c24e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gac6df380fce74364ad8da2b39c516c24e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gac6df380fce74364ad8da2b39c516c24e">countl_zero</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:gac6df380fce74364ad8da2b39c516c24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left").  <br /></td></tr>
<tr class="separator:gac6df380fce74364ad8da2b39c516c24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e3fbba99f7fed7abe96381c03de2e54" id="r_ga0e3fbba99f7fed7abe96381c03de2e54"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga0e3fbba99f7fed7abe96381c03de2e54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga0e3fbba99f7fed7abe96381c03de2e54">countr_one</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ga0e3fbba99f7fed7abe96381c03de2e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 bits in the value of x, starting from the least significant bit ("right").  <br /></td></tr>
<tr class="separator:ga0e3fbba99f7fed7abe96381c03de2e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5490ba02f948e6f27acbe515d47eab" id="r_ga9a5490ba02f948e6f27acbe515d47eab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga9a5490ba02f948e6f27acbe515d47eab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga9a5490ba02f948e6f27acbe515d47eab">countr_zero</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ga9a5490ba02f948e6f27acbe515d47eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the least significant bit ("right").  <br /></td></tr>
<tr class="separator:ga9a5490ba02f948e6f27acbe515d47eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8f84be8fe68d200ccdb6327caca819" id="r_ga6e8f84be8fe68d200ccdb6327caca819"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga6e8f84be8fe68d200ccdb6327caca819"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga6e8f84be8fe68d200ccdb6327caca819">flip_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga6e8f84be8fe68d200ccdb6327caca819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga6e8f84be8fe68d200ccdb6327caca819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d1c3764bf4d6018b0b39251157ac805" id="r_ga9d1c3764bf4d6018b0b39251157ac805"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga9d1c3764bf4d6018b0b39251157ac805"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga9d1c3764bf4d6018b0b39251157ac805">flip_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga9d1c3764bf4d6018b0b39251157ac805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip bit at position Pos.  <br /></td></tr>
<tr class="separator:ga9d1c3764bf4d6018b0b39251157ac805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf064bf9681c55a5f04915eeceb13348a" id="r_gaf064bf9681c55a5f04915eeceb13348a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaf064bf9681c55a5f04915eeceb13348a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaf064bf9681c55a5f04915eeceb13348a">has_single_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gaf064bf9681c55a5f04915eeceb13348a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if x is an integral power of two.  <br /></td></tr>
<tr class="separator:gaf064bf9681c55a5f04915eeceb13348a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec2a511f8b5137e02416b9e4e8dc237" id="r_a6ec2a511f8b5137e02416b9e4e8dc237"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a6ec2a511f8b5137e02416b9e4e8dc237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ec2a511f8b5137e02416b9e4e8dc237">operator&amp;</a> (T <a class="el" href="structetl_1_1static__vector.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:a6ec2a511f8b5137e02416b9e4e8dc237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cb02b81d1ba34fc33b94555749fa92" id="r_ac3cb02b81d1ba34fc33b94555749fa92"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:ac3cb02b81d1ba34fc33b94555749fa92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3cb02b81d1ba34fc33b94555749fa92">operator|</a> (T <a class="el" href="structetl_1_1static__vector.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:ac3cb02b81d1ba34fc33b94555749fa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af622835231ee77bf2d29dd490bcbb2bf" id="r_af622835231ee77bf2d29dd490bcbb2bf"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:af622835231ee77bf2d29dd490bcbb2bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af622835231ee77bf2d29dd490bcbb2bf">operator^</a> (T <a class="el" href="structetl_1_1static__vector.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:af622835231ee77bf2d29dd490bcbb2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92caafb1e73d48a1d1847f64093be44c" id="r_a92caafb1e73d48a1d1847f64093be44c"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a92caafb1e73d48a1d1847f64093be44c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92caafb1e73d48a1d1847f64093be44c">operator~</a> (T <a class="el" href="structetl_1_1static__vector.html">x</a>) -&gt; T</td></tr>
<tr class="separator:a92caafb1e73d48a1d1847f64093be44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e027dfa37f613a9d94fe1ee90e7517" id="r_ad2e027dfa37f613a9d94fe1ee90e7517"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:ad2e027dfa37f613a9d94fe1ee90e7517"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2e027dfa37f613a9d94fe1ee90e7517">operator|=</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:ad2e027dfa37f613a9d94fe1ee90e7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc72777ea30905ff52e4ce6d3448b3e8" id="r_abc72777ea30905ff52e4ce6d3448b3e8"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:abc72777ea30905ff52e4ce6d3448b3e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc72777ea30905ff52e4ce6d3448b3e8">operator&amp;=</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:abc72777ea30905ff52e4ce6d3448b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f94aefe628a0474274befd3437bf64" id="r_a79f94aefe628a0474274befd3437bf64"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a79f94aefe628a0474274befd3437bf64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79f94aefe628a0474274befd3437bf64">operator^=</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:a79f94aefe628a0474274befd3437bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e754daac238cd635c52a571019370d9" id="r_ga9e754daac238cd635c52a571019370d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga9e754daac238cd635c52a571019370d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga9e754daac238cd635c52a571019370d9">popcount</a> (UInt val) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ga9e754daac238cd635c52a571019370d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 1 bits in the value of x.  <br /></td></tr>
<tr class="separator:ga9e754daac238cd635c52a571019370d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568f73d3a90d86bbf2a7c0bd408510c6" id="r_ga568f73d3a90d86bbf2a7c0bd408510c6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga568f73d3a90d86bbf2a7c0bd408510c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga568f73d3a90d86bbf2a7c0bd408510c6">reset_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga568f73d3a90d86bbf2a7c0bd408510c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga568f73d3a90d86bbf2a7c0bd408510c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76b555c9fa24f8068041e222a11a0b02" id="r_ga76b555c9fa24f8068041e222a11a0b02"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga76b555c9fa24f8068041e222a11a0b02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga76b555c9fa24f8068041e222a11a0b02">reset_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga76b555c9fa24f8068041e222a11a0b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset bit at position Pos.  <br /></td></tr>
<tr class="separator:ga76b555c9fa24f8068041e222a11a0b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bbf35871b94190f98acbfc57d75c63c" id="r_ga0bbf35871b94190f98acbfc57d75c63c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga0bbf35871b94190f98acbfc57d75c63c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga0bbf35871b94190f98acbfc57d75c63c">rotl</a> (UInt <a class="el" href="structetl_1_1static__vector.html">t</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">s</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga0bbf35871b94190f98acbfc57d75c63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise left-rotating the value of x by s positions. This operation is also known as a left circular shift.  <br /></td></tr>
<tr class="separator:ga0bbf35871b94190f98acbfc57d75c63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ebdfe26048f199e0778622f63a6653" id="r_ga74ebdfe26048f199e0778622f63a6653"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga74ebdfe26048f199e0778622f63a6653"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga74ebdfe26048f199e0778622f63a6653">rotr</a> (UInt <a class="el" href="structetl_1_1static__vector.html">t</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">s</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga74ebdfe26048f199e0778622f63a6653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise right-rotating the value of x by s positions. This operation is also known as a right circular shift.  <br /></td></tr>
<tr class="separator:ga74ebdfe26048f199e0778622f63a6653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb9437ec95ed5eea0cc55d94b2b64fd" id="r_gaccb9437ec95ed5eea0cc55d94b2b64fd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaccb9437ec95ed5eea0cc55d94b2b64fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaccb9437ec95ed5eea0cc55d94b2b64fd">set_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gaccb9437ec95ed5eea0cc55d94b2b64fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:gaccb9437ec95ed5eea0cc55d94b2b64fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f69fe1215d9240044ca3339a9e4674f" id="r_ga5f69fe1215d9240044ca3339a9e4674f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga5f69fe1215d9240044ca3339a9e4674f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga5f69fe1215d9240044ca3339a9e4674f">set_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga5f69fe1215d9240044ca3339a9e4674f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>Pos</code>  <br /></td></tr>
<tr class="separator:ga5f69fe1215d9240044ca3339a9e4674f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb98500899c20e944fba12d8ffb7f26" id="r_gadcb98500899c20e944fba12d8ffb7f26"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gadcb98500899c20e944fba12d8ffb7f26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gadcb98500899c20e944fba12d8ffb7f26">test_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>, UInt <a class="el" href="structetl_1_1static__vector.html">pos</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gadcb98500899c20e944fba12d8ffb7f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:gadcb98500899c20e944fba12d8ffb7f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5434e69ae82b361a3b7cb108a6f46d75" id="r_ga5434e69ae82b361a3b7cb108a6f46d75"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga5434e69ae82b361a3b7cb108a6f46d75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga5434e69ae82b361a3b7cb108a6f46d75">test_bit</a> (UInt <a class="el" href="structetl_1_1static__vector.html">word</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga5434e69ae82b361a3b7cb108a6f46d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test bit at position <code>Pos</code>  <br /></td></tr>
<tr class="separator:ga5434e69ae82b361a3b7cb108a6f46d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaaf991a15c82d1ea08c9932f513126" id="r_a6eaaf991a15c82d1ea08c9932f513126"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:a6eaaf991a15c82d1ea08c9932f513126"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6eaaf991a15c82d1ea08c9932f513126">operator&amp;</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:a6eaaf991a15c82d1ea08c9932f513126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary AND between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:a6eaaf991a15c82d1ea08c9932f513126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad704bd3a387f58880d2d97024dea9e71" id="r_ad704bd3a387f58880d2d97024dea9e71"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:ad704bd3a387f58880d2d97024dea9e71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad704bd3a387f58880d2d97024dea9e71">operator|</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:ad704bd3a387f58880d2d97024dea9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary OR between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:ad704bd3a387f58880d2d97024dea9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7238e53a5804e54ed1c1fbeb962f74b1" id="r_a7238e53a5804e54ed1c1fbeb962f74b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:a7238e53a5804e54ed1c1fbeb962f74b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7238e53a5804e54ed1c1fbeb962f74b1">operator^</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:a7238e53a5804e54ed1c1fbeb962f74b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary XOR between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:a7238e53a5804e54ed1c1fbeb962f74b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57d9658b5bfda3c9dc53d1a0bd95ca7" id="r_ad57d9658b5bfda3c9dc53d1a0bd95ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad57d9658b5bfda3c9dc53d1a0bd95ca7">default_assert_handler</a> (<a class="el" href="structetl_1_1assert__msg.html">assert_msg</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">msg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ad57d9658b5bfda3c9dc53d1a0bd95ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default assert handler. This will be called, if an assertion is triggered at runtime.  <br /></td></tr>
<tr class="separator:ad57d9658b5bfda3c9dc53d1a0bd95ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebfa4dc6da592b5c2d73f10ba7490dc" id="r_a0ebfa4dc6da592b5c2d73f10ba7490dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ebfa4dc6da592b5c2d73f10ba7490dc">isalnum</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a0ebfa4dc6da592b5c2d73f10ba7490dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is an alphanumeric character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a0ebfa4dc6da592b5c2d73f10ba7490dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ad095d93b811823b48e7b0486be7de" id="r_a89ad095d93b811823b48e7b0486be7de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89ad095d93b811823b48e7b0486be7de">isalpha</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a89ad095d93b811823b48e7b0486be7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is an alphabetic character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a89ad095d93b811823b48e7b0486be7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca9707732972162ec02317639d2154b" id="r_acca9707732972162ec02317639d2154b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acca9707732972162ec02317639d2154b">isblank</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:acca9707732972162ec02317639d2154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank characters.  <br /></td></tr>
<tr class="separator:acca9707732972162ec02317639d2154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037d91a684e54521c31eefa609c57f0f" id="r_a037d91a684e54521c31eefa609c57f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a037d91a684e54521c31eefa609c57f0f">iscntrl</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a037d91a684e54521c31eefa609c57f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a control character as classified by the currently installed C locale. In the default, "C" locale, the control characters are the characters with the codes 0x00-0x1F and 0x7F.  <br /></td></tr>
<tr class="separator:a037d91a684e54521c31eefa609c57f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743aaa8e35549baecb60a7a37fbccb7a" id="r_a743aaa8e35549baecb60a7a37fbccb7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a743aaa8e35549baecb60a7a37fbccb7a">isdigit</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a743aaa8e35549baecb60a7a37fbccb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is one of the 10 decimal digits: 0123456789.  <br /></td></tr>
<tr class="separator:a743aaa8e35549baecb60a7a37fbccb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcb7b22dcd166bd67a94b6b7f7da42e" id="r_a3fcb7b22dcd166bd67a94b6b7f7da42e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fcb7b22dcd166bd67a94b6b7f7da42e">isgraph</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a3fcb7b22dcd166bd67a94b6b7f7da42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is graphic (has a graphical representation) as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a3fcb7b22dcd166bd67a94b6b7f7da42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334ab4709b4cf8c1f5053016825c3bd7" id="r_a334ab4709b4cf8c1f5053016825c3bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a334ab4709b4cf8c1f5053016825c3bd7">islower</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a334ab4709b4cf8c1f5053016825c3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is classified as a lowercase character according to the default C locale.  <br /></td></tr>
<tr class="separator:a334ab4709b4cf8c1f5053016825c3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da49fe7c1e61918bbf7dd210e655d8c" id="r_a8da49fe7c1e61918bbf7dd210e655d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8da49fe7c1e61918bbf7dd210e655d8c">isprint</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a8da49fe7c1e61918bbf7dd210e655d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if ch is a printable character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a8da49fe7c1e61918bbf7dd210e655d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531a127903fbd0d7545d9a69bf13bb3c" id="r_a531a127903fbd0d7545d9a69bf13bb3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a531a127903fbd0d7545d9a69bf13bb3c">ispunct</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a531a127903fbd0d7545d9a69bf13bb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a punctuation character as classified by the current C locale.  <br /></td></tr>
<tr class="separator:a531a127903fbd0d7545d9a69bf13bb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c87145259e2ce0061ac810fee723978" id="r_a3c87145259e2ce0061ac810fee723978"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c87145259e2ce0061ac810fee723978">isspace</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a3c87145259e2ce0061ac810fee723978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is whitespace character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:a3c87145259e2ce0061ac810fee723978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1e3ecf65c20a6bd5f0b06139694269" id="r_a2b1e3ecf65c20a6bd5f0b06139694269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b1e3ecf65c20a6bd5f0b06139694269">isupper</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a2b1e3ecf65c20a6bd5f0b06139694269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is classified as a uppercase character according to the default C locale.  <br /></td></tr>
<tr class="separator:a2b1e3ecf65c20a6bd5f0b06139694269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b0bd8474428652100d3db55092e788" id="r_a77b0bd8474428652100d3db55092e788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b0bd8474428652100d3db55092e788">isxdigit</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a77b0bd8474428652100d3db55092e788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF).  <br /></td></tr>
<tr class="separator:a77b0bd8474428652100d3db55092e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b969e80e81b5a412d56884fc5bfcf2" id="r_a25b969e80e81b5a412d56884fc5bfcf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b969e80e81b5a412d56884fc5bfcf2">tolower</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a25b969e80e81b5a412d56884fc5bfcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given character to lowercase according to the character conversion rules defined by the default C locale.  <br /></td></tr>
<tr class="separator:a25b969e80e81b5a412d56884fc5bfcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b46f5faca236c0de0b9f378c22498c1" id="r_a2b46f5faca236c0de0b9f378c22498c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b46f5faca236c0de0b9f378c22498c1">toupper</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a2b46f5faca236c0de0b9f378c22498c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given character to uppercase according to the character conversion rules defined by the default C locale.  <br /></td></tr>
<tr class="separator:a2b46f5faca236c0de0b9f378c22498c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1ffcebf3ee4f04cf5987def83d0070" id="r_a1c1ffcebf3ee4f04cf5987def83d0070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c1ffcebf3ee4f04cf5987def83d0070">isfinite</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a1c1ffcebf3ee4f04cf5987def83d0070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587d2d42acd3ff40d56a98cdb84e1f57" id="r_a587d2d42acd3ff40d56a98cdb84e1f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a587d2d42acd3ff40d56a98cdb84e1f57">isinf</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a587d2d42acd3ff40d56a98cdb84e1f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8311e8c453fbb5b2e5eea1ed6aead74" id="r_ae8311e8c453fbb5b2e5eea1ed6aead74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8311e8c453fbb5b2e5eea1ed6aead74">isnan</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ae8311e8c453fbb5b2e5eea1ed6aead74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8840adb5e14e1239b4830cdd7e17f29" id="r_ab8840adb5e14e1239b4830cdd7e17f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8840adb5e14e1239b4830cdd7e17f29">isnormal</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ab8840adb5e14e1239b4830cdd7e17f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f672431014d52f52f9ce327fd19b81" id="r_a92f672431014d52f52f9ce327fd19b81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92f672431014d52f52f9ce327fd19b81">signbit</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a92f672431014d52f52f9ce327fd19b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606fa196e600b047397336663f1c7141" id="r_a606fa196e600b047397336663f1c7141"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> same_as&lt;<a class="el" href="structetl_1_1static__vector.html">Int</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</td></tr>
<tr class="memitem:a606fa196e600b047397336663f1c7141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a606fa196e600b047397336663f1c7141">from_chars</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *first, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *last, <a class="el" href="structetl_1_1static__vector.html">Int</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:a606fa196e600b047397336663f1c7141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.  <br /></td></tr>
<tr class="separator:a606fa196e600b047397336663f1c7141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa470408e7403e4491a6a9e5c8f0d81" id="r_affa470408e7403e4491a6a9e5c8f0d81"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> same_as&lt;T, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</td></tr>
<tr class="memitem:affa470408e7403e4491a6a9e5c8f0d81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affa470408e7403e4491a6a9e5c8f0d81">to_chars</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *first, <a class="el" href="structetl_1_1static__vector.html">char</a> *last, T val, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:affa470408e7403e4491a6a9e5c8f0d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <br /></td></tr>
<tr class="separator:affa470408e7403e4491a6a9e5c8f0d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3b3e7cc2dd468ee65c7ba76269f690" id="r_a4e3b3e7cc2dd468ee65c7ba76269f690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e3b3e7cc2dd468ee65c7ba76269f690">to_chars</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *, <a class="el" href="structetl_1_1static__vector.html">char</a> *, <a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">int</a>=10) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a4e3b3e7cc2dd468ee65c7ba76269f690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4847ea4260b5b202b578c17d63084aa8" id="r_a4847ea4260b5b202b578c17d63084aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a4847ea4260b5b202b578c17d63084aa8">operator&quot;&quot;_d</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> d) noexcept -&gt; <a class="el" href="structetl_1_1chrono_1_1day.html">etl::chrono::day</a></td></tr>
<tr class="memdesc:a4847ea4260b5b202b578c17d63084aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1day.html">etl::chrono::day</a> literal representing a day of the month in the calendar.  <br /></td></tr>
<tr class="separator:a4847ea4260b5b202b578c17d63084aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af259e8983c5c9a8c67cf23ad8d93b741" id="r_af259e8983c5c9a8c67cf23ad8d93b741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#af259e8983c5c9a8c67cf23ad8d93b741">operator&quot;&quot;_h</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> h) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a22dea9c3d564ff82ce631f137b0fe700">etl::chrono::hours</a></td></tr>
<tr class="memdesc:af259e8983c5c9a8c67cf23ad8d93b741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing hours. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#a22dea9c3d564ff82ce631f137b0fe700" title="Signed integer type of at least 23 bits.">etl::chrono::hours(hrs)</a>.  <br /></td></tr>
<tr class="separator:af259e8983c5c9a8c67cf23ad8d93b741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128aff56d683f6eadda3bc77941936de" id="r_a128aff56d683f6eadda3bc77941936de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a128aff56d683f6eadda3bc77941936de">operator&quot;&quot;_h</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> h) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 3600, 1 &gt; &gt;</td></tr>
<tr class="memdesc:a128aff56d683f6eadda3bc77941936de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing hours. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a22dea9c3d564ff82ce631f137b0fe700" title="Signed integer type of at least 23 bits.">etl::chrono::hours</a>.  <br /></td></tr>
<tr class="separator:a128aff56d683f6eadda3bc77941936de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562a8614a008f75de13f9aa86715a51d" id="r_a562a8614a008f75de13f9aa86715a51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a562a8614a008f75de13f9aa86715a51d">operator&quot;&quot;_min</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#ae99afa66623386844295e24a1adfcf17">etl::chrono::minutes</a></td></tr>
<tr class="memdesc:a562a8614a008f75de13f9aa86715a51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing minutes. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#ae99afa66623386844295e24a1adfcf17" title="Signed integer type of at least 29 bits.">etl::chrono::minutes(mins)</a>.  <br /></td></tr>
<tr class="separator:a562a8614a008f75de13f9aa86715a51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ceac04bc8536a71eb35464b6cf322f" id="r_a87ceac04bc8536a71eb35464b6cf322f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a87ceac04bc8536a71eb35464b6cf322f">operator&quot;&quot;_min</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="structetl_1_1ratio.html">etl::ratio</a>&lt; 60, 1 &gt; &gt;</td></tr>
<tr class="memdesc:a87ceac04bc8536a71eb35464b6cf322f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing minutes. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#ae99afa66623386844295e24a1adfcf17" title="Signed integer type of at least 29 bits.">etl::chrono::minutes</a>.  <br /></td></tr>
<tr class="separator:a87ceac04bc8536a71eb35464b6cf322f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6279af29ee2e857c794e7cb76dd6f168" id="r_a6279af29ee2e857c794e7cb76dd6f168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a6279af29ee2e857c794e7cb76dd6f168">operator&quot;&quot;_s</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#ab0bf89c241f55b3ca330a6cfc2cdf746">etl::chrono::seconds</a></td></tr>
<tr class="memdesc:a6279af29ee2e857c794e7cb76dd6f168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing seconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#ab0bf89c241f55b3ca330a6cfc2cdf746" title="Signed integer type of at least 35 bits.">etl::chrono::seconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a6279af29ee2e857c794e7cb76dd6f168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a70f7deb8345abdf86d83d8cb728a4" id="r_a93a70f7deb8345abdf86d83d8cb728a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a93a70f7deb8345abdf86d83d8cb728a4">operator&quot;&quot;_s</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="memdesc:a93a70f7deb8345abdf86d83d8cb728a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing seconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#ab0bf89c241f55b3ca330a6cfc2cdf746" title="Signed integer type of at least 35 bits.">etl::chrono::seconds</a>.  <br /></td></tr>
<tr class="separator:a93a70f7deb8345abdf86d83d8cb728a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8644fbcb9057be1a715c64434a21ba4a" id="r_a8644fbcb9057be1a715c64434a21ba4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a8644fbcb9057be1a715c64434a21ba4a">operator&quot;&quot;_ms</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#aadfbf1634ecc6662580dc657767443f0">etl::chrono::milliseconds</a></td></tr>
<tr class="memdesc:a8644fbcb9057be1a715c64434a21ba4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing milliseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#aadfbf1634ecc6662580dc657767443f0" title="Signed integer type of at least 45 bits.">etl::chrono::milliseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a8644fbcb9057be1a715c64434a21ba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb10e271592550fb371f1023a28a0e30" id="r_adb10e271592550fb371f1023a28a0e30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#adb10e271592550fb371f1023a28a0e30">operator&quot;&quot;_ms</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="#acd9927a0f0f2ea2485adb9fe6fc78420">etl::milli</a> &gt;</td></tr>
<tr class="memdesc:adb10e271592550fb371f1023a28a0e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing milliseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#aadfbf1634ecc6662580dc657767443f0" title="Signed integer type of at least 45 bits.">etl::chrono::milliseconds</a>.  <br /></td></tr>
<tr class="separator:adb10e271592550fb371f1023a28a0e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ef0829e29219b2ab6327f4de8a7c13" id="r_a56ef0829e29219b2ab6327f4de8a7c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a56ef0829e29219b2ab6327f4de8a7c13">operator&quot;&quot;_us</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a77f7f4f8c95a704f9a116447c4f20326">etl::chrono::microseconds</a></td></tr>
<tr class="memdesc:a56ef0829e29219b2ab6327f4de8a7c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing microseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#a77f7f4f8c95a704f9a116447c4f20326" title="Signed integer type of at least 55 bits.">etl::chrono::microseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a56ef0829e29219b2ab6327f4de8a7c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9627a966c293803c6800e039705a129" id="r_aa9627a966c293803c6800e039705a129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#aa9627a966c293803c6800e039705a129">operator&quot;&quot;_us</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="#a790708917957bff608703092eecec315">etl::micro</a> &gt;</td></tr>
<tr class="memdesc:aa9627a966c293803c6800e039705a129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing microseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a77f7f4f8c95a704f9a116447c4f20326" title="Signed integer type of at least 55 bits.">etl::chrono::microseconds</a>.  <br /></td></tr>
<tr class="separator:aa9627a966c293803c6800e039705a129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27e56cd9d11bb474497b44ac055ab65" id="r_af27e56cd9d11bb474497b44ac055ab65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#af27e56cd9d11bb474497b44ac055ab65">operator&quot;&quot;_ns</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#af0192a737b530312d99b92863986be70">etl::chrono::nanoseconds</a></td></tr>
<tr class="memdesc:af27e56cd9d11bb474497b44ac055ab65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing nanoseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#af0192a737b530312d99b92863986be70" title="Signed integer type of at least 64 bits.">etl::chrono::nanoseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:af27e56cd9d11bb474497b44ac055ab65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb3a78ec03bd717efe7ae4f4f0e2d7" id="r_ac6bb3a78ec03bd717efe7ae4f4f0e2d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#ac6bb3a78ec03bd717efe7ae4f4f0e2d7">operator&quot;&quot;_ns</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>, <a class="el" href="#a3ebbaf9de296934c9320b7b32932be3f">etl::nano</a> &gt;</td></tr>
<tr class="memdesc:ac6bb3a78ec03bd717efe7ae4f4f0e2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing nanoseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#af0192a737b530312d99b92863986be70" title="Signed integer type of at least 64 bits.">etl::chrono::nanoseconds</a>.  <br /></td></tr>
<tr class="separator:ac6bb3a78ec03bd717efe7ae4f4f0e2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ace77006d897bb11f9e75fc01c6d54" id="r_gad9ace77006d897bb11f9e75fc01c6d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad9ace77006d897bb11f9e75fc01c6d54">acos</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gad9ace77006d897bb11f9e75fc01c6d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:gad9ace77006d897bb11f9e75fc01c6d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d6dec7881376a3795507e224cfc794" id="r_gad6d6dec7881376a3795507e224cfc794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad6d6dec7881376a3795507e224cfc794">acosf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gad6d6dec7881376a3795507e224cfc794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:gad6d6dec7881376a3795507e224cfc794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4747095fd6649df58b77e797a7b6a4ae" id="r_ga4747095fd6649df58b77e797a7b6a4ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4747095fd6649df58b77e797a7b6a4ae">acos</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga4747095fd6649df58b77e797a7b6a4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:ga4747095fd6649df58b77e797a7b6a4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab37e22cd4d9b76197860d41f6d61722" id="r_gaab37e22cd4d9b76197860d41f6d61722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaab37e22cd4d9b76197860d41f6d61722">acos</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaab37e22cd4d9b76197860d41f6d61722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:gaab37e22cd4d9b76197860d41f6d61722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f170557969dafd889c9c4af8c86e6f7" id="r_ga1f170557969dafd889c9c4af8c86e6f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1f170557969dafd889c9c4af8c86e6f7">acosl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga1f170557969dafd889c9c4af8c86e6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:ga1f170557969dafd889c9c4af8c86e6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ca6badc84ba20bc9540c1aecd9ed972" id="r_ga5ca6badc84ba20bc9540c1aecd9ed972"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga5ca6badc84ba20bc9540c1aecd9ed972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5ca6badc84ba20bc9540c1aecd9ed972">acos</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga5ca6badc84ba20bc9540c1aecd9ed972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc cosine of arg.  <br /></td></tr>
<tr class="separator:ga5ca6badc84ba20bc9540c1aecd9ed972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90cae0f69c6df3ad62b9d18a2edfe8bd" id="r_ga90cae0f69c6df3ad62b9d18a2edfe8bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga90cae0f69c6df3ad62b9d18a2edfe8bd">acosh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga90cae0f69c6df3ad62b9d18a2edfe8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga90cae0f69c6df3ad62b9d18a2edfe8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf8da6a971811befc7625a7c6a9c0bf" id="r_gaadf8da6a971811befc7625a7c6a9c0bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaadf8da6a971811befc7625a7c6a9c0bf">acoshf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaadf8da6a971811befc7625a7c6a9c0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gaadf8da6a971811befc7625a7c6a9c0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f78ba5c1b76fcd56f3de95d66338445" id="r_ga3f78ba5c1b76fcd56f3de95d66338445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3f78ba5c1b76fcd56f3de95d66338445">acosh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga3f78ba5c1b76fcd56f3de95d66338445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga3f78ba5c1b76fcd56f3de95d66338445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d388cd651b91d71eeac81bec72bcf1" id="r_ga24d388cd651b91d71eeac81bec72bcf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga24d388cd651b91d71eeac81bec72bcf1">acosh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga24d388cd651b91d71eeac81bec72bcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga24d388cd651b91d71eeac81bec72bcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd4f8c867eb336638c2e85925a11ceb" id="r_ga8cd4f8c867eb336638c2e85925a11ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8cd4f8c867eb336638c2e85925a11ceb">acoshl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga8cd4f8c867eb336638c2e85925a11ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ga8cd4f8c867eb336638c2e85925a11ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa208046cad1bdd0cefca2833574c9dfa" id="r_gaa208046cad1bdd0cefca2833574c9dfa"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gaa208046cad1bdd0cefca2833574c9dfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa208046cad1bdd0cefca2833574c9dfa">acosh</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaa208046cad1bdd0cefca2833574c9dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:gaa208046cad1bdd0cefca2833574c9dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3fb71bd1279ffa3c0ac934adeec55b1" id="r_gaa3fb71bd1279ffa3c0ac934adeec55b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa3fb71bd1279ffa3c0ac934adeec55b1">asin</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaa3fb71bd1279ffa3c0ac934adeec55b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:gaa3fb71bd1279ffa3c0ac934adeec55b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33eb37ff3fb73d04a8d0b6f1a8edf312" id="r_ga33eb37ff3fb73d04a8d0b6f1a8edf312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga33eb37ff3fb73d04a8d0b6f1a8edf312">asinf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga33eb37ff3fb73d04a8d0b6f1a8edf312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga33eb37ff3fb73d04a8d0b6f1a8edf312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5d32ddd2f8d6786e0f347bbfa9f453" id="r_gafd5d32ddd2f8d6786e0f347bbfa9f453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gafd5d32ddd2f8d6786e0f347bbfa9f453">asin</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gafd5d32ddd2f8d6786e0f347bbfa9f453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:gafd5d32ddd2f8d6786e0f347bbfa9f453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74316d1000b469ad778ba8be2a7a837d" id="r_ga74316d1000b469ad778ba8be2a7a837d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga74316d1000b469ad778ba8be2a7a837d">asin</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga74316d1000b469ad778ba8be2a7a837d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga74316d1000b469ad778ba8be2a7a837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938272f1d29c45dfeab834395bca9635" id="r_ga938272f1d29c45dfeab834395bca9635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga938272f1d29c45dfeab834395bca9635">asinl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga938272f1d29c45dfeab834395bca9635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga938272f1d29c45dfeab834395bca9635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621a072ae9ca2d5a6e7156b82595c520" id="r_ga621a072ae9ca2d5a6e7156b82595c520"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga621a072ae9ca2d5a6e7156b82595c520"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga621a072ae9ca2d5a6e7156b82595c520">asin</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga621a072ae9ca2d5a6e7156b82595c520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc sine of arg.  <br /></td></tr>
<tr class="separator:ga621a072ae9ca2d5a6e7156b82595c520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8f020e1fb089580ce1ce2e92007d03" id="r_gaea8f020e1fb089580ce1ce2e92007d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaea8f020e1fb089580ce1ce2e92007d03">asinh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gaea8f020e1fb089580ce1ce2e92007d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gaea8f020e1fb089580ce1ce2e92007d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac985377c2d80c7a118366794fd0e660a" id="r_gac985377c2d80c7a118366794fd0e660a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac985377c2d80c7a118366794fd0e660a">asinhf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gac985377c2d80c7a118366794fd0e660a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gac985377c2d80c7a118366794fd0e660a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922efdb95c11f4715bcbde248c8079d8" id="r_ga922efdb95c11f4715bcbde248c8079d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga922efdb95c11f4715bcbde248c8079d8">asinh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga922efdb95c11f4715bcbde248c8079d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga922efdb95c11f4715bcbde248c8079d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad13ae7860d3df16f57de06f8f8eac566" id="r_gad13ae7860d3df16f57de06f8f8eac566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad13ae7860d3df16f57de06f8f8eac566">asinh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gad13ae7860d3df16f57de06f8f8eac566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gad13ae7860d3df16f57de06f8f8eac566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3742eb491fd2e6a7f8173cb7bbfd01be" id="r_ga3742eb491fd2e6a7f8173cb7bbfd01be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3742eb491fd2e6a7f8173cb7bbfd01be">asinhl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga3742eb491fd2e6a7f8173cb7bbfd01be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga3742eb491fd2e6a7f8173cb7bbfd01be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979329f95265c316f75cda198a8c6219" id="r_ga979329f95265c316f75cda198a8c6219"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga979329f95265c316f75cda198a8c6219"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga979329f95265c316f75cda198a8c6219">asinh</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga979329f95265c316f75cda198a8c6219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga979329f95265c316f75cda198a8c6219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65f8ad4a2909bbebbccfd140525f7c8f" id="r_ga65f8ad4a2909bbebbccfd140525f7c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga65f8ad4a2909bbebbccfd140525f7c8f">atan</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga65f8ad4a2909bbebbccfd140525f7c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:ga65f8ad4a2909bbebbccfd140525f7c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953ddfaa8dc761bf2a3cae7cf03ec743" id="r_ga953ddfaa8dc761bf2a3cae7cf03ec743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga953ddfaa8dc761bf2a3cae7cf03ec743">atanf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga953ddfaa8dc761bf2a3cae7cf03ec743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:ga953ddfaa8dc761bf2a3cae7cf03ec743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11dbb4af5e9f689d738347804fd05f90" id="r_ga11dbb4af5e9f689d738347804fd05f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga11dbb4af5e9f689d738347804fd05f90">atan</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga11dbb4af5e9f689d738347804fd05f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:ga11dbb4af5e9f689d738347804fd05f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b8a8b9108f9ce5f69505e9152a659d7" id="r_ga2b8a8b9108f9ce5f69505e9152a659d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2b8a8b9108f9ce5f69505e9152a659d7">atan</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga2b8a8b9108f9ce5f69505e9152a659d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:ga2b8a8b9108f9ce5f69505e9152a659d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab422245244dbf22608b198e007417b9d" id="r_gab422245244dbf22608b198e007417b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab422245244dbf22608b198e007417b9d">atanl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gab422245244dbf22608b198e007417b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:gab422245244dbf22608b198e007417b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76f32464a65bbf8c839d67f702b2c81" id="r_gab76f32464a65bbf8c839d67f702b2c81"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gab76f32464a65bbf8c839d67f702b2c81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab76f32464a65bbf8c839d67f702b2c81">atan</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gab76f32464a65bbf8c839d67f702b2c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the principal value of the arc tangent of arg.  <br /></td></tr>
<tr class="separator:gab76f32464a65bbf8c839d67f702b2c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2b99c8ac12b4ede3490b55bc38ace7" id="r_ga3d2b99c8ac12b4ede3490b55bc38ace7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3d2b99c8ac12b4ede3490b55bc38ace7">atan2</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga3d2b99c8ac12b4ede3490b55bc38ace7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:ga3d2b99c8ac12b4ede3490b55bc38ace7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b28d5ed840d65898bb4bc7663cc6813" id="r_ga8b28d5ed840d65898bb4bc7663cc6813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8b28d5ed840d65898bb4bc7663cc6813">atan2f</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga8b28d5ed840d65898bb4bc7663cc6813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:ga8b28d5ed840d65898bb4bc7663cc6813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5900f3d1e6a74988a7f45cd04a3627ae" id="r_ga5900f3d1e6a74988a7f45cd04a3627ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5900f3d1e6a74988a7f45cd04a3627ae">atan2</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga5900f3d1e6a74988a7f45cd04a3627ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:ga5900f3d1e6a74988a7f45cd04a3627ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6967d95f89156650197ea75f1f3ba7" id="r_ga2c6967d95f89156650197ea75f1f3ba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2c6967d95f89156650197ea75f1f3ba7">atan2</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga2c6967d95f89156650197ea75f1f3ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:ga2c6967d95f89156650197ea75f1f3ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga037863b294d960041c163520b22381e1" id="r_ga037863b294d960041c163520b22381e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga037863b294d960041c163520b22381e1">atan2l</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga037863b294d960041c163520b22381e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:ga037863b294d960041c163520b22381e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12216cfa04c0976057427be27c64c696" id="r_ga12216cfa04c0976057427be27c64c696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga12216cfa04c0976057427be27c64c696">atanh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga12216cfa04c0976057427be27c64c696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga12216cfa04c0976057427be27c64c696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8783263cfdd3d32199d0cc1257e0c04c" id="r_ga8783263cfdd3d32199d0cc1257e0c04c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8783263cfdd3d32199d0cc1257e0c04c">atanhf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga8783263cfdd3d32199d0cc1257e0c04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga8783263cfdd3d32199d0cc1257e0c04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb11729ba246f5a4098bc553a292295" id="r_gaabb11729ba246f5a4098bc553a292295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaabb11729ba246f5a4098bc553a292295">atanh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaabb11729ba246f5a4098bc553a292295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:gaabb11729ba246f5a4098bc553a292295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6def40d7b11e3e930b6bc1927d8aff69" id="r_ga6def40d7b11e3e930b6bc1927d8aff69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6def40d7b11e3e930b6bc1927d8aff69">atanh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga6def40d7b11e3e930b6bc1927d8aff69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga6def40d7b11e3e930b6bc1927d8aff69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6c389cab358ec81ddee4010aa8f450" id="r_ga6e6c389cab358ec81ddee4010aa8f450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6e6c389cab358ec81ddee4010aa8f450">atanhl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga6e6c389cab358ec81ddee4010aa8f450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga6e6c389cab358ec81ddee4010aa8f450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dbab5667618a4498791559fed34db3b" id="r_ga0dbab5667618a4498791559fed34db3b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga0dbab5667618a4498791559fed34db3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0dbab5667618a4498791559fed34db3b">atanh</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga0dbab5667618a4498791559fed34db3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:ga0dbab5667618a4498791559fed34db3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd33d209fa34a26154dec7971f43ce9" id="r_gaefd33d209fa34a26154dec7971f43ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaefd33d209fa34a26154dec7971f43ce9">beta</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaefd33d209fa34a26154dec7971f43ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y.  <br /></td></tr>
<tr class="separator:gaefd33d209fa34a26154dec7971f43ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb892bd770281574939e288765165ea" id="r_ga5bb892bd770281574939e288765165ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5bb892bd770281574939e288765165ea">betaf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga5bb892bd770281574939e288765165ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y.  <br /></td></tr>
<tr class="separator:ga5bb892bd770281574939e288765165ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1572e65836d75f30b200de7dd2cdc272" id="r_ga1572e65836d75f30b200de7dd2cdc272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1572e65836d75f30b200de7dd2cdc272">betal</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga1572e65836d75f30b200de7dd2cdc272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the beta function of x and y.  <br /></td></tr>
<tr class="separator:ga1572e65836d75f30b200de7dd2cdc272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8714f7ac18944189736a0c986f88b950" id="r_ga8714f7ac18944189736a0c986f88b950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8714f7ac18944189736a0c986f88b950">ceil</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga8714f7ac18944189736a0c986f88b950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:ga8714f7ac18944189736a0c986f88b950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c45cc3c430eb3f9bfbbf4c573faefe" id="r_gae7c45cc3c430eb3f9bfbbf4c573faefe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae7c45cc3c430eb3f9bfbbf4c573faefe">ceilf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:gae7c45cc3c430eb3f9bfbbf4c573faefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:gae7c45cc3c430eb3f9bfbbf4c573faefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199b60a1d291d73e6a88cb7688fcc6b7" id="r_ga199b60a1d291d73e6a88cb7688fcc6b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga199b60a1d291d73e6a88cb7688fcc6b7">ceil</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga199b60a1d291d73e6a88cb7688fcc6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:ga199b60a1d291d73e6a88cb7688fcc6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd0ff04f746f500187517b5b60f48a7" id="r_gaacd0ff04f746f500187517b5b60f48a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaacd0ff04f746f500187517b5b60f48a7">ceil</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaacd0ff04f746f500187517b5b60f48a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:gaacd0ff04f746f500187517b5b60f48a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee2633ec94191433e72d07c9d85cee3" id="r_gafee2633ec94191433e72d07c9d85cee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gafee2633ec94191433e72d07c9d85cee3">ceill</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gafee2633ec94191433e72d07c9d85cee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:gafee2633ec94191433e72d07c9d85cee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga263d08d9bc4ecbeaaed9467440a5fd6b" id="r_ga263d08d9bc4ecbeaaed9467440a5fd6b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga263d08d9bc4ecbeaaed9467440a5fd6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga263d08d9bc4ecbeaaed9467440a5fd6b">ceil</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga263d08d9bc4ecbeaaed9467440a5fd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the smallest integer value not less than arg.  <br /></td></tr>
<tr class="separator:ga263d08d9bc4ecbeaaed9467440a5fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17223939b148fdd815e90f732a5d2ed8" id="r_ga17223939b148fdd815e90f732a5d2ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga17223939b148fdd815e90f732a5d2ed8">copysign</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga17223939b148fdd815e90f732a5d2ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga17223939b148fdd815e90f732a5d2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a3b66b7eaf7fba405c4fabd12b9032" id="r_ga74a3b66b7eaf7fba405c4fabd12b9032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga74a3b66b7eaf7fba405c4fabd12b9032">copysignf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga74a3b66b7eaf7fba405c4fabd12b9032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga74a3b66b7eaf7fba405c4fabd12b9032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c9633a12193b92425f88a20c5f991da" id="r_ga4c9633a12193b92425f88a20c5f991da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4c9633a12193b92425f88a20c5f991da">copysign</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga4c9633a12193b92425f88a20c5f991da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga4c9633a12193b92425f88a20c5f991da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f0ba6ef64b11393c3807cdc25ecc2b" id="r_ga12f0ba6ef64b11393c3807cdc25ecc2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga12f0ba6ef64b11393c3807cdc25ecc2b">copysign</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga12f0ba6ef64b11393c3807cdc25ecc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga12f0ba6ef64b11393c3807cdc25ecc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b8f4abe1c15892a342be040ed0e231" id="r_ga61b8f4abe1c15892a342be040ed0e231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga61b8f4abe1c15892a342be040ed0e231">copysignl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">mag</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="sgn_8hpp.html#a2d1c354640836f90c93cf33ac025b866">sgn</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga61b8f4abe1c15892a342be040ed0e231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a floating point value with the magnitude of mag and the sign of sgn.  <br /></td></tr>
<tr class="separator:ga61b8f4abe1c15892a342be040ed0e231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4906f1caf2586cc2563fc0faf2f7ea30" id="r_ga4906f1caf2586cc2563fc0faf2f7ea30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4906f1caf2586cc2563fc0faf2f7ea30">cos</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga4906f1caf2586cc2563fc0faf2f7ea30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga4906f1caf2586cc2563fc0faf2f7ea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d17a837d13ea55344804cb5c64322c" id="r_ga73d17a837d13ea55344804cb5c64322c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga73d17a837d13ea55344804cb5c64322c">cosf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga73d17a837d13ea55344804cb5c64322c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga73d17a837d13ea55344804cb5c64322c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab6c7ef0dbdd2323343636f79a74f8af" id="r_gaab6c7ef0dbdd2323343636f79a74f8af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaab6c7ef0dbdd2323343636f79a74f8af">cos</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaab6c7ef0dbdd2323343636f79a74f8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gaab6c7ef0dbdd2323343636f79a74f8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07734dc481f156ef3959fb891782b58f" id="r_ga07734dc481f156ef3959fb891782b58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga07734dc481f156ef3959fb891782b58f">cos</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga07734dc481f156ef3959fb891782b58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ga07734dc481f156ef3959fb891782b58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed9df8dfe51ba4bb2b189f503a7cdd75" id="r_gaed9df8dfe51ba4bb2b189f503a7cdd75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaed9df8dfe51ba4bb2b189f503a7cdd75">cosl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaed9df8dfe51ba4bb2b189f503a7cdd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gaed9df8dfe51ba4bb2b189f503a7cdd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e34ec5e84f9fb625cf7ee93df783c4" id="r_gaf4e34ec5e84f9fb625cf7ee93df783c4"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:gaf4e34ec5e84f9fb625cf7ee93df783c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf4e34ec5e84f9fb625cf7ee93df783c4">cos</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gaf4e34ec5e84f9fb625cf7ee93df783c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of arg (measured in radians).  <br /></td></tr>
<tr class="separator:gaf4e34ec5e84f9fb625cf7ee93df783c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b4314a7a0c72385ecb062322e815a" id="r_ab03b4314a7a0c72385ecb062322e815a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab03b4314a7a0c72385ecb062322e815a">cosh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ab03b4314a7a0c72385ecb062322e815a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:ab03b4314a7a0c72385ecb062322e815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2950fdc398f70b0545b2721f57deff" id="r_a4c2950fdc398f70b0545b2721f57deff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c2950fdc398f70b0545b2721f57deff">coshf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a4c2950fdc398f70b0545b2721f57deff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:a4c2950fdc398f70b0545b2721f57deff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c430223db452246c909a258dac5d01" id="r_a85c430223db452246c909a258dac5d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85c430223db452246c909a258dac5d01">cosh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a85c430223db452246c909a258dac5d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:a85c430223db452246c909a258dac5d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa686c109054fee0ccbe9233313fe5811" id="r_aa686c109054fee0ccbe9233313fe5811"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa686c109054fee0ccbe9233313fe5811">cosh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:aa686c109054fee0ccbe9233313fe5811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:aa686c109054fee0ccbe9233313fe5811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ea3e46f7aa043f3a6229e91281655d" id="r_a32ea3e46f7aa043f3a6229e91281655d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32ea3e46f7aa043f3a6229e91281655d">coshl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a32ea3e46f7aa043f3a6229e91281655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:a32ea3e46f7aa043f3a6229e91281655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0497aee842a4aa4f6a0d3c07af34bf27" id="r_a0497aee842a4aa4f6a0d3c07af34bf27"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a0497aee842a4aa4f6a0d3c07af34bf27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0497aee842a4aa4f6a0d3c07af34bf27">cosh</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a0497aee842a4aa4f6a0d3c07af34bf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic cosine of arg.  <br /></td></tr>
<tr class="separator:a0497aee842a4aa4f6a0d3c07af34bf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a87be7c2a7789cc2af84f5620b6ba0" id="r_a67a87be7c2a7789cc2af84f5620b6ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67a87be7c2a7789cc2af84f5620b6ba0">erf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a67a87be7c2a7789cc2af84f5620b6ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:a67a87be7c2a7789cc2af84f5620b6ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16b4888b71e83519b5ef69e90ea6956" id="r_ad16b4888b71e83519b5ef69e90ea6956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad16b4888b71e83519b5ef69e90ea6956">erff</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ad16b4888b71e83519b5ef69e90ea6956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:ad16b4888b71e83519b5ef69e90ea6956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf55df46265ad2dda32d84405c47185d" id="r_acf55df46265ad2dda32d84405c47185d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf55df46265ad2dda32d84405c47185d">erf</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:acf55df46265ad2dda32d84405c47185d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:acf55df46265ad2dda32d84405c47185d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ece4e3c2d0449f2cf42ca64c72eae5" id="r_a27ece4e3c2d0449f2cf42ca64c72eae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27ece4e3c2d0449f2cf42ca64c72eae5">erf</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a27ece4e3c2d0449f2cf42ca64c72eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:a27ece4e3c2d0449f2cf42ca64c72eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843da4273caef9b48e4cdfc9b7c2c369" id="r_a843da4273caef9b48e4cdfc9b7c2c369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a843da4273caef9b48e4cdfc9b7c2c369">erfl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a843da4273caef9b48e4cdfc9b7c2c369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:a843da4273caef9b48e4cdfc9b7c2c369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f46c302ddbc1a6e7a6fea6cfdc3ae2" id="r_ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4f46c302ddbc1a6e7a6fea6cfdc3ae2">erf</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of arg.  <br /></td></tr>
<tr class="separator:ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acc3b86f099266b7744b6cb388ed894" id="r_a9acc3b86f099266b7744b6cb388ed894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9acc3b86f099266b7744b6cb388ed894">exp</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a9acc3b86f099266b7744b6cb388ed894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:a9acc3b86f099266b7744b6cb388ed894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb2a8337db1101a51fa8bf0c9c93aff" id="r_a3bb2a8337db1101a51fa8bf0c9c93aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bb2a8337db1101a51fa8bf0c9c93aff">expf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a3bb2a8337db1101a51fa8bf0c9c93aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:a3bb2a8337db1101a51fa8bf0c9c93aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c94fca30d8f6813d56cd0db16e1f2af" id="r_a5c94fca30d8f6813d56cd0db16e1f2af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c94fca30d8f6813d56cd0db16e1f2af">exp</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a5c94fca30d8f6813d56cd0db16e1f2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:a5c94fca30d8f6813d56cd0db16e1f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f7208d978374f6fdc4b3caa77a5942" id="r_a92f7208d978374f6fdc4b3caa77a5942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92f7208d978374f6fdc4b3caa77a5942">exp</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a92f7208d978374f6fdc4b3caa77a5942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:a92f7208d978374f6fdc4b3caa77a5942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23063bd3e5e1848b1cd8f0adee2bdd0" id="r_ad23063bd3e5e1848b1cd8f0adee2bdd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad23063bd3e5e1848b1cd8f0adee2bdd0">expl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ad23063bd3e5e1848b1cd8f0adee2bdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:ad23063bd3e5e1848b1cd8f0adee2bdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a06161d90cdf8b9af35ddf334a8db2d" id="r_a8a06161d90cdf8b9af35ddf334a8db2d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a8a06161d90cdf8b9af35ddf334a8db2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a06161d90cdf8b9af35ddf334a8db2d">exp</a> (T <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a8a06161d90cdf8b9af35ddf334a8db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e (Euler's number, 2.7182...) raised to the given power v.  <br /></td></tr>
<tr class="separator:a8a06161d90cdf8b9af35ddf334a8db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0241333848ee2ec2b8a53dc9ba0e19e" id="r_af0241333848ee2ec2b8a53dc9ba0e19e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0241333848ee2ec2b8a53dc9ba0e19e">fdim</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:af0241333848ee2ec2b8a53dc9ba0e19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:af0241333848ee2ec2b8a53dc9ba0e19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e19893929bbc794be4206bec3f1ffa" id="r_ad8e19893929bbc794be4206bec3f1ffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8e19893929bbc794be4206bec3f1ffa">fdimf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ad8e19893929bbc794be4206bec3f1ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:ad8e19893929bbc794be4206bec3f1ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7954b159301cbd51a00f4159449458af" id="r_a7954b159301cbd51a00f4159449458af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7954b159301cbd51a00f4159449458af">fdim</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a7954b159301cbd51a00f4159449458af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:a7954b159301cbd51a00f4159449458af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b3f1bd599452cab3d60f96db64c0f7" id="r_a96b3f1bd599452cab3d60f96db64c0f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96b3f1bd599452cab3d60f96db64c0f7">fdim</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a96b3f1bd599452cab3d60f96db64c0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:a96b3f1bd599452cab3d60f96db64c0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7dc714d464e428c74c9f4082a93ea2" id="r_a9f7dc714d464e428c74c9f4082a93ea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f7dc714d464e428c74c9f4082a93ea2">fdiml</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a9f7dc714d464e428c74c9f4082a93ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0.  <br /></td></tr>
<tr class="separator:a9f7dc714d464e428c74c9f4082a93ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177bda599c52cf225f0288ec9043b8bb" id="r_a177bda599c52cf225f0288ec9043b8bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a177bda599c52cf225f0288ec9043b8bb">floor</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a177bda599c52cf225f0288ec9043b8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:a177bda599c52cf225f0288ec9043b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e3263a0f395c13cab460b75b0f55ef" id="r_ac9e3263a0f395c13cab460b75b0f55ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9e3263a0f395c13cab460b75b0f55ef">floorf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ac9e3263a0f395c13cab460b75b0f55ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:ac9e3263a0f395c13cab460b75b0f55ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6604cf790ab829d40c3b4daa730c7c08" id="r_a6604cf790ab829d40c3b4daa730c7c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6604cf790ab829d40c3b4daa730c7c08">floor</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a6604cf790ab829d40c3b4daa730c7c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:a6604cf790ab829d40c3b4daa730c7c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5790bd430f29dc6eeced561fa3a5c054" id="r_a5790bd430f29dc6eeced561fa3a5c054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5790bd430f29dc6eeced561fa3a5c054">floor</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a5790bd430f29dc6eeced561fa3a5c054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:a5790bd430f29dc6eeced561fa3a5c054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2443c1dedde3d2c7efcbffd1c5fa693" id="r_ab2443c1dedde3d2c7efcbffd1c5fa693"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2443c1dedde3d2c7efcbffd1c5fa693">floorl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ab2443c1dedde3d2c7efcbffd1c5fa693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:ab2443c1dedde3d2c7efcbffd1c5fa693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61d4eb26e65da7afe6e0c669e78967b" id="r_af61d4eb26e65da7afe6e0c669e78967b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:af61d4eb26e65da7afe6e0c669e78967b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af61d4eb26e65da7afe6e0c669e78967b">floor</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:af61d4eb26e65da7afe6e0c669e78967b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the largest integer value not greater than arg.  <br /></td></tr>
<tr class="separator:af61d4eb26e65da7afe6e0c669e78967b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e7db11940223760db9220304003446" id="r_a69e7db11940223760db9220304003446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69e7db11940223760db9220304003446">fma</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a69e7db11940223760db9220304003446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:a69e7db11940223760db9220304003446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1060e4829c9f215f998aa669f07907fe" id="r_a1060e4829c9f215f998aa669f07907fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1060e4829c9f215f998aa669f07907fe">fmaf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a1060e4829c9f215f998aa669f07907fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:a1060e4829c9f215f998aa669f07907fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa52aafdd0d75fd5757bc6048241627" id="r_afaa52aafdd0d75fd5757bc6048241627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaa52aafdd0d75fd5757bc6048241627">fma</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:afaa52aafdd0d75fd5757bc6048241627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:afaa52aafdd0d75fd5757bc6048241627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b982d85defc10bdabb054f0f6da09a" id="r_a12b982d85defc10bdabb054f0f6da09a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12b982d85defc10bdabb054f0f6da09a">fma</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a12b982d85defc10bdabb054f0f6da09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:a12b982d85defc10bdabb054f0f6da09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eeb30986666cfb17836f4a95c1ae432" id="r_a4eeb30986666cfb17836f4a95c1ae432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eeb30986666cfb17836f4a95c1ae432">fmal</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a4eeb30986666cfb17836f4a95c1ae432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type.  <br /></td></tr>
<tr class="separator:a4eeb30986666cfb17836f4a95c1ae432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbefc5ea76f13ee1827d6ece5530ddf" id="r_a4cbefc5ea76f13ee1827d6ece5530ddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cbefc5ea76f13ee1827d6ece5530ddf">fmax</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a4cbefc5ea76f13ee1827d6ece5530ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:a4cbefc5ea76f13ee1827d6ece5530ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20521caa4fff8d2a62c7d10d77041c20" id="r_a20521caa4fff8d2a62c7d10d77041c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20521caa4fff8d2a62c7d10d77041c20">fmaxf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a20521caa4fff8d2a62c7d10d77041c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:a20521caa4fff8d2a62c7d10d77041c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02198785b5008814ed4bc399d219bd05" id="r_a02198785b5008814ed4bc399d219bd05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02198785b5008814ed4bc399d219bd05">fmax</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a02198785b5008814ed4bc399d219bd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:a02198785b5008814ed4bc399d219bd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccdc206cb2bbd9ede91a7368c9e5e28" id="r_a2ccdc206cb2bbd9ede91a7368c9e5e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ccdc206cb2bbd9ede91a7368c9e5e28">fmax</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a2ccdc206cb2bbd9ede91a7368c9e5e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:a2ccdc206cb2bbd9ede91a7368c9e5e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aa1fe211f2730e008f27a200e45394" id="r_a81aa1fe211f2730e008f27a200e45394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81aa1fe211f2730e008f27a200e45394">fmaxl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a81aa1fe211f2730e008f27a200e45394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:a81aa1fe211f2730e008f27a200e45394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6dcbdef161930c194abe91e999fa5a" id="r_a7b6dcbdef161930c194abe91e999fa5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6dcbdef161930c194abe91e999fa5a">fmin</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a7b6dcbdef161930c194abe91e999fa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:a7b6dcbdef161930c194abe91e999fa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97261b40d0dadb99feb19718529cb0a4" id="r_a97261b40d0dadb99feb19718529cb0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97261b40d0dadb99feb19718529cb0a4">fminf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a97261b40d0dadb99feb19718529cb0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:a97261b40d0dadb99feb19718529cb0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f5a59fa8f7da66f4b0e8fe9c75eaa8" id="r_ab3f5a59fa8f7da66f4b0e8fe9c75eaa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f5a59fa8f7da66f4b0e8fe9c75eaa8">fmin</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ab3f5a59fa8f7da66f4b0e8fe9c75eaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:ab3f5a59fa8f7da66f4b0e8fe9c75eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7993c9e609fbaadfb6d3c8e2601edc" id="r_a3b7993c9e609fbaadfb6d3c8e2601edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7993c9e609fbaadfb6d3c8e2601edc">fmin</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a3b7993c9e609fbaadfb6d3c8e2601edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:a3b7993c9e609fbaadfb6d3c8e2601edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48da4e487f08e68385af8cd0fd1d5ac" id="r_af48da4e487f08e68385af8cd0fd1d5ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af48da4e487f08e68385af8cd0fd1d5ac">fminl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:af48da4e487f08e68385af8cd0fd1d5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)  <br /></td></tr>
<tr class="separator:af48da4e487f08e68385af8cd0fd1d5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed8605479832389e41046ec57b9ebf3" id="r_a1ed8605479832389e41046ec57b9ebf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ed8605479832389e41046ec57b9ebf3">fmod</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a1ed8605479832389e41046ec57b9ebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:a1ed8605479832389e41046ec57b9ebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5edc9a4f5aaf05aaee40f53925a2907" id="r_ad5edc9a4f5aaf05aaee40f53925a2907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5edc9a4f5aaf05aaee40f53925a2907">fmodf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ad5edc9a4f5aaf05aaee40f53925a2907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:ad5edc9a4f5aaf05aaee40f53925a2907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cfcffa563969a705bb10c8a19708f0" id="r_ab8cfcffa563969a705bb10c8a19708f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8cfcffa563969a705bb10c8a19708f0">fmod</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ab8cfcffa563969a705bb10c8a19708f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:ab8cfcffa563969a705bb10c8a19708f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93062354e3cf23623c19cdf4e38e7379" id="r_a93062354e3cf23623c19cdf4e38e7379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93062354e3cf23623c19cdf4e38e7379">fmod</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a93062354e3cf23623c19cdf4e38e7379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:a93062354e3cf23623c19cdf4e38e7379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62dab0cf57549d61a2af609727b1a63" id="r_ae62dab0cf57549d61a2af609727b1a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae62dab0cf57549d61a2af609727b1a63">fmodl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ae62dab0cf57549d61a2af609727b1a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x/y.  <br /></td></tr>
<tr class="separator:ae62dab0cf57549d61a2af609727b1a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fcd9a9618412844bfb6cb9790394b3" id="r_a69fcd9a9618412844bfb6cb9790394b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69fcd9a9618412844bfb6cb9790394b3">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a69fcd9a9618412844bfb6cb9790394b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:a69fcd9a9618412844bfb6cb9790394b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48afde86c3996c23be30bae9346a7403" id="r_a48afde86c3996c23be30bae9346a7403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48afde86c3996c23be30bae9346a7403">hypotf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a48afde86c3996c23be30bae9346a7403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:a48afde86c3996c23be30bae9346a7403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f30dc3ac97f258a80f04b8ea39336b" id="r_a71f30dc3ac97f258a80f04b8ea39336b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71f30dc3ac97f258a80f04b8ea39336b">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a71f30dc3ac97f258a80f04b8ea39336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:a71f30dc3ac97f258a80f04b8ea39336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdda7a6eb1bcb8686e3769837c959f07" id="r_abdda7a6eb1bcb8686e3769837c959f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdda7a6eb1bcb8686e3769837c959f07">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:abdda7a6eb1bcb8686e3769837c959f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:abdda7a6eb1bcb8686e3769837c959f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aafdc892d2301b2f0a571692519ab0f" id="r_a3aafdc892d2301b2f0a571692519ab0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aafdc892d2301b2f0a571692519ab0f">hypotl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a3aafdc892d2301b2f0a571692519ab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:a3aafdc892d2301b2f0a571692519ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946e30be3d028206c7b77b42a718d305" id="r_a946e30be3d028206c7b77b42a718d305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a946e30be3d028206c7b77b42a718d305">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a946e30be3d028206c7b77b42a718d305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:a946e30be3d028206c7b77b42a718d305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b6df01c497a4410ee0c90dcac298cb" id="r_aa8b6df01c497a4410ee0c90dcac298cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b6df01c497a4410ee0c90dcac298cb">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:aa8b6df01c497a4410ee0c90dcac298cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:aa8b6df01c497a4410ee0c90dcac298cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080df550166a2674a8353362f290a0b3" id="r_a080df550166a2674a8353362f290a0b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a080df550166a2674a8353362f290a0b3">hypot</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a080df550166a2674a8353362f290a0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:a080df550166a2674a8353362f290a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bf904f99630edb18fcb3a07117779f" id="r_a80bf904f99630edb18fcb3a07117779f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80bf904f99630edb18fcb3a07117779f">isfinite</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a80bf904f99630edb18fcb3a07117779f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN.  <br /></td></tr>
<tr class="separator:a80bf904f99630edb18fcb3a07117779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813ce51b2632847f81eed1858528ff8e" id="r_a813ce51b2632847f81eed1858528ff8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a813ce51b2632847f81eed1858528ff8e">isfinite</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a813ce51b2632847f81eed1858528ff8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33b9666e620117df47e7cd5c2faae53" id="r_ae33b9666e620117df47e7cd5c2faae53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33b9666e620117df47e7cd5c2faae53">isfinite</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ae33b9666e620117df47e7cd5c2faae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ef6491e0baea008f09e77e8bdd1893" id="r_a47ef6491e0baea008f09e77e8bdd1893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ef6491e0baea008f09e77e8bdd1893">isinf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a47ef6491e0baea008f09e77e8bdd1893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a positive or negative infinity.  <br /></td></tr>
<tr class="separator:a47ef6491e0baea008f09e77e8bdd1893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd9c92fc417d48f3b71a556c288f34d" id="r_a0bd9c92fc417d48f3b71a556c288f34d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bd9c92fc417d48f3b71a556c288f34d">isinf</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a0bd9c92fc417d48f3b71a556c288f34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac63899ba5cdbbcbe25e867baaa11c8a" id="r_aac63899ba5cdbbcbe25e867baaa11c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac63899ba5cdbbcbe25e867baaa11c8a">isinf</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:aac63899ba5cdbbcbe25e867baaa11c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1a47d9c6cc8ec82135f104f9b5c5d6" id="r_a5d1a47d9c6cc8ec82135f104f9b5c5d6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a5d1a47d9c6cc8ec82135f104f9b5c5d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d1a47d9c6cc8ec82135f104f9b5c5d6">isinf</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a5d1a47d9c6cc8ec82135f104f9b5c5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d9e24e916cbbc8f38c7e377eb792d" id="r_a605d9e24e916cbbc8f38c7e377eb792d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a605d9e24e916cbbc8f38c7e377eb792d">isnan</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a605d9e24e916cbbc8f38c7e377eb792d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <br /></td></tr>
<tr class="separator:a605d9e24e916cbbc8f38c7e377eb792d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4da86e5987c4a4fc2368f5195645c3f" id="r_ac4da86e5987c4a4fc2368f5195645c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4da86e5987c4a4fc2368f5195645c3f">isnan</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ac4da86e5987c4a4fc2368f5195645c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1b06749558d3368fe928aba61d3b46" id="r_a5b1b06749558d3368fe928aba61d3b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b1b06749558d3368fe928aba61d3b46">isnan</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a5b1b06749558d3368fe928aba61d3b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91eb4fc3291fad0f13f2c74c57cd8f" id="r_a3e91eb4fc3291fad0f13f2c74c57cd8f"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a3e91eb4fc3291fad0f13f2c74c57cd8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e91eb4fc3291fad0f13f2c74c57cd8f">isnan</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a3e91eb4fc3291fad0f13f2c74c57cd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <br /></td></tr>
<tr class="separator:a3e91eb4fc3291fad0f13f2c74c57cd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb19442837ee1b2540b722ce1c342e" id="r_ac6bb19442837ee1b2540b722ce1c342e"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:ac6bb19442837ee1b2540b722ce1c342e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6bb19442837ee1b2540b722ce1c342e">lerp</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> a, <a class="el" href="structetl_1_1static__vector.html">Float</a> b, <a class="el" href="structetl_1_1static__vector.html">Float</a> <a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Float</a></td></tr>
<tr class="memdesc:ac6bb19442837ee1b2540b722ce1c342e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a+t(ba), i.e. the linear interpolation between a and b for the parameter t (or extrapolation, when t is outside the range [0,1]).  <br /></td></tr>
<tr class="separator:ac6bb19442837ee1b2540b722ce1c342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9b7f32c9ebfadabdad501a192d828c" id="r_a7c9b7f32c9ebfadabdad501a192d828c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c9b7f32c9ebfadabdad501a192d828c">lgamma</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a7c9b7f32c9ebfadabdad501a192d828c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:a7c9b7f32c9ebfadabdad501a192d828c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655f9724695ea0b1ec56bbc092789817" id="r_a655f9724695ea0b1ec56bbc092789817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a655f9724695ea0b1ec56bbc092789817">lgammaf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a655f9724695ea0b1ec56bbc092789817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:a655f9724695ea0b1ec56bbc092789817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2c01b0ca8e4e672c7797bc873547e" id="r_a4ea2c01b0ca8e4e672c7797bc873547e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ea2c01b0ca8e4e672c7797bc873547e">lgamma</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a4ea2c01b0ca8e4e672c7797bc873547e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:a4ea2c01b0ca8e4e672c7797bc873547e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af7825a746fbacdf9c207c50b52328d" id="r_a6af7825a746fbacdf9c207c50b52328d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af7825a746fbacdf9c207c50b52328d">lgamma</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a6af7825a746fbacdf9c207c50b52328d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:a6af7825a746fbacdf9c207c50b52328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9644a8b5362db2ea680cbe5c99b06b1c" id="r_a9644a8b5362db2ea680cbe5c99b06b1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9644a8b5362db2ea680cbe5c99b06b1c">lgammal</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a9644a8b5362db2ea680cbe5c99b06b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:a9644a8b5362db2ea680cbe5c99b06b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0343114e62c2670e654d329ab0e1bdd0" id="r_a0343114e62c2670e654d329ab0e1bdd0"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a0343114e62c2670e654d329ab0e1bdd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0343114e62c2670e654d329ab0e1bdd0">lgamma</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a0343114e62c2670e654d329ab0e1bdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:a0343114e62c2670e654d329ab0e1bdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a169fd90c749bd105c7ed917785c555" id="r_a4a169fd90c749bd105c7ed917785c555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a169fd90c749bd105c7ed917785c555">log</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a4a169fd90c749bd105c7ed917785c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:a4a169fd90c749bd105c7ed917785c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57095382e9dbd0566b08e4928b380a0b" id="r_a57095382e9dbd0566b08e4928b380a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57095382e9dbd0566b08e4928b380a0b">logf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a57095382e9dbd0566b08e4928b380a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:a57095382e9dbd0566b08e4928b380a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572772bba893a4526620c49993f0ebfc" id="r_a572772bba893a4526620c49993f0ebfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a572772bba893a4526620c49993f0ebfc">log</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a572772bba893a4526620c49993f0ebfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:a572772bba893a4526620c49993f0ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82265667a848fe03195c421e0d9fc14f" id="r_a82265667a848fe03195c421e0d9fc14f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82265667a848fe03195c421e0d9fc14f">log</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a82265667a848fe03195c421e0d9fc14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:a82265667a848fe03195c421e0d9fc14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e443c1bfefaffc909930e82ad506e9c" id="r_a2e443c1bfefaffc909930e82ad506e9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e443c1bfefaffc909930e82ad506e9c">logl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a2e443c1bfefaffc909930e82ad506e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:a2e443c1bfefaffc909930e82ad506e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901ea4277603b09bc1fd59c203d1a5bb" id="r_a901ea4277603b09bc1fd59c203d1a5bb"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a901ea4277603b09bc1fd59c203d1a5bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a901ea4277603b09bc1fd59c203d1a5bb">log</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a901ea4277603b09bc1fd59c203d1a5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of arg.  <br /></td></tr>
<tr class="separator:a901ea4277603b09bc1fd59c203d1a5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f12f27fcd6d0d687061563bf72ff1a1" id="r_a7f12f27fcd6d0d687061563bf72ff1a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f12f27fcd6d0d687061563bf72ff1a1">log10</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a7f12f27fcd6d0d687061563bf72ff1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:a7f12f27fcd6d0d687061563bf72ff1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fee06d1d407f722148dab0c23494b7" id="r_a78fee06d1d407f722148dab0c23494b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78fee06d1d407f722148dab0c23494b7">log10f</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a78fee06d1d407f722148dab0c23494b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:a78fee06d1d407f722148dab0c23494b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a3fb089d374229a5797e5bfef6ebf4" id="r_ae4a3fb089d374229a5797e5bfef6ebf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4a3fb089d374229a5797e5bfef6ebf4">log10</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ae4a3fb089d374229a5797e5bfef6ebf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:ae4a3fb089d374229a5797e5bfef6ebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a16ee742583cc34fd0d79feeb82c3c" id="r_a48a16ee742583cc34fd0d79feeb82c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48a16ee742583cc34fd0d79feeb82c3c">log10</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a48a16ee742583cc34fd0d79feeb82c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:a48a16ee742583cc34fd0d79feeb82c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacfe4fb5b126adc548949313389927b" id="r_acacfe4fb5b126adc548949313389927b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acacfe4fb5b126adc548949313389927b">log10l</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:acacfe4fb5b126adc548949313389927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:acacfe4fb5b126adc548949313389927b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f5caf83538c35d9898a64b78f3d19d" id="r_ab1f5caf83538c35d9898a64b78f3d19d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ab1f5caf83538c35d9898a64b78f3d19d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1f5caf83538c35d9898a64b78f3d19d">log10</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ab1f5caf83538c35d9898a64b78f3d19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-10) logarithm of arg.  <br /></td></tr>
<tr class="separator:ab1f5caf83538c35d9898a64b78f3d19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498813413a98af25e2555e2c54c3256a" id="r_a498813413a98af25e2555e2c54c3256a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498813413a98af25e2555e2c54c3256a">log1p</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a498813413a98af25e2555e2c54c3256a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:a498813413a98af25e2555e2c54c3256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2b22c8715dcf83abd59bb75cb1cdde" id="r_a9b2b22c8715dcf83abd59bb75cb1cdde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b2b22c8715dcf83abd59bb75cb1cdde">log1pf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a9b2b22c8715dcf83abd59bb75cb1cdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:a9b2b22c8715dcf83abd59bb75cb1cdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf80a0d8a6fa5bfa402fc5423250e31f" id="r_aaf80a0d8a6fa5bfa402fc5423250e31f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf80a0d8a6fa5bfa402fc5423250e31f">log1p</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:aaf80a0d8a6fa5bfa402fc5423250e31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:aaf80a0d8a6fa5bfa402fc5423250e31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be7ea716031c69f74aebe909736eb7" id="r_a20be7ea716031c69f74aebe909736eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20be7ea716031c69f74aebe909736eb7">log1p</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a20be7ea716031c69f74aebe909736eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:a20be7ea716031c69f74aebe909736eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25518821ccfbec031fc0d965aa7270bd" id="r_a25518821ccfbec031fc0d965aa7270bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25518821ccfbec031fc0d965aa7270bd">log1pl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a25518821ccfbec031fc0d965aa7270bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:a25518821ccfbec031fc0d965aa7270bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae364b66bba492ce1f0d8cf6cc89926ed" id="r_ae364b66bba492ce1f0d8cf6cc89926ed"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ae364b66bba492ce1f0d8cf6cc89926ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae364b66bba492ce1f0d8cf6cc89926ed">log1p</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ae364b66bba492ce1f0d8cf6cc89926ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero.  <br /></td></tr>
<tr class="separator:ae364b66bba492ce1f0d8cf6cc89926ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187674def6f3f8cb678932d3bae9cbec" id="r_a187674def6f3f8cb678932d3bae9cbec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a187674def6f3f8cb678932d3bae9cbec">log2</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a187674def6f3f8cb678932d3bae9cbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:a187674def6f3f8cb678932d3bae9cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032e2d84a89ad296cc05740845401979" id="r_a032e2d84a89ad296cc05740845401979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a032e2d84a89ad296cc05740845401979">log2f</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a032e2d84a89ad296cc05740845401979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:a032e2d84a89ad296cc05740845401979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48c54e709d90829fb78c40b755c71c7" id="r_ad48c54e709d90829fb78c40b755c71c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad48c54e709d90829fb78c40b755c71c7">log2</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ad48c54e709d90829fb78c40b755c71c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:ad48c54e709d90829fb78c40b755c71c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32086c2c749843ddb53344256a91fce" id="r_aa32086c2c749843ddb53344256a91fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa32086c2c749843ddb53344256a91fce">log2</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:aa32086c2c749843ddb53344256a91fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:aa32086c2c749843ddb53344256a91fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fa117f9915cf0572aa57acab4fe659" id="r_aa3fa117f9915cf0572aa57acab4fe659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3fa117f9915cf0572aa57acab4fe659">log2l</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:aa3fa117f9915cf0572aa57acab4fe659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:aa3fa117f9915cf0572aa57acab4fe659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c53fd481eb75ee3e6bc3ab5cd1b307f" id="r_a9c53fd481eb75ee3e6bc3ab5cd1b307f"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a9c53fd481eb75ee3e6bc3ab5cd1b307f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c53fd481eb75ee3e6bc3ab5cd1b307f">log2</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a9c53fd481eb75ee3e6bc3ab5cd1b307f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binary (base-2) logarithm of arg.  <br /></td></tr>
<tr class="separator:a9c53fd481eb75ee3e6bc3ab5cd1b307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47ed33940ef738b996d13c4fe6b819a" id="r_ad47ed33940ef738b996d13c4fe6b819a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad47ed33940ef738b996d13c4fe6b819a">lrint</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ad47ed33940ef738b996d13c4fe6b819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ad47ed33940ef738b996d13c4fe6b819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd52080b573db11d8e765f46f8e7765" id="r_aedd52080b573db11d8e765f46f8e7765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedd52080b573db11d8e765f46f8e7765">lrintf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:aedd52080b573db11d8e765f46f8e7765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:aedd52080b573db11d8e765f46f8e7765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974d3c30726d8fcb3d66b335f97b2db0" id="r_a974d3c30726d8fcb3d66b335f97b2db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a974d3c30726d8fcb3d66b335f97b2db0">lrint</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a974d3c30726d8fcb3d66b335f97b2db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:a974d3c30726d8fcb3d66b335f97b2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d8ad90ada2dcf269313c7d4cb1d088" id="r_ad9d8ad90ada2dcf269313c7d4cb1d088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9d8ad90ada2dcf269313c7d4cb1d088">lrint</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ad9d8ad90ada2dcf269313c7d4cb1d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ad9d8ad90ada2dcf269313c7d4cb1d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f3372f28a951d577490cd5afe08ff0" id="r_ae9f3372f28a951d577490cd5afe08ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9f3372f28a951d577490cd5afe08ff0">lrintl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ae9f3372f28a951d577490cd5afe08ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ae9f3372f28a951d577490cd5afe08ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197984681c0d3089f3809b6769021ac0" id="r_a197984681c0d3089f3809b6769021ac0"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a197984681c0d3089f3809b6769021ac0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a197984681c0d3089f3809b6769021ac0">lrint</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a197984681c0d3089f3809b6769021ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:a197984681c0d3089f3809b6769021ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad500c9f92de07b192872ebf1d8c85bbd" id="r_ad500c9f92de07b192872ebf1d8c85bbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad500c9f92de07b192872ebf1d8c85bbd">llrint</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ad500c9f92de07b192872ebf1d8c85bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ad500c9f92de07b192872ebf1d8c85bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfebe6109cc6e6cdf8f6910ef52966f4" id="r_acfebe6109cc6e6cdf8f6910ef52966f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfebe6109cc6e6cdf8f6910ef52966f4">llrintf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:acfebe6109cc6e6cdf8f6910ef52966f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:acfebe6109cc6e6cdf8f6910ef52966f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026db8a513ac677c58931204032ea87" id="r_ae026db8a513ac677c58931204032ea87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae026db8a513ac677c58931204032ea87">llrint</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ae026db8a513ac677c58931204032ea87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ae026db8a513ac677c58931204032ea87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72786dec8ee1f7facc0e026e8793ea29" id="r_a72786dec8ee1f7facc0e026e8793ea29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72786dec8ee1f7facc0e026e8793ea29">llrint</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a72786dec8ee1f7facc0e026e8793ea29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:a72786dec8ee1f7facc0e026e8793ea29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06be44ea5149be36d471ea497927242b" id="r_a06be44ea5149be36d471ea497927242b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06be44ea5149be36d471ea497927242b">llrintl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a06be44ea5149be36d471ea497927242b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:a06be44ea5149be36d471ea497927242b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfc54e2b11311c629c920867ab2f0cb" id="r_adcfc54e2b11311c629c920867ab2f0cb"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:adcfc54e2b11311c629c920867ab2f0cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcfc54e2b11311c629c920867ab2f0cb">llrint</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:adcfc54e2b11311c629c920867ab2f0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:adcfc54e2b11311c629c920867ab2f0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21120c1b64cbc4c4d446f0859a011d82" id="r_a21120c1b64cbc4c4d446f0859a011d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21120c1b64cbc4c4d446f0859a011d82">nanf</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a21120c1b64cbc4c4d446f0859a011d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <br /></td></tr>
<tr class="separator:a21120c1b64cbc4c4d446f0859a011d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0c6b512cfa1423e392e02430121c44" id="r_a7e0c6b512cfa1423e392e02430121c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e0c6b512cfa1423e392e02430121c44">nan</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a7e0c6b512cfa1423e392e02430121c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <br /></td></tr>
<tr class="separator:a7e0c6b512cfa1423e392e02430121c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae289a4c91b473e5e1302aa1b0142b48d" id="r_ae289a4c91b473e5e1302aa1b0142b48d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae289a4c91b473e5e1302aa1b0142b48d">nanl</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ae289a4c91b473e5e1302aa1b0142b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the implementation-defined character string arg into the corresponding quiet NaN value.  <br /></td></tr>
<tr class="separator:ae289a4c91b473e5e1302aa1b0142b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59be8945c5efec1cdc9860dd0a8f04ed" id="r_a59be8945c5efec1cdc9860dd0a8f04ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59be8945c5efec1cdc9860dd0a8f04ed">nextafter</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">from</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a59be8945c5efec1cdc9860dd0a8f04ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <br /></td></tr>
<tr class="separator:a59be8945c5efec1cdc9860dd0a8f04ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0420dd56139b0939734e1952cbb1c4" id="r_a7c0420dd56139b0939734e1952cbb1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c0420dd56139b0939734e1952cbb1c4">nextafterf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">from</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a7c0420dd56139b0939734e1952cbb1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <br /></td></tr>
<tr class="separator:a7c0420dd56139b0939734e1952cbb1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f83e49db9982e87ce21075dc80cf9a5" id="r_a3f83e49db9982e87ce21075dc80cf9a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f83e49db9982e87ce21075dc80cf9a5">nextafter</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">from</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a3f83e49db9982e87ce21075dc80cf9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next representable value of from in the direction of to. If from equals to, to is returned.  <br /></td></tr>
<tr class="separator:a3f83e49db9982e87ce21075dc80cf9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c50dace9bf8c161755a654d025b1421" id="r_ga6c50dace9bf8c161755a654d025b1421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6c50dace9bf8c161755a654d025b1421">pow</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> base, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga6c50dace9bf8c161755a654d025b1421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga6c50dace9bf8c161755a654d025b1421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50df9a7ff64e02368510aff26def2e97" id="r_ga50df9a7ff64e02368510aff26def2e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga50df9a7ff64e02368510aff26def2e97">powf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> base, <a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga50df9a7ff64e02368510aff26def2e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga50df9a7ff64e02368510aff26def2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab20e2642b65c1856de9ceff906cc3a" id="r_ga2ab20e2642b65c1856de9ceff906cc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2ab20e2642b65c1856de9ceff906cc3a">pow</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga2ab20e2642b65c1856de9ceff906cc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga2ab20e2642b65c1856de9ceff906cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0f48eee9fb05aa553bc44ece921abe" id="r_ga2b0f48eee9fb05aa553bc44ece921abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2b0f48eee9fb05aa553bc44ece921abe">pow</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga2b0f48eee9fb05aa553bc44ece921abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga2b0f48eee9fb05aa553bc44ece921abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6011900d6daacd4ae59b01436a7b9f1b" id="r_ga6011900d6daacd4ae59b01436a7b9f1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6011900d6daacd4ae59b01436a7b9f1b">powl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="#a9acc3b86f099266b7744b6cb388ed894">exp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga6011900d6daacd4ae59b01436a7b9f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga6011900d6daacd4ae59b01436a7b9f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e30624b74c2fca7355bc13cff7c57c" id="r_ga77e30624b74c2fca7355bc13cff7c57c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga77e30624b74c2fca7355bc13cff7c57c">pow</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> base, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ga77e30624b74c2fca7355bc13cff7c57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga77e30624b74c2fca7355bc13cff7c57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fbc8c440f669809de2fb38d14bd958a" id="r_ga4fbc8c440f669809de2fb38d14bd958a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4fbc8c440f669809de2fb38d14bd958a">pow</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ga4fbc8c440f669809de2fb38d14bd958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga4fbc8c440f669809de2fb38d14bd958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b3dd1df06d2bf8daf01c17e169d36c" id="r_gae4b3dd1df06d2bf8daf01c17e169d36c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae4b3dd1df06d2bf8daf01c17e169d36c">pow</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> base, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:gae4b3dd1df06d2bf8daf01c17e169d36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:gae4b3dd1df06d2bf8daf01c17e169d36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02a7e8321924bb554b336b84c2ee60d" id="r_ad02a7e8321924bb554b336b84c2ee60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad02a7e8321924bb554b336b84c2ee60d">remainder</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ad02a7e8321924bb554b336b84c2ee60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:ad02a7e8321924bb554b336b84c2ee60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dd6c6fa125a008a2226c4f2a8b225f" id="r_a11dd6c6fa125a008a2226c4f2a8b225f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11dd6c6fa125a008a2226c4f2a8b225f">remainderf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a11dd6c6fa125a008a2226c4f2a8b225f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:a11dd6c6fa125a008a2226c4f2a8b225f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bce49452ed33940fa9b1c8d2585072" id="r_ad3bce49452ed33940fa9b1c8d2585072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3bce49452ed33940fa9b1c8d2585072">remainder</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ad3bce49452ed33940fa9b1c8d2585072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:ad3bce49452ed33940fa9b1c8d2585072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999d51f2384d0b2fbfd76288906b3e2d" id="r_a999d51f2384d0b2fbfd76288906b3e2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a999d51f2384d0b2fbfd76288906b3e2d">remainder</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a999d51f2384d0b2fbfd76288906b3e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:a999d51f2384d0b2fbfd76288906b3e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1521d8219ac8ccb84c5de502919411" id="r_a2f1521d8219ac8ccb84c5de502919411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f1521d8219ac8ccb84c5de502919411">remainderl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a2f1521d8219ac8ccb84c5de502919411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:a2f1521d8219ac8ccb84c5de502919411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd8b50cafa711d52c60a19ca80dee8f" id="r_accd8b50cafa711d52c60a19ca80dee8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accd8b50cafa711d52c60a19ca80dee8f">rint</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:accd8b50cafa711d52c60a19ca80dee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <br /></td></tr>
<tr class="separator:accd8b50cafa711d52c60a19ca80dee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285bdc5b020e3beb9ee509210e207dd5" id="r_a285bdc5b020e3beb9ee509210e207dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a285bdc5b020e3beb9ee509210e207dd5">rintf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a285bdc5b020e3beb9ee509210e207dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <br /></td></tr>
<tr class="separator:a285bdc5b020e3beb9ee509210e207dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cfa1d5908f72cf3aff4979a814dd3" id="r_a315cfa1d5908f72cf3aff4979a814dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a315cfa1d5908f72cf3aff4979a814dd3">rint</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a315cfa1d5908f72cf3aff4979a814dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <br /></td></tr>
<tr class="separator:a315cfa1d5908f72cf3aff4979a814dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6deedd67292f24e059f4a0a6f62f1a" id="r_a8c6deedd67292f24e059f4a0a6f62f1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c6deedd67292f24e059f4a0a6f62f1a">rint</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a8c6deedd67292f24e059f4a0a6f62f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <br /></td></tr>
<tr class="separator:a8c6deedd67292f24e059f4a0a6f62f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cb8315104a3f48b9fb3e304aa2a6dd" id="r_a36cb8315104a3f48b9fb3e304aa2a6dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36cb8315104a3f48b9fb3e304aa2a6dd">rintl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a36cb8315104a3f48b9fb3e304aa2a6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <br /></td></tr>
<tr class="separator:a36cb8315104a3f48b9fb3e304aa2a6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6a250e98656b00833eb33ee493b12b" id="r_a1d6a250e98656b00833eb33ee493b12b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a1d6a250e98656b00833eb33ee493b12b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d6a250e98656b00833eb33ee493b12b">rint</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a1d6a250e98656b00833eb33ee493b12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value.  <br /></td></tr>
<tr class="separator:a1d6a250e98656b00833eb33ee493b12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653865fab50c43932f405e8e140e1ced" id="r_a653865fab50c43932f405e8e140e1ced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a653865fab50c43932f405e8e140e1ced">round</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a653865fab50c43932f405e8e140e1ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:a653865fab50c43932f405e8e140e1ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8200750f9da147ccc3c2f647156ed7bb" id="r_a8200750f9da147ccc3c2f647156ed7bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8200750f9da147ccc3c2f647156ed7bb">roundf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a8200750f9da147ccc3c2f647156ed7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:a8200750f9da147ccc3c2f647156ed7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e261cc501d3a147de6d342131c222af" id="r_a7e261cc501d3a147de6d342131c222af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e261cc501d3a147de6d342131c222af">round</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a7e261cc501d3a147de6d342131c222af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:a7e261cc501d3a147de6d342131c222af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5029f46266d011b01975c90e160ab5d9" id="r_a5029f46266d011b01975c90e160ab5d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5029f46266d011b01975c90e160ab5d9">round</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a5029f46266d011b01975c90e160ab5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:a5029f46266d011b01975c90e160ab5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec2b94f73e269d1e72241957410aa01" id="r_a3ec2b94f73e269d1e72241957410aa01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ec2b94f73e269d1e72241957410aa01">roundl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a3ec2b94f73e269d1e72241957410aa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:a3ec2b94f73e269d1e72241957410aa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f6ec1f24e0018a43cc5a4017ad7305" id="r_ae0f6ec1f24e0018a43cc5a4017ad7305"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ae0f6ec1f24e0018a43cc5a4017ad7305"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0f6ec1f24e0018a43cc5a4017ad7305">round</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ae0f6ec1f24e0018a43cc5a4017ad7305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.  <br /></td></tr>
<tr class="separator:ae0f6ec1f24e0018a43cc5a4017ad7305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba0ce5c59de256a555eeaae79891ad0" id="r_a5ba0ce5c59de256a555eeaae79891ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ba0ce5c59de256a555eeaae79891ad0">signbit</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5ba0ce5c59de256a555eeaae79891ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:a5ba0ce5c59de256a555eeaae79891ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16ba0e54e5210e5103728c522ef59c1" id="r_ae16ba0e54e5210e5103728c522ef59c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae16ba0e54e5210e5103728c522ef59c1">signbit</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae16ba0e54e5210e5103728c522ef59c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:ae16ba0e54e5210e5103728c522ef59c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394d0dfcf05ed36d1a93ed7384b3ab4" id="r_a6394d0dfcf05ed36d1a93ed7384b3ab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6394d0dfcf05ed36d1a93ed7384b3ab4">signbit</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6394d0dfcf05ed36d1a93ed7384b3ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:a6394d0dfcf05ed36d1a93ed7384b3ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658bf05b8a1404b6e18366e9666a793b" id="r_a658bf05b8a1404b6e18366e9666a793b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658bf05b8a1404b6e18366e9666a793b">sin</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a658bf05b8a1404b6e18366e9666a793b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:a658bf05b8a1404b6e18366e9666a793b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdde537199b7bb6f4ec05ecb394cf2c9" id="r_abdde537199b7bb6f4ec05ecb394cf2c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdde537199b7bb6f4ec05ecb394cf2c9">sinf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:abdde537199b7bb6f4ec05ecb394cf2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:abdde537199b7bb6f4ec05ecb394cf2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed7450ee38549d51ff3c60fe2630530" id="r_afed7450ee38549d51ff3c60fe2630530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afed7450ee38549d51ff3c60fe2630530">sin</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:afed7450ee38549d51ff3c60fe2630530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:afed7450ee38549d51ff3c60fe2630530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8903f152a43eb61c341a4e03221fa27" id="r_ad8903f152a43eb61c341a4e03221fa27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8903f152a43eb61c341a4e03221fa27">sin</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ad8903f152a43eb61c341a4e03221fa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:ad8903f152a43eb61c341a4e03221fa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1243af94f0a71d9df38ea872c3c84632" id="r_a1243af94f0a71d9df38ea872c3c84632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1243af94f0a71d9df38ea872c3c84632">sinl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a1243af94f0a71d9df38ea872c3c84632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:a1243af94f0a71d9df38ea872c3c84632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42714f17f2630f23993520d2052fab1a" id="r_a42714f17f2630f23993520d2052fab1a"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a42714f17f2630f23993520d2052fab1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42714f17f2630f23993520d2052fab1a">sin</a> (T num) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a42714f17f2630f23993520d2052fab1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of num (measured in radians).  <br /></td></tr>
<tr class="separator:a42714f17f2630f23993520d2052fab1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ea280e9468d3bccca526a7cbc73651" id="r_a81ea280e9468d3bccca526a7cbc73651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81ea280e9468d3bccca526a7cbc73651">sinh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a81ea280e9468d3bccca526a7cbc73651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:a81ea280e9468d3bccca526a7cbc73651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2410ac3995142466f68376374b9d4ec3" id="r_a2410ac3995142466f68376374b9d4ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2410ac3995142466f68376374b9d4ec3">sinhf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a2410ac3995142466f68376374b9d4ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:a2410ac3995142466f68376374b9d4ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134b303ad71ff97a362470bf0d51aeea" id="r_a134b303ad71ff97a362470bf0d51aeea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a134b303ad71ff97a362470bf0d51aeea">sinh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a134b303ad71ff97a362470bf0d51aeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:a134b303ad71ff97a362470bf0d51aeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac254ab46d592daba270994a02a06afbb" id="r_ac254ab46d592daba270994a02a06afbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac254ab46d592daba270994a02a06afbb">sinh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ac254ab46d592daba270994a02a06afbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ac254ab46d592daba270994a02a06afbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d2c54a18b0472cabe0c5a66b6daf30" id="r_ab2d2c54a18b0472cabe0c5a66b6daf30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d2c54a18b0472cabe0c5a66b6daf30">sinhl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ab2d2c54a18b0472cabe0c5a66b6daf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ab2d2c54a18b0472cabe0c5a66b6daf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40d2d23c8e8fccf96b3b782e667c210" id="r_ac40d2d23c8e8fccf96b3b782e667c210"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ac40d2d23c8e8fccf96b3b782e667c210"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac40d2d23c8e8fccf96b3b782e667c210">sinh</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ac40d2d23c8e8fccf96b3b782e667c210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ac40d2d23c8e8fccf96b3b782e667c210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6d19ae1f2df5e1e7f62db7a939946d" id="r_a2e6d19ae1f2df5e1e7f62db7a939946d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e6d19ae1f2df5e1e7f62db7a939946d">sqrt</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a2e6d19ae1f2df5e1e7f62db7a939946d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:a2e6d19ae1f2df5e1e7f62db7a939946d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9f94a766a382b51806352f5e757526" id="r_a5f9f94a766a382b51806352f5e757526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f9f94a766a382b51806352f5e757526">sqrtf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a5f9f94a766a382b51806352f5e757526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:a5f9f94a766a382b51806352f5e757526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e65e7903be2c1a9749a5249e6c790f8" id="r_a7e65e7903be2c1a9749a5249e6c790f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e65e7903be2c1a9749a5249e6c790f8">sqrt</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a7e65e7903be2c1a9749a5249e6c790f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:a7e65e7903be2c1a9749a5249e6c790f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c22d86b18b9a040289d082be62c4ec7" id="r_a5c22d86b18b9a040289d082be62c4ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c22d86b18b9a040289d082be62c4ec7">sqrt</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a5c22d86b18b9a040289d082be62c4ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:a5c22d86b18b9a040289d082be62c4ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b08acd2af82eed59a672ca38721e263" id="r_a1b08acd2af82eed59a672ca38721e263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b08acd2af82eed59a672ca38721e263">sqrtl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a1b08acd2af82eed59a672ca38721e263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:a1b08acd2af82eed59a672ca38721e263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb720e73aa27e1f9c5a3a2bc830bef84" id="r_acb720e73aa27e1f9c5a3a2bc830bef84"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:acb720e73aa27e1f9c5a3a2bc830bef84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb720e73aa27e1f9c5a3a2bc830bef84">sqrt</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:acb720e73aa27e1f9c5a3a2bc830bef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:acb720e73aa27e1f9c5a3a2bc830bef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e43e254d59d4cd608b1d9f1399167d" id="r_aa3e43e254d59d4cd608b1d9f1399167d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3e43e254d59d4cd608b1d9f1399167d">tan</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:aa3e43e254d59d4cd608b1d9f1399167d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:aa3e43e254d59d4cd608b1d9f1399167d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd684aadcdf2df4696dd5c9ae99ea2" id="r_ab7cd684aadcdf2df4696dd5c9ae99ea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7cd684aadcdf2df4696dd5c9ae99ea2">tanf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:ab7cd684aadcdf2df4696dd5c9ae99ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:ab7cd684aadcdf2df4696dd5c9ae99ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6be38a86dc3804ad690b2ea4f3c082" id="r_a2e6be38a86dc3804ad690b2ea4f3c082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e6be38a86dc3804ad690b2ea4f3c082">tan</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a2e6be38a86dc3804ad690b2ea4f3c082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:a2e6be38a86dc3804ad690b2ea4f3c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf39aea93d6cef89e6b047068532251f" id="r_abf39aea93d6cef89e6b047068532251f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf39aea93d6cef89e6b047068532251f">tan</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:abf39aea93d6cef89e6b047068532251f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:abf39aea93d6cef89e6b047068532251f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8821d6a54a089020394afeddd92eb20c" id="r_a8821d6a54a089020394afeddd92eb20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8821d6a54a089020394afeddd92eb20c">tanl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a8821d6a54a089020394afeddd92eb20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:a8821d6a54a089020394afeddd92eb20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82108d39542689318c049d79b7a1443b" id="r_a82108d39542689318c049d79b7a1443b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a82108d39542689318c049d79b7a1443b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82108d39542689318c049d79b7a1443b">tan</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a82108d39542689318c049d79b7a1443b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the tangent of arg (measured in radians).  <br /></td></tr>
<tr class="separator:a82108d39542689318c049d79b7a1443b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a06c6155118cf0eea70d7f72e7ee26" id="r_a94a06c6155118cf0eea70d7f72e7ee26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94a06c6155118cf0eea70d7f72e7ee26">tanh</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a94a06c6155118cf0eea70d7f72e7ee26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:a94a06c6155118cf0eea70d7f72e7ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b71e15eca59ee5d5814c5df7de5f540" id="r_a0b71e15eca59ee5d5814c5df7de5f540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b71e15eca59ee5d5814c5df7de5f540">tanhf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a0b71e15eca59ee5d5814c5df7de5f540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:a0b71e15eca59ee5d5814c5df7de5f540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338f420d3e517380454cff3e76c275de" id="r_a338f420d3e517380454cff3e76c275de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a338f420d3e517380454cff3e76c275de">tanh</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a338f420d3e517380454cff3e76c275de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:a338f420d3e517380454cff3e76c275de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa9bf0ccb082968efc0da1be519a4d3" id="r_abaa9bf0ccb082968efc0da1be519a4d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaa9bf0ccb082968efc0da1be519a4d3">tanh</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:abaa9bf0ccb082968efc0da1be519a4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:abaa9bf0ccb082968efc0da1be519a4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770ad213930a5de35a7e4d8efbb65c16" id="r_a770ad213930a5de35a7e4d8efbb65c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a770ad213930a5de35a7e4d8efbb65c16">tanhl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a770ad213930a5de35a7e4d8efbb65c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:a770ad213930a5de35a7e4d8efbb65c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de6b5cc89e28e1ba7eac7465f380fba" id="r_a9de6b5cc89e28e1ba7eac7465f380fba"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:a9de6b5cc89e28e1ba7eac7465f380fba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9de6b5cc89e28e1ba7eac7465f380fba">tanh</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a9de6b5cc89e28e1ba7eac7465f380fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic tangent of arg.  <br /></td></tr>
<tr class="separator:a9de6b5cc89e28e1ba7eac7465f380fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304d035a3a2740c7fef43426fcf3b9cb" id="r_a304d035a3a2740c7fef43426fcf3b9cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a304d035a3a2740c7fef43426fcf3b9cb">tgamma</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a304d035a3a2740c7fef43426fcf3b9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:a304d035a3a2740c7fef43426fcf3b9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0533d6b346e372e13a35a00e4fe5ac" id="r_aba0533d6b346e372e13a35a00e4fe5ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba0533d6b346e372e13a35a00e4fe5ac">tgammaf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:aba0533d6b346e372e13a35a00e4fe5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:aba0533d6b346e372e13a35a00e4fe5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d14d3d27f8694d9d4b771100bd4c74e" id="r_a8d14d3d27f8694d9d4b771100bd4c74e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d14d3d27f8694d9d4b771100bd4c74e">tgamma</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a8d14d3d27f8694d9d4b771100bd4c74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:a8d14d3d27f8694d9d4b771100bd4c74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7455e948ac61779dbd3be0c44190e569" id="r_a7455e948ac61779dbd3be0c44190e569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7455e948ac61779dbd3be0c44190e569">tgamma</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a7455e948ac61779dbd3be0c44190e569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:a7455e948ac61779dbd3be0c44190e569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6252e2a52632b3b841f2b21455c2fa7a" id="r_a6252e2a52632b3b841f2b21455c2fa7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6252e2a52632b3b841f2b21455c2fa7a">tgammal</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a6252e2a52632b3b841f2b21455c2fa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:a6252e2a52632b3b841f2b21455c2fa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31c7fddeeebae7fde466c96fafadd4c" id="r_ae31c7fddeeebae7fde466c96fafadd4c"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ae31c7fddeeebae7fde466c96fafadd4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae31c7fddeeebae7fde466c96fafadd4c">tgamma</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ae31c7fddeeebae7fde466c96fafadd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of arg.  <br /></td></tr>
<tr class="separator:ae31c7fddeeebae7fde466c96fafadd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e4586e25e102b1dcd61e06b661ac2d" id="r_a77e4586e25e102b1dcd61e06b661ac2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77e4586e25e102b1dcd61e06b661ac2d">trunc</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a77e4586e25e102b1dcd61e06b661ac2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:a77e4586e25e102b1dcd61e06b661ac2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5336aa0b394c2196ad1b8f15b2441b" id="r_a9c5336aa0b394c2196ad1b8f15b2441b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5336aa0b394c2196ad1b8f15b2441b">truncf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a9c5336aa0b394c2196ad1b8f15b2441b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:a9c5336aa0b394c2196ad1b8f15b2441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8316f5c97f691318a53cf91fd135894" id="r_aa8316f5c97f691318a53cf91fd135894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8316f5c97f691318a53cf91fd135894">trunc</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:aa8316f5c97f691318a53cf91fd135894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:aa8316f5c97f691318a53cf91fd135894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33b0697205c635cb1e294cfecbcfd46" id="r_aa33b0697205c635cb1e294cfecbcfd46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa33b0697205c635cb1e294cfecbcfd46">trunc</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:aa33b0697205c635cb1e294cfecbcfd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:aa33b0697205c635cb1e294cfecbcfd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86cd183532a15f7fb8fa893a9db7d44" id="r_aa86cd183532a15f7fb8fa893a9db7d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa86cd183532a15f7fb8fa893a9db7d44">truncl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:aa86cd183532a15f7fb8fa893a9db7d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:aa86cd183532a15f7fb8fa893a9db7d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9896e22ccd29baf6a2bca31d48f6e4b" id="r_af9896e22ccd29baf6a2bca31d48f6e4b"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:af9896e22ccd29baf6a2bca31d48f6e4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9896e22ccd29baf6a2bca31d48f6e4b">trunc</a> (T <a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:af9896e22ccd29baf6a2bca31d48f6e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nearest integer not greater in magnitude than arg.  <br /></td></tr>
<tr class="separator:af9896e22ccd29baf6a2bca31d48f6e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d038b8a789971cb7319f23919ae1d1f" id="r_a1d038b8a789971cb7319f23919ae1d1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d038b8a789971cb7319f23919ae1d1f">is_eq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a1d038b8a789971cb7319f23919ae1d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83376b31eb27942ae5c71f06c91decc8" id="r_a83376b31eb27942ae5c71f06c91decc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83376b31eb27942ae5c71f06c91decc8">is_neq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a83376b31eb27942ae5c71f06c91decc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1b19096d66a3614daa7bc0ec0c564" id="r_a9ec1b19096d66a3614daa7bc0ec0c564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ec1b19096d66a3614daa7bc0ec0c564">is_lt</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a9ec1b19096d66a3614daa7bc0ec0c564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b3b676935f0ab36310d8f87b00da2d" id="r_a46b3b676935f0ab36310d8f87b00da2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b3b676935f0ab36310d8f87b00da2d">is_lteq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a46b3b676935f0ab36310d8f87b00da2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bd271610a81bd07da4d1f15f55ce2b" id="r_a52bd271610a81bd07da4d1f15f55ce2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52bd271610a81bd07da4d1f15f55ce2b">is_gt</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a52bd271610a81bd07da4d1f15f55ce2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff127460a7b71fec87f3156800a3972" id="r_a9ff127460a7b71fec87f3156800a3972"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ff127460a7b71fec87f3156800a3972">is_gteq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1static__vector.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a9ff127460a7b71fec87f3156800a3972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77deb75e76886e1049e79b9acef5a4fa" id="r_ga77deb75e76886e1049e79b9acef5a4fa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga77deb75e76886e1049e79b9acef5a4fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga77deb75e76886e1049e79b9acef5a4fa">abs</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; T</td></tr>
<tr class="separator:ga77deb75e76886e1049e79b9acef5a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06165982b4ed16fe2e57476b46f4ad08" id="r_ga06165982b4ed16fe2e57476b46f4ad08"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga06165982b4ed16fe2e57476b46f4ad08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; T</td></tr>
<tr class="separator:ga06165982b4ed16fe2e57476b46f4ad08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b432350aea176a2542af0d6345b86f" id="r_ga59b432350aea176a2542af0d6345b86f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:ga59b432350aea176a2542af0d6345b86f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga59b432350aea176a2542af0d6345b86f">arg</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> f) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; &gt;</td></tr>
<tr class="separator:ga59b432350aea176a2542af0d6345b86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2cea22609372b06c694bf7011bb7a4" id="r_gafe2cea22609372b06c694bf7011bb7a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:gafe2cea22609372b06c694bf7011bb7a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gafe2cea22609372b06c694bf7011bb7a4">arg</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt; &gt;</td></tr>
<tr class="separator:gafe2cea22609372b06c694bf7011bb7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93401bd9402632426cada76f529d6b9f" id="r_a93401bd9402632426cada76f529d6b9f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a93401bd9402632426cada76f529d6b9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93401bd9402632426cada76f529d6b9f">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;val) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a93401bd9402632426cada76f529d6b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa112bbaeebf7afad6d876c4291b195c8" id="r_aa112bbaeebf7afad6d876c4291b195c8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa112bbaeebf7afad6d876c4291b195c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa112bbaeebf7afad6d876c4291b195c8">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;val) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:aa112bbaeebf7afad6d876c4291b195c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650bebf4618f883ada09c2039a4b725b" id="r_a650bebf4618f883ada09c2039a4b725b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a650bebf4618f883ada09c2039a4b725b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a650bebf4618f883ada09c2039a4b725b">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a650bebf4618f883ada09c2039a4b725b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21b902b9c3ad85f752def9d8b61e99c" id="r_ac21b902b9c3ad85f752def9d8b61e99c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac21b902b9c3ad85f752def9d8b61e99c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac21b902b9c3ad85f752def9d8b61e99c">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ac21b902b9c3ad85f752def9d8b61e99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cbf5d3ec0e799c656a8c39087e0718" id="r_ac4cbf5d3ec0e799c656a8c39087e0718"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac4cbf5d3ec0e799c656a8c39087e0718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4cbf5d3ec0e799c656a8c39087e0718">operator+</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ac4cbf5d3ec0e799c656a8c39087e0718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82931442d5539449fd23546e25bb86ae" id="r_a82931442d5539449fd23546e25bb86ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a82931442d5539449fd23546e25bb86ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82931442d5539449fd23546e25bb86ae">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a82931442d5539449fd23546e25bb86ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499c18a06cffd9fb9930ba800faa4801" id="r_a499c18a06cffd9fb9930ba800faa4801"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a499c18a06cffd9fb9930ba800faa4801"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a499c18a06cffd9fb9930ba800faa4801">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a499c18a06cffd9fb9930ba800faa4801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f5c49d6dab738f50f9729f5e38ffcb" id="r_a48f5c49d6dab738f50f9729f5e38ffcb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a48f5c49d6dab738f50f9729f5e38ffcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48f5c49d6dab738f50f9729f5e38ffcb">operator-</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a48f5c49d6dab738f50f9729f5e38ffcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d31064099961389d855da11c34cd31" id="r_a62d31064099961389d855da11c34cd31"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a62d31064099961389d855da11c34cd31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62d31064099961389d855da11c34cd31">operator*</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a62d31064099961389d855da11c34cd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dea59a34e6077f3bfdbf0bedc4bc6bf" id="r_a0dea59a34e6077f3bfdbf0bedc4bc6bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0dea59a34e6077f3bfdbf0bedc4bc6bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0dea59a34e6077f3bfdbf0bedc4bc6bf">operator*</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a0dea59a34e6077f3bfdbf0bedc4bc6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e69e867df1a1b9564f6825a59062b8" id="r_ae9e69e867df1a1b9564f6825a59062b8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae9e69e867df1a1b9564f6825a59062b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9e69e867df1a1b9564f6825a59062b8">operator*</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ae9e69e867df1a1b9564f6825a59062b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e1ecd06afff7b886ff8690bf298584" id="r_ae5e1ecd06afff7b886ff8690bf298584"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae5e1ecd06afff7b886ff8690bf298584"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5e1ecd06afff7b886ff8690bf298584">operator/</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ae5e1ecd06afff7b886ff8690bf298584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a73215990ea73911836054392d33c25" id="r_a9a73215990ea73911836054392d33c25"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9a73215990ea73911836054392d33c25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a73215990ea73911836054392d33c25">operator/</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a9a73215990ea73911836054392d33c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77987b5129ca33aaac1cc7f239d3f0ba" id="r_a77987b5129ca33aaac1cc7f239d3f0ba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a77987b5129ca33aaac1cc7f239d3f0ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77987b5129ca33aaac1cc7f239d3f0ba">operator/</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a77987b5129ca33aaac1cc7f239d3f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e6646ea6ece6aac46299e9d0ae0204" id="r_ae2e6646ea6ece6aac46299e9d0ae0204"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae2e6646ea6ece6aac46299e9d0ae0204"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2e6646ea6ece6aac46299e9d0ae0204">operator==</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ae2e6646ea6ece6aac46299e9d0ae0204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dbf6c912f63446fe62ca363ce14874" id="r_af1dbf6c912f63446fe62ca363ce14874"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af1dbf6c912f63446fe62ca363ce14874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1dbf6c912f63446fe62ca363ce14874">operator==</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:af1dbf6c912f63446fe62ca363ce14874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a8fc7be9c1bc3f843a73e0e4084a15" id="r_a89a8fc7be9c1bc3f843a73e0e4084a15"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a89a8fc7be9c1bc3f843a73e0e4084a15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89a8fc7be9c1bc3f843a73e0e4084a15">operator==</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a89a8fc7be9c1bc3f843a73e0e4084a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19652b6d64df0961e5821c4df232fcc5" id="r_a19652b6d64df0961e5821c4df232fcc5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a19652b6d64df0961e5821c4df232fcc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19652b6d64df0961e5821c4df232fcc5">operator!=</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a19652b6d64df0961e5821c4df232fcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4c2db5ab66a07bf724a38c83659acd" id="r_aaf4c2db5ab66a07bf724a38c83659acd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aaf4c2db5ab66a07bf724a38c83659acd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf4c2db5ab66a07bf724a38c83659acd">operator!=</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:aaf4c2db5ab66a07bf724a38c83659acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1eb7312810a052d5df24b678a67965" id="r_abd1eb7312810a052d5df24b678a67965"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abd1eb7312810a052d5df24b678a67965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd1eb7312810a052d5df24b678a67965">operator!=</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:abd1eb7312810a052d5df24b678a67965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e09e7ad6bb736c3af3c6d4a8492094" id="r_a90e09e7ad6bb736c3af3c6d4a8492094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a90e09e7ad6bb736c3af3c6d4a8492094">operator&quot;&quot;_il</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:a90e09e7ad6bb736c3af3c6d4a8492094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa4ce488ecc019a255f8b44595576c7" id="r_a9aa4ce488ecc019a255f8b44595576c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a9aa4ce488ecc019a255f8b44595576c7">operator&quot;&quot;_il</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:a9aa4ce488ecc019a255f8b44595576c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7587d4773cb77963d6a4c24788def998" id="r_a7587d4773cb77963d6a4c24788def998"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a7587d4773cb77963d6a4c24788def998">operator&quot;&quot;_i</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:a7587d4773cb77963d6a4c24788def998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13fbd07fcdb34bc2ae3dc0a1206a097" id="r_ae13fbd07fcdb34bc2ae3dc0a1206a097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#ae13fbd07fcdb34bc2ae3dc0a1206a097">operator&quot;&quot;_i</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:ae13fbd07fcdb34bc2ae3dc0a1206a097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7a230f9307ccbebaaca704bbda63ec" id="r_aef7a230f9307ccbebaaca704bbda63ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#aef7a230f9307ccbebaaca704bbda63ec">operator&quot;&quot;_if</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">float</a> &gt;</td></tr>
<tr class="separator:aef7a230f9307ccbebaaca704bbda63ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91587c8bc9e4d1db5665f40bcdba8ba0" id="r_a91587c8bc9e4d1db5665f40bcdba8ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a91587c8bc9e4d1db5665f40bcdba8ba0">operator&quot;&quot;_if</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">float</a> &gt;</td></tr>
<tr class="separator:a91587c8bc9e4d1db5665f40bcdba8ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ff15d018c17347ac61e95ac1a30764" id="r_ga46ff15d018c17347ac61e95ac1a30764"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga46ff15d018c17347ac61e95ac1a30764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga46ff15d018c17347ac61e95ac1a30764">conj</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga46ff15d018c17347ac61e95ac1a30764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481e11363bfa49433fb96a8519c0e35c" id="r_ga481e11363bfa49433fb96a8519c0e35c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:ga481e11363bfa49433fb96a8519c0e35c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga481e11363bfa49433fb96a8519c0e35c">conj</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> f) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; &gt;</td></tr>
<tr class="separator:ga481e11363bfa49433fb96a8519c0e35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603a3bf23daa51e1c00c83f939a33f04" id="r_ga603a3bf23daa51e1c00c83f939a33f04"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:ga603a3bf23daa51e1c00c83f939a33f04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga603a3bf23daa51e1c00c83f939a33f04">conj</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt; &gt;</td></tr>
<tr class="separator:ga603a3bf23daa51e1c00c83f939a33f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270bd6f09628db22fe5bd8b51dd0b715" id="r_ga270bd6f09628db22fe5bd8b51dd0b715"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga270bd6f09628db22fe5bd8b51dd0b715"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga270bd6f09628db22fe5bd8b51dd0b715">cos</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga270bd6f09628db22fe5bd8b51dd0b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46256752d5c736599fc58eff97661928" id="r_ga46256752d5c736599fc58eff97661928"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga46256752d5c736599fc58eff97661928"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga46256752d5c736599fc58eff97661928">cosh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga46256752d5c736599fc58eff97661928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f08cccdf78e0bd6d348c9650dac539" id="r_gaf3f08cccdf78e0bd6d348c9650dac539"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaf3f08cccdf78e0bd6d348c9650dac539"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gaf3f08cccdf78e0bd6d348c9650dac539">imag</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; T</td></tr>
<tr class="separator:gaf3f08cccdf78e0bd6d348c9650dac539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc1933c315d97e15c015707f12c7569b" id="r_gafc1933c315d97e15c015707f12c7569b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:gafc1933c315d97e15c015707f12c7569b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gafc1933c315d97e15c015707f12c7569b">imag</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a>) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;</td></tr>
<tr class="separator:gafc1933c315d97e15c015707f12c7569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b5cb305b608dff6b0e0726fa3e9aa0" id="r_gad4b5cb305b608dff6b0e0726fa3e9aa0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:gad4b5cb305b608dff6b0e0726fa3e9aa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gad4b5cb305b608dff6b0e0726fa3e9aa0">imag</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a>) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:gad4b5cb305b608dff6b0e0726fa3e9aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dab176f001bd0087f3f8652eace5c93" id="r_ga3dab176f001bd0087f3f8652eace5c93"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga3dab176f001bd0087f3f8652eace5c93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga3dab176f001bd0087f3f8652eace5c93">log</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga3dab176f001bd0087f3f8652eace5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb87c5a1d5623bb01299fd23324b1565" id="r_gabb87c5a1d5623bb01299fd23324b1565"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gabb87c5a1d5623bb01299fd23324b1565"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gabb87c5a1d5623bb01299fd23324b1565">log10</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gabb87c5a1d5623bb01299fd23324b1565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87ec2d3c345ee05d9ccf2b964c9158a" id="r_gaf87ec2d3c345ee05d9ccf2b964c9158a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaf87ec2d3c345ee05d9ccf2b964c9158a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gaf87ec2d3c345ee05d9ccf2b964c9158a">norm</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) noexcept -&gt; T</td></tr>
<tr class="separator:gaf87ec2d3c345ee05d9ccf2b964c9158a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470b55e42f2e92bdc567ee6bcbe6a860" id="r_ga470b55e42f2e92bdc567ee6bcbe6a860"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:ga470b55e42f2e92bdc567ee6bcbe6a860"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga470b55e42f2e92bdc567ee6bcbe6a860">norm</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> f) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; &gt;</td></tr>
<tr class="separator:ga470b55e42f2e92bdc567ee6bcbe6a860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77e5264f5b4ac53f724b8d74b943d77" id="r_gae77e5264f5b4ac53f724b8d74b943d77"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:gae77e5264f5b4ac53f724b8d74b943d77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gae77e5264f5b4ac53f724b8d74b943d77">norm</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1static__vector.html">double</a> &gt; &gt;</td></tr>
<tr class="separator:gae77e5264f5b4ac53f724b8d74b943d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408755ab767193cae4b002c03906843a" id="r_ga408755ab767193cae4b002c03906843a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga408755ab767193cae4b002c03906843a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga408755ab767193cae4b002c03906843a">polar</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">r</a>, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">theta</a>=T()) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">etl::complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga408755ab767193cae4b002c03906843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef5852f3127713fd9350fb575a52096" id="r_ga7ef5852f3127713fd9350fb575a52096"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga7ef5852f3127713fd9350fb575a52096"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga7ef5852f3127713fd9350fb575a52096">real</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; T</td></tr>
<tr class="separator:ga7ef5852f3127713fd9350fb575a52096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fac133cf1602f9bec2fd91ac8e93fbf" id="r_ga0fac133cf1602f9bec2fd91ac8e93fbf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt; </td></tr>
<tr class="memitem:ga0fac133cf1602f9bec2fd91ac8e93fbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga0fac133cf1602f9bec2fd91ac8e93fbf">real</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> f) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;, <a class="el" href="structetl_1_1static__vector.html">Float</a> &gt;</td></tr>
<tr class="separator:ga0fac133cf1602f9bec2fd91ac8e93fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga371a4a57669e09596d80f1ff4198aae5" id="r_ga371a4a57669e09596d80f1ff4198aae5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt; </td></tr>
<tr class="memitem:ga371a4a57669e09596d80f1ff4198aae5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga371a4a57669e09596d80f1ff4198aae5">real</a> (<a class="el" href="structetl_1_1static__vector.html">Integer</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="#a7938694f396828f208ccae1688c9c611">enable_if_t</a>&lt; <a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Integer</a> &gt;, <a class="el" href="structetl_1_1static__vector.html">double</a> &gt;</td></tr>
<tr class="separator:ga371a4a57669e09596d80f1ff4198aae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb16919c024711d1b7fbb969fb0f099" id="r_ga7eb16919c024711d1b7fbb969fb0f099"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga7eb16919c024711d1b7fbb969fb0f099"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga7eb16919c024711d1b7fbb969fb0f099">sin</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga7eb16919c024711d1b7fbb969fb0f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6776dd33fc56dbf0aaf7a9c1ececb72c" id="r_ga6776dd33fc56dbf0aaf7a9c1ececb72c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga6776dd33fc56dbf0aaf7a9c1ececb72c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga6776dd33fc56dbf0aaf7a9c1ececb72c">sinh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga6776dd33fc56dbf0aaf7a9c1ececb72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9543be08a43b5b97cd0ed98b44932467" id="r_ga9543be08a43b5b97cd0ed98b44932467"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga9543be08a43b5b97cd0ed98b44932467"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga9543be08a43b5b97cd0ed98b44932467">tan</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga9543be08a43b5b97cd0ed98b44932467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb57b849230e292fb874b066ae1eb6f2" id="r_gafb57b849230e292fb874b066ae1eb6f2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gafb57b849230e292fb874b066ae1eb6f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gafb57b849230e292fb874b066ae1eb6f2">tanh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gafb57b849230e292fb874b066ae1eb6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f88510fb558792c06ba4d60e131fdd1" id="r_a5f88510fb558792c06ba4d60e131fdd1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a5f88510fb558792c06ba4d60e131fdd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f88510fb558792c06ba4d60e131fdd1">to_integer</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="memdesc:a5f88510fb558792c06ba4d60e131fdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return Int(b);</code>  <br /></td></tr>
<tr class="separator:a5f88510fb558792c06ba4d60e131fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f962a144b755b9ea24d08df7e0b0cac" id="r_a7f962a144b755b9ea24d08df7e0b0cac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a7f962a144b755b9ea24d08df7e0b0cac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f962a144b755b9ea24d08df7e0b0cac">operator&lt;&lt;</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> b, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">shift</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:a7f962a144b755b9ea24d08df7e0b0cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return <a class="el" href="#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);</code>  <br /></td></tr>
<tr class="separator:a7f962a144b755b9ea24d08df7e0b0cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c6aea683ce911a79e8e3e149bcbd0a" id="r_ab7c6aea683ce911a79e8e3e149bcbd0a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:ab7c6aea683ce911a79e8e3e149bcbd0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7c6aea683ce911a79e8e3e149bcbd0a">operator&gt;&gt;</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> b, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">shift</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:ab7c6aea683ce911a79e8e3e149bcbd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return <a class="el" href="#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);</code>  <br /></td></tr>
<tr class="separator:ab7c6aea683ce911a79e8e3e149bcbd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b6a5afd1d4bfe41cd6e68c65e863b2" id="r_ab8b6a5afd1d4bfe41cd6e68c65e863b2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:ab8b6a5afd1d4bfe41cd6e68c65e863b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8b6a5afd1d4bfe41cd6e68c65e863b2">operator&lt;&lt;=</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">shift</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:ab8b6a5afd1d4bfe41cd6e68c65e863b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return b = b &lt;&lt; shift;</code>  <br /></td></tr>
<tr class="separator:ab8b6a5afd1d4bfe41cd6e68c65e863b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816d2bda5b74ad68f41da42d2103bd05" id="r_a816d2bda5b74ad68f41da42d2103bd05"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a816d2bda5b74ad68f41da42d2103bd05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a816d2bda5b74ad68f41da42d2103bd05">operator&gt;&gt;=</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;b, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">shift</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a816d2bda5b74ad68f41da42d2103bd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return b = b &gt;&gt; shift;</code>  <br /></td></tr>
<tr class="separator:a816d2bda5b74ad68f41da42d2103bd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8162fc27033213c5febe33984fe4620" id="r_ab8162fc27033213c5febe33984fe4620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8162fc27033213c5febe33984fe4620">operator|</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:ab8162fc27033213c5febe33984fe4620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) | static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:ab8162fc27033213c5febe33984fe4620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd648029508f54a8dbc5a24527893329" id="r_abd648029508f54a8dbc5a24527893329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd648029508f54a8dbc5a24527893329">operator&amp;</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:abd648029508f54a8dbc5a24527893329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) &amp; static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:abd648029508f54a8dbc5a24527893329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f4395e5d3ab16e3babc4d612575cf1" id="r_a13f4395e5d3ab16e3babc4d612575cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13f4395e5d3ab16e3babc4d612575cf1">operator^</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:a13f4395e5d3ab16e3babc4d612575cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) ^ static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:a13f4395e5d3ab16e3babc4d612575cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52840f1140aa019ed0075de67862a323" id="r_a52840f1140aa019ed0075de67862a323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52840f1140aa019ed0075de67862a323">operator~</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> b) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td></tr>
<tr class="memdesc:a52840f1140aa019ed0075de67862a323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(~static_cast&lt;unsigned int&gt;(b));</code>  <br /></td></tr>
<tr class="separator:a52840f1140aa019ed0075de67862a323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68cc74f5c18699cb47643078832090a" id="r_aa68cc74f5c18699cb47643078832090a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68cc74f5c18699cb47643078832090a">operator|=</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:aa68cc74f5c18699cb47643078832090a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs | rhs;</code>  <br /></td></tr>
<tr class="separator:aa68cc74f5c18699cb47643078832090a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca267dc51177e1d336cad3b8d675f85" id="r_a5ca267dc51177e1d336cad3b8d675f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca267dc51177e1d336cad3b8d675f85">operator&amp;=</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a5ca267dc51177e1d336cad3b8d675f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs &amp; rhs;</code>  <br /></td></tr>
<tr class="separator:a5ca267dc51177e1d336cad3b8d675f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc5fb1abc307dee4cb7c8b115ba159c" id="r_a4bc5fb1abc307dee4cb7c8b115ba159c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bc5fb1abc307dee4cb7c8b115ba159c">operator^=</a> (<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a4bc5fb1abc307dee4cb7c8b115ba159c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs ^ rhs;</code>  <br /></td></tr>
<tr class="separator:a4bc5fb1abc307dee4cb7c8b115ba159c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70c570009ef313782a1d98cfdadb585" id="r_af70c570009ef313782a1d98cfdadb585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af70c570009ef313782a1d98cfdadb585">atof</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:af70c570009ef313782a1d98cfdadb585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:af70c570009ef313782a1d98cfdadb585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7960c7c5d175e0f3618b82c78bcdb2" id="r_a3c7960c7c5d175e0f3618b82c78bcdb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c7960c7c5d175e0f3618b82c78bcdb2">atoi</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a3c7960c7c5d175e0f3618b82c78bcdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:a3c7960c7c5d175e0f3618b82c78bcdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f3cb11f38d582981fb054f50f8a39c" id="r_ac7f3cb11f38d582981fb054f50f8a39c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f3cb11f38d582981fb054f50f8a39c">atol</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ac7f3cb11f38d582981fb054f50f8a39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:ac7f3cb11f38d582981fb054f50f8a39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc340d657073dbc2d05ea36759ac0e4" id="r_afbc340d657073dbc2d05ea36759ac0e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbc340d657073dbc2d05ea36759ac0e4">atoll</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:afbc340d657073dbc2d05ea36759ac0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:afbc340d657073dbc2d05ea36759ac0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac545280f6ddc88082f02e4a7db6736" id="r_a1ac545280f6ddc88082f02e4a7db6736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ac545280f6ddc88082f02e4a7db6736">div</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> y) noexcept -&gt; <a class="el" href="structetl_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:a1ac545280f6ddc88082f02e4a7db6736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a1ac545280f6ddc88082f02e4a7db6736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b084ea5ad111474f8921643c3de3931" id="r_a1b084ea5ad111474f8921643c3de3931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b084ea5ad111474f8921643c3de3931">labs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a1b084ea5ad111474f8921643c3de3931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a1b084ea5ad111474f8921643c3de3931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b5e9350f1530967470589c83376b30" id="r_a43b5e9350f1530967470589c83376b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43b5e9350f1530967470589c83376b30">div</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:a43b5e9350f1530967470589c83376b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a43b5e9350f1530967470589c83376b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b706a74e1efaf3c98804627fba671c" id="r_ab7b706a74e1efaf3c98804627fba671c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7b706a74e1efaf3c98804627fba671c">ldiv</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:ab7b706a74e1efaf3c98804627fba671c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:ab7b706a74e1efaf3c98804627fba671c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c11a988c576e5879aa5b6517da8d3e" id="r_a03c11a988c576e5879aa5b6517da8d3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03c11a988c576e5879aa5b6517da8d3e">llabs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a03c11a988c576e5879aa5b6517da8d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a03c11a988c576e5879aa5b6517da8d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea0cf9ba86f1635030cb6a8f03c88b0" id="r_a3ea0cf9ba86f1635030cb6a8f03c88b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ea0cf9ba86f1635030cb6a8f03c88b0">div</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:a3ea0cf9ba86f1635030cb6a8f03c88b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a3ea0cf9ba86f1635030cb6a8f03c88b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6958cfa96164c754c7859d22d8e5a95" id="r_ac6958cfa96164c754c7859d22d8e5a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6958cfa96164c754c7859d22d8e5a95">lldiv</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:ac6958cfa96164c754c7859d22d8e5a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:ac6958cfa96164c754c7859d22d8e5a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1305ac2417af24cbfd08da05eeb1c32d" id="r_a1305ac2417af24cbfd08da05eeb1c32d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1305ac2417af24cbfd08da05eeb1c32d">strtod</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a1305ac2417af24cbfd08da05eeb1c32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a1305ac2417af24cbfd08da05eeb1c32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4" id="r_aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4">strtof</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4892f7bf3b9db8e5a5b3476de9f04c07" id="r_a4892f7bf3b9db8e5a5b3476de9f04c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4892f7bf3b9db8e5a5b3476de9f04c07">strtol</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last, <a class="el" href="structetl_1_1static__vector.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a4892f7bf3b9db8e5a5b3476de9f04c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a4892f7bf3b9db8e5a5b3476de9f04c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53416ace17ca278512fca91c7ba514a9" id="r_a53416ace17ca278512fca91c7ba514a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53416ace17ca278512fca91c7ba514a9">strtoll</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last, <a class="el" href="structetl_1_1static__vector.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a53416ace17ca278512fca91c7ba514a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a53416ace17ca278512fca91c7ba514a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b910e11532f3565d81bd36ff4e4c10" id="r_af4b910e11532f3565d81bd36ff4e4c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4b910e11532f3565d81bd36ff4e4c10">strtold</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:af4b910e11532f3565d81bd36ff4e4c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:af4b910e11532f3565d81bd36ff4e4c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e80359aae6a19c6d0dc9aee1ba6fcb5" id="r_a4e80359aae6a19c6d0dc9aee1ba6fcb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e80359aae6a19c6d0dc9aee1ba6fcb5">strtoul</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last, <a class="el" href="structetl_1_1static__vector.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a4e80359aae6a19c6d0dc9aee1ba6fcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a4e80359aae6a19c6d0dc9aee1ba6fcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b4a7bd2816e64811c98ac8e21e5c3" id="r_a760b4a7bd2816e64811c98ac8e21e5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760b4a7bd2816e64811c98ac8e21e5c3">strtoull</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **last, <a class="el" href="structetl_1_1static__vector.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a760b4a7bd2816e64811c98ac8e21e5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a760b4a7bd2816e64811c98ac8e21e5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d4e77b1294b6c89f3b26e64390c60" id="r_a652d4e77b1294b6c89f3b26e64390c60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a652d4e77b1294b6c89f3b26e64390c60">memchr</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> *ptr, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:a652d4e77b1294b6c89f3b26e64390c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <br /></td></tr>
<tr class="separator:a652d4e77b1294b6c89f3b26e64390c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017dcc9819e43ade5bb455dda0ded667" id="r_a017dcc9819e43ade5bb455dda0ded667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a017dcc9819e43ade5bb455dda0ded667">memchr</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *ptr, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:a017dcc9819e43ade5bb455dda0ded667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <br /></td></tr>
<tr class="separator:a017dcc9819e43ade5bb455dda0ded667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7fa1c3f3f946c9269a7aa241e3efcf" id="r_a1a7fa1c3f3f946c9269a7aa241e3efcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a7fa1c3f3f946c9269a7aa241e3efcf">memcpy</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:a1a7fa1c3f3f946c9269a7aa241e3efcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="#abfee8229e9528f5285c42fde7abbe4b6" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead.  <br /></td></tr>
<tr class="separator:a1a7fa1c3f3f946c9269a7aa241e3efcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfee8229e9528f5285c42fde7abbe4b6" id="r_abfee8229e9528f5285c42fde7abbe4b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfee8229e9528f5285c42fde7abbe4b6">memmove</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:abfee8229e9528f5285c42fde7abbe4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap.  <br /></td></tr>
<tr class="separator:abfee8229e9528f5285c42fde7abbe4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055dc327ea35a394f661ca98bf2b08ad" id="r_a055dc327ea35a394f661ca98bf2b08ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a055dc327ea35a394f661ca98bf2b08ad">memset</a> (<a class="el" href="structetl_1_1static__vector.html">void</a> *<a class="el" href="structetl_1_1static__vector.html">s</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> c, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:a055dc327ea35a394f661ca98bf2b08ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of c (converted to an unsigned char) into each of the rst n characters of the object pointed to by s.  <br /></td></tr>
<tr class="separator:a055dc327ea35a394f661ca98bf2b08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb9a3999d07c6ea33b804dc470d6db3" id="r_abbb9a3999d07c6ea33b804dc470d6db3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbb9a3999d07c6ea33b804dc470d6db3">strcat</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:abbb9a3999d07c6ea33b804dc470d6db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated.  <br /></td></tr>
<tr class="separator:abbb9a3999d07c6ea33b804dc470d6db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae924f4675f1be06ee9610b8998d20101" id="r_ae924f4675f1be06ee9610b8998d20101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae924f4675f1be06ee9610b8998d20101">strchr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:ae924f4675f1be06ee9610b8998d20101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ae924f4675f1be06ee9610b8998d20101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaf5ecef57c791ea8f5d102444af26f" id="r_afdaf5ecef57c791ea8f5d102444af26f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdaf5ecef57c791ea8f5d102444af26f">strchr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:afdaf5ecef57c791ea8f5d102444af26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:afdaf5ecef57c791ea8f5d102444af26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b99355fef2ddb6740fbda691efe5591" id="r_a2b99355fef2ddb6740fbda691efe5591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b99355fef2ddb6740fbda691efe5591">strcmp</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a2b99355fef2ddb6740fbda691efe5591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the C string lhs to the C string rhs.  <br /></td></tr>
<tr class="separator:a2b99355fef2ddb6740fbda691efe5591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72afd377245fa4f73d8c4c49b5e42fd" id="r_ac72afd377245fa4f73d8c4c49b5e42fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac72afd377245fa4f73d8c4c49b5e42fd">strcpy</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:ac72afd377245fa4f73d8c4c49b5e42fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest.  <br /></td></tr>
<tr class="separator:ac72afd377245fa4f73d8c4c49b5e42fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b32f2701df8bd44d7cff9b1ea93c2c" id="r_a07b32f2701df8bd44d7cff9b1ea93c2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b32f2701df8bd44d7cff9b1ea93c2c">strcspn</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td></tr>
<tr class="memdesc:a07b32f2701df8bd44d7cff9b1ea93c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src.  <br /></td></tr>
<tr class="separator:a07b32f2701df8bd44d7cff9b1ea93c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52f9a0c2a72681b011673eb4d16997" id="r_a1f52f9a0c2a72681b011673eb4d16997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f52f9a0c2a72681b011673eb4d16997">strlen</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td></tr>
<tr class="memdesc:a1f52f9a0c2a72681b011673eb4d16997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the C string str.  <br /></td></tr>
<tr class="separator:a1f52f9a0c2a72681b011673eb4d16997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a52c188c85f66642fdcd0b2a5c0f343" id="r_a3a52c188c85f66642fdcd0b2a5c0f343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a52c188c85f66642fdcd0b2a5c0f343">strncat</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:a3a52c188c85f66642fdcd0b2a5c0f343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated.  <br /></td></tr>
<tr class="separator:a3a52c188c85f66642fdcd0b2a5c0f343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ea9bb99dc7df1c93691e27036d4e4c" id="r_a86ea9bb99dc7df1c93691e27036d4e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86ea9bb99dc7df1c93691e27036d4e4c">strncmp</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a86ea9bb99dc7df1c93691e27036d4e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared.  <br /></td></tr>
<tr class="separator:a86ea9bb99dc7df1c93691e27036d4e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591fc182edd0e8beef7af369c2dd772f" id="r_a591fc182edd0e8beef7af369c2dd772f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591fc182edd0e8beef7af369c2dd772f">strncpy</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:a591fc182edd0e8beef7af369c2dd772f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a591fc182edd0e8beef7af369c2dd772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7504aaa95975de1bb831366bbd2c4c7" id="r_af7504aaa95975de1bb831366bbd2c4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7504aaa95975de1bb831366bbd2c4c7">strpbrk</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:af7504aaa95975de1bb831366bbd2c4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <br /></td></tr>
<tr class="separator:af7504aaa95975de1bb831366bbd2c4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e3a1713cb32006d461f6cacaa45938" id="r_aa2e3a1713cb32006d461f6cacaa45938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2e3a1713cb32006d461f6cacaa45938">strpbrk</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:aa2e3a1713cb32006d461f6cacaa45938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <br /></td></tr>
<tr class="separator:aa2e3a1713cb32006d461f6cacaa45938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aa1bb3b20e18932c57369e8dd367ce" id="r_aa1aa1bb3b20e18932c57369e8dd367ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1aa1bb3b20e18932c57369e8dd367ce">strrchr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:aa1aa1bb3b20e18932c57369e8dd367ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:aa1aa1bb3b20e18932c57369e8dd367ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f722dadf4562da90ec04a75000dca60" id="r_a5f722dadf4562da90ec04a75000dca60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f722dadf4562da90ec04a75000dca60">strrchr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:a5f722dadf4562da90ec04a75000dca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a5f722dadf4562da90ec04a75000dca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef81a9b0d796d2bbac780bd021b75d5a" id="r_aef81a9b0d796d2bbac780bd021b75d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef81a9b0d796d2bbac780bd021b75d5a">strspn</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td></tr>
<tr class="memdesc:aef81a9b0d796d2bbac780bd021b75d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src.  <br /></td></tr>
<tr class="separator:aef81a9b0d796d2bbac780bd021b75d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda82eb09b8ee508deb730a58e8e1ad0" id="r_abda82eb09b8ee508deb730a58e8e1ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abda82eb09b8ee508deb730a58e8e1ad0">strstr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">haystack</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> *<a class="el" href="structetl_1_1static__vector.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> *</td></tr>
<tr class="memdesc:abda82eb09b8ee508deb730a58e8e1ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:abda82eb09b8ee508deb730a58e8e1ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dedeb847abd763b3016a290b6efd87e" id="r_a0dedeb847abd763b3016a290b6efd87e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dedeb847abd763b3016a290b6efd87e">strstr</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">haystack</a>, <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:a0dedeb847abd763b3016a290b6efd87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:a0dedeb847abd763b3016a290b6efd87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb64ccab832f8ed29a305df495394bd8" id="r_afb64ccab832f8ed29a305df495394bd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb64ccab832f8ed29a305df495394bd8">wcscat</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:afb64ccab832f8ed29a305df495394bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated.  <br /></td></tr>
<tr class="separator:afb64ccab832f8ed29a305df495394bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f3717d1befc65ded1e73b0dc19405b" id="r_ab4f3717d1befc65ded1e73b0dc19405b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4f3717d1befc65ded1e73b0dc19405b">wcschr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:ab4f3717d1befc65ded1e73b0dc19405b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:ab4f3717d1befc65ded1e73b0dc19405b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc2ac1163d4f8e69b06785a16903b92" id="r_afcc2ac1163d4f8e69b06785a16903b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcc2ac1163d4f8e69b06785a16903b92">wcschr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:afcc2ac1163d4f8e69b06785a16903b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:afcc2ac1163d4f8e69b06785a16903b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dacca606e09097af1b0d48826fbbaf8" id="r_a8dacca606e09097af1b0d48826fbbaf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dacca606e09097af1b0d48826fbbaf8">wcscmp</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a8dacca606e09097af1b0d48826fbbaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two null-terminated wide strings lexicographically.  <br /></td></tr>
<tr class="separator:a8dacca606e09097af1b0d48826fbbaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777b53d3246198c5cbf458e59cbd05bf" id="r_a777b53d3246198c5cbf458e59cbd05bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a777b53d3246198c5cbf458e59cbd05bf">wcscpy</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a777b53d3246198c5cbf458e59cbd05bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a777b53d3246198c5cbf458e59cbd05bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a295816ea0a099202fb0dca32be52c" id="r_af4a295816ea0a099202fb0dca32be52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4a295816ea0a099202fb0dca32be52c">wcscspn</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td></tr>
<tr class="memdesc:af4a295816ea0a099202fb0dca32be52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src.  <br /></td></tr>
<tr class="separator:af4a295816ea0a099202fb0dca32be52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52365d01da2db57b4fd8ab457fde90d4" id="r_a52365d01da2db57b4fd8ab457fde90d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52365d01da2db57b4fd8ab457fde90d4">wcslen</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>) -&gt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a></td></tr>
<tr class="memdesc:a52365d01da2db57b4fd8ab457fde90d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.  <br /></td></tr>
<tr class="separator:a52365d01da2db57b4fd8ab457fde90d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d334b345c8ec3b4df9ed3017e1a0e9" id="r_a31d334b345c8ec3b4df9ed3017e1a0e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31d334b345c8ec3b4df9ed3017e1a0e9">wcsncat</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a31d334b345c8ec3b4df9ed3017e1a0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1).  <br /></td></tr>
<tr class="separator:a31d334b345c8ec3b4df9ed3017e1a0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cb809db1b2078c2f3a183d9cf15fe6" id="r_ad6cb809db1b2078c2f3a183d9cf15fe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6cb809db1b2078c2f3a183d9cf15fe6">wcsncmp</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ad6cb809db1b2078c2f3a183d9cf15fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically.  <br /></td></tr>
<tr class="separator:ad6cb809db1b2078c2f3a183d9cf15fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df6765439e9363b7bd6b29c16e9ad1e" id="r_a3df6765439e9363b7bd6b29c16e9ad1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3df6765439e9363b7bd6b29c16e9ad1e">wcsncpy</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a3df6765439e9363b7bd6b29c16e9ad1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a3df6765439e9363b7bd6b29c16e9ad1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543232e434a1cf41ac373bb986dd6761" id="r_a543232e434a1cf41ac373bb986dd6761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a543232e434a1cf41ac373bb986dd6761">wcspbrk</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a543232e434a1cf41ac373bb986dd6761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a543232e434a1cf41ac373bb986dd6761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b719c7d907c831543f6a36d7c03c358" id="r_a8b719c7d907c831543f6a36d7c03c358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b719c7d907c831543f6a36d7c03c358">wcspbrk</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:a8b719c7d907c831543f6a36d7c03c358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a8b719c7d907c831543f6a36d7c03c358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cde920ef4c8b78dad83887cf67520dd" id="r_a5cde920ef4c8b78dad83887cf67520dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cde920ef4c8b78dad83887cf67520dd">wcsrchr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a5cde920ef4c8b78dad83887cf67520dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a5cde920ef4c8b78dad83887cf67520dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b66e9eebb616eadbab0b3001b1e9660" id="r_a1b66e9eebb616eadbab0b3001b1e9660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b66e9eebb616eadbab0b3001b1e9660">wcsrchr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:a1b66e9eebb616eadbab0b3001b1e9660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a1b66e9eebb616eadbab0b3001b1e9660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c979220a7a1ae7a993a34cce85292a" id="r_a51c979220a7a1ae7a993a34cce85292a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51c979220a7a1ae7a993a34cce85292a">wcsspn</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>) noexcept -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td></tr>
<tr class="memdesc:a51c979220a7a1ae7a993a34cce85292a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src.  <br /></td></tr>
<tr class="separator:a51c979220a7a1ae7a993a34cce85292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32485447cbd1674e0686656279ec028c" id="r_a32485447cbd1674e0686656279ec028c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32485447cbd1674e0686656279ec028c">wcsstr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">haystack</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a32485447cbd1674e0686656279ec028c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:a32485447cbd1674e0686656279ec028c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c0611a936348d0a6ca7ddc93df74a" id="r_a074c0611a936348d0a6ca7ddc93df74a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a074c0611a936348d0a6ca7ddc93df74a">wcsstr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">haystack</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:a074c0611a936348d0a6ca7ddc93df74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:a074c0611a936348d0a6ca7ddc93df74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e196f654f32975356c8fba3537a39de" id="r_a2e196f654f32975356c8fba3537a39de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e196f654f32975356c8fba3537a39de">wmemchr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *ptr, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a2e196f654f32975356c8fba3537a39de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.  <br /></td></tr>
<tr class="separator:a2e196f654f32975356c8fba3537a39de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae467dc0a0abf29b78d47c3b475ecb5ba" id="r_ae467dc0a0abf29b78d47c3b475ecb5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae467dc0a0abf29b78d47c3b475ecb5ba">wmemchr</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *ptr, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td></tr>
<tr class="memdesc:ae467dc0a0abf29b78d47c3b475ecb5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.  <br /></td></tr>
<tr class="separator:ae467dc0a0abf29b78d47c3b475ecb5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379cf75ba2d4c066193884e36556cf04" id="r_a379cf75ba2d4c066193884e36556cf04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a379cf75ba2d4c066193884e36556cf04">wmemcmp</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a379cf75ba2d4c066193884e36556cf04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically.  <br /></td></tr>
<tr class="separator:a379cf75ba2d4c066193884e36556cf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d687ebc1e3e94aa01302127c3eb8400" id="r_a1d687ebc1e3e94aa01302127c3eb8400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d687ebc1e3e94aa01302127c3eb8400">wmemcpy</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a1d687ebc1e3e94aa01302127c3eb8400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing.  <br /></td></tr>
<tr class="separator:a1d687ebc1e3e94aa01302127c3eb8400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cdeb9c67af4a7dfe7cc7ab4c88e390" id="r_a87cdeb9c67af4a7dfe7cc7ab4c88e390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87cdeb9c67af4a7dfe7cc7ab4c88e390">wmemmove</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">src</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a87cdeb9c67af4a7dfe7cc7ab4c88e390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a87cdeb9c67af4a7dfe7cc7ab4c88e390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a108d16f8cd8006676972370a2b2ed" id="r_a24a108d16f8cd8006676972370a2b2ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24a108d16f8cd8006676972370a2b2ed">wmemset</a> (<a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *<a class="el" href="structetl_1_1static__vector.html">dest</a>, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a24a108d16f8cd8006676972370a2b2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a24a108d16f8cd8006676972370a2b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf33590c450c820a71740fa96d4fd8bf" id="r_adf33590c450c820a71740fa96d4fd8bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf33590c450c820a71740fa96d4fd8bf">iswalnum</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:adf33590c450c820a71740fa96d4fd8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale.  <br /></td></tr>
<tr class="separator:adf33590c450c820a71740fa96d4fd8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bb7228a1ec4507b17c3800ae7edaad" id="r_a50bb7228a1ec4507b17c3800ae7edaad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50bb7228a1ec4507b17c3800ae7edaad">iswalpha</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a50bb7228a1ec4507b17c3800ae7edaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale.  <br /></td></tr>
<tr class="separator:a50bb7228a1ec4507b17c3800ae7edaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8266a2249c1038e8be09fc34571aa3" id="r_ace8266a2249c1038e8be09fc34571aa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace8266a2249c1038e8be09fc34571aa3">iswblank</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ace8266a2249c1038e8be09fc34571aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters.  <br /></td></tr>
<tr class="separator:ace8266a2249c1038e8be09fc34571aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16fb2c6452c7d592f75fad4c301f65f" id="r_aa16fb2c6452c7d592f75fad4c301f65f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa16fb2c6452c7d592f75fad4c301f65f">iswcntrl</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:aa16fb2c6452c7d592f75fad4c301f65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale.  <br /></td></tr>
<tr class="separator:aa16fb2c6452c7d592f75fad4c301f65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a984673da6b8253c14ef105d4ecabe" id="r_a91a984673da6b8253c14ef105d4ecabe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91a984673da6b8253c14ef105d4ecabe">iswdigit</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a91a984673da6b8253c14ef105d4ecabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.  <br /></td></tr>
<tr class="separator:a91a984673da6b8253c14ef105d4ecabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f830b2cf289299d90d426cdec407ee" id="r_af1f830b2cf289299d90d426cdec407ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1f830b2cf289299d90d426cdec407ee">iswgraph</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:af1f830b2cf289299d90d426cdec407ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~) or any graphical character specific to the current C locale.  <br /></td></tr>
<tr class="separator:af1f830b2cf289299d90d426cdec407ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eb7b15acffae2d169a7eaed66d9ba8" id="r_a18eb7b15acffae2d169a7eaed66d9ba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18eb7b15acffae2d169a7eaed66d9ba8">iswlower</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a18eb7b15acffae2d169a7eaed66d9ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale.  <br /></td></tr>
<tr class="separator:a18eb7b15acffae2d169a7eaed66d9ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c5da6eb3f6bb1409caaf48fe877d11" id="r_a92c5da6eb3f6bb1409caaf48fe877d11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92c5da6eb3f6bb1409caaf48fe877d11">iswprint</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a92c5da6eb3f6bb1409caaf48fe877d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~), space or any printable character specific to the current C locale.  <br /></td></tr>
<tr class="separator:a92c5da6eb3f6bb1409caaf48fe877d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0e85b2a576c543e973d860e1c1295f" id="r_ace0e85b2a576c543e973d860e1c1295f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace0e85b2a576c543e973d860e1c1295f">iswpunct</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ace0e85b2a576c543e973d860e1c1295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a punctuation character, i.e. it is one of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ or any punctuation character specific to the current locale.  <br /></td></tr>
<tr class="separator:ace0e85b2a576c543e973d860e1c1295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dbfeff185b4dad6a13d3c3e891f366" id="r_a38dbfeff185b4dad6a13d3c3e891f366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38dbfeff185b4dad6a13d3c3e891f366">iswspace</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a38dbfeff185b4dad6a13d3c3e891f366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:  <br /></td></tr>
<tr class="separator:a38dbfeff185b4dad6a13d3c3e891f366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31f677c72798a1e14ebb84dc2672e21" id="r_ae31f677c72798a1e14ebb84dc2672e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae31f677c72798a1e14ebb84dc2672e21">iswupper</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ae31f677c72798a1e14ebb84dc2672e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale.  <br /></td></tr>
<tr class="separator:ae31f677c72798a1e14ebb84dc2672e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac809578dc97747348dcc5795cbfa86ff" id="r_ac809578dc97747348dcc5795cbfa86ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac809578dc97747348dcc5795cbfa86ff">iswxdigit</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ac809578dc97747348dcc5795cbfa86ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF.  <br /></td></tr>
<tr class="separator:ac809578dc97747348dcc5795cbfa86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84de6738bfdc87aa9da8b107db172a43" id="r_a84de6738bfdc87aa9da8b107db172a43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84de6738bfdc87aa9da8b107db172a43">towlower</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td></tr>
<tr class="memdesc:a84de6738bfdc87aa9da8b107db172a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given wide character to lowercase, if possible.  <br /></td></tr>
<tr class="separator:a84de6738bfdc87aa9da8b107db172a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9a0766e4327d94f39e77acc5a88bbc" id="r_a0a9a0766e4327d94f39e77acc5a88bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a9a0766e4327d94f39e77acc5a88bbc">towupper</a> (<a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a> <a class="el" href="structetl_1_1static__vector.html">ch</a>) noexcept -&gt; <a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td></tr>
<tr class="memdesc:a0a9a0766e4327d94f39e77acc5a88bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given wide character to uppercase, if possible.  <br /></td></tr>
<tr class="separator:a0a9a0766e4327d94f39e77acc5a88bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc789d7f68f903e899cff481cd71d1c" id="r_a4cc789d7f68f903e899cff481cd71d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc789d7f68f903e899cff481cd71d1c">breakpoint</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a4cc789d7f68f903e899cff481cd71d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181e440953b961dd37846ec6cfc1727d" id="r_a181e440953b961dd37846ec6cfc1727d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a181e440953b961dd37846ec6cfc1727d">breakpoint_if_debugging</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a181e440953b961dd37846ec6cfc1727d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3eebb4ba67500e7280f6a5fe320c696" id="r_ad3eebb4ba67500e7280f6a5fe320c696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3eebb4ba67500e7280f6a5fe320c696">is_debugger_present</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ad3eebb4ba67500e7280f6a5fe320c696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf97f58690e1661fa4c536e2a89c9b52" id="r_aaf97f58690e1661fa4c536e2a89c9b52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Exception</a> &gt; </td></tr>
<tr class="memitem:aaf97f58690e1661fa4c536e2a89c9b52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#abb156b0e852ad82749ae42934d3b4dbf">TETL_NO_INLINE</a> <a class="el" href="attributes_8hpp.html#af0eb4be3e44a6a8a9235265e12ad89a7">TETL_COLD</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf97f58690e1661fa4c536e2a89c9b52">raise</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">msg</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:aaf97f58690e1661fa4c536e2a89c9b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11c4b54fda6c14f1df7ee9acbb8990b" id="r_af11c4b54fda6c14f1df7ee9acbb8990b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">E</a> &gt; </td></tr>
<tr class="memitem:af11c4b54fda6c14f1df7ee9acbb8990b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af11c4b54fda6c14f1df7ee9acbb8990b">unexpected</a> (<a class="el" href="structetl_1_1static__vector.html">E</a>) -&gt; unexpected&lt; <a class="el" href="structetl_1_1static__vector.html">E</a> &gt;</td></tr>
<tr class="separator:af11c4b54fda6c14f1df7ee9acbb8990b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4a29ac6268a32d655a572bc728d561" id="r_a2e4a29ac6268a32d655a572bc728d561"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a2e4a29ac6268a32d655a572bc728d561"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e4a29ac6268a32d655a572bc728d561">operator==</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;y) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a2e4a29ac6268a32d655a572bc728d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb7776985e823982b6dd579ea9446a5" id="r_adbb7776985e823982b6dd579ea9446a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:adbb7776985e823982b6dd579ea9446a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbb7776985e823982b6dd579ea9446a5">operator!=</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;y) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:adbb7776985e823982b6dd579ea9446a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9846352e3d467e86fb4172d2637104" id="r_a0f9846352e3d467e86fb4172d2637104"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a0f9846352e3d467e86fb4172d2637104"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f9846352e3d467e86fb4172d2637104">operator&lt;</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;y) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a0f9846352e3d467e86fb4172d2637104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f945b742cbe77cd2922aca6e578b56" id="r_ac0f945b742cbe77cd2922aca6e578b56"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ac0f945b742cbe77cd2922aca6e578b56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0f945b742cbe77cd2922aca6e578b56">operator&gt;</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;y) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ac0f945b742cbe77cd2922aca6e578b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105dc9103728fcd8f416fecb9b356558" id="r_a105dc9103728fcd8f416fecb9b356558"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a105dc9103728fcd8f416fecb9b356558"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a105dc9103728fcd8f416fecb9b356558">operator&lt;=</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;y) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a105dc9103728fcd8f416fecb9b356558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c01f47f59173080b54d4233235e144" id="r_ad9c01f47f59173080b54d4233235e144"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ad9c01f47f59173080b54d4233235e144"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9c01f47f59173080b54d4233235e144">operator&gt;=</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;y) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ad9c01f47f59173080b54d4233235e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1cbfaeb551a2e0c9a49d4bb500bc98" id="r_a2d1cbfaeb551a2e0c9a49d4bb500bc98"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a2d1cbfaeb551a2e0c9a49d4bb500bc98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">swap</a> (<a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;y) noexcept(noexcept(x.swap(y))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a2d1cbfaeb551a2e0c9a49d4bb500bc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd52266a9a948c41abe1558e71ac0c95" id="r_afd52266a9a948c41abe1558e71ac0c95"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , typename... Args&gt; </td></tr>
<tr class="memitem:afd52266a9a948c41abe1558e71ac0c95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd52266a9a948c41abe1558e71ac0c95">format_to</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIt</a> out, <a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">fmt</a>, <a class="el" href="structetl_1_1static__vector.html">Args</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;... args) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:afd52266a9a948c41abe1558e71ac0c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and write the result to the output iterator out.  <br /></td></tr>
<tr class="separator:afd52266a9a948c41abe1558e71ac0c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca222d51d5032dd1702938d3a603d705" id="r_aca222d51d5032dd1702938d3a603d705"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> , typename... Args&gt; </td></tr>
<tr class="memitem:aca222d51d5032dd1702938d3a603d705"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca222d51d5032dd1702938d3a603d705">format_to_n</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIter</a> out, <a class="el" href="#a1ccda852d9fec850405ea795d8c58e8f">diff_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> &gt; <a class="el" href="structetl_1_1static__vector.html">n</a>, <a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">fmt</a>, <a class="el" href="structetl_1_1static__vector.html">Args</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;... args) -&gt; <a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a>&lt; <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> &gt;</td></tr>
<tr class="memdesc:aca222d51d5032dd1702938d3a603d705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and write the result to the output iterator out. At most n characters are written.  <br /></td></tr>
<tr class="separator:aca222d51d5032dd1702938d3a603d705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa401a56ff8788d235f9da9eae62db565" id="r_aa401a56ff8788d235f9da9eae62db565"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Context</a>  = etl::format_context, typename... Args&gt; </td></tr>
<tr class="memitem:aa401a56ff8788d235f9da9eae62db565"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa401a56ff8788d235f9da9eae62db565">make_format_args</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; detail::format_arg_store&lt; <a class="el" href="structetl_1_1static__vector.html">Context</a>, Args... &gt;</td></tr>
<tr class="separator:aa401a56ff8788d235f9da9eae62db565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b34548f40179d322193dd18148c65c5" id="r_a2b34548f40179d322193dd18148c65c5"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2b34548f40179d322193dd18148c65c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b34548f40179d322193dd18148c65c5">make_wformat_args</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; detail::format_arg_store&lt; <a class="el" href="#af14a1ebd9061ef0ef02d67e436e4fcd4">wformat_context</a>, Args... &gt;</td></tr>
<tr class="separator:a2b34548f40179d322193dd18148c65c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd3b8fb66cfa5b161911b9be0d00726" id="r_aacd3b8fb66cfa5b161911b9be0d00726"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:aacd3b8fb66cfa5b161911b9be0d00726"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacd3b8fb66cfa5b161911b9be0d00726">vformat_to</a> (<a class="el" href="structetl_1_1static__vector.html">OutputIt</a> out, <a class="el" href="#aafbf680e76b153b8a596435b6059846b">string_view</a> <a class="el" href="structetl_1_1static__vector.html">fmt</a>, <a class="el" href="#a5ca9dac165db8a73a0cd16ab2677fabc">format_args</a> args) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:aacd3b8fb66cfa5b161911b9be0d00726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817e57a985d0eab0156aa074d1928761" id="r_a817e57a985d0eab0156aa074d1928761"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Func</a> , typename... BoundArgs&gt; </td></tr>
<tr class="memitem:a817e57a985d0eab0156aa074d1928761"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a817e57a985d0eab0156aa074d1928761">bind_front</a> (<a class="el" href="structetl_1_1static__vector.html">Func</a> &amp;&amp;func, <a class="el" href="structetl_1_1static__vector.html">BoundArgs</a> &amp;&amp;... <a class="el" href="structetl_1_1static__vector.html">boundArgs</a>)</td></tr>
<tr class="memdesc:a817e57a985d0eab0156aa074d1928761"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args. In other words, bind_front(f,
bound_args...)(call_args...) is equivalent to invoke(f, bound_args..., call_args....).  <br /></td></tr>
<tr class="separator:a817e57a985d0eab0156aa074d1928761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3b5926a2945bf5dfa04525b2b3a11b" id="r_afb3b5926a2945bf5dfa04525b2b3a11b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args&gt; </td></tr>
<tr class="memitem:afb3b5926a2945bf5dfa04525b2b3a11b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb3b5926a2945bf5dfa04525b2b3a11b">function_ref</a> (<a class="el" href="structetl_1_1static__vector.html">R</a>(*)(Args...)) -&gt; function_ref&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...)&gt;</td></tr>
<tr class="separator:afb3b5926a2945bf5dfa04525b2b3a11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d8f8d75e5381d2407570b4d97eaf0a" id="r_a47d8f8d75e5381d2407570b4d97eaf0a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a47d8f8d75e5381d2407570b4d97eaf0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47d8f8d75e5381d2407570b4d97eaf0a">swap</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a47d8f8d75e5381d2407570b4d97eaf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <a class="el" href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">etl::swap</a> algorithm for <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:a47d8f8d75e5381d2407570b4d97eaf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba26643439d5c5c17e5ef7c933528775" id="r_aba26643439d5c5c17e5ef7c933528775"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:aba26643439d5c5c17e5ef7c933528775"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba26643439d5c5c17e5ef7c933528775">operator==</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;f, <a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aba26643439d5c5c17e5ef7c933528775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:aba26643439d5c5c17e5ef7c933528775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8c2f711706013a2f8a700a95963fd4" id="r_aac8c2f711706013a2f8a700a95963fd4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:aac8c2f711706013a2f8a700a95963fd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac8c2f711706013a2f8a700a95963fd4">operator!=</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;f, <a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aac8c2f711706013a2f8a700a95963fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:aac8c2f711706013a2f8a700a95963fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785630c163ba404876a31053f863b666" id="r_a785630c163ba404876a31053f863b666"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a785630c163ba404876a31053f863b666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a785630c163ba404876a31053f863b666">operator==</a> (<a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;f) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a785630c163ba404876a31053f863b666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:a785630c163ba404876a31053f863b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ee6cdf5477e76b8281dd0e20976012" id="r_a71ee6cdf5477e76b8281dd0e20976012"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a71ee6cdf5477e76b8281dd0e20976012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71ee6cdf5477e76b8281dd0e20976012">operator!=</a> (<a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;f) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a71ee6cdf5477e76b8281dd0e20976012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:a71ee6cdf5477e76b8281dd0e20976012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd726a99d25fb6e96ef3527de8a0164" id="r_a0bd726a99d25fb6e96ef3527de8a0164"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a0bd726a99d25fb6e96ef3527de8a0164"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bd726a99d25fb6e96ef3527de8a0164">invoke</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; <a class="el" href="#ad47ced64dcc2c2322893df26022403c5">etl::invoke_result_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">F</a>, Args... &gt;</td></tr>
<tr class="separator:a0bd726a99d25fb6e96ef3527de8a0164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818edb1bc7d4fc7b0dab4127a65f3369" id="r_a818edb1bc7d4fc7b0dab4127a65f3369"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Args&gt; <br />
requires (<a class="el" href="#af8a1ef24a3b6eb7a38ad1307015c2c09">etl::is_invocable_r_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R</a>, <a class="el" href="structetl_1_1static__vector.html">F</a>, Args...&gt;)</td></tr>
<tr class="memitem:a818edb1bc7d4fc7b0dab4127a65f3369"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a818edb1bc7d4fc7b0dab4127a65f3369">invoke_r</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; <a class="el" href="structetl_1_1static__vector.html">R</a></td></tr>
<tr class="separator:a818edb1bc7d4fc7b0dab4127a65f3369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca76f56fc5629be9476b2fd3a153a6e" id="r_abca76f56fc5629be9476b2fd3a153a6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; </td></tr>
<tr class="memitem:abca76f56fc5629be9476b2fd3a153a6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abca76f56fc5629be9476b2fd3a153a6e">not_fn</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f) -&gt; detail::not_fn_t&lt; <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">etl::decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; &gt;</td></tr>
<tr class="separator:abca76f56fc5629be9476b2fd3a153a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfabb170ba259721f7f4c19febd88c5" id="r_a3cfabb170ba259721f7f4c19febd88c5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> ConstFn&gt; </td></tr>
<tr class="memitem:a3cfabb170ba259721f7f4c19febd88c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3cfabb170ba259721f7f4c19febd88c5">not_fn</a> () noexcept -&gt; detail::stateless_not_fn&lt; <a class="el" href="structetl_1_1static__vector.html">ConstFn</a> &gt;</td></tr>
<tr class="separator:a3cfabb170ba259721f7f4c19febd88c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba1ef9fae68ae0f78265ecaa8a3d598" id="r_aeba1ef9fae68ae0f78265ecaa8a3d598"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aeba1ef9fae68ae0f78265ecaa8a3d598"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeba1ef9fae68ae0f78265ecaa8a3d598">reference_wrapper</a> (T &amp;) -&gt; reference_wrapper&lt; T &gt;</td></tr>
<tr class="separator:aeba1ef9fae68ae0f78265ecaa8a3d598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481b27ca7cd9de96cb435adc8a761b2a" id="r_a481b27ca7cd9de96cb435adc8a761b2a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a481b27ca7cd9de96cb435adc8a761b2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a481b27ca7cd9de96cb435adc8a761b2a">ref</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a481b27ca7cd9de96cb435adc8a761b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result.  <br /></td></tr>
<tr class="separator:a481b27ca7cd9de96cb435adc8a761b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f67da318f2742930e9485ebba9b075b" id="r_a1f67da318f2742930e9485ebba9b075b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1f67da318f2742930e9485ebba9b075b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f67da318f2742930e9485ebba9b075b">ref</a> (<a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a1f67da318f2742930e9485ebba9b075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result.  <br /></td></tr>
<tr class="separator:a1f67da318f2742930e9485ebba9b075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00752f4906d9b6f07d99ee2eb2719a09" id="r_a00752f4906d9b6f07d99ee2eb2719a09"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a00752f4906d9b6f07d99ee2eb2719a09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00752f4906d9b6f07d99ee2eb2719a09">cref</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td></tr>
<tr class="memdesc:a00752f4906d9b6f07d99ee2eb2719a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. module Utility.  <br /></td></tr>
<tr class="separator:a00752f4906d9b6f07d99ee2eb2719a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb738286bec1789f1f3c417e6e5e600" id="r_abfb738286bec1789f1f3c417e6e5e600"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abfb738286bec1789f1f3c417e6e5e600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfb738286bec1789f1f3c417e6e5e600">cref</a> (<a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td></tr>
<tr class="separator:abfb738286bec1789f1f3c417e6e5e600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a6667d8776c1662f72e69e5b6a6ae2" id="r_a82a6667d8776c1662f72e69e5b6a6ae2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a82a6667d8776c1662f72e69e5b6a6ae2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82a6667d8776c1662f72e69e5b6a6ae2">cref</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;)=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a82a6667d8776c1662f72e69e5b6a6ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45065b143a47fb9249bda8d57ccca63" id="r_ac45065b143a47fb9249bda8d57ccca63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">It</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Distance</a> &gt; </td></tr>
<tr class="memitem:ac45065b143a47fb9249bda8d57ccca63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac45065b143a47fb9249bda8d57ccca63">advance</a> (<a class="el" href="structetl_1_1static__vector.html">It</a> &amp;<a class="el" href="structetl_1_1static__vector.html">it</a>, <a class="el" href="structetl_1_1static__vector.html">Distance</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ac45065b143a47fb9249bda8d57ccca63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined.  <br /></td></tr>
<tr class="separator:ac45065b143a47fb9249bda8d57ccca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea18354d7bfc7358bf9c13004f0233" id="r_ab4ea18354d7bfc7358bf9c13004f0233"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:ab4ea18354d7bfc7358bf9c13004f0233"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4ea18354d7bfc7358bf9c13004f0233">back_inserter</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;<a class="el" href="structetl_1_1static__vector.html">container</a>) -&gt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt;</td></tr>
<tr class="memdesc:ab4ea18354d7bfc7358bf9c13004f0233"><td class="mdescLeft">&#160;</td><td class="mdescRight">back_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">back_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:ab4ea18354d7bfc7358bf9c13004f0233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3031e070c39546444bdd5fda57ead3d2" id="r_a3031e070c39546444bdd5fda57ead3d2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a3031e070c39546444bdd5fda57ead3d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3031e070c39546444bdd5fda57ead3d2">begin</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.begin())</td></tr>
<tr class="memdesc:a3031e070c39546444bdd5fda57ead3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the given container c or array array. These templates rely on <code>C::begin()</code> having a reasonable implementation. Returns exactly c.begin(), which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns <code>C::iterator</code> when c is not const-qualified, and <code>C::const_iterator</code> otherwise. Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="#a3031e070c39546444bdd5fda57ead3d2" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated.  <br /></td></tr>
<tr class="separator:a3031e070c39546444bdd5fda57ead3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a601a1d87c13d9bcf1d4b0e2cf6c1c" id="r_a62a601a1d87c13d9bcf1d4b0e2cf6c1c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a62a601a1d87c13d9bcf1d4b0e2cf6c1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62a601a1d87c13d9bcf1d4b0e2cf6c1c">begin</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.begin())</td></tr>
<tr class="separator:a62a601a1d87c13d9bcf1d4b0e2cf6c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0330eb79a39a00af31e79ece021f90f" id="r_ab0330eb79a39a00af31e79ece021f90f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:ab0330eb79a39a00af31e79ece021f90f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0330eb79a39a00af31e79ece021f90f">begin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:ab0330eb79a39a00af31e79ece021f90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085b23b10e801da02c5711b10f67141e" id="r_a085b23b10e801da02c5711b10f67141e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a085b23b10e801da02c5711b10f67141e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a085b23b10e801da02c5711b10f67141e">cbegin</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(<a class="el" href="#a3031e070c39546444bdd5fda57ead3d2">begin</a>(c))) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#a3031e070c39546444bdd5fda57ead3d2">begin</a>(c))</td></tr>
<tr class="separator:a085b23b10e801da02c5711b10f67141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259846a061a975e4b40bc6f370701ac6" id="r_a259846a061a975e4b40bc6f370701ac6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a259846a061a975e4b40bc6f370701ac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a259846a061a975e4b40bc6f370701ac6">data</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> &amp;c) noexcept(noexcept(c.data())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.data())</td></tr>
<tr class="memdesc:a259846a061a975e4b40bc6f370701ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the block of memory containing the elements of the container.  <br /></td></tr>
<tr class="separator:a259846a061a975e4b40bc6f370701ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76360f238bdab5ae903a7b8b987ab5ac" id="r_a76360f238bdab5ae903a7b8b987ab5ac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a76360f238bdab5ae903a7b8b987ab5ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76360f238bdab5ae903a7b8b987ab5ac">data</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(c.data())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.data())</td></tr>
<tr class="separator:a76360f238bdab5ae903a7b8b987ab5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94411a453e2a44d4e6b6bf3160b4cf0" id="r_ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad94411a453e2a44d4e6b6bf3160b4cf0">data</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af296e322933205aa92418d74103df68c" id="r_af296e322933205aa92418d74103df68c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">It</a> &gt; </td></tr>
<tr class="memitem:af296e322933205aa92418d74103df68c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af296e322933205aa92418d74103df68c">distance</a> (<a class="el" href="structetl_1_1static__vector.html">It</a> first, <a class="el" href="structetl_1_1static__vector.html">It</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">It</a> &gt;::difference_type</td></tr>
<tr class="memdesc:af296e322933205aa92418d74103df68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of hops from first to last.  <br /></td></tr>
<tr class="separator:af296e322933205aa92418d74103df68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a91f34436b98eaaeaf7e4ae5e19afa" id="r_ab0a91f34436b98eaaeaf7e4ae5e19afa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:ab0a91f34436b98eaaeaf7e4ae5e19afa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0a91f34436b98eaaeaf7e4ae5e19afa">empty</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(c.empty())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.empty())</td></tr>
<tr class="memdesc:ab0a91f34436b98eaaeaf7e4ae5e19afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is empty.  <br /></td></tr>
<tr class="separator:ab0a91f34436b98eaaeaf7e4ae5e19afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3868c40892e752ac869410ba4b0f0407" id="r_a3868c40892e752ac869410ba4b0f0407"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:a3868c40892e752ac869410ba4b0f0407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3868c40892e752ac869410ba4b0f0407">empty</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a3868c40892e752ac869410ba4b0f0407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9eb859a31968a9179b29b638cd054b" id="r_abf9eb859a31968a9179b29b638cd054b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:abf9eb859a31968a9179b29b638cd054b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf9eb859a31968a9179b29b638cd054b">end</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.end())</td></tr>
<tr class="memdesc:abf9eb859a31968a9179b29b638cd054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on.  <br /></td></tr>
<tr class="separator:abf9eb859a31968a9179b29b638cd054b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd63b79cae3d16f47089c029f77e7152" id="r_acd63b79cae3d16f47089c029f77e7152"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:acd63b79cae3d16f47089c029f77e7152"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd63b79cae3d16f47089c029f77e7152">end</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.end())</td></tr>
<tr class="separator:acd63b79cae3d16f47089c029f77e7152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5d203d41447f951c386a27ef969327" id="r_a6f5d203d41447f951c386a27ef969327"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:a6f5d203d41447f951c386a27ef969327"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f5d203d41447f951c386a27ef969327">end</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:a6f5d203d41447f951c386a27ef969327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41acb03578faec2a550c4830c1dd2071" id="r_a41acb03578faec2a550c4830c1dd2071"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a41acb03578faec2a550c4830c1dd2071"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41acb03578faec2a550c4830c1dd2071">cend</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(<a class="el" href="#abf9eb859a31968a9179b29b638cd054b">end</a>(c))) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#abf9eb859a31968a9179b29b638cd054b">end</a>(c))</td></tr>
<tr class="separator:a41acb03578faec2a550c4830c1dd2071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba99d783e3591913ef343af35fa0c7a" id="r_a7ba99d783e3591913ef343af35fa0c7a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a7ba99d783e3591913ef343af35fa0c7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ba99d783e3591913ef343af35fa0c7a">front_inserter</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt;</td></tr>
<tr class="memdesc:a7ba99d783e3591913ef343af35fa0c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">front_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:a7ba99d783e3591913ef343af35fa0c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad833bc2bd06b05dd97d5c1ede8dde609" id="r_ad833bc2bd06b05dd97d5c1ede8dde609"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:ad833bc2bd06b05dd97d5c1ede8dde609"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad833bc2bd06b05dd97d5c1ede8dde609">full</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(c.full())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.full())</td></tr>
<tr class="memdesc:ad833bc2bd06b05dd97d5c1ede8dde609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is full.  <br /></td></tr>
<tr class="separator:ad833bc2bd06b05dd97d5c1ede8dde609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd013eaad14533bf9fba4c179c07fb1" id="r_adfd013eaad14533bf9fba4c179c07fb1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:adfd013eaad14533bf9fba4c179c07fb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfd013eaad14533bf9fba4c179c07fb1">full</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:adfd013eaad14533bf9fba4c179c07fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7891ee1f2ce336c151274551bef111d1" id="r_a7891ee1f2ce336c151274551bef111d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt; </td></tr>
<tr class="memitem:a7891ee1f2ce336c151274551bef111d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7891ee1f2ce336c151274551bef111d1">next</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> <a class="el" href="structetl_1_1static__vector.html">it</a>, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>=1) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a></td></tr>
<tr class="memdesc:a7891ee1f2ce336c151274551bef111d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth successor of iterator it.  <br /></td></tr>
<tr class="separator:a7891ee1f2ce336c151274551bef111d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd767893eec07cc5b92348b4bb72ee8" id="r_a3dd767893eec07cc5b92348b4bb72ee8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:a3dd767893eec07cc5b92348b4bb72ee8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3dd767893eec07cc5b92348b4bb72ee8">prev</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt</a> <a class="el" href="structetl_1_1static__vector.html">it</a>, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>=1) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td></tr>
<tr class="memdesc:a3dd767893eec07cc5b92348b4bb72ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth predecessor of iterator it.  <br /></td></tr>
<tr class="separator:a3dd767893eec07cc5b92348b4bb72ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aadf1fc327da2eaac11d7e6e8617a8" id="r_a31aadf1fc327da2eaac11d7e6e8617a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a31aadf1fc327da2eaac11d7e6e8617a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a31aadf1fc327da2eaac11d7e6e8617a8">rbegin</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rbegin())</td></tr>
<tr class="memdesc:a31aadf1fc327da2eaac11d7e6e8617a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-beginning of the given container.  <br /></td></tr>
<tr class="separator:a31aadf1fc327da2eaac11d7e6e8617a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f3dc4db837147a9d8d28d3f18b40f5" id="r_a12f3dc4db837147a9d8d28d3f18b40f5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a12f3dc4db837147a9d8d28d3f18b40f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12f3dc4db837147a9d8d28d3f18b40f5">rbegin</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rbegin())</td></tr>
<tr class="separator:a12f3dc4db837147a9d8d28d3f18b40f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cec4638c522ca6b45b99da908aa1b7" id="r_a36cec4638c522ca6b45b99da908aa1b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:a36cec4638c522ca6b45b99da908aa1b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36cec4638c522ca6b45b99da908aa1b7">rbegin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; T * &gt;</td></tr>
<tr class="separator:a36cec4638c522ca6b45b99da908aa1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cf5b617456b93d23184aaa8495c411" id="r_a39cf5b617456b93d23184aaa8495c411"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a39cf5b617456b93d23184aaa8495c411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39cf5b617456b93d23184aaa8495c411">crbegin</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#a31aadf1fc327da2eaac11d7e6e8617a8">rbegin</a>(c))</td></tr>
<tr class="separator:a39cf5b617456b93d23184aaa8495c411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db12aaf2a7b1819d28995d635d91954" id="r_a3db12aaf2a7b1819d28995d635d91954"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a3db12aaf2a7b1819d28995d635d91954"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3db12aaf2a7b1819d28995d635d91954">rend</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rend())</td></tr>
<tr class="memdesc:a3db12aaf2a7b1819d28995d635d91954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-end of the given container.  <br /></td></tr>
<tr class="separator:a3db12aaf2a7b1819d28995d635d91954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75830ae03ce26ca2ea7289cc7d83a761" id="r_a75830ae03ce26ca2ea7289cc7d83a761"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a75830ae03ce26ca2ea7289cc7d83a761"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75830ae03ce26ca2ea7289cc7d83a761">rend</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rend())</td></tr>
<tr class="separator:a75830ae03ce26ca2ea7289cc7d83a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d4f59f901468f3a8d07e91a27e2ae2" id="r_a94d4f59f901468f3a8d07e91a27e2ae2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:a94d4f59f901468f3a8d07e91a27e2ae2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94d4f59f901468f3a8d07e91a27e2ae2">rend</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; T * &gt;</td></tr>
<tr class="separator:a94d4f59f901468f3a8d07e91a27e2ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04738c0a8b5aa6e0211bbd7a4aa586e7" id="r_a04738c0a8b5aa6e0211bbd7a4aa586e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:a04738c0a8b5aa6e0211bbd7a4aa586e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04738c0a8b5aa6e0211bbd7a4aa586e7">crend</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#a3db12aaf2a7b1819d28995d635d91954">rend</a>(c))</td></tr>
<tr class="memdesc:a04738c0a8b5aa6e0211bbd7a4aa586e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-end of the given container.  <br /></td></tr>
<tr class="separator:a04738c0a8b5aa6e0211bbd7a4aa586e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fd86ba568b1c1665502fcb72ed4327" id="r_a56fd86ba568b1c1665502fcb72ed4327"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </td></tr>
<tr class="memitem:a56fd86ba568b1c1665502fcb72ed4327"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56fd86ba568b1c1665502fcb72ed4327">make_reverse_iterator</a> (<a class="el" href="structetl_1_1static__vector.html">Iter</a> <a class="el" href="structetl_1_1static__vector.html">i</a>) noexcept -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt;</td></tr>
<tr class="memdesc:a56fd86ba568b1c1665502fcb72ed4327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function template that constructs a <a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">etl::reverse_iterator</a> for the given iterator i (which must be a LegacyBidirectionalIterator) with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:a56fd86ba568b1c1665502fcb72ed4327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed8eb1bf308acc967006e8073f5a132" id="r_a6ed8eb1bf308acc967006e8073f5a132"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:a6ed8eb1bf308acc967006e8073f5a132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ed8eb1bf308acc967006e8073f5a132">operator==</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6ed8eb1bf308acc967006e8073f5a132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:a6ed8eb1bf308acc967006e8073f5a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35badce959782a6ae934df29db1e063" id="r_ab35badce959782a6ae934df29db1e063"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:ab35badce959782a6ae934df29db1e063"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab35badce959782a6ae934df29db1e063">operator!=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab35badce959782a6ae934df29db1e063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:ab35badce959782a6ae934df29db1e063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354acf1f357eacd402309c32fd4d5508" id="r_a354acf1f357eacd402309c32fd4d5508"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:a354acf1f357eacd402309c32fd4d5508"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a354acf1f357eacd402309c32fd4d5508">operator&lt;</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a354acf1f357eacd402309c32fd4d5508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:a354acf1f357eacd402309c32fd4d5508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c13e3aeec42ad159690a49c03ea7f19" id="r_a6c13e3aeec42ad159690a49c03ea7f19"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:a6c13e3aeec42ad159690a49c03ea7f19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c13e3aeec42ad159690a49c03ea7f19">operator&lt;=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6c13e3aeec42ad159690a49c03ea7f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:a6c13e3aeec42ad159690a49c03ea7f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ba00e40d7921ce12fde9c0c231e4c2" id="r_ac1ba00e40d7921ce12fde9c0c231e4c2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:ac1ba00e40d7921ce12fde9c0c231e4c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1ba00e40d7921ce12fde9c0c231e4c2">operator&gt;</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ac1ba00e40d7921ce12fde9c0c231e4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:ac1ba00e40d7921ce12fde9c0c231e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2457527f749e948ff13abbd95621c9" id="r_a9a2457527f749e948ff13abbd95621c9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:a9a2457527f749e948ff13abbd95621c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a2457527f749e948ff13abbd95621c9">operator&gt;=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a9a2457527f749e948ff13abbd95621c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:a9a2457527f749e948ff13abbd95621c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341ce51287200d6d284558bf674303a1" id="r_a341ce51287200d6d284558bf674303a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </td></tr>
<tr class="memitem:a341ce51287200d6d284558bf674303a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a341ce51287200d6d284558bf674303a1">operator+</a> (<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt;::difference_type <a class="el" href="structetl_1_1static__vector.html">n</a>, <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">it</a>) noexcept(noexcept(it.base() - <a class="el" href="structetl_1_1static__vector.html">n</a>)) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt;</td></tr>
<tr class="memdesc:a341ce51287200d6d284558bf674303a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator it incremented by n.  <br /></td></tr>
<tr class="separator:a341ce51287200d6d284558bf674303a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07adb06319a1e865f85ac0caed0820a" id="r_ae07adb06319a1e865f85ac0caed0820a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iterator1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iterator2</a> &gt; </td></tr>
<tr class="memitem:ae07adb06319a1e865f85ac0caed0820a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae07adb06319a1e865f85ac0caed0820a">operator-</a> (<a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iterator1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iterator2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(rhs.base() - lhs.base())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(rhs.base() - lhs.base())</td></tr>
<tr class="memdesc:ae07adb06319a1e865f85ac0caed0820a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two iterator adaptors.  <br /></td></tr>
<tr class="separator:ae07adb06319a1e865f85ac0caed0820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3008e042f920b06e2a67b1aa31a1803" id="r_af3008e042f920b06e2a67b1aa31a1803"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:af3008e042f920b06e2a67b1aa31a1803"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3008e042f920b06e2a67b1aa31a1803">size</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) noexcept(noexcept(c.size())) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.size())</td></tr>
<tr class="memdesc:af3008e042f920b06e2a67b1aa31a1803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the given container c or array array. Returns c.size(), converted to the return type if necessary.  <br /></td></tr>
<tr class="separator:af3008e042f920b06e2a67b1aa31a1803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e3325c99005cfa2cad0752fe472c61" id="r_ab2e3325c99005cfa2cad0752fe472c61"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:ab2e3325c99005cfa2cad0752fe472c61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2e3325c99005cfa2cad0752fe472c61">size</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> (&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept -&gt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a></td></tr>
<tr class="separator:ab2e3325c99005cfa2cad0752fe472c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1396c492b6b649f093736eaba1f92c" id="r_a4d1396c492b6b649f093736eaba1f92c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </td></tr>
<tr class="memitem:a4d1396c492b6b649f093736eaba1f92c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d1396c492b6b649f093736eaba1f92c">ssize</a> (<a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;c) -&gt; <a class="el" href="#a1049bbee37ab0c1445bcd7f020d6ce0c">common_type_t</a>&lt; <a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a>, <a class="el" href="#ace93b7d8b1e564390c651a2e9a3a11f0">make_signed_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.size())&gt; &gt;</td></tr>
<tr class="separator:a4d1396c492b6b649f093736eaba1f92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfe3fbc79d8c1cf42b007bed4267257" id="r_abdfe3fbc79d8c1cf42b007bed4267257"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a> N&gt; </td></tr>
<tr class="memitem:abdfe3fbc79d8c1cf42b007bed4267257"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abdfe3fbc79d8c1cf42b007bed4267257">ssize</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> (&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1static__vector.html">static_cast</a>&lt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> &gt;(<a class="el" href="structetl_1_1static__vector.html">N</a>)]) noexcept -&gt; <a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a></td></tr>
<tr class="separator:abdfe3fbc79d8c1cf42b007bed4267257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f4f3470cc94fc51e21ebfa58e3292a" id="r_a29f4f3470cc94fc51e21ebfa58e3292a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f4f3470cc94fc51e21ebfa58e3292a">abs</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:a29f4f3470cc94fc51e21ebfa58e3292a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a29f4f3470cc94fc51e21ebfa58e3292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67112d360fce8458db9b33c097b809b5" id="r_a67112d360fce8458db9b33c097b809b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67112d360fce8458db9b33c097b809b5">abs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="separator:a67112d360fce8458db9b33c097b809b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f2cb4cae4a97ae3b4736ff1aa6b176" id="r_a28f2cb4cae4a97ae3b4736ff1aa6b176"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28f2cb4cae4a97ae3b4736ff1aa6b176">abs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="separator:a28f2cb4cae4a97ae3b4736ff1aa6b176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528fb6eadbb2c38e178a60155197d6ac" id="r_a528fb6eadbb2c38e178a60155197d6ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a528fb6eadbb2c38e178a60155197d6ac">abs</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="separator:a528fb6eadbb2c38e178a60155197d6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5868e5a9aa938b596cd0d8d04d3ecb96" id="r_a5868e5a9aa938b596cd0d8d04d3ecb96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5868e5a9aa938b596cd0d8d04d3ecb96">abs</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:a5868e5a9aa938b596cd0d8d04d3ecb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1dae41b3151e867f898e88be2e250b" id="r_a1b1dae41b3151e867f898e88be2e250b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b1dae41b3151e867f898e88be2e250b">abs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:a1b1dae41b3151e867f898e88be2e250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f57c390bca894ba9abb01107b367fb" id="r_aa3f57c390bca894ba9abb01107b367fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3f57c390bca894ba9abb01107b367fb">fabs</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="separator:aa3f57c390bca894ba9abb01107b367fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934ff8b65786c53d2df66654258fb9d4" id="r_a934ff8b65786c53d2df66654258fb9d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a934ff8b65786c53d2df66654258fb9d4">fabsf</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="separator:a934ff8b65786c53d2df66654258fb9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc8c16e1d3253b423b905f31cf7267b" id="r_aebc8c16e1d3253b423b905f31cf7267b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebc8c16e1d3253b423b905f31cf7267b">fabs</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:aebc8c16e1d3253b423b905f31cf7267b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab973f9ba5bac126e950c7ff7e1b45dcb" id="r_ab973f9ba5bac126e950c7ff7e1b45dcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab973f9ba5bac126e950c7ff7e1b45dcb">fabs</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:ab973f9ba5bac126e950c7ff7e1b45dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57fa73cac5bc77be92e61c2cea2fa4b" id="r_af57fa73cac5bc77be92e61c2cea2fa4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af57fa73cac5bc77be92e61c2cea2fa4b">fabsl</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="separator:af57fa73cac5bc77be92e61c2cea2fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d6a400b03bbbcc87b81f9a8f70a4e5" id="r_a68d6a400b03bbbcc87b81f9a8f70a4e5"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a68d6a400b03bbbcc87b81f9a8f70a4e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68d6a400b03bbbcc87b81f9a8f70a4e5">ilog2</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="separator:a68d6a400b03bbbcc87b81f9a8f70a4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbcb6eba04cb025fe9ca378236adee0" id="r_a4cbcb6eba04cb025fe9ca378236adee0"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a4cbcb6eba04cb025fe9ca378236adee0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4cbcb6eba04cb025fe9ca378236adee0">ipow</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> base, <a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">exponent</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="separator:a4cbcb6eba04cb025fe9ca378236adee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dd0445f4a32857d03ee0b802a2af19" id="r_a80dd0445f4a32857d03ee0b802a2af19"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> Base&gt; </td></tr>
<tr class="memitem:a80dd0445f4a32857d03ee0b802a2af19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80dd0445f4a32857d03ee0b802a2af19">ipow</a> (<a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">Base</a>) <a class="el" href="structetl_1_1static__vector.html">exponent</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">Base</a>)</td></tr>
<tr class="separator:a80dd0445f4a32857d03ee0b802a2af19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9186fde8e2d9973c0a6d7b0c5370c9" id="r_afc9186fde8e2d9973c0a6d7b0c5370c9"><td class="memTemplParams" colspan="2">template&lt;typename... Integrals&gt; <br />
requires (<a class="el" href="#aa15279e84c7ec40ef8a2d460b81b7fb7">etl::is_convertible_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Integrals</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> ...)</td></tr>
<tr class="memitem:afc9186fde8e2d9973c0a6d7b0c5370c9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afc9186fde8e2d9973c0a6d7b0c5370c9">extents</a> (Integrals...) -&gt; extents&lt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>((<a class="el" href="structetl_1_1static__vector.html">Integrals</a>(), <a class="el" href="#ae174223df490e6263d4648a86326c902">etl::dynamic_extent</a>))... &gt;</td></tr>
<tr class="separator:afc9186fde8e2d9973c0a6d7b0c5370c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3a844784b8e330377ef20a6d1f5ec3" id="r_afe3a844784b8e330377ef20a6d1f5ec3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CArray</a> &gt; <br />
requires (<a class="el" href="#afaa46050181985a6156a6c800c86a7d8">is_array_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CArray</a>&gt; &amp;&amp; <a class="el" href="#a4229d4171b460abc833736d622ce9745">rank_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CArray</a>&gt; == 1)</td></tr>
<tr class="memitem:afe3a844784b8e330377ef20a6d1f5ec3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe3a844784b8e330377ef20a6d1f5ec3">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">CArray</a> &amp;) -&gt; mdspan&lt; <a class="el" href="#a90a0440e799b90521d5959686b4282fb">remove_all_extents_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CArray</a> &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a>, <a class="el" href="#a115f1cea7fc27ee979afae4871d03a03">extent_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CArray</a>, 0 &gt; &gt; &gt;</td></tr>
<tr class="separator:afe3a844784b8e330377ef20a6d1f5ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9a30f2d782abb51c2c1a482f7e70c9" id="r_a6d9a30f2d782abb51c2c1a482f7e70c9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Pointer</a> &gt; <br />
requires (<a class="el" href="#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a>&lt;<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Pointer</a>&gt;&gt;)</td></tr>
<tr class="memitem:a6d9a30f2d782abb51c2c1a482f7e70c9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d9a30f2d782abb51c2c1a482f7e70c9">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">Pointer</a> &amp;&amp;) -&gt; mdspan&lt; <a class="el" href="#a8897fe2703cfaabd33c46ba2ae13b5e2">remove_pointer_t</a>&lt; <a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Pointer</a> &gt; &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> &gt; &gt;</td></tr>
<tr class="separator:a6d9a30f2d782abb51c2c1a482f7e70c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698e5b24b2544f42552e4eb245912d40" id="r_a698e5b24b2544f42552e4eb245912d40"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , typename... Integrals&gt; <br />
requires ((<a class="el" href="#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Integrals</a>, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a>&gt; &amp;&amp; ...) &amp;&amp; sizeof...(<a class="el" href="structetl_1_1static__vector.html">Integrals</a>) &gt; 0)</td></tr>
<tr class="memitem:a698e5b24b2544f42552e4eb245912d40"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a698e5b24b2544f42552e4eb245912d40">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">ElementType</a> *, Integrals...) -&gt; mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="#ad27430ad24df2ec00864b7184d731465">dextents</a>&lt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a>, sizeof...(<a class="el" href="structetl_1_1static__vector.html">Integrals</a>)&gt; &gt;</td></tr>
<tr class="separator:a698e5b24b2544f42552e4eb245912d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa733eabfa7d494cd6e626e58a2d56234" id="r_aa733eabfa7d494cd6e626e58a2d56234"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexType</a> , size_t... ExtentsPack&gt; </td></tr>
<tr class="memitem:aa733eabfa7d494cd6e626e58a2d56234"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa733eabfa7d494cd6e626e58a2d56234">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">ElementType</a> *, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexType</a>, ExtentsPack... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexType</a>, ExtentsPack... &gt; &gt;</td></tr>
<tr class="separator:aa733eabfa7d494cd6e626e58a2d56234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca494e42ded1eb56cf815c645ab4bfe" id="r_a7ca494e42ded1eb56cf815c645ab4bfe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">MappingType</a> &gt; </td></tr>
<tr class="memitem:a7ca494e42ded1eb56cf815c645ab4bfe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ca494e42ded1eb56cf815c645ab4bfe">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">ElementType</a> *, <a class="el" href="structetl_1_1static__vector.html">MappingType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::layout_type &gt;</td></tr>
<tr class="separator:a7ca494e42ded1eb56cf815c645ab4bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536af133718ba537fce35662e803b0e7" id="r_a536af133718ba537fce35662e803b0e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">MappingType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> &gt; </td></tr>
<tr class="memitem:a536af133718ba537fce35662e803b0e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a536af133718ba537fce35662e803b0e7">mdspan</a> (<a class="el" href="structetl_1_1static__vector.html">typename</a> AccessorType::data_handle_type <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, <a class="el" href="structetl_1_1static__vector.html">MappingType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">typename</a> AccessorType::element_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::layout_type, <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> &gt;</td></tr>
<tr class="separator:a536af133718ba537fce35662e803b0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94f2f8d645ecda437b8b417399a808a" id="r_aa94f2f8d645ecda437b8b417399a808a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OffsetType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ExtentType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">StrideType</a> &gt; </td></tr>
<tr class="memitem:aa94f2f8d645ecda437b8b417399a808a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa94f2f8d645ecda437b8b417399a808a">strided_slice</a> (<a class="el" href="structetl_1_1static__vector.html">OffsetType</a>, <a class="el" href="structetl_1_1static__vector.html">ExtentType</a>, <a class="el" href="structetl_1_1static__vector.html">StrideType</a>) -&gt; strided_slice&lt; <a class="el" href="structetl_1_1static__vector.html">OffsetType</a>, <a class="el" href="structetl_1_1static__vector.html">ExtentType</a>, <a class="el" href="structetl_1_1static__vector.html">StrideType</a> &gt;</td></tr>
<tr class="separator:aa94f2f8d645ecda437b8b417399a808a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb29174c026eeabd294649480e7d00b1" id="r_abb29174c026eeabd294649480e7d00b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexT</a> , etl::size_t... Extents, typename... SliceSpecifiers&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1static__vector.html">slices</a>) == <a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt;<a class="el" href="structetl_1_1static__vector.html">IndexT</a>, Extents...&gt;::rank())</td></tr>
<tr class="memitem:abb29174c026eeabd294649480e7d00b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb29174c026eeabd294649480e7d00b1">submdspan_extents</a> (<a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexT</a>, Extents... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">ext</a>, SliceSpecifiers... <a class="el" href="structetl_1_1static__vector.html">slices</a>)</td></tr>
<tr class="separator:abb29174c026eeabd294649480e7d00b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d4abdc9048a47e79b90addc653b930" id="r_a99d4abdc9048a47e79b90addc653b930"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a99d4abdc9048a47e79b90addc653b930"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99d4abdc9048a47e79b90addc653b930">addressof</a> (T &amp;<a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a99d4abdc9048a47e79b90addc653b930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;.  <br /></td></tr>
<tr class="separator:a99d4abdc9048a47e79b90addc653b930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351af276db5fcca32408696c2a4f8be6" id="r_a351af276db5fcca32408696c2a4f8be6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a351af276db5fcca32408696c2a4f8be6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a351af276db5fcca32408696c2a4f8be6">addressof</a> (T &amp;<a class="el" href="group__complex.html#ga06165982b4ed16fe2e57476b46f4ad08">arg</a>) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a351af276db5fcca32408696c2a4f8be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;.  <br /></td></tr>
<tr class="separator:a351af276db5fcca32408696c2a4f8be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13856fe74510e89b04a2310cbc9bde59" id="r_a13856fe74510e89b04a2310cbc9bde59"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a13856fe74510e89b04a2310cbc9bde59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13856fe74510e89b04a2310cbc9bde59">addressof</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;)=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a13856fe74510e89b04a2310cbc9bde59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3d4ba5bde672b48bdaa4fd9eec249e" id="r_afb3d4ba5bde672b48bdaa4fd9eec249e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb3d4ba5bde672b48bdaa4fd9eec249e">align</a> (<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> alignment, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="#af3008e042f920b06e2a67b1aa31a1803">size</a>, <a class="el" href="structetl_1_1static__vector.html">void</a> *&amp;ptr, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> &amp;<a class="el" href="structetl_1_1static__vector.html">space</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> *</td></tr>
<tr class="memdesc:afb3d4ba5bde672b48bdaa4fd9eec249e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.  <br /></td></tr>
<tr class="separator:afb3d4ba5bde672b48bdaa4fd9eec249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe56da868069c04217458df6422d084" id="r_abfe56da868069c04217458df6422d084"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abfe56da868069c04217458df6422d084"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfe56da868069c04217458df6422d084">assume_aligned</a> (T *ptr) -&gt; T *</td></tr>
<tr class="memdesc:abfe56da868069c04217458df6422d084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned.  <br /></td></tr>
<tr class="separator:abfe56da868069c04217458df6422d084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85baa0db208bd4de142559c20735f41" id="r_aa85baa0db208bd4de142559c20735f41"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args, <a class="el" href="structetl_1_1static__vector.html">typename</a>  = decltype(::new(etl::declval&lt;void*&gt;()) T(etl::declval&lt;Args&gt;()...))&gt; </td></tr>
<tr class="memitem:aa85baa0db208bd4de142559c20735f41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa85baa0db208bd4de142559c20735f41">construct_at</a> (T *p, <a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; T *</td></tr>
<tr class="memdesc:aa85baa0db208bd4de142559c20735f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a T object initialized with arguments args... at given address p.  <br /></td></tr>
<tr class="separator:aa85baa0db208bd4de142559c20735f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44bc4884adc1e9dc20ddf2363f3da66" id="r_ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab44bc4884adc1e9dc20ddf2363f3da66">destroy</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the objects in the range [first, last).  <br /></td></tr>
<tr class="separator:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1709580f4bcc18d6efb2b7e4d5c1b728" id="r_a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1709580f4bcc18d6efb2b7e4d5c1b728">destroy_at</a> (T *p) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling destroy(begin(*p), end(*p)).  <br /></td></tr>
<tr class="separator:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440d38af8f9b00df3d5c1369450ba44a" id="r_a440d38af8f9b00df3d5c1369450ba44a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; </td></tr>
<tr class="memitem:a440d38af8f9b00df3d5c1369450ba44a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a440d38af8f9b00df3d5c1369450ba44a">destroy_n</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:a440d38af8f9b00df3d5c1369450ba44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the n objects in the range starting at first.  <br /></td></tr>
<tr class="separator:a440d38af8f9b00df3d5c1369450ba44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa686fb94d6fbf9538a40cf4040a6ac81" id="r_aa686fb94d6fbf9538a40cf4040a6ac81"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Ptr</a> &gt; </td></tr>
<tr class="memitem:aa686fb94d6fbf9538a40cf4040a6ac81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa686fb94d6fbf9538a40cf4040a6ac81">to_address</a> (<a class="el" href="structetl_1_1static__vector.html">Ptr</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;ptr) noexcept</td></tr>
<tr class="memdesc:aa686fb94d6fbf9538a40cf4040a6ac81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by p without forming a reference to the object pointed to by p.  <br /></td></tr>
<tr class="separator:aa686fb94d6fbf9538a40cf4040a6ac81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22eb660431c56725c86c7f2f1e7164d3" id="r_a22eb660431c56725c86c7f2f1e7164d3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#aec3b44fa05f956c1efc4f34af98bd1f0">is_function_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a22eb660431c56725c86c7f2f1e7164d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22eb660431c56725c86c7f2f1e7164d3">to_address</a> (T *ptr) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a22eb660431c56725c86c7f2f1e7164d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by p without forming a reference to the object pointed to by p.  <br /></td></tr>
<tr class="separator:a22eb660431c56725c86c7f2f1e7164d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9b77066dce89b6c75251e5179805f6" id="r_aac9b77066dce89b6c75251e5179805f6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aac9b77066dce89b6c75251e5179805f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac9b77066dce89b6c75251e5179805f6">uninitialized_fill</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:aac9b77066dce89b6c75251e5179805f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b0627d3000daa570306e2c95d25db1" id="r_a66b0627d3000daa570306e2c95d25db1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Mutex</a> &gt; </td></tr>
<tr class="memitem:a66b0627d3000daa570306e2c95d25db1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66b0627d3000daa570306e2c95d25db1">swap</a> (<a class="el" href="structetl_1_1unique__lock.html">unique_lock</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Mutex</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1unique__lock.html">unique_lock</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Mutex</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>)))</td></tr>
<tr class="memdesc:a66b0627d3000daa570306e2c95d25db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a>. Exchanges the state of lhs with that of rhs.  <br /></td></tr>
<tr class="separator:a66b0627d3000daa570306e2c95d25db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga594a7b7fb202c9a1b6d82115e7a172e3" id="r_ga594a7b7fb202c9a1b6d82115e7a172e3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:ga594a7b7fb202c9a1b6d82115e7a172e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga594a7b7fb202c9a1b6d82115e7a172e3">abs</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">input</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a></td></tr>
<tr class="memdesc:ga594a7b7fb202c9a1b6d82115e7a172e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value.  <br /></td></tr>
<tr class="separator:ga594a7b7fb202c9a1b6d82115e7a172e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe443a26a34b79fc921c4583df576333" id="r_gafe443a26a34b79fc921c4583df576333"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:gafe443a26a34b79fc921c4583df576333"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gafe443a26a34b79fc921c4583df576333">accumulate</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Type</a> init) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a></td></tr>
<tr class="memdesc:gafe443a26a34b79fc921c4583df576333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gafe443a26a34b79fc921c4583df576333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9413959b7ee39d393e7c35ad2cd78294" id="r_ga9413959b7ee39d393e7c35ad2cd78294"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga9413959b7ee39d393e7c35ad2cd78294"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga9413959b7ee39d393e7c35ad2cd78294">accumulate</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Type</a> init, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a></td></tr>
<tr class="memdesc:ga9413959b7ee39d393e7c35ad2cd78294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga9413959b7ee39d393e7c35ad2cd78294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8090c84a226cdc13d3b2a1420e1d8e4f" id="r_ga8090c84a226cdc13d3b2a1420e1d8e4f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__integer.html">etl::builtin_integer</a> Int&gt; </td></tr>
<tr class="memitem:ga8090c84a226cdc13d3b2a1420e1d8e4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga8090c84a226cdc13d3b2a1420e1d8e4f">add_sat</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> <a class="el" href="structetl_1_1static__vector.html">x</a>, <a class="el" href="structetl_1_1static__vector.html">Int</a> y) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="separator:ga8090c84a226cdc13d3b2a1420e1d8e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cdf06dcb6cdb229ddf2f001f7063d82" id="r_ga4cdf06dcb6cdb229ddf2f001f7063d82"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga4cdf06dcb6cdb229ddf2f001f7063d82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga4cdf06dcb6cdb229ddf2f001f7063d82">adjacent_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ga4cdf06dcb6cdb229ddf2f001f7063d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between the second and the first of each adjacent pair of elements of the range [first, last) and writes them to the range beginning at destination + 1. An unmodified copy of *first is written to *destination.  <br /></td></tr>
<tr class="separator:ga4cdf06dcb6cdb229ddf2f001f7063d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233e4dea3a5bcb4fa4018e9110735184" id="r_ga233e4dea3a5bcb4fa4018e9110735184"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga233e4dea3a5bcb4fa4018e9110735184"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga233e4dea3a5bcb4fa4018e9110735184">adjacent_difference</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:ga233e4dea3a5bcb4fa4018e9110735184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65cd6f8748c172eab6ee36130dca3c3" id="r_gab65cd6f8748c172eab6ee36130dca3c3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">M</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; </td></tr>
<tr class="memitem:gab65cd6f8748c172eab6ee36130dca3c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gab65cd6f8748c172eab6ee36130dca3c3">gcd</a> (<a class="el" href="structetl_1_1static__vector.html">M</a> m, <a class="el" href="structetl_1_1static__vector.html">N</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) noexcept -&gt; <a class="el" href="#a1049bbee37ab0c1445bcd7f020d6ce0c">etl::common_type_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">M</a>, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:gab65cd6f8748c172eab6ee36130dca3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of the integers m and n.  <br /></td></tr>
<tr class="separator:gab65cd6f8748c172eab6ee36130dca3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b02b91109bd6987f6dd8c0cfe583d5" id="r_ga42b02b91109bd6987f6dd8c0cfe583d5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga42b02b91109bd6987f6dd8c0cfe583d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga42b02b91109bd6987f6dd8c0cfe583d5">inner_product</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, T init) -&gt; T</td></tr>
<tr class="memdesc:ga42b02b91109bd6987f6dd8c0cfe583d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2.  <br /></td></tr>
<tr class="separator:ga42b02b91109bd6987f6dd8c0cfe583d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0039bdc9a6970a2089121ae3ee285b1" id="r_gae0039bdc9a6970a2089121ae3ee285b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation2</a> &gt; </td></tr>
<tr class="memitem:gae0039bdc9a6970a2089121ae3ee285b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gae0039bdc9a6970a2089121ae3ee285b1">inner_product</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">first1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> <a class="el" href="structetl_1_1static__vector.html">last1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> <a class="el" href="structetl_1_1static__vector.html">first2</a>, T init, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation1</a> <a class="el" href="structetl_1_1static__vector.html">op1</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation2</a> <a class="el" href="structetl_1_1static__vector.html">op2</a>) -&gt; T</td></tr>
<tr class="separator:gae0039bdc9a6970a2089121ae3ee285b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44562b8c2da2eb5f51eb8e98d09ea697" id="r_ga44562b8c2da2eb5f51eb8e98d09ea697"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga44562b8c2da2eb5f51eb8e98d09ea697"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga44562b8c2da2eb5f51eb8e98d09ea697">iota</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga44562b8c2da2eb5f51eb8e98d09ea697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value.  <br /></td></tr>
<tr class="separator:ga44562b8c2da2eb5f51eb8e98d09ea697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98515054c51d1be411b978c2f9f89203" id="r_ga98515054c51d1be411b978c2f9f89203"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">M</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <br />
requires (<a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">M</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">M</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</td></tr>
<tr class="memitem:ga98515054c51d1be411b978c2f9f89203"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga98515054c51d1be411b978c2f9f89203">lcm</a> (<a class="el" href="structetl_1_1static__vector.html">M</a> m, <a class="el" href="structetl_1_1static__vector.html">N</a> <a class="el" href="structetl_1_1static__vector.html">n</a>) -&gt; <a class="el" href="#a1049bbee37ab0c1445bcd7f020d6ce0c">common_type_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">M</a>, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td></tr>
<tr class="memdesc:ga98515054c51d1be411b978c2f9f89203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common multiple of the integers m and n.  <br /></td></tr>
<tr class="separator:ga98515054c51d1be411b978c2f9f89203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6134e0efc11c94fbc4541fd103e80471" id="r_ga6134e0efc11c94fbc4541fd103e80471"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Int</a> &gt; <br />
requires (<a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Int</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Int</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</td></tr>
<tr class="memitem:ga6134e0efc11c94fbc4541fd103e80471"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga6134e0efc11c94fbc4541fd103e80471">midpoint</a> (<a class="el" href="structetl_1_1static__vector.html">Int</a> a, <a class="el" href="structetl_1_1static__vector.html">Int</a> b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a></td></tr>
<tr class="memdesc:ga6134e0efc11c94fbc4541fd103e80471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns half the sum of a + b. If the sum is odd, the result is rounded towards a.  <br /></td></tr>
<tr class="separator:ga6134e0efc11c94fbc4541fd103e80471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9de23ef1f08847d45765eaaab59f46d5" id="r_ga9de23ef1f08847d45765eaaab59f46d5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1floating__point.html">etl::floating_point</a> Float&gt; </td></tr>
<tr class="memitem:ga9de23ef1f08847d45765eaaab59f46d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga9de23ef1f08847d45765eaaab59f46d5">midpoint</a> (<a class="el" href="structetl_1_1static__vector.html">Float</a> a, <a class="el" href="structetl_1_1static__vector.html">Float</a> b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Float</a></td></tr>
<tr class="separator:ga9de23ef1f08847d45765eaaab59f46d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8905c086d6212eea0b6237e7f6e9bb10" id="r_ga8905c086d6212eea0b6237e7f6e9bb10"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Ptr</a> &gt; <br />
requires <a class="el" href="#ac00eca7d51c4d2c1021402ee9a70f03c">etl::is_pointer_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Ptr</a>&gt;</td></tr>
<tr class="memitem:ga8905c086d6212eea0b6237e7f6e9bb10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga8905c086d6212eea0b6237e7f6e9bb10">midpoint</a> (<a class="el" href="structetl_1_1static__vector.html">Ptr</a> a, <a class="el" href="structetl_1_1static__vector.html">Ptr</a> b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Ptr</a></td></tr>
<tr class="separator:ga8905c086d6212eea0b6237e7f6e9bb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717726a2fed08cececaa93b504419300" id="r_ga717726a2fed08cececaa93b504419300"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga717726a2fed08cececaa93b504419300"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga717726a2fed08cececaa93b504419300">partial_sum</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>, <a class="el" href="structetl_1_1static__vector.html">BinaryOperation</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:ga717726a2fed08cececaa93b504419300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses the given binary function op, both applying <a class="el" href="#a1b8df3814fc65f04932c2f0d09a56107" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> to their operands on the left hand side.  <br /></td></tr>
<tr class="separator:ga717726a2fed08cececaa93b504419300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d274a25ea5a88eb47898c8832795e3e" id="r_ga8d274a25ea5a88eb47898c8832795e3e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga8d274a25ea5a88eb47898c8832795e3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga8d274a25ea5a88eb47898c8832795e3e">partial_sum</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="separator:ga8d274a25ea5a88eb47898c8832795e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84c6438ff40771d562eba2df365db32b" id="r_ga84c6438ff40771d562eba2df365db32b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIter</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> &gt; </td></tr>
<tr class="memitem:ga84c6438ff40771d562eba2df365db32b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga84c6438ff40771d562eba2df365db32b">reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIter</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIter</a> last, T init, <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> <a class="el" href="structetl_1_1static__vector.html">op</a>) -&gt; T</td></tr>
<tr class="memdesc:ga84c6438ff40771d562eba2df365db32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gafe443a26a34b79fc921c4583df576333" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:ga84c6438ff40771d562eba2df365db32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf19beb246e0b495f1af0e0dda7ba07ce" id="r_gaf19beb246e0b495f1af0e0dda7ba07ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIter</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaf19beb246e0b495f1af0e0dda7ba07ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gaf19beb246e0b495f1af0e0dda7ba07ce">reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIter</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIter</a> last, T init) -&gt; T</td></tr>
<tr class="memdesc:gaf19beb246e0b495f1af0e0dda7ba07ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gafe443a26a34b79fc921c4583df576333" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:gaf19beb246e0b495f1af0e0dda7ba07ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714efac01ef228fff45d4f6ab456dfb6" id="r_ga714efac01ef228fff45d4f6ab456dfb6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIter</a> &gt; </td></tr>
<tr class="memitem:ga714efac01ef228fff45d4f6ab456dfb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga714efac01ef228fff45d4f6ab456dfb6">reduce</a> (<a class="el" href="structetl_1_1static__vector.html">InputIter</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIter</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIter</a> &gt;::value_type</td></tr>
<tr class="memdesc:ga714efac01ef228fff45d4f6ab456dfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gafe443a26a34b79fc921c4583df576333" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:ga714efac01ef228fff45d4f6ab456dfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df599327b8ca16e8018e4e941f1f749" id="r_a0df599327b8ca16e8018e4e941f1f749"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0df599327b8ca16e8018e4e941f1f749"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0df599327b8ca16e8018e4e941f1f749">make_optional</a> (T &amp;&amp;value) -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt; <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">etl::decay_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a0df599327b8ca16e8018e4e941f1f749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object from value.  <br /></td></tr>
<tr class="separator:a0df599327b8ca16e8018e4e941f1f749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596e87d0c3bd7cc7e9d514639b141b04" id="r_a596e87d0c3bd7cc7e9d514639b141b04"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a596e87d0c3bd7cc7e9d514639b141b04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a596e87d0c3bd7cc7e9d514639b141b04">make_optional</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;... args) -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a596e87d0c3bd7cc7e9d514639b141b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object constructed in-place from args...  <br /></td></tr>
<tr class="separator:a596e87d0c3bd7cc7e9d514639b141b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cac911cf6d9b9b3b37254bc227e53" id="r_ae75cac911cf6d9b9b3b37254bc227e53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae75cac911cf6d9b9b3b37254bc227e53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae75cac911cf6d9b9b3b37254bc227e53">optional</a> (T) -&gt; optional&lt; T &gt;</td></tr>
<tr class="separator:ae75cac911cf6d9b9b3b37254bc227e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba6597548d02352070810c2d6c92e1a" id="r_a8ba6597548d02352070810c2d6c92e1a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a8ba6597548d02352070810c2d6c92e1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ba6597548d02352070810c2d6c92e1a">swap</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a8ba6597548d02352070810c2d6c92e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <a class="el" href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">etl::swap</a> algorithm for <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:a8ba6597548d02352070810c2d6c92e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1cc2f7a422e0cadab9361b16f7e875" id="r_a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d1cc2f7a422e0cadab9361b16f7e875">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0199291e596a6580c028a4fbb4c1a439" id="r_a0199291e596a6580c028a4fbb4c1a439"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a0199291e596a6580c028a4fbb4c1a439"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0199291e596a6580c028a4fbb4c1a439">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a0199291e596a6580c028a4fbb4c1a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:a0199291e596a6580c028a4fbb4c1a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dad36bf3c15c14d239e80047211e27" id="r_ad2dad36bf3c15c14d239e80047211e27"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ad2dad36bf3c15c14d239e80047211e27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2dad36bf3c15c14d239e80047211e27">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad2dad36bf3c15c14d239e80047211e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:ad2dad36bf3c15c14d239e80047211e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cfb4c68d3b5bf2a12e64973a9ee892" id="r_aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8cfb4c68d3b5bf2a12e64973a9ee892">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d41e110c97a6f118fac996337da06" id="r_abc6d41e110c97a6f118fac996337da06"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:abc6d41e110c97a6f118fac996337da06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc6d41e110c97a6f118fac996337da06">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:abc6d41e110c97a6f118fac996337da06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:abc6d41e110c97a6f118fac996337da06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd1c4702ae19a08b1aa3f03807f1267" id="r_a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4cd1c4702ae19a08b1aa3f03807f1267">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <br /></td></tr>
<tr class="separator:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb0eb100ae57232d484215f1b4315d6" id="r_afbb0eb100ae57232d484215f1b4315d6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afbb0eb100ae57232d484215f1b4315d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbb0eb100ae57232d484215f1b4315d6">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:afbb0eb100ae57232d484215f1b4315d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:afbb0eb100ae57232d484215f1b4315d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bdc0584358e44c777f1ff6dd845026" id="r_a55bdc0584358e44c777f1ff6dd845026"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a55bdc0584358e44c777f1ff6dd845026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a55bdc0584358e44c777f1ff6dd845026">operator==</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a55bdc0584358e44c777f1ff6dd845026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a55bdc0584358e44c777f1ff6dd845026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e737d88ff2f1d432403026a91a24766" id="r_a8e737d88ff2f1d432403026a91a24766"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8e737d88ff2f1d432403026a91a24766"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e737d88ff2f1d432403026a91a24766">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a8e737d88ff2f1d432403026a91a24766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a8e737d88ff2f1d432403026a91a24766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bf68822d73dd9f0d84b6a5aa3f3618" id="r_ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6bf68822d73dd9f0d84b6a5aa3f3618">operator!=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d07feb0fa4c7f8287a166fbbe4975ee" id="r_a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d07feb0fa4c7f8287a166fbbe4975ee">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91acd82b61f0b96647711aa1414b71" id="r_a0b91acd82b61f0b96647711aa1414b71"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0b91acd82b61f0b96647711aa1414b71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b91acd82b61f0b96647711aa1414b71">operator&lt;</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a0b91acd82b61f0b96647711aa1414b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a0b91acd82b61f0b96647711aa1414b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffa5aed44c30aae39950e0d82c7a256" id="r_a0ffa5aed44c30aae39950e0d82c7a256"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0ffa5aed44c30aae39950e0d82c7a256"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ffa5aed44c30aae39950e0d82c7a256">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a0ffa5aed44c30aae39950e0d82c7a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a0ffa5aed44c30aae39950e0d82c7a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3003b74d5cf5363cb983a63f0beaa5b8" id="r_a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3003b74d5cf5363cb983a63f0beaa5b8">operator&lt;=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ec0f3b39223f0c48dcae6bf744ac8f" id="r_aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2ec0f3b39223f0c48dcae6bf744ac8f">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d0943c411911df11ac5176fa48016" id="r_a070d0943c411911df11ac5176fa48016"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a070d0943c411911df11ac5176fa48016"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a070d0943c411911df11ac5176fa48016">operator&gt;</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a070d0943c411911df11ac5176fa48016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a070d0943c411911df11ac5176fa48016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad322ae7ca3d230a2cfb6aae8d633356b" id="r_ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad322ae7ca3d230a2cfb6aae8d633356b">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe18304d67bab939fd57ac52900323a" id="r_a8fe18304d67bab939fd57ac52900323a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8fe18304d67bab939fd57ac52900323a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8fe18304d67bab939fd57ac52900323a">operator&gt;=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a8fe18304d67bab939fd57ac52900323a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <br /></td></tr>
<tr class="separator:a8fe18304d67bab939fd57ac52900323a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975270db4255209c6d0a1664d9072560" id="r_a975270db4255209c6d0a1664d9072560"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a975270db4255209c6d0a1664d9072560"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a975270db4255209c6d0a1664d9072560">operator==</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a975270db4255209c6d0a1664d9072560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a975270db4255209c6d0a1664d9072560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5311a7c4d14b66f603c0fff05bb0670f" id="r_a5311a7c4d14b66f603c0fff05bb0670f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a5311a7c4d14b66f603c0fff05bb0670f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5311a7c4d14b66f603c0fff05bb0670f">operator==</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5311a7c4d14b66f603c0fff05bb0670f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a5311a7c4d14b66f603c0fff05bb0670f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad955578770fdb3a931ddd25d78ed03de" id="r_ad955578770fdb3a931ddd25d78ed03de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ad955578770fdb3a931ddd25d78ed03de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad955578770fdb3a931ddd25d78ed03de">operator!=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad955578770fdb3a931ddd25d78ed03de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:ad955578770fdb3a931ddd25d78ed03de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86505f8f0a3853f5fd106b17b367ebd0" id="r_a86505f8f0a3853f5fd106b17b367ebd0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a86505f8f0a3853f5fd106b17b367ebd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86505f8f0a3853f5fd106b17b367ebd0">operator!=</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a86505f8f0a3853f5fd106b17b367ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a86505f8f0a3853f5fd106b17b367ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d356ce4c5ed39ba60230ccb9bcdc76a" id="r_a5d356ce4c5ed39ba60230ccb9bcdc76a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a5d356ce4c5ed39ba60230ccb9bcdc76a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d356ce4c5ed39ba60230ccb9bcdc76a">operator&lt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a5d356ce4c5ed39ba60230ccb9bcdc76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a5d356ce4c5ed39ba60230ccb9bcdc76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683d8509d04f83a6cb7061df789c630c" id="r_a683d8509d04f83a6cb7061df789c630c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a683d8509d04f83a6cb7061df789c630c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a683d8509d04f83a6cb7061df789c630c">operator&lt;</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a683d8509d04f83a6cb7061df789c630c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a683d8509d04f83a6cb7061df789c630c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a59b23e259ef7140b324f681aa07dd" id="r_a83a59b23e259ef7140b324f681aa07dd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a83a59b23e259ef7140b324f681aa07dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a83a59b23e259ef7140b324f681aa07dd">operator&gt;</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a83a59b23e259ef7140b324f681aa07dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a83a59b23e259ef7140b324f681aa07dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4a6c0e67c15c1663f2cf60e9281833" id="r_abf4a6c0e67c15c1663f2cf60e9281833"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:abf4a6c0e67c15c1663f2cf60e9281833"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf4a6c0e67c15c1663f2cf60e9281833">operator&gt;</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:abf4a6c0e67c15c1663f2cf60e9281833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:abf4a6c0e67c15c1663f2cf60e9281833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270636ff7b3f10c31fea081efff5be7e" id="r_a270636ff7b3f10c31fea081efff5be7e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a270636ff7b3f10c31fea081efff5be7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a270636ff7b3f10c31fea081efff5be7e">operator&lt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a270636ff7b3f10c31fea081efff5be7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a270636ff7b3f10c31fea081efff5be7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60f7a5afa042d61659f05a0810ac1cd" id="r_af60f7a5afa042d61659f05a0810ac1cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:af60f7a5afa042d61659f05a0810ac1cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af60f7a5afa042d61659f05a0810ac1cd">operator&lt;=</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af60f7a5afa042d61659f05a0810ac1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:af60f7a5afa042d61659f05a0810ac1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cb53ac332644f510d613388dc9403" id="r_a315cb53ac332644f510d613388dc9403"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a315cb53ac332644f510d613388dc9403"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a315cb53ac332644f510d613388dc9403">operator&gt;=</a> (<a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a315cb53ac332644f510d613388dc9403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a315cb53ac332644f510d613388dc9403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e08e7d4bbce49c0f236c523f6ca908a" id="r_a1e08e7d4bbce49c0f236c523f6ca908a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a1e08e7d4bbce49c0f236c523f6ca908a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e08e7d4bbce49c0f236c523f6ca908a">operator&gt;=</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">opt</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1e08e7d4bbce49c0f236c523f6ca908a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a1e08e7d4bbce49c0f236c523f6ca908a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga740c4c4c7e95fbc853b0f8494375b927" id="r_ga740c4c4c7e95fbc853b0f8494375b927"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Real</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Bits, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RNG</a> &gt; </td></tr>
<tr class="memitem:ga740c4c4c7e95fbc853b0f8494375b927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga740c4c4c7e95fbc853b0f8494375b927">generate_canonical</a> (<a class="el" href="structetl_1_1static__vector.html">RNG</a> &amp;g) noexcept(noexcept(g())) -&gt; <a class="el" href="structetl_1_1static__vector.html">Real</a></td></tr>
<tr class="memdesc:ga740c4c4c7e95fbc853b0f8494375b927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random floating point number in range [0,1).  <br /></td></tr>
<tr class="separator:ga740c4c4c7e95fbc853b0f8494375b927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8f753ac26046a2f64b357e73ca88a4" id="r_aeb8f753ac26046a2f64b357e73ca88a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aeb8f753ac26046a2f64b357e73ca88a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb8f753ac26046a2f64b357e73ca88a4">decay_copy</a> (T &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept(<a class="el" href="#a2efb1cd1aad111e64a98e89322815a8f">is_nothrow_convertible_v</a>&lt; T, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; T &gt; &gt;) -&gt; <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; T &gt;</td></tr>
<tr class="separator:aeb8f753ac26046a2f64b357e73ca88a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4936d228847b9e7bb245a6f6d2a0064c" id="r_a4936d228847b9e7bb245a6f6d2a0064c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FuncT</a> &gt; </td></tr>
<tr class="memitem:a4936d228847b9e7bb245a6f6d2a0064c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4936d228847b9e7bb245a6f6d2a0064c">scope_exit</a> (<a class="el" href="structetl_1_1static__vector.html">FuncT</a>) -&gt; scope_exit&lt; <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">FuncT</a> &gt; &gt;</td></tr>
<tr class="separator:a4936d228847b9e7bb245a6f6d2a0064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16898ab8f9b95de51802d2ac8840c5cb" id="r_a16898ab8f9b95de51802d2ac8840c5cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:a16898ab8f9b95de51802d2ac8840c5cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16898ab8f9b95de51802d2ac8840c5cb">operator==</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a16898ab8f9b95de51802d2ac8840c5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:a16898ab8f9b95de51802d2ac8840c5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5ef95c5d2a3f3b77b9d48b0ee394c6" id="r_aeb5ef95c5d2a3f3b77b9d48b0ee394c6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:aeb5ef95c5d2a3f3b77b9d48b0ee394c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb5ef95c5d2a3f3b77b9d48b0ee394c6">operator!=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aeb5ef95c5d2a3f3b77b9d48b0ee394c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:aeb5ef95c5d2a3f3b77b9d48b0ee394c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51f4f81c713960abeab665d097df056" id="r_aa51f4f81c713960abeab665d097df056"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:aa51f4f81c713960abeab665d097df056"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa51f4f81c713960abeab665d097df056">operator&lt;</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aa51f4f81c713960abeab665d097df056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:aa51f4f81c713960abeab665d097df056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac570ea8aff6b11f4ff8930690e4c5a8e" id="r_ac570ea8aff6b11f4ff8930690e4c5a8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:ac570ea8aff6b11f4ff8930690e4c5a8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac570ea8aff6b11f4ff8930690e4c5a8e">operator&lt;=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ac570ea8aff6b11f4ff8930690e4c5a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:ac570ea8aff6b11f4ff8930690e4c5a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1767a8d6dec411f212efe9a29c8e0b3" id="r_af1767a8d6dec411f212efe9a29c8e0b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:af1767a8d6dec411f212efe9a29c8e0b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1767a8d6dec411f212efe9a29c8e0b3">operator&gt;</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af1767a8d6dec411f212efe9a29c8e0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:af1767a8d6dec411f212efe9a29c8e0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c3dfb9a3684b8b5905335affb701f" id="r_afb1c3dfb9a3684b8b5905335affb701f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </td></tr>
<tr class="memitem:afb1c3dfb9a3684b8b5905335affb701f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb1c3dfb9a3684b8b5905335affb701f">operator&gt;=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:afb1c3dfb9a3684b8b5905335affb701f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:afb1c3dfb9a3684b8b5905335affb701f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdaddf256aba01af62859d1d068472d" id="r_adbdaddf256aba01af62859d1d068472d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:adbdaddf256aba01af62859d1d068472d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbdaddf256aba01af62859d1d068472d">swap</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:adbdaddf256aba01af62859d1d068472d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:adbdaddf256aba01af62859d1d068472d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae916c7bad3feb7fd82e7f7932d5bb1" id="r_a7ae916c7bad3feb7fd82e7f7932d5bb1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:a7ae916c7bad3feb7fd82e7f7932d5bb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ae916c7bad3feb7fd82e7f7932d5bb1">as_bytes</a> (<a class="el" href="structetl_1_1span.html">span</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">s</a>) noexcept -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">byte</a> <a class="el" href="structetl_1_1static__vector.html">const</a>, detail::span_as_bytes_size&lt; T, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; &gt;</td></tr>
<tr class="memdesc:a7ae916c7bad3feb7fd82e7f7932d5bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a view to the object representation of the elements of the span s.  <br /></td></tr>
<tr class="separator:a7ae916c7bad3feb7fd82e7f7932d5bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25fa4eb811ee0ab2d424da51a7925c1" id="r_ab25fa4eb811ee0ab2d424da51a7925c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a40862de0c689f5281b8d680741bc7cf9">is_const_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:ab25fa4eb811ee0ab2d424da51a7925c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab25fa4eb811ee0ab2d424da51a7925c1">as_writable_bytes</a> (<a class="el" href="structetl_1_1span.html">span</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">s</a>) noexcept -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">byte</a>, detail::span_as_bytes_size&lt; T, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; &gt;</td></tr>
<tr class="memdesc:ab25fa4eb811ee0ab2d424da51a7925c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a view to the object representation of the elements of the span s.  <br /></td></tr>
<tr class="separator:ab25fa4eb811ee0ab2d424da51a7925c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da3a02a79034271cbc560bc94dbe2cd" id="r_a0da3a02a79034271cbc560bc94dbe2cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Extent&gt; </td></tr>
<tr class="memitem:a0da3a02a79034271cbc560bc94dbe2cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0da3a02a79034271cbc560bc94dbe2cd">span</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a>(&amp;)[<a class="el" href="structetl_1_1static__vector.html">Extent</a>]) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Extent</a> &gt;</td></tr>
<tr class="separator:a0da3a02a79034271cbc560bc94dbe2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ab2c6a5bc678d0ca3f5137c4004543" id="r_ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6ab2c6a5bc678d0ca3f5137c4004543">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;</td></tr>
<tr class="separator:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5667307c6ae6ae51fa6d1488fbab93b" id="r_aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5667307c6ae6ae51fa6d1488fbab93b">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;</td></tr>
<tr class="separator:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e186959b2d5132ab142843576d30048" id="r_a9e186959b2d5132ab142843576d30048"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:a9e186959b2d5132ab142843576d30048"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e186959b2d5132ab142843576d30048">span</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Element</a> &gt;</td></tr>
<tr class="separator:a9e186959b2d5132ab142843576d30048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc55cb127ec094c3dbdec3ed03452ebc" id="r_adc55cb127ec094c3dbdec3ed03452ebc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:adc55cb127ec094c3dbdec3ed03452ebc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc55cb127ec094c3dbdec3ed03452ebc">span</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1static__vector.html">Element</a> &gt;</td></tr>
<tr class="separator:adc55cb127ec094c3dbdec3ed03452ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d951f6a467976762f8f57f9b49cee" id="r_ab57d951f6a467976762f8f57f9b49cee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </td></tr>
<tr class="memitem:ab57d951f6a467976762f8f57f9b49cee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab57d951f6a467976762f8f57f9b49cee">stack</a> (<a class="el" href="structetl_1_1static__vector.html">Container</a>) -&gt; stack&lt; <a class="el" href="structetl_1_1static__vector.html">typename</a> Container::value_type, <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt;</td></tr>
<tr class="separator:ab57d951f6a467976762f8f57f9b49cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731b8a1123b0ae68ac65b81165953715" id="r_a731b8a1123b0ae68ac65b81165953715"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; <br />
requires (<a class="el" href="#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">C</a>&gt;)</td></tr>
<tr class="memitem:a731b8a1123b0ae68ac65b81165953715"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a731b8a1123b0ae68ac65b81165953715">swap</a> (<a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a731b8a1123b0ae68ac65b81165953715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for stack. Swaps the contents of lhs and rhs. This overload only participates in overload resolution if is_swappable&lt;C&gt;::value is true.  <br /></td></tr>
<tr class="separator:a731b8a1123b0ae68ac65b81165953715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550be74a772ee835b7969103906449d0" id="r_a550be74a772ee835b7969103906449d0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a550be74a772ee835b7969103906449d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a550be74a772ee835b7969103906449d0">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a550be74a772ee835b7969103906449d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a550be74a772ee835b7969103906449d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f68785d405ab507029b4dc21d784f32" id="r_a8f68785d405ab507029b4dc21d784f32"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a8f68785d405ab507029b4dc21d784f32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f68785d405ab507029b4dc21d784f32">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a8f68785d405ab507029b4dc21d784f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a8f68785d405ab507029b4dc21d784f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3730f573680ab7ee2848994263888494" id="r_a3730f573680ab7ee2848994263888494"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a3730f573680ab7ee2848994263888494"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3730f573680ab7ee2848994263888494">operator+</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a3730f573680ab7ee2848994263888494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a3730f573680ab7ee2848994263888494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0402f15f7abdd70ed375cfc0c967739a" id="r_a0402f15f7abdd70ed375cfc0c967739a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a0402f15f7abdd70ed375cfc0c967739a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0402f15f7abdd70ed375cfc0c967739a">operator+</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a0402f15f7abdd70ed375cfc0c967739a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a0402f15f7abdd70ed375cfc0c967739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6e97ff485e83eeab3a47dda30b592b" id="r_a1e6e97ff485e83eeab3a47dda30b592b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a1e6e97ff485e83eeab3a47dda30b592b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e6e97ff485e83eeab3a47dda30b592b">operator+</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a1e6e97ff485e83eeab3a47dda30b592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a1e6e97ff485e83eeab3a47dda30b592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6b52bf4545c553a814d0bdb36cfc3b" id="r_a1d6b52bf4545c553a814d0bdb36cfc3b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a1d6b52bf4545c553a814d0bdb36cfc3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d6b52bf4545c553a814d0bdb36cfc3b">operator==</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1d6b52bf4545c553a814d0bdb36cfc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a1d6b52bf4545c553a814d0bdb36cfc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7dc7e7afd9ab5389cf089585ecb7ff" id="r_afd7dc7e7afd9ab5389cf089585ecb7ff"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:afd7dc7e7afd9ab5389cf089585ecb7ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd7dc7e7afd9ab5389cf089585ecb7ff">operator==</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:afd7dc7e7afd9ab5389cf089585ecb7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:afd7dc7e7afd9ab5389cf089585ecb7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c985efe97b9de9bcb2fd57ed62f63" id="r_a1f7c985efe97b9de9bcb2fd57ed62f63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a1f7c985efe97b9de9bcb2fd57ed62f63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f7c985efe97b9de9bcb2fd57ed62f63">operator==</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1f7c985efe97b9de9bcb2fd57ed62f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a1f7c985efe97b9de9bcb2fd57ed62f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af595ea9358f1b118453f23ce14c7c539" id="r_af595ea9358f1b118453f23ce14c7c539"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:af595ea9358f1b118453f23ce14c7c539"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af595ea9358f1b118453f23ce14c7c539">operator!=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af595ea9358f1b118453f23ce14c7c539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:af595ea9358f1b118453f23ce14c7c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9556a73ed76342b9e3acbfde9f9cdac8" id="r_a9556a73ed76342b9e3acbfde9f9cdac8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a9556a73ed76342b9e3acbfde9f9cdac8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9556a73ed76342b9e3acbfde9f9cdac8">operator!=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a9556a73ed76342b9e3acbfde9f9cdac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a9556a73ed76342b9e3acbfde9f9cdac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2996ca93f7497f0f26bc52448cbc3a87" id="r_a2996ca93f7497f0f26bc52448cbc3a87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a2996ca93f7497f0f26bc52448cbc3a87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2996ca93f7497f0f26bc52448cbc3a87">operator!=</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a2996ca93f7497f0f26bc52448cbc3a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a2996ca93f7497f0f26bc52448cbc3a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac484f684a7e23d519733aa7a1dfdd2cc" id="r_ac484f684a7e23d519733aa7a1dfdd2cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:ac484f684a7e23d519733aa7a1dfdd2cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac484f684a7e23d519733aa7a1dfdd2cc">operator&lt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:ac484f684a7e23d519733aa7a1dfdd2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ac484f684a7e23d519733aa7a1dfdd2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f66fcbe677016753265cda13588a02" id="r_a25f66fcbe677016753265cda13588a02"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a25f66fcbe677016753265cda13588a02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a25f66fcbe677016753265cda13588a02">operator&lt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a25f66fcbe677016753265cda13588a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a25f66fcbe677016753265cda13588a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834f76d59c40a1aaa9b9f45222a5815c" id="r_a834f76d59c40a1aaa9b9f45222a5815c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a834f76d59c40a1aaa9b9f45222a5815c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a834f76d59c40a1aaa9b9f45222a5815c">operator&lt;</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a834f76d59c40a1aaa9b9f45222a5815c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a834f76d59c40a1aaa9b9f45222a5815c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105ce49011cd77ed4c6e3b72390ed12b" id="r_a105ce49011cd77ed4c6e3b72390ed12b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a105ce49011cd77ed4c6e3b72390ed12b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a105ce49011cd77ed4c6e3b72390ed12b">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a105ce49011cd77ed4c6e3b72390ed12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a105ce49011cd77ed4c6e3b72390ed12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dc9a85456db0c3b0085526ad74898c" id="r_a24dc9a85456db0c3b0085526ad74898c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a24dc9a85456db0c3b0085526ad74898c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24dc9a85456db0c3b0085526ad74898c">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a24dc9a85456db0c3b0085526ad74898c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a24dc9a85456db0c3b0085526ad74898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3378b9bc8853f3e35709acd2a945d2a" id="r_ad3378b9bc8853f3e35709acd2a945d2a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:ad3378b9bc8853f3e35709acd2a945d2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3378b9bc8853f3e35709acd2a945d2a">operator&lt;=</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad3378b9bc8853f3e35709acd2a945d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ad3378b9bc8853f3e35709acd2a945d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbbab6f8321779c8eb9b3b173cb34e" id="r_a07dbbab6f8321779c8eb9b3b173cb34e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a07dbbab6f8321779c8eb9b3b173cb34e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07dbbab6f8321779c8eb9b3b173cb34e">operator&gt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a07dbbab6f8321779c8eb9b3b173cb34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a07dbbab6f8321779c8eb9b3b173cb34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fe899d26d372e2f56cbe8fa4551770" id="r_af8fe899d26d372e2f56cbe8fa4551770"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:af8fe899d26d372e2f56cbe8fa4551770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8fe899d26d372e2f56cbe8fa4551770">operator&gt;</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af8fe899d26d372e2f56cbe8fa4551770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:af8fe899d26d372e2f56cbe8fa4551770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd663da7cd107379f89f863f44d18d7c" id="r_abd663da7cd107379f89f863f44d18d7c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:abd663da7cd107379f89f863f44d18d7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd663da7cd107379f89f863f44d18d7c">operator&gt;</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:abd663da7cd107379f89f863f44d18d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:abd663da7cd107379f89f863f44d18d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e94a2069d38ef480a1f723e594c4f60" id="r_a0e94a2069d38ef480a1f723e594c4f60"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a0e94a2069d38ef480a1f723e594c4f60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e94a2069d38ef480a1f723e594c4f60">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a0e94a2069d38ef480a1f723e594c4f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a0e94a2069d38ef480a1f723e594c4f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7782ee247113a01628108deed5640" id="r_a1fe7782ee247113a01628108deed5640"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a1fe7782ee247113a01628108deed5640"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fe7782ee247113a01628108deed5640">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1fe7782ee247113a01628108deed5640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a1fe7782ee247113a01628108deed5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada97bd78bce6e3f4b4181a18403077da" id="r_ada97bd78bce6e3f4b4181a18403077da"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ada97bd78bce6e3f4b4181a18403077da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada97bd78bce6e3f4b4181a18403077da">operator&gt;=</a> (<a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ada97bd78bce6e3f4b4181a18403077da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ada97bd78bce6e3f4b4181a18403077da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9897e71535e601101f19e29b7fb9c82" id="r_ad9897e71535e601101f19e29b7fb9c82"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ad9897e71535e601101f19e29b7fb9c82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9897e71535e601101f19e29b7fb9c82">swap</a> (<a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ad9897e71535e601101f19e29b7fb9c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the <a class="el" href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">etl::swap</a> algorithm for <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">etl::basic_static_string</a>. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:ad9897e71535e601101f19e29b7fb9c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cf7e5dcda9f55d609ec4236a37c3b0" id="r_a21cf7e5dcda9f55d609ec4236a37c3b0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a21cf7e5dcda9f55d609ec4236a37c3b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21cf7e5dcda9f55d609ec4236a37c3b0">erase</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;c, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;::size_type</td></tr>
<tr class="memdesc:a21cf7e5dcda9f55d609ec4236a37c3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that compare equal to value from the container.  <br /></td></tr>
<tr class="separator:a21cf7e5dcda9f55d609ec4236a37c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b84ee8ace15469eade7ad329497759" id="r_ae5b84ee8ace15469eade7ad329497759"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ae5b84ee8ace15469eade7ad329497759"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5b84ee8ace15469eade7ad329497759">erase_if</a> (<a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;c, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;::size_type</td></tr>
<tr class="memdesc:ae5b84ee8ace15469eade7ad329497759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container.  <br /></td></tr>
<tr class="separator:ae5b84ee8ace15469eade7ad329497759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5346fd1e1c69c9da34adc6ba0d875b" id="r_a7b5346fd1e1c69c9da34adc6ba0d875b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a7b5346fd1e1c69c9da34adc6ba0d875b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b5346fd1e1c69c9da34adc6ba0d875b">stof</a> (<a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a></td></tr>
<tr class="memdesc:a7b5346fd1e1c69c9da34adc6ba0d875b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:a7b5346fd1e1c69c9da34adc6ba0d875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03247c5be7114ad3402fea1ac09a5323" id="r_a03247c5be7114ad3402fea1ac09a5323"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a03247c5be7114ad3402fea1ac09a5323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03247c5be7114ad3402fea1ac09a5323">stod</a> (<a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:a03247c5be7114ad3402fea1ac09a5323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:a03247c5be7114ad3402fea1ac09a5323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d8c5321a6401ffca589167c2f5200c" id="r_ad2d8c5321a6401ffca589167c2f5200c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ad2d8c5321a6401ffca589167c2f5200c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2d8c5321a6401ffca589167c2f5200c">stold</a> (<a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td></tr>
<tr class="memdesc:ad2d8c5321a6401ffca589167c2f5200c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:ad2d8c5321a6401ffca589167c2f5200c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67d02a60ed99d7b4f7caa47c456418c" id="r_ad67d02a60ed99d7b4f7caa47c456418c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67d02a60ed99d7b4f7caa47c456418c">stoi</a> (<a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a></td></tr>
<tr class="memdesc:ad67d02a60ed99d7b4f7caa47c456418c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:ad67d02a60ed99d7b4f7caa47c456418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e713476eeb2d06c599abb03b3c81da" id="r_ac5e713476eeb2d06c599abb03b3c81da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5e713476eeb2d06c599abb03b3c81da">stol</a> (<a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:ac5e713476eeb2d06c599abb03b3c81da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:ac5e713476eeb2d06c599abb03b3c81da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6979ddaeccf0df75fc74642fad0938" id="r_a3e6979ddaeccf0df75fc74642fad0938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e6979ddaeccf0df75fc74642fad0938">stoll</a> (<a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a3e6979ddaeccf0df75fc74642fad0938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a3e6979ddaeccf0df75fc74642fad0938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5ca51303826f354fffce9e40115186" id="r_aab5ca51303826f354fffce9e40115186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab5ca51303826f354fffce9e40115186">stoul</a> (<a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:aab5ca51303826f354fffce9e40115186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:aab5ca51303826f354fffce9e40115186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fff36f8d372c069a8335afa15afab5d" id="r_a5fff36f8d372c069a8335afa15afab5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fff36f8d372c069a8335afa15afab5d">stoull</a> (<a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a> <a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *<a class="el" href="structetl_1_1static__vector.html">pos</a>=<a class="el" href="structetl_1_1static__vector.html">nullptr</a>, <a class="el" href="structetl_1_1static__vector.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td></tr>
<tr class="memdesc:a5fff36f8d372c069a8335afa15afab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a5fff36f8d372c069a8335afa15afab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefef503dc1f63ba2e9183e92350a35d6" id="r_aefef503dc1f63ba2e9183e92350a35d6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , CharT... Chars&gt; </td></tr>
<tr class="memitem:aefef503dc1f63ba2e9183e92350a35d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefef503dc1f63ba2e9183e92350a35d6">operator==</a> (<a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, Chars... &gt;, <a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, Chars... &gt;) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:aefef503dc1f63ba2e9183e92350a35d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06688b616d203a7f05d1902d4e9e9ae6" id="r_a06688b616d203a7f05d1902d4e9e9ae6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , CharT... CharsL, CharT... CharsR&gt; </td></tr>
<tr class="memitem:a06688b616d203a7f05d1902d4e9e9ae6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06688b616d203a7f05d1902d4e9e9ae6">operator==</a> (<a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, CharsL... &gt;, <a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, CharsR... &gt;) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a06688b616d203a7f05d1902d4e9e9ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3175965fb95cd90d46d8741581b050a9" id="r_a3175965fb95cd90d46d8741581b050a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a3175965fb95cd90d46d8741581b050a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3175965fb95cd90d46d8741581b050a9">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">int</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a3175965fb95cd90d46d8741581b050a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a3175965fb95cd90d46d8741581b050a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae1922b9fe325bc073f9157245ea62f" id="r_a0ae1922b9fe325bc073f9157245ea62f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a0ae1922b9fe325bc073f9157245ea62f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ae1922b9fe325bc073f9157245ea62f">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a0ae1922b9fe325bc073f9157245ea62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a0ae1922b9fe325bc073f9157245ea62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866ea97f8268ee79e420deb4e7d0b5c8" id="r_a866ea97f8268ee79e420deb4e7d0b5c8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a866ea97f8268ee79e420deb4e7d0b5c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a866ea97f8268ee79e420deb4e7d0b5c8">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a866ea97f8268ee79e420deb4e7d0b5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a866ea97f8268ee79e420deb4e7d0b5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cec2c910331a0348fbc177f79fb5d7" id="r_a76cec2c910331a0348fbc177f79fb5d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a76cec2c910331a0348fbc177f79fb5d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76cec2c910331a0348fbc177f79fb5d7">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a76cec2c910331a0348fbc177f79fb5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a76cec2c910331a0348fbc177f79fb5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1591359f7f91cee90f3670ee200fd71e" id="r_a1591359f7f91cee90f3670ee200fd71e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a1591359f7f91cee90f3670ee200fd71e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1591359f7f91cee90f3670ee200fd71e">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a1591359f7f91cee90f3670ee200fd71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a1591359f7f91cee90f3670ee200fd71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316c748b2a3e782707bf5f99266226ce" id="r_a316c748b2a3e782707bf5f99266226ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a316c748b2a3e782707bf5f99266226ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a316c748b2a3e782707bf5f99266226ce">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a316c748b2a3e782707bf5f99266226ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a316c748b2a3e782707bf5f99266226ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de851aa9fa43387b4735c74a2e913ac" id="r_a3de851aa9fa43387b4735c74a2e913ac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a3de851aa9fa43387b4735c74a2e913ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3de851aa9fa43387b4735c74a2e913ac">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">float</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a3de851aa9fa43387b4735c74a2e913ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a3de851aa9fa43387b4735c74a2e913ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fe48f1155730f6d6beed4ac618c03" id="r_ad12fe48f1155730f6d6beed4ac618c03"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ad12fe48f1155730f6d6beed4ac618c03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad12fe48f1155730f6d6beed4ac618c03">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">double</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:ad12fe48f1155730f6d6beed4ac618c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:ad12fe48f1155730f6d6beed4ac618c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252c37b56c955507d6f799b10f6d7bf8" id="r_a252c37b56c955507d6f799b10f6d7bf8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a252c37b56c955507d6f799b10f6d7bf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a252c37b56c955507d6f799b10f6d7bf8">to_string</a> (<a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> value) noexcept -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a252c37b56c955507d6f799b10f6d7bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>.  <br /></td></tr>
<tr class="separator:a252c37b56c955507d6f799b10f6d7bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e970cc5b5992d8eb7ac649c247c62c" id="r_ab7e970cc5b5992d8eb7ac649c247c62c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:ab7e970cc5b5992d8eb7ac649c247c62c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7e970cc5b5992d8eb7ac649c247c62c">operator==</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab7e970cc5b5992d8eb7ac649c247c62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:ab7e970cc5b5992d8eb7ac649c247c62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43931ca9d54ef886964eed7b4bc14d63" id="r_a43931ca9d54ef886964eed7b4bc14d63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a43931ca9d54ef886964eed7b4bc14d63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43931ca9d54ef886964eed7b4bc14d63">operator==</a> (<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a43931ca9d54ef886964eed7b4bc14d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e5027c4f68ca37175378f38f9118d7" id="r_a86e5027c4f68ca37175378f38f9118d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a86e5027c4f68ca37175378f38f9118d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86e5027c4f68ca37175378f38f9118d7">operator==</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a86e5027c4f68ca37175378f38f9118d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75a10e3bbd7b95eda40943d83c2c213" id="r_ac75a10e3bbd7b95eda40943d83c2c213"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:ac75a10e3bbd7b95eda40943d83c2c213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac75a10e3bbd7b95eda40943d83c2c213">operator!=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ac75a10e3bbd7b95eda40943d83c2c213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:ac75a10e3bbd7b95eda40943d83c2c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86a94a336ccbaa866716958140a221f" id="r_ad86a94a336ccbaa866716958140a221f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:ad86a94a336ccbaa866716958140a221f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad86a94a336ccbaa866716958140a221f">operator!=</a> (<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ad86a94a336ccbaa866716958140a221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5676aa014a2ce611e045553339c23ea" id="r_aa5676aa014a2ce611e045553339c23ea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:aa5676aa014a2ce611e045553339c23ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5676aa014a2ce611e045553339c23ea">operator!=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:aa5676aa014a2ce611e045553339c23ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5e98d445c114716af566d56c8846de" id="r_adc5e98d445c114716af566d56c8846de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:adc5e98d445c114716af566d56c8846de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc5e98d445c114716af566d56c8846de">operator&lt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:adc5e98d445c114716af566d56c8846de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:adc5e98d445c114716af566d56c8846de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9340746d2b31deae49c0079c6a1393" id="r_a5b9340746d2b31deae49c0079c6a1393"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a5b9340746d2b31deae49c0079c6a1393"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5b9340746d2b31deae49c0079c6a1393">operator&lt;</a> (<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a5b9340746d2b31deae49c0079c6a1393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d40be1a03198a33e40d2deb6727f3b" id="r_a02d40be1a03198a33e40d2deb6727f3b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a02d40be1a03198a33e40d2deb6727f3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02d40be1a03198a33e40d2deb6727f3b">operator&lt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a02d40be1a03198a33e40d2deb6727f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda576b0bc560a8f6d7fe3ab07ee4f80" id="r_aeda576b0bc560a8f6d7fe3ab07ee4f80"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:aeda576b0bc560a8f6d7fe3ab07ee4f80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeda576b0bc560a8f6d7fe3ab07ee4f80">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aeda576b0bc560a8f6d7fe3ab07ee4f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:aeda576b0bc560a8f6d7fe3ab07ee4f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc2112c91d1850707c947cfde474606" id="r_a1fc2112c91d1850707c947cfde474606"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a1fc2112c91d1850707c947cfde474606"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fc2112c91d1850707c947cfde474606">operator&lt;=</a> (<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a1fc2112c91d1850707c947cfde474606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe770e6fbd84cf40351c0d39a6f09a24" id="r_abe770e6fbd84cf40351c0d39a6f09a24"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:abe770e6fbd84cf40351c0d39a6f09a24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe770e6fbd84cf40351c0d39a6f09a24">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:abe770e6fbd84cf40351c0d39a6f09a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a16921121279f4b613b0c0228f839b" id="r_ae5a16921121279f4b613b0c0228f839b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:ae5a16921121279f4b613b0c0228f839b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5a16921121279f4b613b0c0228f839b">operator&gt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae5a16921121279f4b613b0c0228f839b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:ae5a16921121279f4b613b0c0228f839b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c15495d593a5126ee28f51f045404a9" id="r_a3c15495d593a5126ee28f51f045404a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a3c15495d593a5126ee28f51f045404a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c15495d593a5126ee28f51f045404a9">operator&gt;</a> (<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a3c15495d593a5126ee28f51f045404a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810842dd51a024da236472a9b4530d00" id="r_a810842dd51a024da236472a9b4530d00"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a810842dd51a024da236472a9b4530d00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a810842dd51a024da236472a9b4530d00">operator&gt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a810842dd51a024da236472a9b4530d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8245ad8d38c37448fb6f2b289695f3" id="r_a1e8245ad8d38c37448fb6f2b289695f3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a1e8245ad8d38c37448fb6f2b289695f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e8245ad8d38c37448fb6f2b289695f3">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a1e8245ad8d38c37448fb6f2b289695f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a1e8245ad8d38c37448fb6f2b289695f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2ffff69037efea21229e2041a41f5c" id="r_a6b2ffff69037efea21229e2041a41f5c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a6b2ffff69037efea21229e2041a41f5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b2ffff69037efea21229e2041a41f5c">operator&gt;=</a> (<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a6b2ffff69037efea21229e2041a41f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56b3763d8f4d6a4cbda61095d8b9cfc" id="r_ae56b3763d8f4d6a4cbda61095d8b9cfc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:ae56b3763d8f4d6a4cbda61095d8b9cfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae56b3763d8f4d6a4cbda61095d8b9cfc">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ae56b3763d8f4d6a4cbda61095d8b9cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9ad17f89aa026ee52417e1a98d119c" id="r_aae9ad17f89aa026ee52417e1a98d119c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1string__view__literals.html#aae9ad17f89aa026ee52417e1a98d119c">operator&quot;&quot;_sv</a> (<a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">str</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">len</a>) noexcept -&gt; <a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a></td></tr>
<tr class="memdesc:aae9ad17f89aa026ee52417e1a98d119c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a string view of a character literal. Returns <a class="el" href="#aafbf680e76b153b8a596435b6059846b" title="Typedefs for common character type.">etl::string_view</a>{str, len}.  <br /></td></tr>
<tr class="separator:aae9ad17f89aa026ee52417e1a98d119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974fb6faa222ecb40a59180647ccb79d" id="r_a974fb6faa222ecb40a59180647ccb79d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &gt; </td></tr>
<tr class="memitem:a974fb6faa222ecb40a59180647ccb79d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a974fb6faa222ecb40a59180647ccb79d">apply</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">auto</a>)</td></tr>
<tr class="separator:a974fb6faa222ecb40a59180647ccb79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed3d4879ef8b1df2012935a3022f720" id="r_a0ed3d4879ef8b1df2012935a3022f720"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a0ed3d4879ef8b1df2012935a3022f720"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ed3d4879ef8b1df2012935a3022f720">forward_as_tuple</a> (<a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;... args) noexcept -&gt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;... &gt;</td></tr>
<tr class="memdesc:a0ed3d4879ef8b1df2012935a3022f720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members.  <br /></td></tr>
<tr class="separator:a0ed3d4879ef8b1df2012935a3022f720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722cde6b61e815e5a032f34f922c3e99" id="r_a722cde6b61e815e5a032f34f922c3e99"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &gt; </td></tr>
<tr class="memitem:a722cde6b61e815e5a032f34f922c3e99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a722cde6b61e815e5a032f34f922c3e99">make_from_tuple</a> (<a class="el" href="structetl_1_1static__vector.html">Tuple</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; T</td></tr>
<tr class="separator:a722cde6b61e815e5a032f34f922c3e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e0097403ec5f189d1192cca821a7e4" id="r_aa7e0097403ec5f189d1192cca821a7e4"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aa7e0097403ec5f189d1192cca821a7e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7e0097403ec5f189d1192cca821a7e4">make_tuple</a> (<a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa7e0097403ec5f189d1192cca821a7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tuple object, deducing the target type from the types of arguments.  <br /></td></tr>
<tr class="separator:aa7e0097403ec5f189d1192cca821a7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3ddae955d45b6a63298906227f2f60" id="r_ada3ddae955d45b6a63298906227f2f60"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ada3ddae955d45b6a63298906227f2f60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada3ddae955d45b6a63298906227f2f60">tie</a> (<a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;... args) noexcept -&gt; <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;... &gt;</td></tr>
<tr class="separator:ada3ddae955d45b6a63298906227f2f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7332293756222129bddd488f2be46c89" id="r_a7332293756222129bddd488f2be46c89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a7332293756222129bddd488f2be46c89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7332293756222129bddd488f2be46c89">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td></tr>
<tr class="separator:a7332293756222129bddd488f2be46c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3910901935da4bd1aa0404bb8e4344cd" id="r_a3910901935da4bd1aa0404bb8e4344cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a3910901935da4bd1aa0404bb8e4344cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3910901935da4bd1aa0404bb8e4344cd">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:a3910901935da4bd1aa0404bb8e4344cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d05954af24fa3a51c81a56eac04b53" id="r_a44d05954af24fa3a51c81a56eac04b53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a44d05954af24fa3a51c81a56eac04b53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44d05954af24fa3a51c81a56eac04b53">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:a44d05954af24fa3a51c81a56eac04b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca389dd668b413db5163594031d441dc" id="r_aca389dd668b413db5163594031d441dc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:aca389dd668b413db5163594031d441dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca389dd668b413db5163594031d441dc">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="separator:aca389dd668b413db5163594031d441dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88a49cfacc8c17b0b3dc1091e82b6d3" id="r_ae88a49cfacc8c17b0b3dc1091e82b6d3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Us&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1static__vector.html">Ts</a>) == sizeof...(<a class="el" href="structetl_1_1static__vector.html">Us</a>))</td></tr>
<tr class="memitem:ae88a49cfacc8c17b0b3dc1091e82b6d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae88a49cfacc8c17b0b3dc1091e82b6d3">operator==</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Us... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ae88a49cfacc8c17b0b3dc1091e82b6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308b29ca423e2fd99cd291d2f7ac00af" id="r_a308b29ca423e2fd99cd291d2f7ac00af"><td class="memTemplParams" colspan="2">template&lt;etl::tuple_like... Tuples&gt; </td></tr>
<tr class="memitem:a308b29ca423e2fd99cd291d2f7ac00af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a308b29ca423e2fd99cd291d2f7ac00af">tuple_cat</a> (<a class="el" href="structetl_1_1static__vector.html">Tuples</a> &amp;&amp;... <a class="el" href="structetl_1_1static__vector.html">ts</a>)</td></tr>
<tr class="separator:a308b29ca423e2fd99cd291d2f7ac00af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1c3baeebc248b3f787a308af595c6a" id="r_a0a1c3baeebc248b3f787a308af595c6a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0a1c3baeebc248b3f787a308af595c6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a1c3baeebc248b3f787a308af595c6a">swap</a> (T &amp;a, T &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a0a1c3baeebc248b3f787a308af595c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:a0a1c3baeebc248b3f787a308af595c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a1a97135d4a41771948063bd8c3a90" id="r_a27a1a97135d4a41771948063bd8c3a90"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a27a1a97135d4a41771948063bd8c3a90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">declval</a> () noexcept -&gt; etl::add_rvalue_reference_t&lt; T &gt;</td></tr>
<tr class="separator:a27a1a97135d4a41771948063bd8c3a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b9b4f72a823403539ecfc03192012e" id="r_a57b9b4f72a823403539ecfc03192012e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:a57b9b4f72a823403539ecfc03192012e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57b9b4f72a823403539ecfc03192012e">operator+</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">L</a>+<a class="el" href="structetl_1_1static__vector.html">R</a>), <a class="el" href="structetl_1_1static__vector.html">L</a>+<a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td></tr>
<tr class="separator:a57b9b4f72a823403539ecfc03192012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b41a63ce6030e00a502be9c802192dc" id="r_a9b41a63ce6030e00a502be9c802192dc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:a9b41a63ce6030e00a502be9c802192dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b41a63ce6030e00a502be9c802192dc">operator==</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">L</a>==<a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td></tr>
<tr class="separator:a9b41a63ce6030e00a502be9c802192dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043a792e889d30e7160364a8a4670297" id="r_a043a792e889d30e7160364a8a4670297"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:a043a792e889d30e7160364a8a4670297"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a043a792e889d30e7160364a8a4670297">operator!=</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> !=<a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td></tr>
<tr class="separator:a043a792e889d30e7160364a8a4670297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5c14f53ef79e0b6debfffb6ce947f" id="r_a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ec5c14f53ef79e0b6debfffb6ce947f">is_constant_evaluated</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false.  <br /></td></tr>
<tr class="separator:a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2a8839b0088ceabc861e39e5a15daa" id="r_a5d2a8839b0088ceabc861e39e5a15daa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5d2a8839b0088ceabc861e39e5a15daa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d2a8839b0088ceabc861e39e5a15daa">test_implicit_default_constructible</a> (T)</td></tr>
<tr class="separator:a5d2a8839b0088ceabc861e39e5a15daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e832bccac59295eb90e8d9fad5614c" id="r_a22e832bccac59295eb90e8d9fad5614c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a22e832bccac59295eb90e8d9fad5614c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22e832bccac59295eb90e8d9fad5614c">swap</a> (T &amp;a, T &amp;b) noexcept(<a class="el" href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="#ab5d18b577003e8d090a82e4c6d497cdd">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a22e832bccac59295eb90e8d9fad5614c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:a22e832bccac59295eb90e8d9fad5614c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88ceada984879d542eb815dfb0a8d83" id="r_ae88ceada984879d542eb815dfb0a8d83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="structetl_1_1is__swappable.html">etl::is_swappable</a>&lt;T&gt;::value)</td></tr>
<tr class="memitem:ae88ceada984879d542eb815dfb0a8d83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae88ceada984879d542eb815dfb0a8d83">swap</a> (T(&amp;a)[<a class="el" href="structetl_1_1static__vector.html">N</a>], T(&amp;b)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept(<a class="el" href="structetl_1_1is__nothrow__swappable.html">etl::is_nothrow_swappable</a>&lt; T &gt;::value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:ae88ceada984879d542eb815dfb0a8d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa180d468fdf2378d57e100ab2bd37ccc" id="r_aa180d468fdf2378d57e100ab2bd37ccc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa180d468fdf2378d57e100ab2bd37ccc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa180d468fdf2378d57e100ab2bd37ccc">as_const</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; add_const_t&lt; T &gt; &amp;</td></tr>
<tr class="memdesc:aa180d468fdf2378d57e100ab2bd37ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms lvalue reference to const type of t.  <br /></td></tr>
<tr class="separator:aa180d468fdf2378d57e100ab2bd37ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467b2ed1f8f9d51ceb6786d6f6cd2c1d" id="r_a467b2ed1f8f9d51ceb6786d6f6cd2c1d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a467b2ed1f8f9d51ceb6786d6f6cd2c1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a467b2ed1f8f9d51ceb6786d6f6cd2c1d">as_const</a> (T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>=<a class="el" href="structetl_1_1static__vector.html">delete</a></td></tr>
<tr class="separator:a467b2ed1f8f9d51ceb6786d6f6cd2c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a742e008686e62913e47c8505cba405" id="r_a6a742e008686e62913e47c8505cba405"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:a6a742e008686e62913e47c8505cba405"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a742e008686e62913e47c8505cba405">cmp_equal</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a6a742e008686e62913e47c8505cba405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:a6a742e008686e62913e47c8505cba405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad080d4f56f57aee81f93bf37b9599f95" id="r_ad080d4f56f57aee81f93bf37b9599f95"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:ad080d4f56f57aee81f93bf37b9599f95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad080d4f56f57aee81f93bf37b9599f95">cmp_greater</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ad080d4f56f57aee81f93bf37b9599f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:ad080d4f56f57aee81f93bf37b9599f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134f08c8956146e4c44840cd7e9391d1" id="r_a134f08c8956146e4c44840cd7e9391d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:a134f08c8956146e4c44840cd7e9391d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a134f08c8956146e4c44840cd7e9391d1">cmp_greater_equal</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a134f08c8956146e4c44840cd7e9391d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:a134f08c8956146e4c44840cd7e9391d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b2305599709550b391642927bba54f" id="r_a14b2305599709550b391642927bba54f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:a14b2305599709550b391642927bba54f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14b2305599709550b391642927bba54f">cmp_less</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a14b2305599709550b391642927bba54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:a14b2305599709550b391642927bba54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af861969a29a90c954b15c74f8c483e94" id="r_af861969a29a90c954b15c74f8c483e94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:af861969a29a90c954b15c74f8c483e94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af861969a29a90c954b15c74f8c483e94">cmp_less_equal</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:af861969a29a90c954b15c74f8c483e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:af861969a29a90c954b15c74f8c483e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f934565a407af9752f6792d80720e4" id="r_a13f934565a407af9752f6792d80720e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:a13f934565a407af9752f6792d80720e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13f934565a407af9752f6792d80720e4">cmp_not_equal</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>, U <a class="el" href="structetl_1_1static__vector.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a13f934565a407af9752f6792d80720e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:a13f934565a407af9752f6792d80720e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab9c512cd288c92340c8a957b3742fe" id="r_abab9c512cd288c92340c8a957b3742fe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U  = T&gt; </td></tr>
<tr class="memitem:abab9c512cd288c92340c8a957b3742fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abab9c512cd288c92340c8a957b3742fe">exchange</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">obj</a>, U &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">newValue</a>) noexcept(<a class="el" href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#a865b2c54ee24d227ee6f222e49fd076c">etl::is_nothrow_assignable_v</a>&lt; T &amp;, U &gt;) -&gt; T</td></tr>
<tr class="memdesc:abab9c512cd288c92340c8a957b3742fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the value of obj with new_value and returns the old value of obj.  <br /></td></tr>
<tr class="separator:abab9c512cd288c92340c8a957b3742fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed541bafacdd55b5d4bd723e6b9bb91f" id="r_aed541bafacdd55b5d4bd723e6b9bb91f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aed541bafacdd55b5d4bd723e6b9bb91f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed541bafacdd55b5d4bd723e6b9bb91f">forward</a> (<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a>&lt; T &gt; &amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="memdesc:aed541bafacdd55b5d4bd723e6b9bb91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards lvalues as either lvalues or as rvalues, depending on T. When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function.  <br /></td></tr>
<tr class="separator:aed541bafacdd55b5d4bd723e6b9bb91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7788668573df04d891d55b5433f6e49b" id="r_a7788668573df04d891d55b5433f6e49b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7788668573df04d891d55b5433f6e49b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7788668573df04d891d55b5433f6e49b">forward</a> (<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a>&lt; T &gt; &amp;&amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="separator:a7788668573df04d891d55b5433f6e49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb59d3fc5e1767148b6803b4b3a1ba4" id="r_a9eb59d3fc5e1767148b6803b4b3a1ba4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a9eb59d3fc5e1767148b6803b4b3a1ba4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9eb59d3fc5e1767148b6803b4b3a1ba4">forward_like</a> (U &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:a9eb59d3fc5e1767148b6803b4b3a1ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce870bde6a96dc0634f235573439dd1" id="r_acce870bde6a96dc0634f235573439dd1"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:acce870bde6a96dc0634f235573439dd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acce870bde6a96dc0634f235573439dd1">ignore_unused</a> (<a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;...) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:acce870bde6a96dc0634f235573439dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly ignore arguments or variables.  <br /></td></tr>
<tr class="separator:acce870bde6a96dc0634f235573439dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0f06f15831068e00de541ddb64433f" id="r_a2b0f06f15831068e00de541ddb64433f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires etl::detail::integer_and_not_char&lt;T&gt;</td></tr>
<tr class="memitem:a2b0f06f15831068e00de541ddb64433f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b0f06f15831068e00de541ddb64433f">in_range</a> (T <a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a2b0f06f15831068e00de541ddb64433f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss.  <br /></td></tr>
<tr class="separator:a2b0f06f15831068e00de541ddb64433f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c81fb3d2e0ae2e41e87e2381bd9776a" id="r_a4c81fb3d2e0ae2e41e87e2381bd9776a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4c81fb3d2e0ae2e41e87e2381bd9776a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c81fb3d2e0ae2e41e87e2381bd9776a">move</a> (T &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>) noexcept -&gt; <a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a>&lt; T &gt; &amp;&amp;</td></tr>
<tr class="memdesc:a4c81fb3d2e0ae2e41e87e2381bd9776a"><td class="mdescLeft">&#160;</td><td class="mdescRight">move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.  <br /></td></tr>
<tr class="separator:a4c81fb3d2e0ae2e41e87e2381bd9776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd2f9cfbab270ff115707284d5c73a7" id="r_afdd2f9cfbab270ff115707284d5c73a7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afdd2f9cfbab270ff115707284d5c73a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdd2f9cfbab270ff115707284d5c73a7">move_if_noexcept</a> (T &amp;<a class="el" href="structetl_1_1static__vector.html">x</a>) noexcept -&gt; <a class="el" href="#ab39305667768a11caaca93abf03c21ce">etl::conditional_t</a>&lt;!<a class="el" href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#a045ef39158833b2ba6592fa8a1d0ebc1">etl::is_copy_constructible_v</a>&lt; T &gt;, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;, T &amp;&amp; &gt;</td></tr>
<tr class="memdesc:afdd2f9cfbab270ff115707284d5c73a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally convert a value to an rvalue.  <br /></td></tr>
<tr class="separator:afdd2f9cfbab270ff115707284d5c73a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eed856cd0d950a984b3f7b4bed78b4" id="r_a53eed856cd0d950a984b3f7b4bed78b4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a53eed856cd0d950a984b3f7b4bed78b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53eed856cd0d950a984b3f7b4bed78b4">pair</a> (<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>) -&gt; pair&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt;</td></tr>
<tr class="separator:a53eed856cd0d950a984b3f7b4bed78b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa50aa68713ac9f56128ad9c0406b737" id="r_aaa50aa68713ac9f56128ad9c0406b737"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:aaa50aa68713ac9f56128ad9c0406b737"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa50aa68713ac9f56128ad9c0406b737">swap</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:aaa50aa68713ac9f56128ad9c0406b737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of x and y. Equivalent to x.swap(y).  <br /></td></tr>
<tr class="separator:aaa50aa68713ac9f56128ad9c0406b737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d50e8f816232b73e33c92b7f022699" id="r_ad6d50e8f816232b73e33c92b7f022699"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:ad6d50e8f816232b73e33c92b7f022699"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6d50e8f816232b73e33c92b7f022699">make_pair</a> (<a class="el" href="structetl_1_1static__vector.html">T1</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">t</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">u</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a> &gt;, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt;</td></tr>
<tr class="memdesc:ad6d50e8f816232b73e33c92b7f022699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments.  <br /></td></tr>
<tr class="separator:ad6d50e8f816232b73e33c92b7f022699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca122149a06ebd4ab08b8ed486df0198" id="r_aca122149a06ebd4ab08b8ed486df0198"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:aca122149a06ebd4ab08b8ed486df0198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca122149a06ebd4ab08b8ed486df0198">operator==</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aca122149a06ebd4ab08b8ed486df0198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second.  <br /></td></tr>
<tr class="separator:aca122149a06ebd4ab08b8ed486df0198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eb6d42bd94db249c6bb61f3b07ca8b" id="r_a30eb6d42bd94db249c6bb61f3b07ca8b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a30eb6d42bd94db249c6bb61f3b07ca8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a30eb6d42bd94db249c6bb61f3b07ca8b">operator&lt;</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a30eb6d42bd94db249c6bb61f3b07ca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a30eb6d42bd94db249c6bb61f3b07ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880fb1e1ee9736f911f931c4f10e4a1c" id="r_a880fb1e1ee9736f911f931c4f10e4a1c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a880fb1e1ee9736f911f931c4f10e4a1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a880fb1e1ee9736f911f931c4f10e4a1c">operator&lt;=</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a880fb1e1ee9736f911f931c4f10e4a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a880fb1e1ee9736f911f931c4f10e4a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc0b3aadb4525efaf31a9e8d62acc46" id="r_a9fc0b3aadb4525efaf31a9e8d62acc46"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a9fc0b3aadb4525efaf31a9e8d62acc46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9fc0b3aadb4525efaf31a9e8d62acc46">operator&gt;</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a9fc0b3aadb4525efaf31a9e8d62acc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a9fc0b3aadb4525efaf31a9e8d62acc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110f9b6f4b39272ee65e708330f7905a" id="r_a110f9b6f4b39272ee65e708330f7905a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a110f9b6f4b39272ee65e708330f7905a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a110f9b6f4b39272ee65e708330f7905a">operator&gt;=</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a110f9b6f4b39272ee65e708330f7905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a110f9b6f4b39272ee65e708330f7905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91adb4adaf07aefbd39d4e39c7e58bd0" id="r_a91adb4adaf07aefbd39d4e39c7e58bd0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a91adb4adaf07aefbd39d4e39c7e58bd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91adb4adaf07aefbd39d4e39c7e58bd0">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;p) noexcept -&gt; <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt; &amp;</td></tr>
<tr class="memdesc:a91adb4adaf07aefbd39d4e39c7e58bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:a91adb4adaf07aefbd39d4e39c7e58bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76a94bc8cf735d9d2d1820a3c472cdf" id="r_ad76a94bc8cf735d9d2d1820a3c472cdf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:ad76a94bc8cf735d9d2d1820a3c472cdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad76a94bc8cf735d9d2d1820a3c472cdf">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;p) noexcept -&gt; <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:ad76a94bc8cf735d9d2d1820a3c472cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:ad76a94bc8cf735d9d2d1820a3c472cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8980f3eee6ed4cb54eacd20d86193d" id="r_acb8980f3eee6ed4cb54eacd20d86193d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:acb8980f3eee6ed4cb54eacd20d86193d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb8980f3eee6ed4cb54eacd20d86193d">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;&amp;p) noexcept -&gt; <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt; &amp;&amp;</td></tr>
<tr class="memdesc:acb8980f3eee6ed4cb54eacd20d86193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:acb8980f3eee6ed4cb54eacd20d86193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731452106e6fad9a1630d20ab204689c" id="r_a731452106e6fad9a1630d20ab204689c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </td></tr>
<tr class="memitem:a731452106e6fad9a1630d20ab204689c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a731452106e6fad9a1630d20ab204689c">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;p) noexcept -&gt; <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a731452106e6fad9a1630d20ab204689c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:a731452106e6fad9a1630d20ab204689c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da3c5e232d1dfb7eef6e49bc5de33aa" id="r_a4da3c5e232d1dfb7eef6e49bc5de33aa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a4da3c5e232d1dfb7eef6e49bc5de33aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4da3c5e232d1dfb7eef6e49bc5de33aa">swap</a> (T &amp;a, T &amp;b) noexcept(<a class="el" href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#ab5d18b577003e8d090a82e4c6d497cdd">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a4da3c5e232d1dfb7eef6e49bc5de33aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:a4da3c5e232d1dfb7eef6e49bc5de33aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32960cfb5370eebeb6deb98ca9d3ee26" id="r_a32960cfb5370eebeb6deb98ca9d3ee26"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="#a46cb1671f31576cce07cf1bac1e99f7c">etl::is_swappable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a32960cfb5370eebeb6deb98ca9d3ee26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32960cfb5370eebeb6deb98ca9d3ee26">swap</a> (T(&amp;a)[<a class="el" href="structetl_1_1static__vector.html">N</a>], T(&amp;b)[<a class="el" href="structetl_1_1static__vector.html">N</a>]) noexcept(<a class="el" href="structetl_1_1is__nothrow__swappable.html">etl::is_nothrow_swappable</a>&lt; T &gt;::value) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:a32960cfb5370eebeb6deb98ca9d3ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81467d3810ee7b1ebc9c41ebd6941a1" id="r_ad81467d3810ee7b1ebc9c41ebd6941a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Enum</a> &gt; </td></tr>
<tr class="memitem:ad81467d3810ee7b1ebc9c41ebd6941a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad81467d3810ee7b1ebc9c41ebd6941a1">to_underlying</a> (<a class="el" href="structetl_1_1static__vector.html">Enum</a> e) noexcept -&gt; <a class="el" href="#ac73e7dfe08364dfb94ca2fafa560a559">underlying_type_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Enum</a> &gt;</td></tr>
<tr class="memdesc:ad81467d3810ee7b1ebc9c41ebd6941a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an enumeration to its underlying type.  <br /></td></tr>
<tr class="separator:ad81467d3810ee7b1ebc9c41ebd6941a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaf10daac93eed1add86c6ca8317c29" id="r_addaf10daac93eed1add86c6ca8317c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addaf10daac93eed1add86c6ca8317c29">unreachable</a> () -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:addaf10daac93eed1add86c6ca8317c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3b824f87ab3ce98ad82b777b551b2d" id="r_abd3b824f87ab3ce98ad82b777b551b2d"><td class="memTemplParams" colspan="2">template&lt;typename... Functor&gt; </td></tr>
<tr class="memitem:abd3b824f87ab3ce98ad82b777b551b2d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd3b824f87ab3ce98ad82b777b551b2d">overload</a> (Functor...) -&gt; overload&lt; Functor... &gt;</td></tr>
<tr class="separator:abd3b824f87ab3ce98ad82b777b551b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de48e614d4f8453bb551220e84d9e2d" id="r_a5de48e614d4f8453bb551220e84d9e2d"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; <br />
requires (detail::enable_variant_swap&lt;Ts...&gt;)</td></tr>
<tr class="memitem:a5de48e614d4f8453bb551220e84d9e2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5de48e614d4f8453bb551220e84d9e2d">swap</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1static__vector.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:a5de48e614d4f8453bb551220e84d9e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the swap algorithm for variant. Effectively calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:a5de48e614d4f8453bb551220e84d9e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863041a1cb8498c8853e859e29367241" id="r_a863041a1cb8498c8853e859e29367241"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a863041a1cb8498c8853e859e29367241"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a863041a1cb8498c8853e859e29367241">operator==</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a863041a1cb8498c8853e859e29367241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for variants:  <br /></td></tr>
<tr class="separator:a863041a1cb8498c8853e859e29367241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5ac4ee748bb8b9017c1a38e275a288" id="r_add5ac4ee748bb8b9017c1a38e275a288"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:add5ac4ee748bb8b9017c1a38e275a288"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add5ac4ee748bb8b9017c1a38e275a288">operator!=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:add5ac4ee748bb8b9017c1a38e275a288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for variants:  <br /></td></tr>
<tr class="separator:add5ac4ee748bb8b9017c1a38e275a288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254c3da6eb0085b05cecc9c4c7586758" id="r_a254c3da6eb0085b05cecc9c4c7586758"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a254c3da6eb0085b05cecc9c4c7586758"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a254c3da6eb0085b05cecc9c4c7586758">operator&lt;</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a254c3da6eb0085b05cecc9c4c7586758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator for variants:  <br /></td></tr>
<tr class="separator:a254c3da6eb0085b05cecc9c4c7586758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1ddfed1011b3663a305e72aca1fe0" id="r_a97a1ddfed1011b3663a305e72aca1fe0"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a97a1ddfed1011b3663a305e72aca1fe0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97a1ddfed1011b3663a305e72aca1fe0">operator&lt;=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a97a1ddfed1011b3663a305e72aca1fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-equal operator for variants:  <br /></td></tr>
<tr class="separator:a97a1ddfed1011b3663a305e72aca1fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe841983c5c96ec128c540e07d8ae590" id="r_afe841983c5c96ec128c540e07d8ae590"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:afe841983c5c96ec128c540e07d8ae590"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe841983c5c96ec128c540e07d8ae590">operator&gt;</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:afe841983c5c96ec128c540e07d8ae590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator for variants:  <br /></td></tr>
<tr class="separator:afe841983c5c96ec128c540e07d8ae590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46d330593ce07ddecb63c78618e1f73" id="r_ae46d330593ce07ddecb63c78618e1f73"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ae46d330593ce07ddecb63c78618e1f73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae46d330593ce07ddecb63c78618e1f73">operator&gt;=</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ae46d330593ce07ddecb63c78618e1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-equal operator for variants:  <br /></td></tr>
<tr class="separator:ae46d330593ce07ddecb63c78618e1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81f6c62201f50e40031c362915e191" id="r_aaf81f6c62201f50e40031c362915e191"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Ts&gt; </td></tr>
<tr class="memitem:aaf81f6c62201f50e40031c362915e191"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf81f6c62201f50e40031c362915e191">holds_alternative</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:aaf81f6c62201f50e40031c362915e191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Ts...  <br /></td></tr>
<tr class="separator:aaf81f6c62201f50e40031c362915e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f35bc3fbdafc55d32dfd35bf1f7d446" id="r_a7f35bc3fbdafc55d32dfd35bf1f7d446"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a7f35bc3fbdafc55d32dfd35bf1f7d446"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f35bc3fbdafc55d32dfd35bf1f7d446">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td></tr>
<tr class="memdesc:a7f35bc3fbdafc55d32dfd35bf1f7d446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <br /></td></tr>
<tr class="separator:a7f35bc3fbdafc55d32dfd35bf1f7d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c84339b3f6aa69a3df586dc2a5b1f69" id="r_a3c84339b3f6aa69a3df586dc2a5b1f69"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a3c84339b3f6aa69a3df586dc2a5b1f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c84339b3f6aa69a3df586dc2a5b1f69">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a3c84339b3f6aa69a3df586dc2a5b1f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <br /></td></tr>
<tr class="separator:a3c84339b3f6aa69a3df586dc2a5b1f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54d98119a0f0e56078324af917a37e7" id="r_ab54d98119a0f0e56078324af917a37e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:ab54d98119a0f0e56078324af917a37e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab54d98119a0f0e56078324af917a37e7">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td></tr>
<tr class="memdesc:ab54d98119a0f0e56078324af917a37e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <br /></td></tr>
<tr class="separator:ab54d98119a0f0e56078324af917a37e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7502c4e6253168a35b9f80528d9264" id="r_abf7502c4e6253168a35b9f80528d9264"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:abf7502c4e6253168a35b9f80528d9264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf7502c4e6253168a35b9f80528d9264">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:abf7502c4e6253168a35b9f80528d9264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the object stored in the variant.  <br /></td></tr>
<tr class="separator:abf7502c4e6253168a35b9f80528d9264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9910dcb967e65b0a22ccd44afa94d37" id="r_aa9910dcb967e65b0a22ccd44afa94d37"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:aa9910dcb967e65b0a22ccd44afa94d37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9910dcb967e65b0a22ccd44afa94d37">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; *<a class="el" href="structetl_1_1static__vector.html">pv</a>) noexcept -&gt; add_pointer_t&lt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; &gt;</td></tr>
<tr class="memdesc:aa9910dcb967e65b0a22ccd44afa94d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant.  <br /></td></tr>
<tr class="separator:aa9910dcb967e65b0a22ccd44afa94d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc1de0794c709d6e34006e8d77e8777" id="r_a3bc1de0794c709d6e34006e8d77e8777"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a3bc1de0794c709d6e34006e8d77e8777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bc1de0794c709d6e34006e8d77e8777">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">pv</a>) noexcept -&gt; add_pointer_t&lt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td></tr>
<tr class="memdesc:a3bc1de0794c709d6e34006e8d77e8777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant.  <br /></td></tr>
<tr class="separator:a3bc1de0794c709d6e34006e8d77e8777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ae7d5a6472050c47066e83c7c8ce15" id="r_a11ae7d5a6472050c47066e83c7c8ce15"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a11ae7d5a6472050c47066e83c7c8ce15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11ae7d5a6472050c47066e83c7c8ce15">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; &amp;</td></tr>
<tr class="memdesc:a11ae7d5a6472050c47066e83c7c8ce15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <br /></td></tr>
<tr class="separator:a11ae7d5a6472050c47066e83c7c8ce15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ab22ab939eed35b82e1f4b4125dcb6" id="r_a72ab22ab939eed35b82e1f4b4125dcb6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a72ab22ab939eed35b82e1f4b4125dcb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72ab22ab939eed35b82e1f4b4125dcb6">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; &amp;&amp;</td></tr>
<tr class="memdesc:a72ab22ab939eed35b82e1f4b4125dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <br /></td></tr>
<tr class="separator:a72ab22ab939eed35b82e1f4b4125dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a7b28c60246ca5eae2e499467e4a1" id="r_a9a8a7b28c60246ca5eae2e499467e4a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a9a8a7b28c60246ca5eae2e499467e4a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a8a7b28c60246ca5eae2e499467e4a1">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:a9a8a7b28c60246ca5eae2e499467e4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <br /></td></tr>
<tr class="separator:a9a8a7b28c60246ca5eae2e499467e4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dd3494ef27567671c9d7046e78e2bd" id="r_a65dd3494ef27567671c9d7046e78e2bd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a65dd3494ef27567671c9d7046e78e2bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65dd3494ef27567671c9d7046e78e2bd">get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a65dd3494ef27567671c9d7046e78e2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based value accessor.  <br /></td></tr>
<tr class="separator:a65dd3494ef27567671c9d7046e78e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4d75c3208d681357d77774b729444d" id="r_a6f4d75c3208d681357d77774b729444d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a6f4d75c3208d681357d77774b729444d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f4d75c3208d681357d77774b729444d">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td></tr>
<tr class="separator:a6f4d75c3208d681357d77774b729444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa90ac4a6cf3911ab23789c9af4d089" id="r_aeaa90ac4a6cf3911ab23789c9af4d089"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:aeaa90ac4a6cf3911ab23789c9af4d089"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeaa90ac4a6cf3911ab23789c9af4d089">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:aeaa90ac4a6cf3911ab23789c9af4d089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c39898b60620723d80247080de0439d" id="r_a3c39898b60620723d80247080de0439d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a3c39898b60620723d80247080de0439d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c39898b60620723d80247080de0439d">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:a3c39898b60620723d80247080de0439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2c2a52094776da58ed54719f0bcbd" id="r_a9ec2c2a52094776da58ed54719f0bcbd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a9ec2c2a52094776da58ed54719f0bcbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ec2c2a52094776da58ed54719f0bcbd">unchecked_get</a> (<a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1static__vector.html">v</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td></tr>
<tr class="separator:a9ec2c2a52094776da58ed54719f0bcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffc9f0ae12737a221731fd43249e944" id="r_aeffc9f0ae12737a221731fd43249e944"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </td></tr>
<tr class="memitem:aeffc9f0ae12737a221731fd43249e944"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeffc9f0ae12737a221731fd43249e944">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; *<a class="el" href="structetl_1_1static__vector.html">pv</a>) noexcept -&gt; add_pointer_t&lt; T &gt;</td></tr>
<tr class="separator:aeffc9f0ae12737a221731fd43249e944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dbeed267147923b02448b493be930d" id="r_a32dbeed267147923b02448b493be930d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </td></tr>
<tr class="memitem:a32dbeed267147923b02448b493be930d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32dbeed267147923b02448b493be930d">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> *<a class="el" href="structetl_1_1static__vector.html">pv</a>) noexcept -&gt; add_pointer_t&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td></tr>
<tr class="separator:a32dbeed267147923b02448b493be930d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43fcb4942d4cec1824f6e38edce9981" id="r_aa43fcb4942d4cec1824f6e38edce9981"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Vs&gt; </td></tr>
<tr class="memitem:aa43fcb4942d4cec1824f6e38edce9981"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa43fcb4942d4cec1824f6e38edce9981">visit</a> (<a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1static__vector.html">Vs</a> &amp;&amp;... <a class="el" href="structetl_1_1static__vector.html">vs</a>)</td></tr>
<tr class="memdesc:aa43fcb4942d4cec1824f6e38edce9981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the visitor vis (Callable that can be called with any combination of types from variants) to the variants vars.  <br /></td></tr>
<tr class="separator:aa43fcb4942d4cec1824f6e38edce9981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c5f129858d55474d1d7ae92c374456" id="r_ac1c5f129858d55474d1d7ae92c374456"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ac1c5f129858d55474d1d7ae92c374456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1c5f129858d55474d1d7ae92c374456">swap</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ac1c5f129858d55474d1d7ae92c374456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">static_vector</a>. Swaps the contents of lhs and rhs.  <br /></td></tr>
<tr class="separator:ac1c5f129858d55474d1d7ae92c374456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3aa3446aca179d812252faf83360c6" id="r_a9d3aa3446aca179d812252faf83360c6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a9d3aa3446aca179d812252faf83360c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d3aa3446aca179d812252faf83360c6">operator==</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a9d3aa3446aca179d812252faf83360c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors.  <br /></td></tr>
<tr class="separator:a9d3aa3446aca179d812252faf83360c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2867e9d12d25137a50a1b3aee3c5a7" id="r_a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d2867e9d12d25137a50a1b3aee3c5a7">operator!=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dfb93223a9c8e4413fe9368cd36046" id="r_ab0dfb93223a9c8e4413fe9368cd36046"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ab0dfb93223a9c8e4413fe9368cd36046"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0dfb93223a9c8e4413fe9368cd36046">operator&lt;</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ab0dfb93223a9c8e4413fe9368cd36046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors.  <br /></td></tr>
<tr class="separator:ab0dfb93223a9c8e4413fe9368cd36046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715395c53fa693969e269ef5af1972e6" id="r_a715395c53fa693969e269ef5af1972e6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a715395c53fa693969e269ef5af1972e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a715395c53fa693969e269ef5af1972e6">operator&lt;=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a715395c53fa693969e269ef5af1972e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fd2ea0cf33ad9339a54469a92f5121" id="r_ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4fd2ea0cf33ad9339a54469a92f5121">operator&gt;</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf47ed021fd1e8bfbc389525967e551" id="r_aebf47ed021fd1e8bfbc389525967e551"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:aebf47ed021fd1e8bfbc389525967e551"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aebf47ed021fd1e8bfbc389525967e551">operator&gt;=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:aebf47ed021fd1e8bfbc389525967e551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6028d08459dc299edcae40876481fca" id="r_ab6028d08459dc299edcae40876481fca"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ab6028d08459dc299edcae40876481fca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6028d08459dc299edcae40876481fca">erase_if</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;c, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;::size_type</td></tr>
<tr class="memdesc:ab6028d08459dc299edcae40876481fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container.  <br /></td></tr>
<tr class="separator:ab6028d08459dc299edcae40876481fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eea328e45af7e2f0cba2ecf9bfae03e" id="r_a7eea328e45af7e2f0cba2ecf9bfae03e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a7eea328e45af7e2f0cba2ecf9bfae03e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7eea328e45af7e2f0cba2ecf9bfae03e">erase</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;c, U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt;::size_type</td></tr>
<tr class="separator:a7eea328e45af7e2f0cba2ecf9bfae03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b8bc94405a580d276749fde24834f7" id="r_a47b8bc94405a580d276749fde24834f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">consteval</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b8bc94405a580d276749fde24834f7">is_hosted</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a47b8bc94405a580d276749fde24834f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0643ba313eeb2da0a37a713fa74cb5f" id="r_ae0643ba313eeb2da0a37a713fa74cb5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">consteval</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0643ba313eeb2da0a37a713fa74cb5f">is_freestanding</a> () noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:ae0643ba313eeb2da0a37a713fa74cb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b353c6f122b14a8e9b78c453d8fa381" id="r_a7b353c6f122b14a8e9b78c453d8fa381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b353c6f122b14a8e9b78c453d8fa381">operator==</a> (<a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:a7b353c6f122b14a8e9b78c453d8fa381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares language_standards.  <br /></td></tr>
<tr class="separator:a7b353c6f122b14a8e9b78c453d8fa381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be806bd6b96b20e9313a7e398cc5783" id="r_a0be806bd6b96b20e9313a7e398cc5783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0be806bd6b96b20e9313a7e398cc5783">operator!=</a> (<a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a0be806bd6b96b20e9313a7e398cc5783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2e2b8ee1daac1fdf220e6aad21fbea" id="r_afb2e2b8ee1daac1fdf220e6aad21fbea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb2e2b8ee1daac1fdf220e6aad21fbea">operator&lt;</a> (<a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:afb2e2b8ee1daac1fdf220e6aad21fbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff7b111685f53a1a28d184323c9a7c3" id="r_a6ff7b111685f53a1a28d184323c9a7c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ff7b111685f53a1a28d184323c9a7c3">operator&lt;=</a> (<a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a6ff7b111685f53a1a28d184323c9a7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5748614e8daf5563998666a4584ee575" id="r_a5748614e8daf5563998666a4584ee575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5748614e8daf5563998666a4584ee575">operator&gt;</a> (<a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a5748614e8daf5563998666a4584ee575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00deb6a88953ac9fe457f6f79b347152" id="r_a00deb6a88953ac9fe457f6f79b347152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00deb6a88953ac9fe457f6f79b347152">operator&gt;=</a> (<a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">lhs</a>, <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a> <a class="el" href="structetl_1_1static__vector.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:a00deb6a88953ac9fe457f6f79b347152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga09c5b412c05c58fb89e569a2d72ed17e" id="r_ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga09c5b412c05c58fb89e569a2d72ed17e">adjacent_find</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga09c5b412c05c58fb89e569a2d72ed17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe91c66e3042bde20710111a8d622e4" id="r_ga4fe91c66e3042bde20710111a8d622e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga4fe91c66e3042bde20710111a8d622e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4fe91c66e3042bde20710111a8d622e4">adjacent_find</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td></tr>
<tr class="separator:ga4fe91c66e3042bde20710111a8d622e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gac76b028bf28233ada520a5bc0d52f6b9" id="r_gac76b028bf28233ada520a5bc0d52f6b9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gac76b028bf28233ada520a5bc0d52f6b9">all_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:gac76b028bf28233ada520a5bc0d52f6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gac76b028bf28233ada520a5bc0d52f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga1d4122ca9a611ac90a64ff447c212a42" id="r_ga1d4122ca9a611ac90a64ff447c212a42"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1d4122ca9a611ac90a64ff447c212a42">any_of</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga1d4122ca9a611ac90a64ff447c212a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga1d4122ca9a611ac90a64ff447c212a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga8844708a6931fb2b21419d7a605328dd" id="r_ga8844708a6931fb2b21419d7a605328dd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga8844708a6931fb2b21419d7a605328dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga8844708a6931fb2b21419d7a605328dd">binary_search</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="memdesc:ga8844708a6931fb2b21419d7a605328dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range <code>[first, last)</code>. For binary_search to succeed, the range <code>[first, last)</code> must be at least partially ordered with respect to <code>value</code>.  <br /></td></tr>
<tr class="separator:ga8844708a6931fb2b21419d7a605328dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb446f356892ac1d540180018a20faba" id="r_gadb446f356892ac1d540180018a20faba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gadb446f356892ac1d540180018a20faba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gadb446f356892ac1d540180018a20faba">binary_search</a> (<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> first, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td></tr>
<tr class="separator:gadb446f356892ac1d540180018a20faba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga46270726b5073fd6eeefb5ccd9ed1f72" id="r_ga46270726b5073fd6eeefb5ccd9ed1f72"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga46270726b5073fd6eeefb5ccd9ed1f72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga46270726b5073fd6eeefb5ccd9ed1f72">bubble_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="memdesc:ga46270726b5073fd6eeefb5ccd9ed1f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga46270726b5073fd6eeefb5ccd9ed1f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc149eb7abea4405c02e767e7860dae" id="r_ga1cc149eb7abea4405c02e767e7860dae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ga1cc149eb7abea4405c02e767e7860dae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1cc149eb7abea4405c02e767e7860dae">bubble_sort</a> (<a class="el" href="structetl_1_1static__vector.html">RandomIt</a> first, <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a></td></tr>
<tr class="separator:ga1cc149eb7abea4405c02e767e7860dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gabfa416a307b0bb33666d34845c42ba2b" id="r_gabfa416a307b0bb33666d34845c42ba2b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gabfa416a307b0bb33666d34845c42ba2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gabfa416a307b0bb33666d34845c42ba2b">clamp</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lo</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">hi</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> <a class="el" href="structetl_1_1static__vector.html">comp</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="memdesc:gabfa416a307b0bb33666d34845c42ba2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <br /></td></tr>
<tr class="separator:gabfa416a307b0bb33666d34845c42ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90379160c94dc0396b5f32204c790bf" id="r_gaf90379160c94dc0396b5f32204c790bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:gaf90379160c94dc0396b5f32204c790bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaf90379160c94dc0396b5f32204c790bf">clamp</a> (<a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">v</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">lo</a>, <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;<a class="el" href="structetl_1_1static__vector.html">hi</a>) noexcept -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td></tr>
<tr class="separator:gaf90379160c94dc0396b5f32204c790bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad3271ee1abafc543f4bf69cc20b01ded" id="r_gad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gad3271ee1abafc543f4bf69cc20b01ded">copy</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">destination</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:gad3271ee1abafc543f4bf69cc20b01ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:gad3271ee1abafc543f4bf69cc20b01ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaf5caeb0f954aff0eb31c350558f7e827" id="r_gaf5caeb0f954aff0eb31c350558f7e827"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> &gt; </td></tr>
<tr class="memitem:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaf5caeb0f954aff0eb31c350558f7e827">copy_backward</a> (<a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> first, <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> last, <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> <a class="el" href="structetl_1_1static__vector.html">dLast</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a></td></tr>
<tr class="memdesc:gaf5caeb0f954aff0eb31c350558f7e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:gaf5caeb0f954aff0eb31c350558f7e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga31799054ecdf344760efe76af7987776" id="r_ga31799054ecdf344760efe76af7987776"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Pred</a> &gt; </td></tr>
<tr class="memitem:ga31799054ecdf344760efe76af7987776"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga31799054ecdf344760efe76af7987776">copy_if</a> (<a class="el" href="structetl_1_1static__vector.html">InIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InIt</a> last, <a class="el" href="structetl_1_1static__vector.html">OutIt</a> <a class="el" href="structetl_1_1static__vector.html">dFirst</a>, <a class="el" href="structetl_1_1static__vector.html">Pred</a> <a class="el" href="structetl_1_1static__vector.html">pred</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutIt</a></td></tr>
<tr class="memdesc:ga31799054ecdf344760efe76af7987776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:ga31799054ecdf344760efe76af7987776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaa65063d9f87cd088156f3d49bb32f2e5" id="r_gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaa65063d9f87cd088156f3d49bb32f2e5">copy_n</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">Size</a> <a class="el" href="#a3f9162720047d01bb438874bf56df5d2">count</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> <a class="el" href="structetl_1_1static__vector.html">result</a>) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td></tr>
<tr class="memdesc:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <br /></td></tr>
<tr class="separator:gaa65063d9f87cd088156f3d49bb32f2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga7aff5cc5281436a205079dc71ee4c317" id="r_ga7aff5cc5281436a205079dc71ee4c317"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga7aff5cc5281436a205079dc71ee4c317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7aff5cc5281436a205079dc71ee4c317">count_if</a> (<a class="el" href="structetl_1_1static__vector.html">InputIt</a> first, <a class="el" href="structetl_1_1static__vector.html">InputIt</a> last, <a class="el" href="structetl_1_1static__vector.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type</td></tr>
<tr class="memdesc:ga7aff5cc5281436a205079dc71ee4c317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:ga7aff5cc5281436a205079dc71ee4c317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aedb63d88f3219c350ab03af8bd0adb5a" id="r_aedb63d88f3219c350ab03af8bd0adb5a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aedb63d88f3219c350ab03af8bd0adb5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aedb63d88f3219c350ab03af8bd0adb5a">is_bitmask_type_v</a> = <a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aedb63d88f3219c350ab03af8bd0adb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cc35f4fca27a07908f67b7ef595cd3" id="r_ab8cc35f4fca27a07908f67b7ef595cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8cc35f4fca27a07908f67b7ef595cd3">binary</a> = <a class="el" href="structetl_1_1binary__t.html">binary_t</a>{}</td></tr>
<tr class="separator:ab8cc35f4fca27a07908f67b7ef595cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d957fa8529e9617c445e42519518e5e" id="r_a1d957fa8529e9617c445e42519518e5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="attributes_8hpp.html#a6cf990edeb7f9f6f1b5928471cef5e56">TETL_MAY_ALIAS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">byte</a></td></tr>
<tr class="memdesc:a1d957fa8529e9617c445e42519518e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a> is a distinct type that implements the concept of byte as specified in the C++ language definition.  <br /></td></tr>
<tr class="separator:a1d957fa8529e9617c445e42519518e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2932a67109d86a3d3414866785f19613" id="r_a2932a67109d86a3d3414866785f19613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2932a67109d86a3d3414866785f19613">unexpect</a> = <a class="el" href="structetl_1_1unexpect__t.html">unexpect_t</a>{}</td></tr>
<tr class="separator:a2932a67109d86a3d3414866785f19613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3206db2ddd4b49017ef0d257ca69a515" id="r_a3206db2ddd4b49017ef0d257ca69a515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3206db2ddd4b49017ef0d257ca69a515">sorted_unique</a> = <a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a>{}</td></tr>
<tr class="separator:a3206db2ddd4b49017ef0d257ca69a515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ecf4e1b001cdba463b17849f4b55e4" id="r_ad5ecf4e1b001cdba463b17849f4b55e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad5ecf4e1b001cdba463b17849f4b55e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5ecf4e1b001cdba463b17849f4b55e4">is_placeholder_v</a> = <a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad5ecf4e1b001cdba463b17849f4b55e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751416861268d9328aa2a7263fd85e1b" id="r_a751416861268d9328aa2a7263fd85e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a751416861268d9328aa2a7263fd85e1b">full_extent</a> = <a class="el" href="structetl_1_1full__extent__t.html">full_extent_t</a>{}</td></tr>
<tr class="separator:a751416861268d9328aa2a7263fd85e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fea0e76b0257b8f9ffbca0b6de6aaa" id="r_a74fea0e76b0257b8f9ffbca0b6de6aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74fea0e76b0257b8f9ffbca0b6de6aaa">allocator_arg</a> {}</td></tr>
<tr class="memdesc:a74fea0e76b0257b8f9ffbca0b6de6aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator_arg is a constant of type <a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects.  <br /></td></tr>
<tr class="separator:a74fea0e76b0257b8f9ffbca0b6de6aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cf19d8af06969d839fa909ad6e184f" id="r_a16cf19d8af06969d839fa909ad6e184f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Alloc</a> &gt; </td></tr>
<tr class="memitem:a16cf19d8af06969d839fa909ad6e184f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16cf19d8af06969d839fa909ad6e184f">uses_allocator_v</a> = <a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Alloc</a>&gt;::value</td></tr>
<tr class="memdesc:a16cf19d8af06969d839fa909ad6e184f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false.  <br /></td></tr>
<tr class="separator:a16cf19d8af06969d839fa909ad6e184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9e177fde5dc55ea58bb3771c37051a" id="r_a3e9e177fde5dc55ea58bb3771c37051a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e9e177fde5dc55ea58bb3771c37051a">defer_lock</a> {}</td></tr>
<tr class="memdesc:a3e9e177fde5dc55ea58bb3771c37051a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1defer__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">defer_lock_t</a>.  <br /></td></tr>
<tr class="separator:a3e9e177fde5dc55ea58bb3771c37051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e79db17e8b72ae86d834fad514b2e" id="r_a086e79db17e8b72ae86d834fad514b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a086e79db17e8b72ae86d834fad514b2e">try_to_lock</a> {}</td></tr>
<tr class="memdesc:a086e79db17e8b72ae86d834fad514b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1try__to__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">try_to_lock_t</a>.  <br /></td></tr>
<tr class="separator:a086e79db17e8b72ae86d834fad514b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ee00292ff760cd8ecf8b41bb4de696" id="r_a03ee00292ff760cd8ecf8b41bb4de696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03ee00292ff760cd8ecf8b41bb4de696">adopt_lock</a> {}</td></tr>
<tr class="memdesc:a03ee00292ff760cd8ecf8b41bb4de696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1adopt__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">adopt_lock_t</a>.  <br /></td></tr>
<tr class="separator:a03ee00292ff760cd8ecf8b41bb4de696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7234bd8fd6d2e05055093f7a4bb53d7" id="r_ac7234bd8fd6d2e05055093f7a4bb53d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7234bd8fd6d2e05055093f7a4bb53d7">destroying_delete</a> = <a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a>{}</td></tr>
<tr class="memdesc:ac7234bd8fd6d2e05055093f7a4bb53d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to identify the destroying delete form of operator delete.  <br /></td></tr>
<tr class="separator:ac7234bd8fd6d2e05055093f7a4bb53d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ecb067c83bfce58af4f03457f15c8c" id="r_a20ecb067c83bfce58af4f03457f15c8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20ecb067c83bfce58af4f03457f15c8c">hardware_constructive_interference_size</a> = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td></tr>
<tr class="memdesc:a20ecb067c83bfce58af4f03457f15c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum offset between two objects to avoid false sharing. Guaranteed to be at least alignof(max_align_t).  <br /></td></tr>
<tr class="separator:a20ecb067c83bfce58af4f03457f15c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc217ae19afd481b0993696cbb1729bf" id="r_abc217ae19afd481b0993696cbb1729bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc217ae19afd481b0993696cbb1729bf">hardware_destructive_interference_size</a> = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td></tr>
<tr class="memdesc:abc217ae19afd481b0993696cbb1729bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least alignof(max_align_t).  <br /></td></tr>
<tr class="separator:abc217ae19afd481b0993696cbb1729bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1ead4c5ac981fe88bcd71d1aba1d61" id="r_a8a1ead4c5ac981fe88bcd71d1aba1d61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a1ead4c5ac981fe88bcd71d1aba1d61">nothrow</a> = <a class="el" href="structetl_1_1nothrow__t.html">etl::nothrow_t</a>{}</td></tr>
<tr class="memdesc:a8a1ead4c5ac981fe88bcd71d1aba1d61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a8a1ead4c5ac981fe88bcd71d1aba1d61" title="etl::nothrow is a constant of type etl::nothrow_t used to disambiguate the overloads of throwing and ...">etl::nothrow</a> is a constant of type <a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> used to disambiguate the overloads of throwing and non-throwing allocation functions.  <br /></td></tr>
<tr class="separator:a8a1ead4c5ac981fe88bcd71d1aba1d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d7a7601aedf2ce125a34a9d83b80a7" id="r_a93d7a7601aedf2ce125a34a9d83b80a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93d7a7601aedf2ce125a34a9d83b80a7">nullopt</a> = <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>{{}}</td></tr>
<tr class="memdesc:a93d7a7601aedf2ce125a34a9d83b80a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a93d7a7601aedf2ce125a34a9d83b80a7" title="etl::nullopt is a constant of type etl::nullopt_t that is used to indicate optional type with uniniti...">etl::nullopt</a> is a constant of type <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> that is used to indicate optional type with uninitialized state.  <br /></td></tr>
<tr class="separator:a93d7a7601aedf2ce125a34a9d83b80a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce653ddb9ec91f96bda7e292725dc0e" id="r_gabce653ddb9ec91f96bda7e292725dc0e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:gabce653ddb9ec91f96bda7e292725dc0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#gabce653ddb9ec91f96bda7e292725dc0e">ratio_greater_v</a> = <a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R1</a>, <a class="el" href="structetl_1_1static__vector.html">R2</a>&gt;::value</td></tr>
<tr class="separator:gabce653ddb9ec91f96bda7e292725dc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d7dd3cfa6494a27aaf40f11ec60b62" id="r_gaa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:gaa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#gaa8d7dd3cfa6494a27aaf40f11ec60b62">ratio_less_v</a> = <a class="el" href="structetl_1_1ratio__less.html">ratio_less</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R1</a>, <a class="el" href="structetl_1_1static__vector.html">R2</a>&gt;::value</td></tr>
<tr class="separator:gaa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31e01f9b1a6c95f6f7b793bdfb54755d" id="r_ga31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga31e01f9b1a6c95f6f7b793bdfb54755d">ratio_less_equal_v</a> = <a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R1</a>, <a class="el" href="structetl_1_1static__vector.html">R2</a>&gt;::value</td></tr>
<tr class="separator:ga31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf88cdc68bd2c8d7aa353d030c3c1e6c" id="r_gadf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R2</a> &gt; </td></tr>
<tr class="memitem:gadf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#gadf88cdc68bd2c8d7aa353d030c3c1e6c">ratio_not_equal_v</a> = <a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R1</a>, <a class="el" href="structetl_1_1static__vector.html">R2</a>&gt;::value</td></tr>
<tr class="separator:gadf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b2aa1aec32660fd5004c4847957f20" id="r_a92b2aa1aec32660fd5004c4847957f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92b2aa1aec32660fd5004c4847957f20">element_aligned</a> {}</td></tr>
<tr class="separator:a92b2aa1aec32660fd5004c4847957f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e9c30285b23943d7021abf09160e1" id="r_ae57e9c30285b23943d7021abf09160e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae57e9c30285b23943d7021abf09160e1">vector_aligned</a> {}</td></tr>
<tr class="separator:ae57e9c30285b23943d7021abf09160e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9312dc46a8d75ebd1d2ac9315c09bf57" id="r_a9312dc46a8d75ebd1d2ac9315c09bf57"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </td></tr>
<tr class="memitem:a9312dc46a8d75ebd1d2ac9315c09bf57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9312dc46a8d75ebd1d2ac9315c09bf57">overaligned</a> {}</td></tr>
<tr class="separator:a9312dc46a8d75ebd1d2ac9315c09bf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae174223df490e6263d4648a86326c902" id="r_ae174223df490e6263d4648a86326c902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae174223df490e6263d4648a86326c902">dynamic_extent</a> = <a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>&gt;<a class="el" href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">::max</a>()</td></tr>
<tr class="memdesc:ae174223df490e6263d4648a86326c902"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#ae174223df490e6263d4648a86326c902" title="etl::dynamic_extent is a constant of type etl::size_t that is used to differentiate etl::span of stat...">etl::dynamic_extent</a> is a constant of type <a class="el" href="#a49823583370a499813db70f494111109" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> that is used to differentiate <a class="el" href="structetl_1_1span.html" title="A non-owning view over a contiguous sequence of objects.">etl::span</a> of static and dynamic extent.  <br /></td></tr>
<tr class="separator:ae174223df490e6263d4648a86326c902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a0374b0fe975ab01bcc129d60f5d03" id="r_ad8a0374b0fe975ab01bcc129d60f5d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> etl::ignore&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a0374b0fe975ab01bcc129d60f5d03">ignore</a></td></tr>
<tr class="separator:ad8a0374b0fe975ab01bcc129d60f5d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e2b2e600cad8b86cd15cb73d7f0a4c" id="r_ac3e2b2e600cad8b86cd15cb73d7f0a4c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac3e2b2e600cad8b86cd15cb73d7f0a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3e2b2e600cad8b86cd15cb73d7f0a4c">is_tuple_like</a> = <a class="el" href="structetl_1_1static__vector.html">false</a></td></tr>
<tr class="separator:ac3e2b2e600cad8b86cd15cb73d7f0a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d0a5fb70cb82c336299812b04498f8" id="r_a93d0a5fb70cb82c336299812b04498f8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a93d0a5fb70cb82c336299812b04498f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93d0a5fb70cb82c336299812b04498f8">tuple_size_v</a> = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a93d0a5fb70cb82c336299812b04498f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e66c3ede7a3c2d993850cd16d1b4e3" id="r_a76e66c3ede7a3c2d993850cd16d1b4e3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a76e66c3ede7a3c2d993850cd16d1b4e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76e66c3ede7a3c2d993850cd16d1b4e3">alignment_of_v</a> = <a class="el" href="structetl_1_1alignment__of.html">etl::alignment_of</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a76e66c3ede7a3c2d993850cd16d1b4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815380448fc90ab014b40a47938372f9" id="r_a815380448fc90ab014b40a47938372f9"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a815380448fc90ab014b40a47938372f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a815380448fc90ab014b40a47938372f9">always_false</a> = <a class="el" href="structetl_1_1static__vector.html">false</a></td></tr>
<tr class="separator:a815380448fc90ab014b40a47938372f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d9f32a20bf813fd8ce025d0aebbff5" id="r_af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memTemplParams" colspan="2">template&lt;typename... B&gt; </td></tr>
<tr class="memitem:af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0d9f32a20bf813fd8ce025d0aebbff5">conjunction_v</a> = (B::value &amp;&amp; ...)</td></tr>
<tr class="separator:af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f460d9cd9dc39f08fc926828d8b442" id="r_a29f460d9cd9dc39f08fc926828d8b442"><td class="memTemplParams" colspan="2">template&lt;typename... B&gt; </td></tr>
<tr class="memitem:a29f460d9cd9dc39f08fc926828d8b442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29f460d9cd9dc39f08fc926828d8b442">disjunction_v</a> = (B::value || ...)</td></tr>
<tr class="separator:a29f460d9cd9dc39f08fc926828d8b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115f1cea7fc27ee979afae4871d03a03" id="r_a115f1cea7fc27ee979afae4871d03a03"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">unsigned</a> N = 0&gt; </td></tr>
<tr class="memitem:a115f1cea7fc27ee979afae4871d03a03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a115f1cea7fc27ee979afae4871d03a03">extent_v</a> = <a class="el" href="structetl_1_1static__vector.html">static_cast</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a>&gt;(<a class="el" href="structetl_1_1extent.html">extent</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">N</a>&gt;::value)</td></tr>
<tr class="separator:a115f1cea7fc27ee979afae4871d03a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a60e01980cd945b387ffc47f44eccf" id="r_a66a60e01980cd945b387ffc47f44eccf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a66a60e01980cd945b387ffc47f44eccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66a60e01980cd945b387ffc47f44eccf">has_unique_object_representations_v</a> = <a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a66a60e01980cd945b387ffc47f44eccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f3f4c2468d1d1f33a449bf167efbbc" id="r_a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46f3f4c2468d1d1f33a449bf167efbbc">has_virtual_destructor_v</a> = <a class="el" href="structetl_1_1static__vector.html">__has_virtual_destructor</a>(T)</td></tr>
<tr class="memdesc:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <br /></td></tr>
<tr class="separator:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27862efe6b9f1ba007a712b5e2a6e8a" id="r_af27862efe6b9f1ba007a712b5e2a6e8a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I&gt; </td></tr>
<tr class="memitem:af27862efe6b9f1ba007a712b5e2a6e8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af27862efe6b9f1ba007a712b5e2a6e8a">index_c</a> = <a class="el" href="#aa8298a20279ec5d2a5df508272115cc3">etl::index_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>&gt;{}</td></tr>
<tr class="separator:af27862efe6b9f1ba007a712b5e2a6e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad586ed3dee38cd4cc1b409e607230ffb" id="r_ad586ed3dee38cd4cc1b409e607230ffb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad586ed3dee38cd4cc1b409e607230ffb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad586ed3dee38cd4cc1b409e607230ffb">is_abstract_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_abstract</a>(T)</td></tr>
<tr class="separator:ad586ed3dee38cd4cc1b409e607230ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacace2162b09f525f4baff15548ecda" id="r_afacace2162b09f525f4baff15548ecda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afacace2162b09f525f4baff15548ecda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afacace2162b09f525f4baff15548ecda">is_aggregate_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_aggregate</a>(<a class="el" href="#a7d3ea939d0e932fceedbae01d7a3af90">remove_cv_t</a>&lt;T&gt;)</td></tr>
<tr class="separator:afacace2162b09f525f4baff15548ecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0de9ab0c91e46602a77993e77ec8a6d" id="r_ad0de9ab0c91e46602a77993e77ec8a6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </td></tr>
<tr class="memitem:ad0de9ab0c91e46602a77993e77ec8a6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0de9ab0c91e46602a77993e77ec8a6d">is_any_of_v</a> = <a class="el" href="#a29f460d9cd9dc39f08fc926828d8b442">disjunction_v</a>&lt;<a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">Types</a>&gt;...&gt;</td></tr>
<tr class="separator:ad0de9ab0c91e46602a77993e77ec8a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e" id="r_a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a105e2a5ac8fc634dcc71675e27e3f95e">is_arithmetic_v</a> = <a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">or</a> <a class="el" href="#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a>&lt;T&gt;</td></tr>
<tr class="separator:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8" id="r_afaa46050181985a6156a6c800c86a7d8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afaa46050181985a6156a6c800c86a7d8">is_array_v</a> = <a class="el" href="structetl_1_1is__array.html">etl::is_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afaa46050181985a6156a6c800c86a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae630f4cbcf30c3c7912d50547711e86d" id="r_ae630f4cbcf30c3c7912d50547711e86d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ae630f4cbcf30c3c7912d50547711e86d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae630f4cbcf30c3c7912d50547711e86d">is_assignable_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_assignable</a>(T, U)</td></tr>
<tr class="separator:ae630f4cbcf30c3c7912d50547711e86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00bab8d0b02bcb2974969b9d69639bb" id="r_af00bab8d0b02bcb2974969b9d69639bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Base</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Derived</a> &gt; </td></tr>
<tr class="memitem:af00bab8d0b02bcb2974969b9d69639bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af00bab8d0b02bcb2974969b9d69639bb">is_base_of_v</a> = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Base</a>, <a class="el" href="structetl_1_1static__vector.html">Derived</a>&gt;::value</td></tr>
<tr class="separator:af00bab8d0b02bcb2974969b9d69639bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d2eef20a4d7f2fcfb333c7e5c23444" id="r_ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6d2eef20a4d7f2fcfb333c7e5c23444">is_bounded_array_v</a> = <a class="el" href="structetl_1_1is__bounded__array.html">etl::is_bounded_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75" id="r_af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8d441fab48eb459b77f6f5829f7fc75">is_class_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_class</a>(T)</td></tr>
<tr class="separator:af8d441fab48eb459b77f6f5829f7fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e49677aea4d7ed533e7c73ea7f2b6" id="r_ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab45e49677aea4d7ed533e7c73ea7f2b6">is_compound_v</a> = !<a class="el" href="#af6b1115f04c131e47ab31a50aa2194b2">etl::is_fundamental_v</a>&lt;T&gt;</td></tr>
<tr class="separator:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9" id="r_a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40862de0c689f5281b8d680741bc7cf9">is_const_v</a> = <a class="el" href="structetl_1_1is__const.html">etl::is_const</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a40862de0c689f5281b8d680741bc7cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4" id="r_a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ab616d6855ca5fc60968a153587b2b4">is_constructible_v</a> = <a class="el" href="#a43743001594f300bde6a116196b1a2b8">is_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a1ab616d6855ca5fc60968a153587b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7" id="r_aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> &gt; </td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a> = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;<a class="el" href="structetl_1_1static__vector.html">From</a>, <a class="el" href="structetl_1_1static__vector.html">To</a>&gt;::value</td></tr>
<tr class="separator:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e13a2d8cce95954bee3d62ec059851" id="r_a17e13a2d8cce95954bee3d62ec059851"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a17e13a2d8cce95954bee3d62ec059851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17e13a2d8cce95954bee3d62ec059851">is_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a17e13a2d8cce95954bee3d62ec059851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045ef39158833b2ba6592fa8a1d0ebc1" id="r_a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0093a625b8acbeac1878b9a9668a2563" id="r_a0093a625b8acbeac1878b9a9668a2563"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0093a625b8acbeac1878b9a9668a2563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0093a625b8acbeac1878b9a9668a2563">is_default_constructible_v</a> = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0093a625b8acbeac1878b9a9668a2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ff2b6f5e9a98730031297120e28af4" id="r_a34ff2b6f5e9a98730031297120e28af4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a34ff2b6f5e9a98730031297120e28af4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a34ff2b6f5e9a98730031297120e28af4">is_destructible_v</a> = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a34ff2b6f5e9a98730031297120e28af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258143fbbaaef57434ff042f35db08a6" id="r_a258143fbbaaef57434ff042f35db08a6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a258143fbbaaef57434ff042f35db08a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a258143fbbaaef57434ff042f35db08a6">is_empty_v</a> = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a258143fbbaaef57434ff042f35db08a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef" id="r_aa4784b73e6d758a37358b62211a308ef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4784b73e6d758a37358b62211a308ef">is_enum_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_enum</a>(T)</td></tr>
<tr class="separator:aa4784b73e6d758a37358b62211a308ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8c484a0ff37fdfc1fc2c47b092ade2" id="r_a0b8c484a0ff37fdfc1fc2c47b092ade2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0b8c484a0ff37fdfc1fc2c47b092ade2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b8c484a0ff37fdfc1fc2c47b092ade2">is_final_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_final</a>(T)</td></tr>
<tr class="separator:a0b8c484a0ff37fdfc1fc2c47b092ade2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4" id="r_a5cf273d19443134cffcd66310d027ae4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a> = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5cf273d19443134cffcd66310d027ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3b44fa05f956c1efc4f34af98bd1f0" id="r_aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec3b44fa05f956c1efc4f34af98bd1f0">is_function_v</a> = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a function type. Types like etl::function, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false.  <br /></td></tr>
<tr class="separator:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b1115f04c131e47ab31a50aa2194b2" id="r_af6b1115f04c131e47ab31a50aa2194b2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af6b1115f04c131e47ab31a50aa2194b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6b1115f04c131e47ab31a50aa2194b2">is_fundamental_v</a> = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af6b1115f04c131e47ab31a50aa2194b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750d61c5b9f6964af8d9465794b92953" id="r_a750d61c5b9f6964af8d9465794b92953"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a750d61c5b9f6964af8d9465794b92953"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a750d61c5b9f6964af8d9465794b92953">is_implicit_default_constructible_v</a> = <a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a750d61c5b9f6964af8d9465794b92953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd" id="r_a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a></td></tr>
<tr class="separator:a0ef2a50a29c8803d461abedd7437effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcda8292d5b910aed63532a701d39e87" id="r_abcda8292d5b910aed63532a701d39e87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Fn</a> , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:abcda8292d5b910aed63532a701d39e87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abcda8292d5b910aed63532a701d39e87">is_invocable_v</a> = <a class="el" href="structetl_1_1is__invocable.html">is_invocable</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Fn</a>, ArgTypes...&gt;::value</td></tr>
<tr class="separator:abcda8292d5b910aed63532a701d39e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a1ef24a3b6eb7a38ad1307015c2c09" id="r_af8a1ef24a3b6eb7a38ad1307015c2c09"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Fn</a> , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:af8a1ef24a3b6eb7a38ad1307015c2c09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8a1ef24a3b6eb7a38ad1307015c2c09">is_invocable_r_v</a> = <a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R</a>, <a class="el" href="structetl_1_1static__vector.html">Fn</a>, ArgTypes...&gt;::value</td></tr>
<tr class="separator:af8a1ef24a3b6eb7a38ad1307015c2c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf67506d7e83cba3f386c212a824e9c" id="r_abdf67506d7e83cba3f386c212a824e9c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abdf67506d7e83cba3f386c212a824e9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abdf67506d7e83cba3f386c212a824e9c">is_lvalue_reference_v</a> = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:abdf67506d7e83cba3f386c212a824e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690a598d20472c340a3e6969d5fe58af" id="r_a690a598d20472c340a3e6969d5fe58af"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a690a598d20472c340a3e6969d5fe58af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a690a598d20472c340a3e6969d5fe58af">is_member_function_pointer_v</a> = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a690a598d20472c340a3e6969d5fe58af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe5ff6b0b6727ff7c98a53e5eb1c80" id="r_a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05fe5ff6b0b6727ff7c98a53e5eb1c80">is_member_object_pointer_v</a> = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a" id="r_adbaaa5057d498812ee848f491a20649a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbaaa5057d498812ee848f491a20649a">is_member_pointer_v</a> = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:adbaaa5057d498812ee848f491a20649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad208b3b6c99d59cdc5d698310e59143e" id="r_ad208b3b6c99d59cdc5d698310e59143e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad208b3b6c99d59cdc5d698310e59143e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">is_move_assignable_v</a> = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad208b3b6c99d59cdc5d698310e59143e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b776d5da5e25514489bfd330d7940d" id="r_a82b776d5da5e25514489bfd330d7940d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a82b776d5da5e25514489bfd330d7940d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a> = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a82b776d5da5e25514489bfd330d7940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865b2c54ee24d227ee6f222e49fd076c" id="r_a865b2c54ee24d227ee6f222e49fd076c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a865b2c54ee24d227ee6f222e49fd076c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a865b2c54ee24d227ee6f222e49fd076c">is_nothrow_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:a865b2c54ee24d227ee6f222e49fd076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff5fc00d3b16aa2421ea49dae4e864e" id="r_a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ff5fc00d3b16aa2421ea49dae4e864e">is_nothrow_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efb1cd1aad111e64a98e89322815a8f" id="r_a2efb1cd1aad111e64a98e89322815a8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> &gt; </td></tr>
<tr class="memitem:a2efb1cd1aad111e64a98e89322815a8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2efb1cd1aad111e64a98e89322815a8f">is_nothrow_convertible_v</a> = <a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a>&lt;<a class="el" href="structetl_1_1static__vector.html">From</a>, <a class="el" href="structetl_1_1static__vector.html">To</a>&gt;::value</td></tr>
<tr class="separator:a2efb1cd1aad111e64a98e89322815a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5684c28598fd5bde573fccdf36cccda9" id="r_a5684c28598fd5bde573fccdf36cccda9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5684c28598fd5bde573fccdf36cccda9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5684c28598fd5bde573fccdf36cccda9">is_nothrow_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5684c28598fd5bde573fccdf36cccda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05ca75073ae3731fef7c09200d9f693" id="r_ab05ca75073ae3731fef7c09200d9f693"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab05ca75073ae3731fef7c09200d9f693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab05ca75073ae3731fef7c09200d9f693">is_nothrow_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ab05ca75073ae3731fef7c09200d9f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e312d7578609fe1f21277a6d7a1606" id="r_a12e312d7578609fe1f21277a6d7a1606"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a12e312d7578609fe1f21277a6d7a1606"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a12e312d7578609fe1f21277a6d7a1606">is_nothrow_default_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a12e312d7578609fe1f21277a6d7a1606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bb068a979f4237eb8c218d4f0112f2" id="r_a92bb068a979f4237eb8c218d4f0112f2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a92bb068a979f4237eb8c218d4f0112f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92bb068a979f4237eb8c218d4f0112f2">is_nothrow_destructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a92bb068a979f4237eb8c218d4f0112f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d18b577003e8d090a82e4c6d497cdd" id="r_ab5d18b577003e8d090a82e4c6d497cdd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab5d18b577003e8d090a82e4c6d497cdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5d18b577003e8d090a82e4c6d497cdd">is_nothrow_move_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ab5d18b577003e8d090a82e4c6d497cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00f5b3ced7a1f4ebd3e7b1119a4c12a" id="r_ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">is_nothrow_move_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe0a7655d7b161139e48f8eb34838ac" id="r_a4fe0a7655d7b161139e48f8eb34838ac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4fe0a7655d7b161139e48f8eb34838ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4fe0a7655d7b161139e48f8eb34838ac">is_nothrow_swappable_v</a> = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4fe0a7655d7b161139e48f8eb34838ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d458068230554e22227d91a28708809" id="r_a8d458068230554e22227d91a28708809"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a8d458068230554e22227d91a28708809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d458068230554e22227d91a28708809">is_nothrow_swappable_with_v</a> = <a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:a8d458068230554e22227d91a28708809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4" id="r_a016c8419365e8e3697a56040d335bca4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a016c8419365e8e3697a56040d335bca4">is_null_pointer_v</a> = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a016c8419365e8e3697a56040d335bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc" id="r_a63efd09c0ee7195824be65423adadedc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63efd09c0ee7195824be65423adadedc">is_object_v</a> = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a63efd09c0ee7195824be65423adadedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c" id="r_ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a> = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8f73739262829ccbc6f7400f3b2601" id="r_aca8f73739262829ccbc6f7400f3b2601"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aca8f73739262829ccbc6f7400f3b2601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca8f73739262829ccbc6f7400f3b2601">is_polymorphic_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_polymorphic</a>(T)</td></tr>
<tr class="separator:aca8f73739262829ccbc6f7400f3b2601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a" id="r_a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22294e9170ea0547c68724eabe0c8c5a">is_reference_v</a> = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a22294e9170ea0547c68724eabe0c8c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c52ea67297deb4aba0a1d7abb142f5" id="r_a73c52ea67297deb4aba0a1d7abb142f5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a73c52ea67297deb4aba0a1d7abb142f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73c52ea67297deb4aba0a1d7abb142f5">is_reference_wrapper_v</a> = <a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a73c52ea67297deb4aba0a1d7abb142f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cba0c4e29fbd91ba77cbf6b9744ebc" id="r_af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af2cba0c4e29fbd91ba77cbf6b9744ebc">is_rvalue_reference_v</a> = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666" id="r_a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a> = <a class="el" href="structetl_1_1static__vector.html">false</a></td></tr>
<tr class="separator:a3f74da2365a9a6f68d472686fd0f1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699a4890b6c210a9503c517082e10e6c" id="r_a699a4890b6c210a9503c517082e10e6c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a699a4890b6c210a9503c517082e10e6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a699a4890b6c210a9503c517082e10e6c">is_same_v&lt; T, T &gt;</a> = <a class="el" href="structetl_1_1static__vector.html">true</a></td></tr>
<tr class="separator:a699a4890b6c210a9503c517082e10e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228" id="r_ab43d223a689de0810df63d7c223d4228"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab43d223a689de0810df63d7c223d4228">is_scalar_v</a> = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ab43d223a689de0810df63d7c223d4228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e458f80e6889b85b2e3bf2ee84360b" id="r_af3e458f80e6889b85b2e3bf2ee84360b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af3e458f80e6889b85b2e3bf2ee84360b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3e458f80e6889b85b2e3bf2ee84360b">is_scoped_enum_v</a> = <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:af3e458f80e6889b85b2e3bf2ee84360b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an scoped enumeration type. Provides the member constant value which is equal to true, if T is an scoped enumeration type. Otherwise, value is equal to false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a> or is_scoped_enum_v is undefined.  <br /></td></tr>
<tr class="separator:af3e458f80e6889b85b2e3bf2ee84360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3fadd2a1e349c45f524ab5444220ff" id="r_aff3fadd2a1e349c45f524ab5444220ff"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aff3fadd2a1e349c45f524ab5444220ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff3fadd2a1e349c45f524ab5444220ff">is_signed_v</a> = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aff3fadd2a1e349c45f524ab5444220ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efadb1ffae420e853d78309b080bb5" id="r_a68efadb1ffae420e853d78309b080bb5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">template</a>&lt; typename... &gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> Template, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tag</a>  = void&gt; </td></tr>
<tr class="memitem:a68efadb1ffae420e853d78309b080bb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68efadb1ffae420e853d78309b080bb5">is_specialized_v</a> = <a class="el" href="structetl_1_1is__specialized.html">etl::is_specialized</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Template</a>, T, <a class="el" href="structetl_1_1static__vector.html">Tag</a>&gt;::value</td></tr>
<tr class="separator:a68efadb1ffae420e853d78309b080bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0627b73385571d2f5b0bb7b5f23d0c4e" id="r_a0627b73385571d2f5b0bb7b5f23d0c4e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0627b73385571d2f5b0bb7b5f23d0c4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0627b73385571d2f5b0bb7b5f23d0c4e">is_standard_layout_v</a> = <a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0627b73385571d2f5b0bb7b5f23d0c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb1671f31576cce07cf1bac1e99f7c" id="r_a46cb1671f31576cce07cf1bac1e99f7c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a46cb1671f31576cce07cf1bac1e99f7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a> = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a46cb1671f31576cce07cf1bac1e99f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be84147dabbe2371aec6974e74d0f77" id="r_a7be84147dabbe2371aec6974e74d0f77"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a7be84147dabbe2371aec6974e74d0f77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7be84147dabbe2371aec6974e74d0f77">is_swappable_with_v</a> = <a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:a7be84147dabbe2371aec6974e74d0f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5a4c4924b529a3f8760925c283ce6" id="r_a1dc5a4c4924b529a3f8760925c283ce6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1dc5a4c4924b529a3f8760925c283ce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1dc5a4c4924b529a3f8760925c283ce6">is_trivial_v</a> = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a1dc5a4c4924b529a3f8760925c283ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cfce5bc9de7ea45285ad503a807a9b" id="r_ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2cfce5bc9de7ea45285ad503a807a9b">is_trivially_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a74c34b46b65c2b8fa633d1e6211b25" id="r_a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a74c34b46b65c2b8fa633d1e6211b25">is_trivially_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4028d9154b8d629e56fd488b33587786" id="r_a4028d9154b8d629e56fd488b33587786"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4028d9154b8d629e56fd488b33587786"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4028d9154b8d629e56fd488b33587786">is_trivially_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4028d9154b8d629e56fd488b33587786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56b91d45ec88c108b77f55e9f6bc187" id="r_ac56b91d45ec88c108b77f55e9f6bc187"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac56b91d45ec88c108b77f55e9f6bc187">is_trivially_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3b937c99443cbaf5f1817d061261bd" id="r_a5b3b937c99443cbaf5f1817d061261bd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5b3b937c99443cbaf5f1817d061261bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5b3b937c99443cbaf5f1817d061261bd">is_trivially_copyable_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_trivially_copyable</a>(T)</td></tr>
<tr class="separator:a5b3b937c99443cbaf5f1817d061261bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f37ab88cda78781a7aca13f18adac97" id="r_a6f37ab88cda78781a7aca13f18adac97"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6f37ab88cda78781a7aca13f18adac97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f37ab88cda78781a7aca13f18adac97">is_trivially_default_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6f37ab88cda78781a7aca13f18adac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b9d2d77f59d05a317cc9715ac7aa8c" id="r_a11b9d2d77f59d05a317cc9715ac7aa8c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a11b9d2d77f59d05a317cc9715ac7aa8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11b9d2d77f59d05a317cc9715ac7aa8c">is_trivially_destructible_v</a> = <a class="el" href="structetl_1_1static__vector.html">__has_trivial_destructor</a>(T)</td></tr>
<tr class="separator:a11b9d2d77f59d05a317cc9715ac7aa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3673480825caede3c2d5095f8a39fe0d" id="r_a3673480825caede3c2d5095f8a39fe0d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3673480825caede3c2d5095f8a39fe0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3673480825caede3c2d5095f8a39fe0d">is_trivially_move_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3673480825caede3c2d5095f8a39fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6928ba542ac2317ce2796c3a71a9b7" id="r_aef6928ba542ac2317ce2796c3a71a9b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aef6928ba542ac2317ce2796c3a71a9b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef6928ba542ac2317ce2796c3a71a9b7">is_trivially_move_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">etl::is_trivially_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aef6928ba542ac2317ce2796c3a71a9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c65af89fc55014250b54559626d075" id="r_a00c65af89fc55014250b54559626d075"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a00c65af89fc55014250b54559626d075"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00c65af89fc55014250b54559626d075">is_unbounded_array_v</a> = <a class="el" href="structetl_1_1is__unbounded__array.html">etl::is_unbounded_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a00c65af89fc55014250b54559626d075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00" id="r_a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51d4c31d288adf2cb4c5d7fd14c32f00">is_union_v</a> = <a class="el" href="structetl_1_1static__vector.html">__is_union</a>(T)</td></tr>
<tr class="separator:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108" id="r_a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bbd05dc09b68b19c63d7b4fbf6f1108">is_unsigned_v</a> = <a class="el" href="structetl_1_1is__unsigned.html">etl::is_unsigned</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e" id="r_a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a149f8ba4063995f2c8ed7248d93a4d9e">is_void_v</a> = <a class="el" href="#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">void</a>, <a class="el" href="#a7d3ea939d0e932fceedbae01d7a3af90">etl::remove_cv_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76b943cef158f554f60c8d61b6835bc" id="r_aa76b943cef158f554f60c8d61b6835bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa76b943cef158f554f60c8d61b6835bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa76b943cef158f554f60c8d61b6835bc">is_volatile_v</a> = <a class="el" href="structetl_1_1is__volatile.html">etl::is_volatile</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa76b943cef158f554f60c8d61b6835bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0422e10e238c05956150aa5f4ed77e" id="r_a2e0422e10e238c05956150aa5f4ed77e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">B</a> &gt; </td></tr>
<tr class="memitem:a2e0422e10e238c05956150aa5f4ed77e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e0422e10e238c05956150aa5f4ed77e">negation_v</a> = !<a class="el" href="structetl_1_1static__vector.html">bool</a>(B::value)</td></tr>
<tr class="separator:a2e0422e10e238c05956150aa5f4ed77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229d4171b460abc833736d622ce9745" id="r_a4229d4171b460abc833736d622ce9745"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </td></tr>
<tr class="memitem:a4229d4171b460abc833736d622ce9745"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="#a49823583370a499813db70f494111109">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4229d4171b460abc833736d622ce9745">rank_v</a> = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Type</a>&gt;::value</td></tr>
<tr class="separator:a4229d4171b460abc833736d622ce9745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53057a1d7b9d22a69eb3e40fdc44eb3d" id="r_a53057a1d7b9d22a69eb3e40fdc44eb3d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> V&gt; </td></tr>
<tr class="memitem:a53057a1d7b9d22a69eb3e40fdc44eb3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53057a1d7b9d22a69eb3e40fdc44eb3d">nontype</a> = <a class="el" href="structetl_1_1nontype__t.html">etl::nontype_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">V</a>&gt;{}</td></tr>
<tr class="separator:a53057a1d7b9d22a69eb3e40fdc44eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29815251de01b00c45a0bb62678930c5" id="r_a29815251de01b00c45a0bb62678930c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29815251de01b00c45a0bb62678930c5">piecewise_construct</a> = <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>{}</td></tr>
<tr class="memdesc:a29815251de01b00c45a0bb62678930c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant <a class="el" href="#a29815251de01b00c45a0bb62678930c5" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>.  <br /></td></tr>
<tr class="separator:a29815251de01b00c45a0bb62678930c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d369052fc23b452882a9fd514abb87" id="r_a28d369052fc23b452882a9fd514abb87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28d369052fc23b452882a9fd514abb87">variant_npos</a> = <a class="el" href="structetl_1_1numeric__limits.html">etl::numeric_limits</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>&gt;<a class="el" href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">::max</a>()</td></tr>
<tr class="memdesc:a28d369052fc23b452882a9fd514abb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the largest value representable by the type size_t, used as the return value of index() when valueless_by_exception() is true.  <br /></td></tr>
<tr class="separator:a28d369052fc23b452882a9fd514abb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9289432c6100af2ec8b2563959f2c261" id="r_a9289432c6100af2ec8b2563959f2c261"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9289432c6100af2ec8b2563959f2c261"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9289432c6100af2ec8b2563959f2c261">variant_size_v</a> = <a class="el" href="structetl_1_1variant__size.html">variant_size</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a9289432c6100af2ec8b2563959f2c261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8047ec1fd97af797afb4226eba8bd80f" id="r_a8047ec1fd97af797afb4226eba8bd80f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8047ec1fd97af797afb4226eba8bd80f">current_implementation</a> = <a class="el" href="#a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1">implementation::freestanding</a></td></tr>
<tr class="separator:a8047ec1fd97af797afb4226eba8bd80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c600f9a9722bf7bef4af93af1d5ca" id="r_afb1c600f9a9722bf7bef4af93af1d5ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb1c600f9a9722bf7bef4af93af1d5ca">current_standard</a> = <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff">language_standard::cpp_26</a></td></tr>
<tr class="memdesc:afb1c600f9a9722bf7bef4af93af1d5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently configured C++ standard.  <br /></td></tr>
<tr class="separator:afb1c600f9a9722bf7bef4af93af1d5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a27e36416cdc5e1021c9d5151775e7ec9" name="a27e36416cdc5e1021c9d5151775e7ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e36416cdc5e1021c9d5151775e7ec9">&#9670;&#160;</a></span>float_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a27e36416cdc5e1021c9d5151775e7ec9">etl::float_t</a> = <a class="el" href="structetl_1_1static__vector.html">float</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most efficient floating-point type at least as wide as float. </p>

</div>
</div>
<a id="a77bf8f126e3cdf99b95d6b073210cfe7" name="a77bf8f126e3cdf99b95d6b073210cfe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bf8f126e3cdf99b95d6b073210cfe7">&#9670;&#160;</a></span>double_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a77bf8f126e3cdf99b95d6b073210cfe7">etl::double_t</a> = <a class="el" href="structetl_1_1static__vector.html">double</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most efficient floating-point type at least as wide as double. </p>

</div>
</div>
<a id="a9b4eb7e1110a660a8bdaba03466cea51" name="a9b4eb7e1110a660a8bdaba03466cea51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4eb7e1110a660a8bdaba03466cea51">&#9670;&#160;</a></span>common_comparison_category_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a9b4eb7e1110a660a8bdaba03466cea51">etl::common_comparison_category_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade5c3bd3598ac28c038c72211877c543" name="ade5c3bd3598ac28c038c72211877c543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5c3bd3598ac28c038c72211877c543">&#9670;&#160;</a></span>compare_three_way_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ade5c3bd3598ac28c038c72211877c543">etl::compare_three_way_result_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;() &lt;=&gt; <a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a>&lt;U&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0838d3bb433682c6c13b31dbd1c27f4a" name="a0838d3bb433682c6c13b31dbd1c27f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0838d3bb433682c6c13b31dbd1c27f4a">&#9670;&#160;</a></span>nullptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">etl::nullptr_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">nullptr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/nullptr_t">https://en.cppreference.com/w/cpp/types/nullptr_t</a> </p>

</div>
</div>
<a id="a1630ee9e07d0d32697249d7a63e131c1" name="a1630ee9e07d0d32697249d7a63e131c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1630ee9e07d0d32697249d7a63e131c1">&#9670;&#160;</a></span>ptrdiff_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1">etl::ptrdiff_t</a> = <a class="el" href="builtin__types_8hpp.html#a19bfe4995271e67306bab6dc974ed002">TETL_BUILTIN_PTRDIFF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1" title="etl::ptrdiff_t is the signed integer type of the result of subtracting two pointers.">etl::ptrdiff_t</a> is the signed integer type of the result of subtracting two pointers. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/ptrdiff_t">https://en.cppreference.com/w/cpp/types/ptrdiff_t</a> </p>

</div>
</div>
<a id="a49823583370a499813db70f494111109" name="a49823583370a499813db70f494111109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49823583370a499813db70f494111109">&#9670;&#160;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> = <a class="el" href="builtin__types_8hpp.html#ab236bea848bc390350ba3fc38ae07819">TETL_BUILTIN_SIZET</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a49823583370a499813db70f494111109" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> is the unsigned integer type of the result of the sizeof operator. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/size_t">https://en.cppreference.com/w/cpp/types/size_t</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a0">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac4a034210e12ea1e1148227df5d391ce" name="ac4a034210e12ea1e1148227df5d391ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a034210e12ea1e1148227df5d391ce">&#9670;&#160;</a></span>int_fast8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac4a034210e12ea1e1148227df5d391ce">etl::int_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="ac098905947cf95d8ea831ad1531152f5" name="ac098905947cf95d8ea831ad1531152f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac098905947cf95d8ea831ad1531152f5">&#9670;&#160;</a></span>int_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac098905947cf95d8ea831ad1531152f5">etl::int_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="a0fdf87490ddb044e4f5b85c0f11e4db4" name="a0fdf87490ddb044e4f5b85c0f11e4db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdf87490ddb044e4f5b85c0f11e4db4">&#9670;&#160;</a></span>int_fast32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a0fdf87490ddb044e4f5b85c0f11e4db4">etl::int_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="abcf7a7cd9831dd78a5d9d752fbfa4975" name="abcf7a7cd9831dd78a5d9d752fbfa4975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf7a7cd9831dd78a5d9d752fbfa4975">&#9670;&#160;</a></span>int_fast64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#abcf7a7cd9831dd78a5d9d752fbfa4975">etl::int_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="a611b1ddc1add76163ef8b3580a251826" name="a611b1ddc1add76163ef8b3580a251826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611b1ddc1add76163ef8b3580a251826">&#9670;&#160;</a></span>int_least8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a611b1ddc1add76163ef8b3580a251826">etl::int_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a00cfb600b8fc4fecd1034781659bc3e7" name="a00cfb600b8fc4fecd1034781659bc3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cfb600b8fc4fecd1034781659bc3e7">&#9670;&#160;</a></span>int_least16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a00cfb600b8fc4fecd1034781659bc3e7">etl::int_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="aa549fa2d009dc12211e58320777f180d" name="aa549fa2d009dc12211e58320777f180d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa549fa2d009dc12211e58320777f180d">&#9670;&#160;</a></span>int_least32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa549fa2d009dc12211e58320777f180d">etl::int_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a176e603bb1a7a34edafdf69d14cf6059" name="a176e603bb1a7a34edafdf69d14cf6059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176e603bb1a7a34edafdf69d14cf6059">&#9670;&#160;</a></span>int_least64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a176e603bb1a7a34edafdf69d14cf6059">etl::int_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="ac09572027600fa251a322b4f80ffdccc" name="ac09572027600fa251a322b4f80ffdccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09572027600fa251a322b4f80ffdccc">&#9670;&#160;</a></span>int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac09572027600fa251a322b4f80ffdccc">etl::int8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 8 bits. </p>

</div>
</div>
<a id="a8de4cb652edc81c4cba48d1dc09e78b8" name="a8de4cb652edc81c4cba48d1dc09e78b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de4cb652edc81c4cba48d1dc09e78b8">&#9670;&#160;</a></span>int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a8de4cb652edc81c4cba48d1dc09e78b8">etl::int16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 16 bits. </p>

</div>
</div>
<a id="a3bf8abffff5f3413df839b52454c989d" name="a3bf8abffff5f3413df839b52454c989d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf8abffff5f3413df839b52454c989d">&#9670;&#160;</a></span>int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3bf8abffff5f3413df839b52454c989d">etl::int32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 32 bits. </p>

</div>
</div>
<a id="a0d07242009a2523b463d707f4ee84822" name="a0d07242009a2523b463d707f4ee84822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d07242009a2523b463d707f4ee84822">&#9670;&#160;</a></span>int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a0d07242009a2523b463d707f4ee84822">etl::int64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 64 bits. </p>

</div>
</div>
<a id="a14d3758a68be146a2ff828389077015e" name="a14d3758a68be146a2ff828389077015e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d3758a68be146a2ff828389077015e">&#9670;&#160;</a></span>intmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a14d3758a68be146a2ff828389077015e">etl::intmax_t</a> = <a class="el" href="builtin__types_8hpp.html#ad8678dda9c4b939fee5244864c53ada1">TETL_BUILTIN_INTMAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum-width signed integer type. </p>

</div>
</div>
<a id="a416f114fb5e96e069668044817b75e91" name="a416f114fb5e96e069668044817b75e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416f114fb5e96e069668044817b75e91">&#9670;&#160;</a></span>intptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a416f114fb5e96e069668044817b75e91">etl::intptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a021098c463419df8b156d80c9153387e">TETL_BUILTIN_INTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type capable of holding a pointer. </p>

</div>
</div>
<a id="ad2d0cdc49e3e364509210f258e92ed7d" name="ad2d0cdc49e3e364509210f258e92ed7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d0cdc49e3e364509210f258e92ed7d">&#9670;&#160;</a></span>uint_fast8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad2d0cdc49e3e364509210f258e92ed7d">etl::uint_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a2d06db5bf54290f0c376c5561abbe6b3" name="a2d06db5bf54290f0c376c5561abbe6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d06db5bf54290f0c376c5561abbe6b3">&#9670;&#160;</a></span>uint_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2d06db5bf54290f0c376c5561abbe6b3">etl::uint_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="a8e97b929c1029e6984db90eda7c13f21" name="a8e97b929c1029e6984db90eda7c13f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e97b929c1029e6984db90eda7c13f21">&#9670;&#160;</a></span>uint_fast32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a8e97b929c1029e6984db90eda7c13f21">etl::uint_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a33880814fae54b15cd6b0684319f98b2" name="a33880814fae54b15cd6b0684319f98b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33880814fae54b15cd6b0684319f98b2">&#9670;&#160;</a></span>uint_fast64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a33880814fae54b15cd6b0684319f98b2">etl::uint_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="af0bcd0adbd229010c6badbb1d5780d65" name="af0bcd0adbd229010c6badbb1d5780d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bcd0adbd229010c6badbb1d5780d65">&#9670;&#160;</a></span>uint_least8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af0bcd0adbd229010c6badbb1d5780d65">etl::uint_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a79ede9c2d7befd651fb785146cd41474" name="a79ede9c2d7befd651fb785146cd41474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ede9c2d7befd651fb785146cd41474">&#9670;&#160;</a></span>uint_least16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a79ede9c2d7befd651fb785146cd41474">etl::uint_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="aacad985f8a3fd8c90a9cfef41e7f9809" name="aacad985f8a3fd8c90a9cfef41e7f9809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacad985f8a3fd8c90a9cfef41e7f9809">&#9670;&#160;</a></span>uint_least32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aacad985f8a3fd8c90a9cfef41e7f9809">etl::uint_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a2f84136e9fa7e12c207d816febd16555" name="a2f84136e9fa7e12c207d816febd16555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f84136e9fa7e12c207d816febd16555">&#9670;&#160;</a></span>uint_least64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2f84136e9fa7e12c207d816febd16555">etl::uint_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="af5cb8d6d7baf449891507753e9a62587" name="af5cb8d6d7baf449891507753e9a62587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cb8d6d7baf449891507753e9a62587">&#9670;&#160;</a></span>uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af5cb8d6d7baf449891507753e9a62587">etl::uint8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 8 bits. </p>

</div>
</div>
<a id="a732998f95607dc2fe0c03b19dee4e666" name="a732998f95607dc2fe0c03b19dee4e666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732998f95607dc2fe0c03b19dee4e666">&#9670;&#160;</a></span>uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a732998f95607dc2fe0c03b19dee4e666">etl::uint16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 16 bits. </p>

</div>
</div>
<a id="a25c9e89a742d0f6cc76010445825b70e" name="a25c9e89a742d0f6cc76010445825b70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c9e89a742d0f6cc76010445825b70e">&#9670;&#160;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a25c9e89a742d0f6cc76010445825b70e">etl::uint32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 32 bits. </p>

</div>
</div>
<a id="a1baaba7bb13a976f75b1cd7aa49dc56b" name="a1baaba7bb13a976f75b1cd7aa49dc56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1baaba7bb13a976f75b1cd7aa49dc56b">&#9670;&#160;</a></span>uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1baaba7bb13a976f75b1cd7aa49dc56b">etl::uint64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 64 bits. </p>

</div>
</div>
<a id="ae05541f3495353edefb00e00beb38efc" name="ae05541f3495353edefb00e00beb38efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05541f3495353edefb00e00beb38efc">&#9670;&#160;</a></span>uintmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae05541f3495353edefb00e00beb38efc">etl::uintmax_t</a> = <a class="el" href="builtin__types_8hpp.html#a64175350ea04c19125422816cd6184e1">TETL_BUILTIN_UINTMAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum-width unsigned integer type. </p>

</div>
</div>
<a id="af7c906948794adfe5ec093499e436a37" name="af7c906948794adfe5ec093499e436a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c906948794adfe5ec093499e436a37">&#9670;&#160;</a></span>uintptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af7c906948794adfe5ec093499e436a37">etl::uintptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a3b013e093af0767d757a3606463295d9">TETL_BUILTIN_UINTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type capable of holding a pointer. </p>

</div>
</div>
<a id="af3a144275abbc1202be775e01755ac4c" name="af3a144275abbc1202be775e01755ac4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a144275abbc1202be775e01755ac4c">&#9670;&#160;</a></span>clock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af3a144275abbc1202be775e01755ac4c">etl::clock_t</a> = <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2504f109f893e3cd550112cfc616c42d" name="a2504f109f893e3cd550112cfc616c42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2504f109f893e3cd550112cfc616c42d">&#9670;&#160;</a></span>time_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2504f109f893e3cd550112cfc616c42d">etl::time_t</a> = <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic type capable of representing times. </p>
<p>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to POSIX time. </p>

</div>
</div>
<a id="a2057177bf6f151716e055fc52a2fb9e7" name="a2057177bf6f151716e055fc52a2fb9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2057177bf6f151716e055fc52a2fb9e7">&#9670;&#160;</a></span>wint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">etl::wint_t</a> = <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">int</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ca9dac165db8a73a0cd16ab2677fabc" name="a5ca9dac165db8a73a0cd16ab2677fabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca9dac165db8a73a0cd16ab2677fabc">&#9670;&#160;</a></span>format_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a5ca9dac165db8a73a0cd16ab2677fabc">etl::format_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#ad867dbf777d0e2fcf904b16ffbbd1ac1">format_context</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae60d95f2193b80fc48eb339789555fbc" name="ae60d95f2193b80fc48eb339789555fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60d95f2193b80fc48eb339789555fbc">&#9670;&#160;</a></span>wformat_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae60d95f2193b80fc48eb339789555fbc">etl::wformat_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#af14a1ebd9061ef0ef02d67e436e4fcd4">wformat_context</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad867dbf777d0e2fcf904b16ffbbd1ac1" name="ad867dbf777d0e2fcf904b16ffbbd1ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867dbf777d0e2fcf904b16ffbbd1ac1">&#9670;&#160;</a></span>format_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad867dbf777d0e2fcf904b16ffbbd1ac1">etl::format_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;&gt;, <a class="el" href="structetl_1_1static__vector.html">char</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to formatting state consisting of the formatting arguments and the output iterator. </p>
<p>The first template argument is an output iterator that appends to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>, such as etl::back_insert_iterator&lt;etl::static_string&gt;. Implementations are encouraged to use an iterator to type-erased buffer type that supports appending to any contiguous and resizable container.</p>
<p>The behavior is undefined if OutputIt does not model output_iterator&lt;const CharT&amp;&gt;.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/basic_format_context">https://en.cppreference.com/w/cpp/utility/format/basic_format_context</a> </p>

</div>
</div>
<a id="af14a1ebd9061ef0ef02d67e436e4fcd4" name="af14a1ebd9061ef0ef02d67e436e4fcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14a1ebd9061ef0ef02d67e436e4fcd4">&#9670;&#160;</a></span>wformat_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af14a1ebd9061ef0ef02d67e436e4fcd4">etl::wformat_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;&gt;, <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefb586d74437e6af949ebb96b9dd5699" name="aefb586d74437e6af949ebb96b9dd5699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb586d74437e6af949ebb96b9dd5699">&#9670;&#160;</a></span>format_parse_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aefb586d74437e6af949ebb96b9dd5699">etl::format_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a67767b36e7722169bb853b762ce270" name="a3a67767b36e7722169bb853b762ce270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a67767b36e7722169bb853b762ce270">&#9670;&#160;</a></span>wformat_parse_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3a67767b36e7722169bb853b762ce270">etl::wformat_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1165db7522758e370f2f0505425e997" name="ab1165db7522758e370f2f0505425e997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1165db7522758e370f2f0505425e997">&#9670;&#160;</a></span>format_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ab1165db7522758e370f2f0505425e997">etl::format_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="#aca5bede918f0a9391b776b0721c80e40">type_identity_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88d54d8ee8d9e9db4ee7a2fae3dfa173" name="a88d54d8ee8d9e9db4ee7a2fae3dfa173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d54d8ee8d9e9db4ee7a2fae3dfa173">&#9670;&#160;</a></span>wformat_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a88d54d8ee8d9e9db4ee7a2fae3dfa173">etl::wformat_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>, <a class="el" href="#aca5bede918f0a9391b776b0721c80e40">type_identity_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ccda852d9fec850405ea795d8c58e8f" name="a1ccda852d9fec850405ea795d8c58e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccda852d9fec850405ea795d8c58e8f">&#9670;&#160;</a></span>diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1ccda852d9fec850405ea795d8c58e8f">etl::diff_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;<a class="el" href="#a2fff237ed0afc787415c06ce1315553e">etl::remove_cvref_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>&gt;&gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a4017a970d2adc04f09c1389910f70d" name="a8a4017a970d2adc04f09c1389910f70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4017a970d2adc04f09c1389910f70d">&#9670;&#160;</a></span>stringbuf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a8a4017a970d2adc04f09c1389910f70d">etl::stringbuf</a> = <a class="el" href="structetl_1_1basic__stringbuf.html">basic_stringbuf</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa45281465d730bea49ffecd03ac96072" name="aa45281465d730bea49ffecd03ac96072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45281465d730bea49ffecd03ac96072">&#9670;&#160;</a></span>streamoff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa45281465d730bea49ffecd03ac96072">etl::streamoff</a> = <a class="el" href="structetl_1_1static__vector.html">long</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d460594ca594c171a5e0ed2934b46f2" name="a2d460594ca594c171a5e0ed2934b46f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d460594ca594c171a5e0ed2934b46f2">&#9670;&#160;</a></span>streamsize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2d460594ca594c171a5e0ed2934b46f2">etl::streamsize</a> = <a class="el" href="#ace93b7d8b1e564390c651a2e9a3a11f0">make_signed_t</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac263fc338e385e101a2ce83db886dbb" name="aac263fc338e385e101a2ce83db886dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac263fc338e385e101a2ce83db886dbb">&#9670;&#160;</a></span>indirect_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Iters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aac263fc338e385e101a2ce83db886dbb">etl::indirect_result_t</a> = <a class="el" href="#ad47ced64dcc2c2322893df26022403c5">etl::invoke_result_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, <a class="el" href="#afcc6810798d0569072d3d767bf074836">etl::iter_reference_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iters</a>&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ec6862301fef8edad6700319db71e8f" name="a2ec6862301fef8edad6700319db71e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec6862301fef8edad6700319db71e8f">&#9670;&#160;</a></span>iter_common_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2ec6862301fef8edad6700319db71e8f">etl::iter_common_reference_t</a> = <a class="el" href="#adee609f391eb3188705d52e09cb8fb04">etl::common_reference_t</a>&lt;<a class="el" href="#afcc6810798d0569072d3d767bf074836">etl::iter_reference_t</a>&lt;T&gt;, <a class="el" href="#ac8309531bbf46301417735269d8088b6">etl::iter_value_t</a>&lt;T&gt;&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeedb33aa3223d3aa48257386b72f6db9" name="aeedb33aa3223d3aa48257386b72f6db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedb33aa3223d3aa48257386b72f6db9">&#9670;&#160;</a></span>iter_difference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aeedb33aa3223d3aa48257386b72f6db9">etl::iter_difference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::iter_difference&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcc6810798d0569072d3d767bf074836" name="afcc6810798d0569072d3d767bf074836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc6810798d0569072d3d767bf074836">&#9670;&#160;</a></span>iter_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::detail::dereferenceable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afcc6810798d0569072d3d767bf074836">etl::iter_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(*<a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;T&amp;&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5662463c2068e9f434f18f4d18380bb" name="aa5662463c2068e9f434f18f4d18380bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5662463c2068e9f434f18f4d18380bb">&#9670;&#160;</a></span>iter_rvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::detail::dereferenceable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa5662463c2068e9f434f18f4d18380bb">etl::iter_rvalue_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="namespaceetl_1_1ranges_1_1cpo.html#adbb4630e362144a441c559ced59ebf86">etl::ranges::iter_move</a>(<a class="el" href="#a27a1a97135d4a41771948063bd8c3a90">etl::declval</a>&lt;T&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8309531bbf46301417735269d8088b6" name="ac8309531bbf46301417735269d8088b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8309531bbf46301417735269d8088b6">&#9670;&#160;</a></span>iter_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac8309531bbf46301417735269d8088b6">etl::iter_value_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::iter_value&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54e1a2b1f3db0980f0ab01630917f72d" name="a54e1a2b1f3db0980f0ab01630917f72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e1a2b1f3db0980f0ab01630917f72d">&#9670;&#160;</a></span>projected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> Iter, <a class="el" href="conceptetl_1_1indirectly__regular__unary__invocable.html">etl::indirectly_regular_unary_invocable</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; Proj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a54e1a2b1f3db0980f0ab01630917f72d">etl::projected</a> = etl::detail::projected_impl&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>, <a class="el" href="structetl_1_1static__vector.html">Proj</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad27430ad24df2ec00864b7184d731465" name="ad27430ad24df2ec00864b7184d731465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27430ad24df2ec00864b7184d731465">&#9670;&#160;</a></span>dextents</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexType</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad27430ad24df2ec00864b7184d731465">etl::dextents</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> detail::dextents_impl&lt;<a class="el" href="structetl_1_1static__vector.html">IndexType</a>, <a class="el" href="#a3aebb59d8745facee9c0002882401c78">etl::make_index_sequence</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Rank</a>&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec9a616880e946c9354707df919cb7bb" name="aec9a616880e946c9354707df919cb7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9a616880e946c9354707df919cb7bb">&#9670;&#160;</a></span>new_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aec9a616880e946c9354707df919cb7bb">etl::new_handler</a> = <a class="el" href="structetl_1_1static__vector.html">void</a> (*)()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aec9a616880e946c9354707df919cb7bb" title="etl::new_handler is the function pointer type (pointer to function that takes no arguments and return...">etl::new_handler</a> is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions etl::set_new_handler and etl::get_new_handler </p>

</div>
</div>
<a id="a968a1e0d1e8d9494d021d34bc2e6c82a" name="a968a1e0d1e8d9494d021d34bc2e6c82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968a1e0d1e8d9494d021d34bc2e6c82a">&#9670;&#160;</a></span>atto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a968a1e0d1e8d9494d021d34bc2e6c82a">etl::atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13b1921a95623fff3a9b8e397eb4a3f7" name="a13b1921a95623fff3a9b8e397eb4a3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b1921a95623fff3a9b8e397eb4a3f7">&#9670;&#160;</a></span>femto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a13b1921a95623fff3a9b8e397eb4a3f7">etl::femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac489b67384efcc27fe4baeac5893713a" name="ac489b67384efcc27fe4baeac5893713a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac489b67384efcc27fe4baeac5893713a">&#9670;&#160;</a></span>pico</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac489b67384efcc27fe4baeac5893713a">etl::pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ebbaf9de296934c9320b7b32932be3f" name="a3ebbaf9de296934c9320b7b32932be3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebbaf9de296934c9320b7b32932be3f">&#9670;&#160;</a></span>nano</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3ebbaf9de296934c9320b7b32932be3f">etl::nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a790708917957bff608703092eecec315" name="a790708917957bff608703092eecec315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790708917957bff608703092eecec315">&#9670;&#160;</a></span>micro</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a790708917957bff608703092eecec315">etl::micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd9927a0f0f2ea2485adb9fe6fc78420" name="acd9927a0f0f2ea2485adb9fe6fc78420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9927a0f0f2ea2485adb9fe6fc78420">&#9670;&#160;</a></span>milli</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#acd9927a0f0f2ea2485adb9fe6fc78420">etl::milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4c3c77e0d8a4219fff42cebc05f122a" name="af4c3c77e0d8a4219fff42cebc05f122a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c3c77e0d8a4219fff42cebc05f122a">&#9670;&#160;</a></span>centi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af4c3c77e0d8a4219fff42cebc05f122a">etl::centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e3f53d1282340b8092c7e91328b12e8" name="a7e3f53d1282340b8092c7e91328b12e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3f53d1282340b8092c7e91328b12e8">&#9670;&#160;</a></span>deci</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a7e3f53d1282340b8092c7e91328b12e8">etl::deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4abe01140e9514d91cd6057a514321e9" name="a4abe01140e9514d91cd6057a514321e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abe01140e9514d91cd6057a514321e9">&#9670;&#160;</a></span>deca</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a4abe01140e9514d91cd6057a514321e9">etl::deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3fc89aef3b186473e36d98d651fcecc" name="ab3fc89aef3b186473e36d98d651fcecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fc89aef3b186473e36d98d651fcecc">&#9670;&#160;</a></span>hecto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ab3fc89aef3b186473e36d98d651fcecc">etl::hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56133acde37eca9a5fbe395afee81b71" name="a56133acde37eca9a5fbe395afee81b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56133acde37eca9a5fbe395afee81b71">&#9670;&#160;</a></span>kilo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a56133acde37eca9a5fbe395afee81b71">etl::kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae46b3082c199eb1091a486b255a8fa6a" name="ae46b3082c199eb1091a486b255a8fa6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46b3082c199eb1091a486b255a8fa6a">&#9670;&#160;</a></span>mega</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae46b3082c199eb1091a486b255a8fa6a">etl::mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae410f2def2ff11d6d3690f6359ecfc51" name="ae410f2def2ff11d6d3690f6359ecfc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae410f2def2ff11d6d3690f6359ecfc51">&#9670;&#160;</a></span>giga</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae410f2def2ff11d6d3690f6359ecfc51">etl::giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a9a9ad3120ecbe6d32aea31529f2742" name="a3a9a9ad3120ecbe6d32aea31529f2742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9a9ad3120ecbe6d32aea31529f2742">&#9670;&#160;</a></span>tera</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3a9a9ad3120ecbe6d32aea31529f2742">etl::tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79b2db64fe4fbe00098b99f59227d908" name="a79b2db64fe4fbe00098b99f59227d908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b2db64fe4fbe00098b99f59227d908">&#9670;&#160;</a></span>peta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a79b2db64fe4fbe00098b99f59227d908">etl::peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee0e54567f57499ec5482bfdef64572c" name="aee0e54567f57499ec5482bfdef64572c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0e54567f57499ec5482bfdef64572c">&#9670;&#160;</a></span>exa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aee0e54567f57499ec5482bfdef64572c">etl::exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b6783d01d27625ab2919f8254ad76f9" name="a9b6783d01d27625ab2919f8254ad76f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6783d01d27625ab2919f8254ad76f9">&#9670;&#160;</a></span>static_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'char'. </p>

</div>
</div>
<a id="a095186d92f1db9993904799b96af15bb" name="a095186d92f1db9993904799b96af15bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095186d92f1db9993904799b96af15bb">&#9670;&#160;</a></span>static_wstring</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a095186d92f1db9993904799b96af15bb">etl::static_wstring</a> = <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">wchar_t</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">basic_static_string</a> using 'wchar_t'. </p>

</div>
</div>
<a id="aafbf680e76b153b8a596435b6059846b" name="aafbf680e76b153b8a596435b6059846b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbf680e76b153b8a596435b6059846b">&#9670;&#160;</a></span>string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a> = <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">char</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedefs for common character type. </p>

</div>
</div>
<a id="ac95a227784ffb2786ffbff1dda6a9935" name="ac95a227784ffb2786ffbff1dda6a9935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95a227784ffb2786ffbff1dda6a9935">&#9670;&#160;</a></span>tuple_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">etl::tuple_element_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6bfcfe3186e868223ff85722f343dc0" name="aa6bfcfe3186e868223ff85722f343dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bfcfe3186e868223ff85722f343dc0">&#9670;&#160;</a></span>aligned_storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Len, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Align = alignof(detail::aligned_storage_impl&lt;Len&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa6bfcfe3186e868223ff85722f343dc0">etl::aligned_storage_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1aligned__storage.html">etl::aligned_storage</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Len</a>, <a class="el" href="structetl_1_1static__vector.html">Align</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae90b42ca2c97e25ae857469d922a7b17" name="ae90b42ca2c97e25ae857469d922a7b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90b42ca2c97e25ae857469d922a7b17">&#9670;&#160;</a></span>aligned_union_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Len, typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae90b42ca2c97e25ae857469d922a7b17">etl::aligned_union_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1aligned__union.html">etl::aligned_union</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Len</a>, Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae91dc3f8feab79708723b75f54e9cc21" name="ae91dc3f8feab79708723b75f54e9cc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91dc3f8feab79708723b75f54e9cc21">&#9670;&#160;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae91dc3f8feab79708723b75f54e9cc21">etl::bool_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">B</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a251ff8ada16d1b2942679b1cac95a5ed" name="a251ff8ada16d1b2942679b1cac95a5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251ff8ada16d1b2942679b1cac95a5ed">&#9670;&#160;</a></span>true_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a251ff8ada16d1b2942679b1cac95a5ed">etl::true_type</a> = <a class="el" href="#ae91dc3f8feab79708723b75f54e9cc21">bool_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4427bfeb098157f5bd5c0dc9d4dca6de" name="a4427bfeb098157f5bd5c0dc9d4dca6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4427bfeb098157f5bd5c0dc9d4dca6de">&#9670;&#160;</a></span>false_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a4427bfeb098157f5bd5c0dc9d4dca6de">etl::false_type</a> = <a class="el" href="#ae91dc3f8feab79708723b75f54e9cc21">bool_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">false</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adee609f391eb3188705d52e09cb8fb04" name="adee609f391eb3188705d52e09cb8fb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee609f391eb3188705d52e09cb8fb04">&#9670;&#160;</a></span>common_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#adee609f391eb3188705d52e09cb8fb04">etl::common_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__reference.html">common_reference</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1049bbee37ab0c1445bcd7f020d6ce0c" name="a1049bbee37ab0c1445bcd7f020d6ce0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1049bbee37ab0c1445bcd7f020d6ce0c">&#9670;&#160;</a></span>common_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1049bbee37ab0c1445bcd7f020d6ce0c">etl::common_type_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1common__type.html">etl::common_type</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab39305667768a11caaca93abf03c21ce" name="ab39305667768a11caaca93abf03c21ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39305667768a11caaca93abf03c21ce">&#9670;&#160;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ab39305667768a11caaca93abf03c21ce">etl::conditional_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1conditional.html">etl::conditional</a>&lt;<a class="el" href="structetl_1_1static__vector.html">B</a>, T, <a class="el" href="structetl_1_1static__vector.html">F</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac731e2d13871fb7848c6f0ccde332949" name="ac731e2d13871fb7848c6f0ccde332949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac731e2d13871fb7848c6f0ccde332949">&#9670;&#160;</a></span>decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">etl::decay_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7938694f396828f208ccae1688c9c611" name="a7938694f396828f208ccae1688c9c611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7938694f396828f208ccae1688c9c611">&#9670;&#160;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a> B, <a class="el" href="structetl_1_1static__vector.html">typename</a> T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a7938694f396828f208ccae1688c9c611">etl::enable_if_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structetl_1_1static__vector.html">B</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8298a20279ec5d2a5df508272115cc3" name="aa8298a20279ec5d2a5df508272115cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8298a20279ec5d2a5df508272115cc3">&#9670;&#160;</a></span>index_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa8298a20279ec5d2a5df508272115cc3">etl::index_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">etl::integral_constant</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>, <a class="el" href="structetl_1_1static__vector.html">I</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad47ced64dcc2c2322893df26022403c5" name="ad47ced64dcc2c2322893df26022403c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47ced64dcc2c2322893df26022403c5">&#9670;&#160;</a></span>invoke_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... ArgTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad47ced64dcc2c2322893df26022403c5">etl::invoke_result_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1invoke__result.html">etl::invoke_result</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, ArgTypes...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43743001594f300bde6a116196b1a2b8" name="a43743001594f300bde6a116196b1a2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43743001594f300bde6a116196b1a2b8">&#9670;&#160;</a></span>is_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a43743001594f300bde6a116196b1a2b8">etl::is_constructible</a> = detail::is_constructible_helper&lt;<a class="el" href="#ab24730cbedd18b7acd975fd5dddadb3e">etl::void_t</a>&lt;&gt;, T, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace93b7d8b1e564390c651a2e9a3a11f0" name="ace93b7d8b1e564390c651a2e9a3a11f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace93b7d8b1e564390c651a2e9a3a11f0">&#9670;&#160;</a></span>make_signed_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ace93b7d8b1e564390c651a2e9a3a11f0">etl::make_signed_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3362d26921844abefbea548c78556d1" name="af3362d26921844abefbea548c78556d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3362d26921844abefbea548c78556d1">&#9670;&#160;</a></span>make_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af3362d26921844abefbea548c78556d1">etl::make_unsigned_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90a0440e799b90521d5959686b4282fb" name="a90a0440e799b90521d5959686b4282fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a0440e799b90521d5959686b4282fb">&#9670;&#160;</a></span>remove_all_extents_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a90a0440e799b90521d5959686b4282fb">etl::remove_all_extents_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60a45d5e6c658b2e351cfff1be97d293" name="a60a45d5e6c658b2e351cfff1be97d293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a45d5e6c658b2e351cfff1be97d293">&#9670;&#160;</a></span>remove_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a60a45d5e6c658b2e351cfff1be97d293">etl::remove_const_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__const.html">etl::remove_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d3ea939d0e932fceedbae01d7a3af90" name="a7d3ea939d0e932fceedbae01d7a3af90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3ea939d0e932fceedbae01d7a3af90">&#9670;&#160;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a7d3ea939d0e932fceedbae01d7a3af90">etl::remove_cv_t</a> = <a class="el" href="#a60a45d5e6c658b2e351cfff1be97d293">etl::remove_const_t</a>&lt;<a class="el" href="#a3946b4f225aed94dc2bd43033712b219">etl::remove_volatile_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fff237ed0afc787415c06ce1315553e" name="a2fff237ed0afc787415c06ce1315553e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fff237ed0afc787415c06ce1315553e">&#9670;&#160;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a2fff237ed0afc787415c06ce1315553e">etl::remove_cvref_t</a> = <a class="el" href="#a7d3ea939d0e932fceedbae01d7a3af90">etl::remove_cv_t</a>&lt;<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96fa88f2463bb67e914b54eb17bc6e64" name="a96fa88f2463bb67e914b54eb17bc6e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fa88f2463bb67e914b54eb17bc6e64">&#9670;&#160;</a></span>remove_extent_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a96fa88f2463bb67e914b54eb17bc6e64">etl::remove_extent_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__extent.html">etl::remove_extent</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8897fe2703cfaabd33c46ba2ae13b5e2" name="a8897fe2703cfaabd33c46ba2ae13b5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8897fe2703cfaabd33c46ba2ae13b5e2">&#9670;&#160;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a8897fe2703cfaabd33c46ba2ae13b5e2">etl::remove_pointer_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__pointer.html">etl::remove_pointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa53ab28b069b34ebab412b775f8999ab" name="aa53ab28b069b34ebab412b775f8999ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53ab28b069b34ebab412b775f8999ab">&#9670;&#160;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3946b4f225aed94dc2bd43033712b219" name="a3946b4f225aed94dc2bd43033712b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3946b4f225aed94dc2bd43033712b219">&#9670;&#160;</a></span>remove_volatile_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3946b4f225aed94dc2bd43033712b219">etl::remove_volatile_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1remove__volatile.html">etl::remove_volatile</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6de5169fe6c7349d18aac6efef76f30f" name="a6de5169fe6c7349d18aac6efef76f30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5169fe6c7349d18aac6efef76f30f">&#9670;&#160;</a></span>smallest_size_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a6de5169fe6c7349d18aac6efef76f30f">etl::smallest_size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">            <a class="code hl_struct" href="structetl_1_1static__vector.html">etl::conditional_t&lt;(N &lt; static_cast&lt;unsigned char&gt;</a>(-1)),     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>,</div>
<div class="line">            <a class="code hl_typedef" href="#ab39305667768a11caaca93abf03c21ce">etl::conditional_t</a>&lt;(N &lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span><span class="keyword">&gt;</span>(-1)),    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>,</div>
<div class="line">            <a class="code hl_typedef" href="#ab39305667768a11caaca93abf03c21ce">etl::conditional_t</a>&lt;(N &lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(-1)),      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,</div>
<div class="line">            <a class="code hl_typedef" href="#ab39305667768a11caaca93abf03c21ce">etl::conditional_t</a>&lt;(N &lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(-1)),     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,</div>
<div class="line">                                                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>&gt;&gt;&gt;&gt;</div>
<div class="ttc" id="anamespaceetl_html_ab39305667768a11caaca93abf03c21ce"><div class="ttname"><a href="#ab39305667768a11caaca93abf03c21ce">etl::conditional_t</a></div><div class="ttdeci">typename etl::conditional&lt; B, T, F &gt;::type conditional_t</div><div class="ttdef"><b>Definition</b> conditional.hpp:21</div></div>
<div class="ttc" id="astructetl_1_1static__vector_html"><div class="ttname"><a href="structetl_1_1static__vector.html">etl::static_vector</a></div><div class="ttdoc">Dynamically-resizable fixed-capacity vector.</div><div class="ttdef"><b>Definition</b> static_vector.hpp:326</div></div>
</div><!-- fragment -->
<p>Smallest fixed-width unsigned integer type that can represent values in the range [0, N]. </p>

</div>
</div>
<a id="aca5bede918f0a9391b776b0721c80e40" name="aca5bede918f0a9391b776b0721c80e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5bede918f0a9391b776b0721c80e40">&#9670;&#160;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#aca5bede918f0a9391b776b0721c80e40">etl::type_identity_t</a> = T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac73e7dfe08364dfb94ca2fafa560a559" name="ac73e7dfe08364dfb94ca2fafa560a559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73e7dfe08364dfb94ca2fafa560a559">&#9670;&#160;</a></span>underlying_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ac73e7dfe08364dfb94ca2fafa560a559">etl::underlying_type_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1underlying__type.html">etl::underlying_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e3d889e3a1a2b38c9faf0939d900514" name="a1e3d889e3a1a2b38c9faf0939d900514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3d889e3a1a2b38c9faf0939d900514">&#9670;&#160;</a></span>unwrap_ref_decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a1e3d889e3a1a2b38c9faf0939d900514">etl::unwrap_ref_decay_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1unwrap__ref__decay.html">etl::unwrap_ref_decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab24730cbedd18b7acd975fd5dddadb3e" name="ab24730cbedd18b7acd975fd5dddadb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24730cbedd18b7acd975fd5dddadb3e">&#9670;&#160;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ab24730cbedd18b7acd975fd5dddadb3e">etl::void_t</a> = <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afaf82c69e1c6f2ddf23f227a9931b8ca" name="afaf82c69e1c6f2ddf23f227a9931b8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf82c69e1c6f2ddf23f227a9931b8ca">&#9670;&#160;</a></span>index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t... Ints&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#afaf82c69e1c6f2ddf23f227a9931b8ca">etl::index_sequence</a> = <a class="el" href="structetl_1_1integer__sequence.html">etl::integer_sequence</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>, Ints...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aebb59d8745facee9c0002882401c78" name="a3aebb59d8745facee9c0002882401c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aebb59d8745facee9c0002882401c78">&#9670;&#160;</a></span>make_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#a3aebb59d8745facee9c0002882401c78">etl::make_index_sequence</a> = <a class="el" href="#ae3e45bc6e2d57d570b8b026a50c075fb">etl::make_integer_sequence</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af71fc9c72974e4f7f357106bdac43d7a" name="af71fc9c72974e4f7f357106bdac43d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71fc9c72974e4f7f357106bdac43d7a">&#9670;&#160;</a></span>index_sequence_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#af71fc9c72974e4f7f357106bdac43d7a">etl::index_sequence_for</a> = <a class="el" href="#a3aebb59d8745facee9c0002882401c78">etl::make_index_sequence</a>&lt;sizeof...(T)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3e45bc6e2d57d570b8b026a50c075fb" name="ae3e45bc6e2d57d570b8b026a50c075fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e45bc6e2d57d570b8b026a50c075fb">&#9670;&#160;</a></span>make_integer_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , T Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ae3e45bc6e2d57d570b8b026a50c075fb">etl::make_integer_sequence</a> = <a class="el" href="builtin__functions_8hpp.html#a303c6144751de3e45c44990112e8b1cb">TETL_BUILTIN_INT_SEQ</a>(T, <a class="el" href="structetl_1_1static__vector.html">Size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad029dc8759242c03cbb2d3507ccb0f4e" name="ad029dc8759242c03cbb2d3507ccb0f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad029dc8759242c03cbb2d3507ccb0f4e">&#9670;&#160;</a></span>variant_alternative_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">using</a> <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">etl::variant_alternative_t</a> = <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="af524d0acb625979997f7a2dd1c0ea944" name="af524d0acb625979997f7a2dd1c0ea944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524d0acb625979997f7a2dd1c0ea944">&#9670;&#160;</a></span>chars_format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#af524d0acb625979997f7a2dd1c0ea944">etl::chars_format</a> : <a class="el" href="#af5cb8d6d7baf449891507753e9a62587">etl::uint8_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A BitmaskType used to specify floating-point formatting for to_chars and from_chars. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af524d0acb625979997f7a2dd1c0ea944a55a95650a66b53ecbb960b53d985b964" name="af524d0acb625979997f7a2dd1c0ea944a55a95650a66b53ecbb960b53d985b964"></a>scientific&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af524d0acb625979997f7a2dd1c0ea944acec315e3d0975e5cc2811d5d8725f149" name="af524d0acb625979997f7a2dd1c0ea944acec315e3d0975e5cc2811d5d8725f149"></a>fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af524d0acb625979997f7a2dd1c0ea944ab8d1b43eae73587ba56baef574709ecb" name="af524d0acb625979997f7a2dd1c0ea944ab8d1b43eae73587ba56baef574709ecb"></a>hex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af524d0acb625979997f7a2dd1c0ea944a958153f1b8b96ec4c4eb2147429105d9" name="af524d0acb625979997f7a2dd1c0ea944a958153f1b8b96ec4c4eb2147429105d9"></a>general&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad4892bd9af0bd3ad759fb95ab241247c" name="ad4892bd9af0bd3ad759fb95ab241247c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4892bd9af0bd3ad759fb95ab241247c">&#9670;&#160;</a></span>float_denorm_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="#ad4892bd9af0bd3ad759fb95ab241247c">etl::float_denorm_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287" name="ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287"></a>denorm_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141" name="ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141"></a>denorm_absent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5" name="ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5"></a>denorm_present&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0cdec522db16c755ade7c7222bf8af92" name="a0cdec522db16c755ade7c7222bf8af92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdec522db16c755ade7c7222bf8af92">&#9670;&#160;</a></span>float_round_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="#a0cdec522db16c755ade7c7222bf8af92">etl::float_round_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b" name="a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b"></a>round_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d" name="a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d"></a>round_toward_zero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3" name="a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3"></a>round_to_nearest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0" name="a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0"></a>round_toward_infinity&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f" name="a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f"></a>round_toward_neg_infinity&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a91722a64a739818dbac515ddd4ea5387" name="a91722a64a739818dbac515ddd4ea5387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91722a64a739818dbac515ddd4ea5387">&#9670;&#160;</a></span>align_val_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#a91722a64a739818dbac515ddd4ea5387">etl::align_val_t</a> : <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than the default, pass that alignment requirement as an argument of type align_val_t to the selected allocation/deallocation function. </p>

</div>
</div>
<a id="abf855e66ccd0c031e0994ed578f1c170" name="abf855e66ccd0c031e0994ed578f1c170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf855e66ccd0c031e0994ed578f1c170">&#9670;&#160;</a></span>errc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170">etl::errc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scoped enumeration <a class="el" href="#abf855e66ccd0c031e0994ed578f1c170" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8ab69162f060cc46b805b3265ad1cdf1" name="abf855e66ccd0c031e0994ed578f1c170a8ab69162f060cc46b805b3265ad1cdf1"></a>address_family_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8e2bc80599069d337b43dff6edfb6891" name="abf855e66ccd0c031e0994ed578f1c170a8e2bc80599069d337b43dff6edfb6891"></a>address_in_use&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a20abf2ffbf6e82e36405843f269d6438" name="abf855e66ccd0c031e0994ed578f1c170a20abf2ffbf6e82e36405843f269d6438"></a>address_not_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ab5580b198f691ab2df12f5e2ab974373" name="abf855e66ccd0c031e0994ed578f1c170ab5580b198f691ab2df12f5e2ab974373"></a>already_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a1b245b26b5ea3428c050d7f1503d7715" name="abf855e66ccd0c031e0994ed578f1c170a1b245b26b5ea3428c050d7f1503d7715"></a>argument_list_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4b82222a0895b538d0597092b3ceab3e" name="abf855e66ccd0c031e0994ed578f1c170a4b82222a0895b538d0597092b3ceab3e"></a>argument_out_of_domain&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aaf169f73a82794128aa491c4b4f1c071" name="abf855e66ccd0c031e0994ed578f1c170aaf169f73a82794128aa491c4b4f1c071"></a>bad_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a9941c5c8c58ff058b870e94e96ac38e1" name="abf855e66ccd0c031e0994ed578f1c170a9941c5c8c58ff058b870e94e96ac38e1"></a>bad_file_descriptor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ac7944ab5d2e25bf75b267d070b506d1c" name="abf855e66ccd0c031e0994ed578f1c170ac7944ab5d2e25bf75b267d070b506d1c"></a>bad_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2f0338eed54503152be1d31c93c9c2f1" name="abf855e66ccd0c031e0994ed578f1c170a2f0338eed54503152be1d31c93c9c2f1"></a>broken_pipe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2f8f27a7eef1ad585c7ab6f25a6c2c79" name="abf855e66ccd0c031e0994ed578f1c170a2f8f27a7eef1ad585c7ab6f25a6c2c79"></a>connection_aborted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a81cf222a9b1530171fdfd66c3f734989" name="abf855e66ccd0c031e0994ed578f1c170a81cf222a9b1530171fdfd66c3f734989"></a>connection_already_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a53793ee58fc24168a0d6549c3cb2df8e" name="abf855e66ccd0c031e0994ed578f1c170a53793ee58fc24168a0d6549c3cb2df8e"></a>connection_refused&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abf39bfc8665384194e343c08ab344405" name="abf855e66ccd0c031e0994ed578f1c170abf39bfc8665384194e343c08ab344405"></a>connection_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6177070a517d51a4382ab0d7c88e5b58" name="abf855e66ccd0c031e0994ed578f1c170a6177070a517d51a4382ab0d7c88e5b58"></a>cross_device_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a326032e01f2a5e14c7f730f4d03d753a" name="abf855e66ccd0c031e0994ed578f1c170a326032e01f2a5e14c7f730f4d03d753a"></a>destination_address_required&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ab3ab5338a00f49c4451851cc5442f370" name="abf855e66ccd0c031e0994ed578f1c170ab3ab5338a00f49c4451851cc5442f370"></a>device_or_resource_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6a336135d33e62f49edc55f29354e12e" name="abf855e66ccd0c031e0994ed578f1c170a6a336135d33e62f49edc55f29354e12e"></a>directory_not_empty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4dfaf9c996cf045f32d17edc9754fc95" name="abf855e66ccd0c031e0994ed578f1c170a4dfaf9c996cf045f32d17edc9754fc95"></a>executable_format_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a41edf636e3c7b59f797348fc58472258" name="abf855e66ccd0c031e0994ed578f1c170a41edf636e3c7b59f797348fc58472258"></a>file_exists&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa1e14bfb89b41ddf654b1772c8fd2e74" name="abf855e66ccd0c031e0994ed578f1c170aa1e14bfb89b41ddf654b1772c8fd2e74"></a>file_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6e56e6ed055b9771b8192a4f229fee27" name="abf855e66ccd0c031e0994ed578f1c170a6e56e6ed055b9771b8192a4f229fee27"></a>filename_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa33c516bbdfb179cef733c8daeb97bed" name="abf855e66ccd0c031e0994ed578f1c170aa33c516bbdfb179cef733c8daeb97bed"></a>function_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afe2377fbd16d7f335474e1df7d6376bf" name="abf855e66ccd0c031e0994ed578f1c170afe2377fbd16d7f335474e1df7d6376bf"></a>host_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a054e5b4ff59331386872de744d661719" name="abf855e66ccd0c031e0994ed578f1c170a054e5b4ff59331386872de744d661719"></a>identifier_removed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a53a9e57a679708b2d8ff0ccd8ec96b18" name="abf855e66ccd0c031e0994ed578f1c170a53a9e57a679708b2d8ff0ccd8ec96b18"></a>illegal_byte_sequence&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a45fe7da1767194b580aeba752d7b44ae" name="abf855e66ccd0c031e0994ed578f1c170a45fe7da1767194b580aeba752d7b44ae"></a>inappropriate_io_control_operation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afadb76763385627e57ec386c9b6038f0" name="abf855e66ccd0c031e0994ed578f1c170afadb76763385627e57ec386c9b6038f0"></a>interrupted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae55d43eabeefe5a8271b4a3c898bd18f" name="abf855e66ccd0c031e0994ed578f1c170ae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abd86a2c65caf6a270b916234ab321ce3" name="abf855e66ccd0c031e0994ed578f1c170abd86a2c65caf6a270b916234ab321ce3"></a>invalid_seek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170acccc32f2a5f7dc7b87d2f85daea66789" name="abf855e66ccd0c031e0994ed578f1c170acccc32f2a5f7dc7b87d2f85daea66789"></a>io_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170af3c51d7ea75a76f26c0a2bdc00c4e006" name="abf855e66ccd0c031e0994ed578f1c170af3c51d7ea75a76f26c0a2bdc00c4e006"></a>is_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ade5f4bc2f8a4690176e22e83196b9fd3" name="abf855e66ccd0c031e0994ed578f1c170ade5f4bc2f8a4690176e22e83196b9fd3"></a>message_size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a93b16d34b1689f66f0cfed60e99c0009" name="abf855e66ccd0c031e0994ed578f1c170a93b16d34b1689f66f0cfed60e99c0009"></a>network_down&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a0e1d200ae35ede416bf85f84093ce37a" name="abf855e66ccd0c031e0994ed578f1c170a0e1d200ae35ede416bf85f84093ce37a"></a>network_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a608a68344b4eb1fe0690861a83828816" name="abf855e66ccd0c031e0994ed578f1c170a608a68344b4eb1fe0690861a83828816"></a>network_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a618ead44397b73cf0baa08b460b66c39" name="abf855e66ccd0c031e0994ed578f1c170a618ead44397b73cf0baa08b460b66c39"></a>no_buffer_space&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad08d4c854a6810cebd2a8ab61876f919" name="abf855e66ccd0c031e0994ed578f1c170ad08d4c854a6810cebd2a8ab61876f919"></a>no_child_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170add431dfaf61ea842693dca8be1ebcaf7" name="abf855e66ccd0c031e0994ed578f1c170add431dfaf61ea842693dca8be1ebcaf7"></a>no_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a58688487c3e24313637a76bd29881e64" name="abf855e66ccd0c031e0994ed578f1c170a58688487c3e24313637a76bd29881e64"></a>no_lock_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aeec0f03ad92584c78835c10ab79d7f42" name="abf855e66ccd0c031e0994ed578f1c170aeec0f03ad92584c78835c10ab79d7f42"></a>no_message_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170acec935db07cfc57caafa37e98eafb213" name="abf855e66ccd0c031e0994ed578f1c170acec935db07cfc57caafa37e98eafb213"></a>no_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abed8a9032d9366c28582a0ad59a31525" name="abf855e66ccd0c031e0994ed578f1c170abed8a9032d9366c28582a0ad59a31525"></a>no_protocol_option&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a1a5334dd8d1ca56e33887bd44630641b" name="abf855e66ccd0c031e0994ed578f1c170a1a5334dd8d1ca56e33887bd44630641b"></a>no_space_on_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad8b1d94a0ac09c6d55b2ed68f0836142" name="abf855e66ccd0c031e0994ed578f1c170ad8b1d94a0ac09c6d55b2ed68f0836142"></a>no_stream_resources&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a5c83a012eac17bbf458df5804801e373" name="abf855e66ccd0c031e0994ed578f1c170a5c83a012eac17bbf458df5804801e373"></a>no_such_device_or_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170af42b2e58729e2783b683c8610977fc22" name="abf855e66ccd0c031e0994ed578f1c170af42b2e58729e2783b683c8610977fc22"></a>no_such_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2e70fc89b08f26fa3fc77694c91e8f7a" name="abf855e66ccd0c031e0994ed578f1c170a2e70fc89b08f26fa3fc77694c91e8f7a"></a>no_such_file_or_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad91a9b8a734f2bef4b778f89806cbab7" name="abf855e66ccd0c031e0994ed578f1c170ad91a9b8a734f2bef4b778f89806cbab7"></a>no_such_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a21e867ca95e1dfecff4701863547dcec" name="abf855e66ccd0c031e0994ed578f1c170a21e867ca95e1dfecff4701863547dcec"></a>not_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a22ac64bb14c46bcbc338a21950b6e722" name="abf855e66ccd0c031e0994ed578f1c170a22ac64bb14c46bcbc338a21950b6e722"></a>not_a_socket&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6e752b7a04543e5052b2d0dd05eca0fa" name="abf855e66ccd0c031e0994ed578f1c170a6e752b7a04543e5052b2d0dd05eca0fa"></a>not_a_stream&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a69c2dbb5917ca550a862e9c1c839bca1" name="abf855e66ccd0c031e0994ed578f1c170a69c2dbb5917ca550a862e9c1c839bca1"></a>not_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aafdb5594dc3e484fc1bfd7c564d550c1" name="abf855e66ccd0c031e0994ed578f1c170aafdb5594dc3e484fc1bfd7c564d550c1"></a>not_enough_memory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa55e82356e9721946aa9ba954733c6f0" name="abf855e66ccd0c031e0994ed578f1c170aa55e82356e9721946aa9ba954733c6f0"></a>not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afd3d0bdcc9eb9e68534b7d055c5fe586" name="abf855e66ccd0c031e0994ed578f1c170afd3d0bdcc9eb9e68534b7d055c5fe586"></a>operation_canceled&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4c7eb50b6d86ac8a130ebebc18dbe263" name="abf855e66ccd0c031e0994ed578f1c170a4c7eb50b6d86ac8a130ebebc18dbe263"></a>operation_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8344b3d509942f035d5e303022f9b986" name="abf855e66ccd0c031e0994ed578f1c170a8344b3d509942f035d5e303022f9b986"></a>operation_not_permitted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a69bf074bf052ee4c9047b62fe7c24569" name="abf855e66ccd0c031e0994ed578f1c170a69bf074bf052ee4c9047b62fe7c24569"></a>operation_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a738abdaead9cd7b2e2ea19a34764b385" name="abf855e66ccd0c031e0994ed578f1c170a738abdaead9cd7b2e2ea19a34764b385"></a>operation_would_block&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2abac2fa6722c56b2ea17ac6c4097f68" name="abf855e66ccd0c031e0994ed578f1c170a2abac2fa6722c56b2ea17ac6c4097f68"></a>owner_dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae8ee838822072f02738dbd7d97ea03fc" name="abf855e66ccd0c031e0994ed578f1c170ae8ee838822072f02738dbd7d97ea03fc"></a>permission_denied&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a9665c745d0a9132d8da6ed55e89a0564" name="abf855e66ccd0c031e0994ed578f1c170a9665c745d0a9132d8da6ed55e89a0564"></a>protocol_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa2635acef8b9a3e1c40923829722d472" name="abf855e66ccd0c031e0994ed578f1c170aa2635acef8b9a3e1c40923829722d472"></a>protocol_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a06108efce8ef1cd8aa4cc440f8b4317f" name="abf855e66ccd0c031e0994ed578f1c170a06108efce8ef1cd8aa4cc440f8b4317f"></a>read_only_file_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aed65f7649c6f0e365673d65a9d8119d8" name="abf855e66ccd0c031e0994ed578f1c170aed65f7649c6f0e365673d65a9d8119d8"></a>resource_deadlock_would_occur&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae46a97ea2906921c8c626890bde832cf" name="abf855e66ccd0c031e0994ed578f1c170ae46a97ea2906921c8c626890bde832cf"></a>resource_unavailable_try_again&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8e0fafb181567cc468e1ee81983d739d" name="abf855e66ccd0c031e0994ed578f1c170a8e0fafb181567cc468e1ee81983d739d"></a>result_out_of_range&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6805059549401365b824b54573a6f46e" name="abf855e66ccd0c031e0994ed578f1c170a6805059549401365b824b54573a6f46e"></a>state_not_recoverable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ac1a620a30954dc9402a811453c2c3e3f" name="abf855e66ccd0c031e0994ed578f1c170ac1a620a30954dc9402a811453c2c3e3f"></a>stream_timeout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad2f80f12d22bb099fcf1062db660b567" name="abf855e66ccd0c031e0994ed578f1c170ad2f80f12d22bb099fcf1062db660b567"></a>text_file_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a56c27b1ab1a5a5a0eae853cabb4dc0c1" name="abf855e66ccd0c031e0994ed578f1c170a56c27b1ab1a5a5a0eae853cabb4dc0c1"></a>timed_out&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a3130d1d4e000cdc1e7c47013e313c10e" name="abf855e66ccd0c031e0994ed578f1c170a3130d1d4e000cdc1e7c47013e313c10e"></a>too_many_files_open_in_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aed2c33c8fe874cfeba6f4a7747c62d05" name="abf855e66ccd0c031e0994ed578f1c170aed2c33c8fe874cfeba6f4a7747c62d05"></a>too_many_files_open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abfe22fc9b27a8ff13186aba60b6bc5c8" name="abf855e66ccd0c031e0994ed578f1c170abfe22fc9b27a8ff13186aba60b6bc5c8"></a>too_many_links&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a33c78baca1480479c88aa4d50cb68206" name="abf855e66ccd0c031e0994ed578f1c170a33c78baca1480479c88aa4d50cb68206"></a>too_many_symbolic_link_levels&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a143653b075bff946193644ba6d97fa5d" name="abf855e66ccd0c031e0994ed578f1c170a143653b075bff946193644ba6d97fa5d"></a>value_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a81cac28a38438710de9856af4a8bcd0b" name="abf855e66ccd0c031e0994ed578f1c170a81cac28a38438710de9856af4a8bcd0b"></a>wrong_protocol_type&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a035e7d2ea0f6aebad724e7fab40495d5" name="a035e7d2ea0f6aebad724e7fab40495d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035e7d2ea0f6aebad724e7fab40495d5">&#9670;&#160;</a></span>implementation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#a035e7d2ea0f6aebad724e7fab40495d5">etl::implementation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1" name="a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1"></a>freestanding&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a035e7d2ea0f6aebad724e7fab40495d5a734d3030ff72ad8d9678efa82b1db7d2" name="a035e7d2ea0f6aebad724e7fab40495d5a734d3030ff72ad8d9678efa82b1db7d2"></a>hosted&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a2f63a594bf7e2b29cb07e1868483ee53" name="a2f63a594bf7e2b29cb07e1868483ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f63a594bf7e2b29cb07e1868483ee53">&#9670;&#160;</a></span>language_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="structetl_1_1static__vector.html">struct</a> <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">etl::language_standard</a> : <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">char</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for the currently selected C++ standard version. Unlike the official macro <code>__cplusplus</code>, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2f63a594bf7e2b29cb07e1868483ee53a6289bbfa378818f7066ccad5847da5a2" name="a2f63a594bf7e2b29cb07e1868483ee53a6289bbfa378818f7066ccad5847da5a2"></a>cpp_17&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f63a594bf7e2b29cb07e1868483ee53a4c7aabdc3eb0d845c62edfb822b0fe5a" name="a2f63a594bf7e2b29cb07e1868483ee53a4c7aabdc3eb0d845c62edfb822b0fe5a"></a>cpp_20&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f63a594bf7e2b29cb07e1868483ee53af7d98f68372c9de30cc2d571b75b19d7" name="a2f63a594bf7e2b29cb07e1868483ee53af7d98f68372c9de30cc2d571b75b19d7"></a>cpp_23&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff" name="a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff"></a>cpp_26&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3f9162720047d01bb438874bf56df5d2" name="a3f9162720047d01bb438874bf56df5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9162720047d01bb438874bf56df5d2">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt</a>&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">value</td><td>The value to search for.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a> </p>

</div>
</div>
<a id="a9be834c1a5353b7d9b51d77cd30a9654" name="a9be834c1a5353b7d9b51d77cd30a9654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be834c1a5353b7d9b51d77cd30a9654">&#9670;&#160;</a></span>equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise. </p>

</div>
</div>
<a id="a934bfc901fe1ed60e93f7f9b9fb34079" name="a934bfc901fe1ed60e93f7f9b9fb34079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934bfc901fe1ed60e93f7f9b9fb34079">&#9670;&#160;</a></span>equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dda20bb1c4958e2a9ce23f6ebd4fb9c" name="a7dda20bb1c4958e2a9ce23f6ebd4fb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dda20bb1c4958e2a9ce23f6ebd4fb9c">&#9670;&#160;</a></span>equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19bb44dc832eef8b58d30b1cc70411ff" name="a19bb44dc832eef8b58d30b1cc70411ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bb44dc832eef8b58d30b1cc70411ff">&#9670;&#160;</a></span>equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a292ca875d178a8cfb23a5b2f74d5ed33" name="a292ca875d178a8cfb23a5b2f74d5ed33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292ca875d178a8cfb23a5b2f74d5ed33">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a> </p>

</div>
</div>
<a id="af67b5001d764da2ece198e4fc86fde26" name="af67b5001d764da2ece198e4fc86fde26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67b5001d764da2ece198e4fc86fde26">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::equal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a086d2ed75d087dea9497d60549d77485" name="a086d2ed75d087dea9497d60549d77485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086d2ed75d087dea9497d60549d77485">&#9670;&#160;</a></span>exchange_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::exchange_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort">https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort</a>. </p>

</div>
</div>
<a id="a9635d27783910f84b9a83730f26f2c19" name="a9635d27783910f84b9a83730f26f2c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9635d27783910f84b9a83730f26f2c19">&#9670;&#160;</a></span>exchange_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::exchange_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa11bb84e871a5db6b2a230e5ef065234" name="aa11bb84e871a5db6b2a230e5ef065234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11bb84e871a5db6b2a230e5ef065234">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value to the elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ad5ac240345a96ad39668967bf8bdf76f" name="ad5ac240345a96ad39668967bf8bdf76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ac240345a96ad39668967bf8bdf76f">&#9670;&#160;</a></span>fill_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fill_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator one past the last element assigned if <code>count &gt; 0</code>, <code>first</code> otherwise. </dd></dl>

</div>
</div>
<a id="a074d4da4cb7d3a678c5ae1fce471ddfb" name="a074d4da4cb7d3a678c5ae1fce471ddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074d4da4cb7d3a678c5ae1fce471ddfb">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element equal to value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">value</td><td>Value to compare the elements to.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a0">algorithm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7c8d78c0146673a9463dc7c68540b963" name="a7c8d78c0146673a9463dc7c68540b963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8d78c0146673a9463dc7c68540b963">&#9670;&#160;</a></span>find_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for </td></tr>
    <tr><td class="paramname">p</td><td>Binary predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the beginning of last occurrence of the sequence [sFirst, sLast) in range <code>[first, last)</code>. If [sFirst, sLast) is empty or if no such sequence is found, last is returned. </dd></dl>

</div>
</div>
<a id="a67a3af0f6b1ea2008b53ed21446814f5" name="a67a3af0f6b1ea2008b53ed21446814f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a3af0f6b1ea2008b53ed21446814f5">&#9670;&#160;</a></span>find_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::find_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea99982a37144ad397257540600269a0" name="aea99982a37144ad397257540600269a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea99982a37144ad397257540600269a0">&#9670;&#160;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of">https://en.cppreference.com/w/cpp/algorithm/find_first_of</a> </p>

</div>
</div>
<a id="a4931d3f143272627df883beae8bd9bd5" name="a4931d3f143272627df883beae8bd9bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4931d3f143272627df883beae8bd9bd5">&#9670;&#160;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of">https://en.cppreference.com/w/cpp/algorithm/find_first_of</a> </p>

</div>
</div>
<a id="a9c802502e6a81c3b77d98dbcaf030c19" name="a9c802502e6a81c3b77d98dbcaf030c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c802502e6a81c3b77d98dbcaf030c19">&#9670;&#160;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::find_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate p returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Unary predicate which returns true for the required element.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>

</div>
</div>
<a id="a29e68ff6f7166005f9862c8772fa43fd" name="a29e68ff6f7166005f9862c8772fa43fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e68ff6f7166005f9862c8772fa43fd">&#9670;&#160;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::find_if_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate q returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">pred</td><td>Unary predicate which returns true for the required element.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find">https://en.cppreference.com/w/cpp/algorithm/find</a> </p>

</div>
</div>
<a id="a3ad01de69ea01da886464fc3ef1390cc" name="a3ad01de69ea01da886464fc3ef1390cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad01de69ea01da886464fc3ef1390cc">&#9670;&#160;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::for_each </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range to apply the function to. </td></tr>
    <tr><td class="paramname">last</td><td>The range to apply the function to. </td></tr>
    <tr><td class="paramname">f</td><td>Function object, to be applied to the result of dereferencing every iterator in the range.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each">https://en.cppreference.com/w/cpp/algorithm/for_each</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a1">algorithm.cpp</a>, and <a class="el" href="set_8cpp-example.html#a1">set.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab9839f986201c53e618b3435d27ad43a" name="ab9839f986201c53e618b3435d27ad43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9839f986201c53e618b3435d27ad43a">&#9670;&#160;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::for_each_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">UnaryFunc</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to apply the function to. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements to apply the function to. </td></tr>
    <tr><td class="paramname">f</td><td>Function object, to be applied to the result of dereferencing every iterator in the range.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each_n">https://en.cppreference.com/w/cpp/algorithm/for_each_n</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="algorithm_8cpp-example.html#a2">algorithm.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0b963791bdb1da038a64b23555f245c4" name="a0b963791bdb1da038a64b23555f245c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b963791bdb1da038a64b23555f245c4">&#9670;&#160;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Generator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Generator</a></td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns each element in range <code>[first, last)</code> a value generated by the given function object g. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">g</td><td>Generator function object that will be called.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate">https://en.cppreference.com/w/cpp/algorithm/generate</a> </p>

</div>
</div>
<a id="ab984bfa2eb0fd6da7369b629ca3acdc7" name="ab984bfa2eb0fd6da7369b629ca3acdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984bfa2eb0fd6da7369b629ca3acdc7">&#9670;&#160;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">SizeT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Generator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::generate_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">SizeT</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Generator</a></td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to generate. </td></tr>
    <tr><td class="paramname">count</td><td>Number of the elements to generate. </td></tr>
    <tr><td class="paramname">g</td><td>Generator function object that will be called.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate_n">https://en.cppreference.com/w/cpp/algorithm/generate_n</a> </p>

</div>
</div>
<a id="a72d92f2387c738f0636ab8495aa18613" name="a72d92f2387c738f0636ab8495aa18613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d92f2387c738f0636ab8495aa18613">&#9670;&#160;</a></span>gnome_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::gnome_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Gnome_sort">https://en.wikipedia.org/wiki/Gnome_sort</a>. </p>

</div>
</div>
<a id="add4a4559a0af0147ebc0d7572dbc142e" name="add4a4559a0af0147ebc0d7572dbc142e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4a4559a0af0147ebc0d7572dbc142e">&#9670;&#160;</a></span>gnome_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::gnome_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f97df033ed5dc7c5458f991078633d9" name="a2f97df033ed5dc7c5458f991078633d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f97df033ed5dc7c5458f991078633d9">&#9670;&#160;</a></span>includes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::includes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted. </p>

</div>
</div>
<a id="acc7d9a038b385aff889235d470b837e4" name="acc7d9a038b385aff889235d470b837e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7d9a038b385aff889235d470b837e4">&#9670;&#160;</a></span>includes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::includes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8a63b710f7e13e8142d025fe5f2ef94" name="af8a63b710f7e13e8142d025fe5f2ef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a63b710f7e13e8142d025fe5f2ef94">&#9670;&#160;</a></span>inplace_merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::inplace_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>mid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). </p>
<p>A sequence [first, last) is said to be sorted with respect to a comparator comp if for any iterator it pointing comp(*(it + n), *it) evaluates to false.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/inplace_merge">https://en.cppreference.com/w/cpp/algorithm/inplace_merge</a> </p>

</div>
</div>
<a id="a0e9e7376359b4a88a505f218d6aa0ddc" name="a0e9e7376359b4a88a505f218d6aa0ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9e7376359b4a88a505f218d6aa0ddc">&#9670;&#160;</a></span>inplace_merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::inplace_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>mid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0080a41003199426077c02b6175ae904" name="a0080a41003199426077c02b6175ae904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0080a41003199426077c02b6175ae904">&#9670;&#160;</a></span>insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::insertion_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved. <a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a>. </p>

</div>
</div>
<a id="a5e6d5b25a5beae6b886f7eaccb6ccfd2" name="a5e6d5b25a5beae6b886f7eaccb6ccfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6d5b25a5beae6b886f7eaccb6ccfd2">&#9670;&#160;</a></span>insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::insertion_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a577d3ae817b5678a0a0b91213a403c21" name="a577d3ae817b5678a0a0b91213a403c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577d3ae817b5678a0a0b91213a403c21">&#9670;&#160;</a></span>is_partitioned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_partitioned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty. <a href="https://en.cppreference.com/w/cpp/algorithm/is_partitioned">https://en.cppreference.com/w/cpp/algorithm/is_partitioned</a>. </p>

</div>
</div>
<a id="a01459034f5f84e415ed7c9f73700b54f" name="a01459034f5f84e415ed7c9f73700b54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01459034f5f84e415ed7c9f73700b54f">&#9670;&#160;</a></span>is_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given. </p>

</div>
</div>
<a id="adc05db4110903905f00fc26bb6de03a1" name="adc05db4110903905f00fc26bb6de03a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc05db4110903905f00fc26bb6de03a1">&#9670;&#160;</a></span>is_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a671187bf1a3dd1a99a1acfada1927fcf" name="a671187bf1a3dd1a99a1acfada1927fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671187bf1a3dd1a99a1acfada1927fcf">&#9670;&#160;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order. </p>

</div>
</div>
<a id="ab728b1a920fd45e985ed73b9874fcb7d" name="ab728b1a920fd45e985ed73b9874fcb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab728b1a920fd45e985ed73b9874fcb7d">&#9670;&#160;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26cb4df55d0b061279b599134e294f22" name="a26cb4df55d0b061279b599134e294f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cb4df55d0b061279b599134e294f22">&#9670;&#160;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04cca9919e02704d1dd11db707e679ee" name="a04cca9919e02704d1dd11db707e679ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cca9919e02704d1dd11db707e679ee">&#9670;&#160;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order. </p>

</div>
</div>
<a id="aa18b878794474881fce640e7a163abf3" name="aa18b878794474881fce640e7a163abf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18b878794474881fce640e7a163abf3">&#9670;&#160;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iter_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the values of the elements the given iterators are pointing to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Iterators to the elements to swap. </td></tr>
    <tr><td class="paramname">b</td><td>Iterators to the elements to swap.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/iter_swap">https://en.cppreference.com/w/cpp/algorithm/iter_swap</a> </p>

</div>
</div>
<a id="a73951d21be0807534a52bbd26b866f7b" name="a73951d21be0807534a52bbd26b866f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73951d21be0807534a52bbd26b866f7b">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>l1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>f2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>l2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare">https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare</a> </p>

</div>
</div>
<a id="a386a232aa903a5387aa91c4ed5194d9f" name="a386a232aa903a5387aa91c4ed5194d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386a232aa903a5387aa91c4ed5194d9f">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>l1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>f2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>l2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a779ffb051a7e52e4702eb01aa18f167f" name="a779ffb051a7e52e4702eb01aa18f167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779ffb051a7e52e4702eb01aa18f167f">&#9670;&#160;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a> </p>

</div>
</div>
<a id="a9fb1800f39f2305708f67187a3a49993" name="a9fb1800f39f2305708f67187a3a49993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb1800f39f2305708f67187a3a49993">&#9670;&#160;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fdd0cf88f36f44f8fe8ec8327cfac74" name="a7fdd0cf88f36f44f8fe8ec8327cfac74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b. </p>

</div>
</div>
<a id="a220fbd23aca7dbc728c200471ed114c8" name="a220fbd23aca7dbc728c200471ed114c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220fbd23aca7dbc728c200471ed114c8">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b, using a compare function. </p>

</div>
</div>
<a id="aedcf261d2d7377e2284ab3f5738b34e1" name="aedcf261d2d7377e2284ab3f5738b34e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcf261d2d7377e2284ab3f5738b34e1">&#9670;&#160;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::max_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="abc62e1e0c57de79b8b007265bc308ec2" name="abc62e1e0c57de79b8b007265bc308ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc62e1e0c57de79b8b007265bc308ec2">&#9670;&#160;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::max_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="a9ee09e4768fc381002cd7dc14e8e561b" name="a9ee09e4768fc381002cd7dc14e8e561b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee09e4768fc381002cd7dc14e8e561b">&#9670;&#160;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>. </p>

</div>
</div>
<a id="a6d0face2f5fe06333854b6b120bd6bad" name="a6d0face2f5fe06333854b6b120bd6bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0face2f5fe06333854b6b120bd6bad">&#9670;&#160;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bffa34e9bd6075ec150aa9e30153950" name="a5bffa34e9bd6075ec150aa9e30153950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bffa34e9bd6075ec150aa9e30153950">&#9670;&#160;</a></span>merge_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::merge_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. <a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a>. </p>

</div>
</div>
<a id="a4da0fcb091026bf11e56eb257e9d3bc5" name="a4da0fcb091026bf11e56eb257e9d3bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da0fcb091026bf11e56eb257e9d3bc5">&#9670;&#160;</a></span>merge_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::merge_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adae1500815312b248e453896d5439b63" name="adae1500815312b248e453896d5439b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae1500815312b248e453896d5439b63">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b. </p>

</div>
</div>
<a id="a479c4a8315ae3ef2d1128858d723afc2" name="a479c4a8315ae3ef2d1128858d723afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479c4a8315ae3ef2d1128858d723afc2">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b, using a compare function. </p>

</div>
</div>
<a id="a4af4c7706179eef16ba76242c48518a9" name="a4af4c7706179eef16ba76242c48518a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af4c7706179eef16ba76242c48518a9">&#9670;&#160;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::min_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a71878538e0e2b2f8026ed657836382c0" name="a71878538e0e2b2f8026ed657836382c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71878538e0e2b2f8026ed657836382c0">&#9670;&#160;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::min_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="ae81f900b934c83cdb278826ede239e6b" name="ae81f900b934c83cdb278826ede239e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81f900b934c83cdb278826ede239e6b">&#9670;&#160;</a></span>minmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::minmax </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;, T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest and the greatest of the given values. </p>

</div>
</div>
<a id="a1a85dc58adf499e8f90a9e9c4eb0594a" name="a1a85dc58adf499e8f90a9e9c4eb0594a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a85dc58adf499e8f90a9e9c4eb0594a">&#9670;&#160;</a></span>minmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::minmax </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;, T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest and the greatest of the given values. </p>

</div>
</div>
<a id="adf3573e5fccf8f6ff5d8636e23b1ffa0" name="adf3573e5fccf8f6ff5d8636e23b1ffa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3573e5fccf8f6ff5d8636e23b1ffa0">&#9670;&#160;</a></span>minmax_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::minmax_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest and greatest element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="a3442eebc68bb878d66ab8a37478ff679" name="a3442eebc68bb878d66ab8a37478ff679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3442eebc68bb878d66ab8a37478ff679">&#9670;&#160;</a></span>minmax_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::minmax_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>, <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest and greatest element in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="a5674e86a91ac9cb808d365aa09d5d07f" name="a5674e86a91ac9cb808d365aa09d5d07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5674e86a91ac9cb808d365aa09d5d07f">&#9670;&#160;</a></span>mismatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The first range of the elements. </td></tr>
    <tr><td class="paramname">last1</td><td>The first range of the elements. </td></tr>
    <tr><td class="paramname">first2</td><td>The second range of the elements. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/mismatch">https://en.cppreference.com/w/cpp/algorithm/mismatch</a> </p>

</div>
</div>
<a id="ae399b1c12f42fcf2365021710f1e1667" name="ae399b1c12f42fcf2365021710f1e1667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae399b1c12f42fcf2365021710f1e1667">&#9670;&#160;</a></span>mismatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85be5a2493fc37bb07bab46871d7732b" name="a85be5a2493fc37bb07bab46871d7732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85be5a2493fc37bb07bab46871d7732b">&#9670;&#160;</a></span>mismatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8936cbbb27640ce6d9411dd5bc4859b3" name="a8936cbbb27640ce6d9411dd5bc4859b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8936cbbb27640ce6d9411dd5bc4859b3">&#9670;&#160;</a></span>mismatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">InputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b8df3814fc65f04932c2f0d09a56107" name="a1b8df3814fc65f04932c2f0d09a56107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8df3814fc65f04932c2f0d09a56107">&#9670;&#160;</a></span>move() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">destination</td><td>The beginning of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element past the last element moved.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/move">https://en.cppreference.com/w/cpp/algorithm/move</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a3">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a739385d15b43be76e906acbc6e6459a5" name="a739385d15b43be76e906acbc6e6459a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739385d15b43be76e906acbc6e6459a5">&#9670;&#160;</a></span>move_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::move_backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt2</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt2</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to move. </td></tr>
    <tr><td class="paramname">destination</td><td>End of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator in the destination range, pointing at the last element moved.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/move_backward">https://en.cppreference.com/w/cpp/algorithm/move_backward</a> </p>

</div>
</div>
<a id="ae2b5fe643bd62734bbb66af22e88544c" name="ae2b5fe643bd62734bbb66af22e88544c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b5fe643bd62734bbb66af22e88544c">&#9670;&#160;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::none_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ade97d95e33160e2176476b303cacc224" name="ade97d95e33160e2176476b303cacc224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade97d95e33160e2176476b303cacc224">&#9670;&#160;</a></span>nth_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nth_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>nth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that: </p>
<ul>
<li>The element pointed at by nth is changed to whatever element would occur in that position if <code>[first, last)</code> were sorted.</li>
<li>All of the elements before this new nth element are less than or equal to the elements after the new nth element.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/nth_element">https://en.cppreference.com/w/cpp/algorithm/nth_element</a> </p>

</div>
</div>
<a id="a31997e04071d6cfa4b887e46783efbf3" name="a31997e04071d6cfa4b887e46783efbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31997e04071d6cfa4b887e46783efbf3">&#9670;&#160;</a></span>nth_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nth_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>nth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61d1bed984c0aceff254e912cf251c6e" name="a61d1bed984c0aceff254e912cf251c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d1bed984c0aceff254e912cf251c6e">&#9670;&#160;</a></span>partial_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::partial_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/partial_sort">https://en.cppreference.com/w/cpp/algorithm/partial_sort</a> </p>

</div>
</div>
<a id="adf059ef9f744ed7d731faa69834ddc9a" name="adf059ef9f744ed7d731faa69834ddc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf059ef9f744ed7d731faa69834ddc9a">&#9670;&#160;</a></span>partial_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::partial_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94c256595c3b4e99c28c50d5f1c0d73f" name="a94c256595c3b4e99c28c50d5f1c0d73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c256595c3b4e99c28c50d5f1c0d73f">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved. </p>

</div>
</div>
<a id="ad34f1c15b38f8436c5d6dcc1f9f38491" name="ad34f1c15b38f8436c5d6dcc1f9f38491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34f1c15b38f8436c5d6dcc1f9f38491">&#9670;&#160;</a></span>partition_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::partition_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt1</a></td>          <td class="paramname"><span class="paramname"><em>destinationTrue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt2</a></td>          <td class="paramname"><span class="paramname"><em>destinationFalse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">OutputIt1</a>, <a class="el" href="structetl_1_1static__vector.html">OutputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false. </p>
<p>The behavior is undefined if the input range overlaps either of the output ranges. </p>

</div>
</div>
<a id="a8d4c550073b16bc102ef6b2447cc31d6" name="a8d4c550073b16bc102ef6b2447cc31d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4c550073b16bc102ef6b2447cc31d6">&#9670;&#160;</a></span>partition_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::partition_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p. </p>

</div>
</div>
<a id="adde454dc915d0c4c32bd8041b0bd8ecf" name="adde454dc915d0c4c32bd8041b0bd8ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde454dc915d0c4c32bd8041b0bd8ecf">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range. </p>

</div>
</div>
<a id="a7e0bacdf9416ed0db41e5527c7bb1b29" name="a7e0bacdf9416ed0db41e5527c7bb1b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0bacdf9416ed0db41e5527c7bb1b29">&#9670;&#160;</a></span>remove_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remove_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element copied. </dd></dl>

</div>
</div>
<a id="a68dc3e941f0f6b0d00f923fec94b6694" name="a68dc3e941f0f6b0d00f923fec94b6694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dc3e941f0f6b0d00f923fec94b6694">&#9670;&#160;</a></span>remove_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element copied. </dd></dl>

</div>
</div>
<a id="a5dc5f42480a4033b9a58cb5c7236fbee" name="a5dc5f42480a4033b9a58cb5c7236fbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc5f42480a4033b9a58cb5c7236fbee">&#9670;&#160;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remove_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range. </p>

</div>
</div>
<a id="ab115e24caa45f16f79bb770a6e3cbbab" name="ab115e24caa45f16f79bb770a6e3cbbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab115e24caa45f16f79bb770a6e3cbbab">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>oldValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value. </p>

</div>
</div>
<a id="a290953b933269399f045b7e2b37d97b7" name="a290953b933269399f045b7e2b37d97b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290953b933269399f045b7e2b37d97b7">&#9670;&#160;</a></span>replace_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::replace_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true. </p>

</div>
</div>
<a id="aa198aa5e9e5759947d51496cede4e6f6" name="aa198aa5e9e5759947d51496cede4e6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa198aa5e9e5759947d51496cede4e6f6">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the range <code>[first, last)</code>. </p>

</div>
</div>
<a id="ae0246fc85a8996116ecfe4be33cd1495" name="ae0246fc85a8996116ecfe4be33cd1495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0246fc85a8996116ecfe4be33cd1495">&#9670;&#160;</a></span>reverse_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::reverse_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order. </p>
<p>If the source and destination ranges (that is, <code>[first, last)</code> and [d_first, d_first+(last-first)) respectively) overlap, the behavior is undefined. </p>

</div>
</div>
<a id="a1c0cdef8cb8f1fb054c43f8aadb43d36" name="a1c0cdef8cb8f1fb054c43f8aadb43d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0cdef8cb8f1fb054c43f8aadb43d36">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>nFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a left rotation on a range of elements. </p>
<p>Specifically, rotate swaps the elements in the range [first, last) in such a way that the element n_first becomes the first element of the new range and n_first - 1 becomes the last element. A precondition of this function is that [first, n_first) and [n_first, last) are valid ranges. </p>

</div>
</div>
<a id="ad0d28d5f25cdee05003b4190e57dd519" name="ad0d28d5f25cdee05003b4190e57dd519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d28d5f25cdee05003b4190e57dd519">&#9670;&#160;</a></span>rotate_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rotate_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>nFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element. </p>

</div>
</div>
<a id="af39a57bc56c6f3c0bf94045777e9f274" name="af39a57bc56c6f3c0bf94045777e9f274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39a57bc56c6f3c0bf94045777e9f274">&#9670;&#160;</a></span>search() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt2</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt2</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the first occurrence of the sequence of elements [sFirst, sLast) in the range <code>[first, last)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">last</td><td>The range of elements to examine. </td></tr>
    <tr><td class="paramname">sFirst</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">sLast</td><td>The range of elements to search for. </td></tr>
    <tr><td class="paramname">pred</td><td>Binary predicate which returns true if the elements should be treated as equal.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/search">https://en.cppreference.com/w/cpp/algorithm/search</a> </p>

</div>
</div>
<a id="a5e8c774a650ce6535a79e6a11dd90fdf" name="a5e8c774a650ce6535a79e6a11dd90fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8c774a650ce6535a79e6a11dd90fdf">&#9670;&#160;</a></span>search() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt1</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt2</a></td>          <td class="paramname"><span class="paramname"><em>sFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt2</a></td>          <td class="paramname"><span class="paramname"><em>sLast</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt1</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21a90d9aad4e00eb080d9dce99472a40" name="a21a90d9aad4e00eb080d9dce99472a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a90d9aad4e00eb080d9dce99472a40">&#9670;&#160;</a></span>search() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FwdIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Searcher</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FwdIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Searcher</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>searcher</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">FwdIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a047bb8dc9dd92624ad901db1d27e5d83" name="a047bb8dc9dd92624ad901db1d27e5d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047bb8dc9dd92624ad901db1d27e5d83">&#9670;&#160;</a></span>search_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::search_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ValueT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value. </p>

</div>
</div>
<a id="a6c8fcaf19422ff5c92791797f6373260" name="a6c8fcaf19422ff5c92791797f6373260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8fcaf19422ff5c92791797f6373260">&#9670;&#160;</a></span>search_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ValueT</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::search_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ValueT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a563244b70e444026e7ddee3ad609b4a5" name="a563244b70e444026e7ddee3ad609b4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563244b70e444026e7ddee3ad609b4a5">&#9670;&#160;</a></span>set_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::set_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same. </p>

</div>
</div>
<a id="a50c804f0766a786779b7c17886e601a2" name="a50c804f0766a786779b7c17886e601a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c804f0766a786779b7c17886e601a2">&#9670;&#160;</a></span>set_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::set_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6670fa3cc294c702e9b6245c55a1da4" name="ac6670fa3cc294c702e9b6245c55a1da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6670fa3cc294c702e9b6245c55a1da4">&#9670;&#160;</a></span>set_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::set_intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="a47a31828bddd42fb93f6afb491bd4b4f" name="a47a31828bddd42fb93f6afb491bd4b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a31828bddd42fb93f6afb491bd4b4f">&#9670;&#160;</a></span>set_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::set_intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40c7a269a772f000cb710d042d7aee20" name="a40c7a269a772f000cb710d042d7aee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c7a269a772f000cb710d042d7aee20">&#9670;&#160;</a></span>set_symmetric_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes symmetric difference of two sorted ranges: the elements that are found in either of the ranges, but not in both of them are copied to the range beginning at destination. The resulting range is also sorted. </p>

</div>
</div>
<a id="ac0e87148d2ced5612a3f9f09fd4eb941" name="ac0e87148d2ced5612a3f9f09fd4eb941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e87148d2ced5612a3f9f09fd4eb941">&#9670;&#160;</a></span>set_symmetric_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9009346ce6e69bac2a9406592192aef1" name="a9009346ce6e69bac2a9406592192aef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9009346ce6e69bac2a9406592192aef1">&#9670;&#160;</a></span>set_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::set_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges. </p>

</div>
</div>
<a id="a4c31225d785d8d6b0702705ce2706c53" name="a4c31225d785d8d6b0702705ce2706c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c31225d785d8d6b0702705ce2706c53">&#9670;&#160;</a></span>set_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::set_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9df8e5c73b49b744646fa291c63525c1" name="a9df8e5c73b49b744646fa291c63525c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df8e5c73b49b744646fa291c63525c1">&#9670;&#160;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::shift_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the elements in the range [first, last) by n positions. </p>
<p>Shifts the elements towards the beginning of the range. If n == 0 || n &gt;= last - first, there are no effects. If n &lt; 0, the behavior is undefined. Otherwise, for every integer i in [0, last - first - n), moves the element originally at position first + n + i to position first + i. The moves are performed in increasing order of i starting from 0. </p>

</div>
</div>
<a id="a2a9ba1876aaa603ff0092cf872376265" name="a2a9ba1876aaa603ff0092cf872376265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9ba1876aaa603ff0092cf872376265">&#9670;&#160;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::shift_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidiIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidiIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">BidiIt</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidiIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the elements in the range [first, last) by n positions. </p>
<p>Shifts the elements towards the end of the range. If n &lt;= 0 || n &gt;= last - first, there are no effects. Otherwise, for every integer i in [0, last - first - n), moves the element originally at position first + i to position first + n + i.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/shift">https://en.cppreference.com/w/cpp/algorithm/shift</a></p>
<dl class="section note"><dt>Note</dt><dd>The standard specifies that this algorithm should also work with legacy forward iterators. I don't know how to implement that without dynamic memory, so forward iterators are not supported. </dd></dl>

</div>
</div>
<a id="adda62f64ad31faeb43dab1bbe8b2a664" name="adda62f64ad31faeb43dab1bbe8b2a664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda62f64ad31faeb43dab1bbe8b2a664">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is not guaranteed to be preserved. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a> </p>

</div>
</div>
<a id="a29031b0fee25653ff42e6fab29670267" name="a29031b0fee25653ff42e6fab29670267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29031b0fee25653ff42e6fab29670267">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04627f836421020d549c77618e404bef" name="a04627f836421020d549c77618e404bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04627f836421020d549c77618e404bef">&#9670;&#160;</a></span>stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stable_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved. </p>

</div>
</div>
<a id="aba546db0dc7852f32bae5b43c1cbb973" name="aba546db0dc7852f32bae5b43c1cbb973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba546db0dc7852f32bae5b43c1cbb973">&#9670;&#160;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stable_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equivalent elements is guaranteed to be preserved. Elements are compared using the given comparison function comp. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a> </p>

</div>
</div>
<a id="a018602a1181cba5553c619612ae2bf58" name="a018602a1181cba5553c619612ae2bf58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018602a1181cba5553c619612ae2bf58">&#9670;&#160;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stable_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2864370cd9173ff7ac8fb507dd6779a" name="ab2864370cd9173ff7ac8fb507dd6779a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2864370cd9173ff7ac8fb507dd6779a">&#9670;&#160;</a></span>swap_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt2</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The first range of elements to swap. </td></tr>
    <tr><td class="paramname">last1</td><td>The first range of elements to swap. </td></tr>
    <tr><td class="paramname">first2</td><td>Beginning of the second range of elements to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element exchanged in the range beginning with <code>first2</code>.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap_ranges">https://en.cppreference.com/w/cpp/algorithm/swap_ranges</a> </p>

</div>
</div>
<a id="a4467ebe5b0d985e1661eb04cb65fab6a" name="a4467ebe5b0d985e1661eb04cb65fab6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4467ebe5b0d985e1661eb04cb65fab6a">&#9670;&#160;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">UnaryOp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">UnaryOp</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by <code>[first, last)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">last</td><td>The first range of elements to transform. </td></tr>
    <tr><td class="paramname">dest</td><td>The beginning of the destination range, may be equal to first. </td></tr>
    <tr><td class="paramname">op</td><td>Unary operation function object that will be applied.</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_8cpp-example.html#a3">string.cpp</a>, and <a class="el" href="vector_8cpp-example.html#a2">vector.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab2860fb376fc216b93922e036f8ead03" name="ab2860fb376fc216b93922e036f8ead03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2860fb376fc216b93922e036f8ead03">&#9670;&#160;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt2</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BinaryOp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BinaryOp</a></td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ff9322bfeec8125aeb86d43fee6fade" name="a8ff9322bfeec8125aeb86d43fee6fade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9322bfeec8125aeb86d43fee6fade">&#9670;&#160;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="a438b893eeeaa7e54c01596344dbc939d" name="a438b893eeeaa7e54c01596344dbc939d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438b893eeeaa7e54c01596344dbc939d">&#9670;&#160;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range <code>[first, last)</code> and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="ab8e100f1e4a026e9d4789c972b7a4c8d" name="ab8e100f1e4a026e9d4789c972b7a4c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e100f1e4a026e9d4789c972b7a4c8d">&#9670;&#160;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unique_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied. </p>
<p>Elements are compared using the given binary predicate pred. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="a7c63f087df9180e1901cc4105a3a0363" name="a7c63f087df9180e1901cc4105a3a0363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c63f087df9180e1901cc4105a3a0363">&#9670;&#160;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unique_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>destination</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from the range <code>[first, last)</code>, to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied. </p>
<p>Elements are compared using operator==. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="a9b32d22be5cb9bbaaf24e21d8b700bcb" name="a9b32d22be5cb9bbaaf24e21d8b700bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b32d22be5cb9bbaaf24e21d8b700bcb">&#9670;&#160;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Compare</a></td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is greater than <code>value</code>, or last if no such element is found. </p>
<p>The range <code>[first, last)</code> must be partitioned with respect to the expression <code>!(value &lt; element)</code> or <code>!comp(value, element)</code>, i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion. </p>

</div>
</div>
<a id="a3448c90cac95ec2e155cf8ac02b6c592" name="a3448c90cac95ec2e155cf8ac02b6c592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3448c90cac95ec2e155cf8ac02b6c592">&#9670;&#160;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ec2a511f8b5137e02416b9e4e8dc237" name="a6ec2a511f8b5137e02416b9e4e8dc237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec2a511f8b5137e02416b9e4e8dc237">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3cb02b81d1ba34fc33b94555749fa92" name="ac3cb02b81d1ba34fc33b94555749fa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cb02b81d1ba34fc33b94555749fa92">&#9670;&#160;</a></span>operator|() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>| </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af622835231ee77bf2d29dd490bcbb2bf" name="af622835231ee77bf2d29dd490bcbb2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af622835231ee77bf2d29dd490bcbb2bf">&#9670;&#160;</a></span>operator^() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>^ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92caafb1e73d48a1d1847f64093be44c" name="a92caafb1e73d48a1d1847f64093be44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92caafb1e73d48a1d1847f64093be44c">&#9670;&#160;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::operator~ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2e027dfa37f613a9d94fe1ee90e7517" name="ad2e027dfa37f613a9d94fe1ee90e7517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e027dfa37f613a9d94fe1ee90e7517">&#9670;&#160;</a></span>operator|=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>|= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc72777ea30905ff52e4ce6d3448b3e8" name="abc72777ea30905ff52e4ce6d3448b3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc72777ea30905ff52e4ce6d3448b3e8">&#9670;&#160;</a></span>operator&amp;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&amp;= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79f94aefe628a0474274befd3437bf64" name="a79f94aefe628a0474274befd3437bf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f94aefe628a0474274befd3437bf64">&#9670;&#160;</a></span>operator^=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>^= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eaaf991a15c82d1ea08c9932f513126" name="a6eaaf991a15c82d1ea08c9932f513126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaaf991a15c82d1ea08c9932f513126">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary AND between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="ad704bd3a387f58880d2d97024dea9e71" name="ad704bd3a387f58880d2d97024dea9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad704bd3a387f58880d2d97024dea9e71">&#9670;&#160;</a></span>operator|() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary OR between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="a7238e53a5804e54ed1c1fbeb962f74b1" name="a7238e53a5804e54ed1c1fbeb962f74b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7238e53a5804e54ed1c1fbeb962f74b1">&#9670;&#160;</a></span>operator^() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1static__vector.html">N</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary XOR between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="ad57d9658b5bfda3c9dc53d1a0bd95ca7" name="ad57d9658b5bfda3c9dc53d1a0bd95ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57d9658b5bfda3c9dc53d1a0bd95ca7">&#9670;&#160;</a></span>default_assert_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::default_assert_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1assert__msg.html">assert_msg</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default assert handler. This will be called, if an assertion is triggered at runtime. </p>

</div>
</div>
<a id="a0ebfa4dc6da592b5c2d73f10ba7490dc" name="a0ebfa4dc6da592b5c2d73f10ba7490dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebfa4dc6da592b5c2d73f10ba7490dc">&#9670;&#160;</a></span>isalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isalnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is an alphanumeric character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is an alphanumeric character, 0 otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isalnum">https://en.cppreference.com/w/cpp/string/byte/isalnum</a> </p>

</div>
</div>
<a id="a89ad095d93b811823b48e7b0486be7de" name="a89ad095d93b811823b48e7b0486be7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ad095d93b811823b48e7b0486be7de">&#9670;&#160;</a></span>isalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isalpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is an alphabetic character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is an alphabetic character, 0 otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isalpha">https://en.cppreference.com/w/cpp/string/byte/isalpha</a> </p>

</div>
</div>
<a id="acca9707732972162ec02317639d2154b" name="acca9707732972162ec02317639d2154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca9707732972162ec02317639d2154b">&#9670;&#160;</a></span>isblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isblank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a blank character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isblank">https://en.cppreference.com/w/cpp/string/byte/isblank</a> </p>

</div>
</div>
<a id="a037d91a684e54521c31eefa609c57f0f" name="a037d91a684e54521c31eefa609c57f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037d91a684e54521c31eefa609c57f0f">&#9670;&#160;</a></span>iscntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iscntrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a control character as classified by the currently installed C locale. In the default, "C" locale, the control characters are the characters with the codes 0x00-0x1F and 0x7F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a control character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/iscntrl">https://en.cppreference.com/w/cpp/string/byte/iscntrl</a> </p>

</div>
</div>
<a id="a743aaa8e35549baecb60a7a37fbccb7a" name="a743aaa8e35549baecb60a7a37fbccb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743aaa8e35549baecb60a7a37fbccb7a">&#9670;&#160;</a></span>isdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is one of the 10 decimal digits: 0123456789. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a numeric character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isdigit">https://en.cppreference.com/w/cpp/string/byte/isdigit</a> </p>

</div>
</div>
<a id="a3fcb7b22dcd166bd67a94b6b7f7da42e" name="a3fcb7b22dcd166bd67a94b6b7f7da42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcb7b22dcd166bd67a94b6b7f7da42e">&#9670;&#160;</a></span>isgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is graphic (has a graphical representation) as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isgraph">https://en.cppreference.com/w/cpp/string/byte/isgraph</a> </p>

</div>
</div>
<a id="a334ab4709b4cf8c1f5053016825c3bd7" name="a334ab4709b4cf8c1f5053016825c3bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334ab4709b4cf8c1f5053016825c3bd7">&#9670;&#160;</a></span>islower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::islower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is classified as a lowercase character according to the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a lowercase letter, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/islower">https://en.cppreference.com/w/cpp/string/byte/islower</a> </p>

</div>
</div>
<a id="a8da49fe7c1e61918bbf7dd210e655d8c" name="a8da49fe7c1e61918bbf7dd210e655d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da49fe7c1e61918bbf7dd210e655d8c">&#9670;&#160;</a></span>isprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isprint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if ch is a printable character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isprint">https://en.cppreference.com/w/cpp/string/byte/isprint</a> </p>

</div>
</div>
<a id="a531a127903fbd0d7545d9a69bf13bb3c" name="a531a127903fbd0d7545d9a69bf13bb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531a127903fbd0d7545d9a69bf13bb3c">&#9670;&#160;</a></span>ispunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ispunct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a punctuation character as classified by the current C locale. </p>
<p>The default C locale classifies the characters !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ as punctuation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a punctuation character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/ispunct">https://en.cppreference.com/w/cpp/string/byte/ispunct</a> </p>

</div>
</div>
<a id="a3c87145259e2ce0061ac810fee723978" name="a3c87145259e2ce0061ac810fee723978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c87145259e2ce0061ac810fee723978">&#9670;&#160;</a></span>isspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is whitespace character as classified by the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a whitespace character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isspace">https://en.cppreference.com/w/cpp/string/byte/isspace</a> </p>

</div>
</div>
<a id="a2b1e3ecf65c20a6bd5f0b06139694269" name="a2b1e3ecf65c20a6bd5f0b06139694269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1e3ecf65c20a6bd5f0b06139694269">&#9670;&#160;</a></span>isupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is classified as a uppercase character according to the default C locale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a uppercase letter, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isupper">https://en.cppreference.com/w/cpp/string/byte/isupper</a> </p>

</div>
</div>
<a id="a77b0bd8474428652100d3db55092e788" name="a77b0bd8474428652100d3db55092e788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b0bd8474428652100d3db55092e788">&#9670;&#160;</a></span>isxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isxdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero value if the character is a hexadecimal numeric character, zero otherwise.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/isxdigit">https://en.cppreference.com/w/cpp/string/byte/isxdigit</a> </p>

</div>
</div>
<a id="a25b969e80e81b5a412d56884fc5bfcf2" name="a25b969e80e81b5a412d56884fc5bfcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b969e80e81b5a412d56884fc5bfcf2">&#9670;&#160;</a></span>tolower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tolower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given character to lowercase according to the character conversion rules defined by the default C locale. </p>
<p>In the default "C" locale, the following uppercase letters <b>ABCDEFGHIJKLMNOPQRSTUVWXYZ</b> are replaced with respective lowercase letters <b>abcdefghijklmnopqrstuvwxyz</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lowercase version of ch or unmodified ch if no lowercase version is listed in the current C locale.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/tolower">https://en.cppreference.com/w/cpp/string/byte/tolower</a> </p>

</div>
</div>
<a id="a2b46f5faca236c0de0b9f378c22498c1" name="a2b46f5faca236c0de0b9f378c22498c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b46f5faca236c0de0b9f378c22498c1">&#9670;&#160;</a></span>toupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::toupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given character to uppercase according to the character conversion rules defined by the default C locale. </p>
<p>In the default "C" locale, the following lowercase letters <b>abcdefghijklmnopqrstuvwxyz</b> are replaced with respective uppercase letters <b>ABCDEFGHIJKLMNOPQRSTUVWXYZ</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Character to classify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted character or ch if no uppercase version is defined by the current C locale.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/toupper">https://en.cppreference.com/w/cpp/string/byte/toupper</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="string_8cpp-example.html#a2">string.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1c1ffcebf3ee4f04cf5987def83d0070" name="a1c1ffcebf3ee4f04cf5987def83d0070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1ffcebf3ee4f04cf5987def83d0070">&#9670;&#160;</a></span>isfinite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isfinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a587d2d42acd3ff40d56a98cdb84e1f57" name="a587d2d42acd3ff40d56a98cdb84e1f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587d2d42acd3ff40d56a98cdb84e1f57">&#9670;&#160;</a></span>isinf() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8311e8c453fbb5b2e5eea1ed6aead74" name="ae8311e8c453fbb5b2e5eea1ed6aead74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8311e8c453fbb5b2e5eea1ed6aead74">&#9670;&#160;</a></span>isnan() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8840adb5e14e1239b4830cdd7e17f29" name="ab8840adb5e14e1239b4830cdd7e17f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8840adb5e14e1239b4830cdd7e17f29">&#9670;&#160;</a></span>isnormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isnormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92f672431014d52f52f9ce327fd19b81" name="a92f672431014d52f52f9ce327fd19b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f672431014d52f52f9ce327fd19b81">&#9670;&#160;</a></span>signbit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::signbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a606fa196e600b047397336663f1c7141" name="a606fa196e600b047397336663f1c7141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606fa196e600b047397336663f1c7141">&#9670;&#160;</a></span>from_chars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> same_as&lt;<a class="el" href="structetl_1_1static__vector.html">Int</a>, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::from_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value. </p>

</div>
</div>
<a id="affa470408e7403e4491a6a9e5c8f0d81" name="affa470408e7403e4491a6a9e5c8f0d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa470408e7403e4491a6a9e5c8f0d81">&#9670;&#160;</a></span>to_chars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> same_as&lt;T, <a class="el" href="structetl_1_1static__vector.html">bool</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<p>Integer formatters: value is converted to a string of digits in the given base (with no redundant leading zeroes). Digits in the range 10..35 (inclusive) are represented as lowercase characters a..z. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type char as the type of the parameter value. </p>

</div>
</div>
<a id="a4e3b3e7cc2dd468ee65c7ba76269f690" name="a4e3b3e7cc2dd468ee65c7ba76269f690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3b3e7cc2dd468ee65c7ba76269f690">&#9670;&#160;</a></span>to_chars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">bool</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt;  <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>=<a class="el" href="structetl_1_1static__vector.html">delete</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab03b4314a7a0c72385ecb062322e815a" name="ab03b4314a7a0c72385ecb062322e815a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03b4314a7a0c72385ecb062322e815a">&#9670;&#160;</a></span>cosh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a> </p>

</div>
</div>
<a id="a4c2950fdc398f70b0545b2721f57deff" name="a4c2950fdc398f70b0545b2721f57deff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2950fdc398f70b0545b2721f57deff">&#9670;&#160;</a></span>coshf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::coshf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a> </p>

</div>
</div>
<a id="a85c430223db452246c909a258dac5d01" name="a85c430223db452246c909a258dac5d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c430223db452246c909a258dac5d01">&#9670;&#160;</a></span>cosh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a> </p>

</div>
</div>
<a id="aa686c109054fee0ccbe9233313fe5811" name="aa686c109054fee0ccbe9233313fe5811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa686c109054fee0ccbe9233313fe5811">&#9670;&#160;</a></span>cosh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a> </p>

</div>
</div>
<a id="a32ea3e46f7aa043f3a6229e91281655d" name="a32ea3e46f7aa043f3a6229e91281655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ea3e46f7aa043f3a6229e91281655d">&#9670;&#160;</a></span>coshl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::coshl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a> </p>

</div>
</div>
<a id="a0497aee842a4aa4f6a0d3c07af34bf27" name="a0497aee842a4aa4f6a0d3c07af34bf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0497aee842a4aa4f6a0d3c07af34bf27">&#9670;&#160;</a></span>cosh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cosh </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic cosine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/cosh">https://en.cppreference.com/w/cpp/numeric/math/cosh</a> </p>

</div>
</div>
<a id="a67a87be7c2a7789cc2af84f5620b6ba0" name="a67a87be7c2a7789cc2af84f5620b6ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a87be7c2a7789cc2af84f5620b6ba0">&#9670;&#160;</a></span>erf() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a> </p>

</div>
</div>
<a id="ad16b4888b71e83519b5ef69e90ea6956" name="ad16b4888b71e83519b5ef69e90ea6956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16b4888b71e83519b5ef69e90ea6956">&#9670;&#160;</a></span>erff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a> </p>

</div>
</div>
<a id="acf55df46265ad2dda32d84405c47185d" name="acf55df46265ad2dda32d84405c47185d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf55df46265ad2dda32d84405c47185d">&#9670;&#160;</a></span>erf() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a> </p>

</div>
</div>
<a id="a27ece4e3c2d0449f2cf42ca64c72eae5" name="a27ece4e3c2d0449f2cf42ca64c72eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ece4e3c2d0449f2cf42ca64c72eae5">&#9670;&#160;</a></span>erf() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a> </p>

</div>
</div>
<a id="a843da4273caef9b48e4cdfc9b7c2c369" name="a843da4273caef9b48e4cdfc9b7c2c369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843da4273caef9b48e4cdfc9b7c2c369">&#9670;&#160;</a></span>erfl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erfl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a> </p>

</div>
</div>
<a id="ac4f46c302ddbc1a6e7a6fea6cfdc3ae2" name="ac4f46c302ddbc1a6e7a6fea6cfdc3ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f46c302ddbc1a6e7a6fea6cfdc3ae2">&#9670;&#160;</a></span>erf() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erf </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/erf">https://en.cppreference.com/w/cpp/numeric/math/erf</a> </p>

</div>
</div>
<a id="a9acc3b86f099266b7744b6cb388ed894" name="a9acc3b86f099266b7744b6cb388ed894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acc3b86f099266b7744b6cb388ed894">&#9670;&#160;</a></span>exp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a> </p>

</div>
</div>
<a id="a3bb2a8337db1101a51fa8bf0c9c93aff" name="a3bb2a8337db1101a51fa8bf0c9c93aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb2a8337db1101a51fa8bf0c9c93aff">&#9670;&#160;</a></span>expf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::expf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a> </p>

</div>
</div>
<a id="a5c94fca30d8f6813d56cd0db16e1f2af" name="a5c94fca30d8f6813d56cd0db16e1f2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c94fca30d8f6813d56cd0db16e1f2af">&#9670;&#160;</a></span>exp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a> </p>

</div>
</div>
<a id="a92f7208d978374f6fdc4b3caa77a5942" name="a92f7208d978374f6fdc4b3caa77a5942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f7208d978374f6fdc4b3caa77a5942">&#9670;&#160;</a></span>exp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a> </p>

</div>
</div>
<a id="ad23063bd3e5e1848b1cd8f0adee2bdd0" name="ad23063bd3e5e1848b1cd8f0adee2bdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23063bd3e5e1848b1cd8f0adee2bdd0">&#9670;&#160;</a></span>expl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::expl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a> </p>

</div>
</div>
<a id="a8a06161d90cdf8b9af35ddf334a8db2d" name="a8a06161d90cdf8b9af35ddf334a8db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a06161d90cdf8b9af35ddf334a8db2d">&#9670;&#160;</a></span>exp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::exp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes e (Euler's number, 2.7182...) raised to the given power v. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/exp">https://en.cppreference.com/w/cpp/numeric/math/exp</a> </p>

</div>
</div>
<a id="af0241333848ee2ec2b8a53dc9ba0e19e" name="af0241333848ee2ec2b8a53dc9ba0e19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0241333848ee2ec2b8a53dc9ba0e19e">&#9670;&#160;</a></span>fdim() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fdim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="ad8e19893929bbc794be4206bec3f1ffa" name="ad8e19893929bbc794be4206bec3f1ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e19893929bbc794be4206bec3f1ffa">&#9670;&#160;</a></span>fdimf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fdimf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="a7954b159301cbd51a00f4159449458af" name="a7954b159301cbd51a00f4159449458af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7954b159301cbd51a00f4159449458af">&#9670;&#160;</a></span>fdim() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fdim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="a96b3f1bd599452cab3d60f96db64c0f7" name="a96b3f1bd599452cab3d60f96db64c0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b3f1bd599452cab3d60f96db64c0f7">&#9670;&#160;</a></span>fdim() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fdim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="a9f7dc714d464e428c74c9f4082a93ea2" name="a9f7dc714d464e428c74c9f4082a93ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7dc714d464e428c74c9f4082a93ea2">&#9670;&#160;</a></span>fdiml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fdiml </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x&gt;y, returns x-y, otherwise (if xy), returns +0. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fdim">https://en.cppreference.com/w/cpp/numeric/math/fdim</a> </p>

</div>
</div>
<a id="a177bda599c52cf225f0288ec9043b8bb" name="a177bda599c52cf225f0288ec9043b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177bda599c52cf225f0288ec9043b8bb">&#9670;&#160;</a></span>floor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a> </p>

</div>
</div>
<a id="ac9e3263a0f395c13cab460b75b0f55ef" name="ac9e3263a0f395c13cab460b75b0f55ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e3263a0f395c13cab460b75b0f55ef">&#9670;&#160;</a></span>floorf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::floorf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a> </p>

</div>
</div>
<a id="a6604cf790ab829d40c3b4daa730c7c08" name="a6604cf790ab829d40c3b4daa730c7c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6604cf790ab829d40c3b4daa730c7c08">&#9670;&#160;</a></span>floor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a> </p>

</div>
</div>
<a id="a5790bd430f29dc6eeced561fa3a5c054" name="a5790bd430f29dc6eeced561fa3a5c054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5790bd430f29dc6eeced561fa3a5c054">&#9670;&#160;</a></span>floor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a> </p>

</div>
</div>
<a id="ab2443c1dedde3d2c7efcbffd1c5fa693" name="ab2443c1dedde3d2c7efcbffd1c5fa693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2443c1dedde3d2c7efcbffd1c5fa693">&#9670;&#160;</a></span>floorl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::floorl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a> </p>

</div>
</div>
<a id="af61d4eb26e65da7afe6e0c669e78967b" name="af61d4eb26e65da7afe6e0c669e78967b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61d4eb26e65da7afe6e0c669e78967b">&#9670;&#160;</a></span>floor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::floor </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the largest integer value not greater than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a> </p>

</div>
</div>
<a id="a69e7db11940223760db9220304003446" name="a69e7db11940223760db9220304003446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e7db11940223760db9220304003446">&#9670;&#160;</a></span>fma() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="a1060e4829c9f215f998aa669f07907fe" name="a1060e4829c9f215f998aa669f07907fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1060e4829c9f215f998aa669f07907fe">&#9670;&#160;</a></span>fmaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="afaa52aafdd0d75fd5757bc6048241627" name="afaa52aafdd0d75fd5757bc6048241627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa52aafdd0d75fd5757bc6048241627">&#9670;&#160;</a></span>fma() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="a12b982d85defc10bdabb054f0f6da09a" name="a12b982d85defc10bdabb054f0f6da09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b982d85defc10bdabb054f0f6da09a">&#9670;&#160;</a></span>fma() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="a4eeb30986666cfb17836f4a95c1ae432" name="a4eeb30986666cfb17836f4a95c1ae432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eeb30986666cfb17836f4a95c1ae432">&#9670;&#160;</a></span>fmal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes (x*y) + z as if to infinite precision and rounded only once to fit the result type. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fma">https://en.cppreference.com/w/cpp/numeric/math/fma</a> </p>

</div>
</div>
<a id="a4cbefc5ea76f13ee1827d6ece5530ddf" name="a4cbefc5ea76f13ee1827d6ece5530ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbefc5ea76f13ee1827d6ece5530ddf">&#9670;&#160;</a></span>fmax() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a20521caa4fff8d2a62c7d10d77041c20" name="a20521caa4fff8d2a62c7d10d77041c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20521caa4fff8d2a62c7d10d77041c20">&#9670;&#160;</a></span>fmaxf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmaxf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a02198785b5008814ed4bc399d219bd05" name="a02198785b5008814ed4bc399d219bd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02198785b5008814ed4bc399d219bd05">&#9670;&#160;</a></span>fmax() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a2ccdc206cb2bbd9ede91a7368c9e5e28" name="a2ccdc206cb2bbd9ede91a7368c9e5e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccdc206cb2bbd9ede91a7368c9e5e28">&#9670;&#160;</a></span>fmax() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a81aa1fe211f2730e008f27a200e45394" name="a81aa1fe211f2730e008f27a200e45394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81aa1fe211f2730e008f27a200e45394">&#9670;&#160;</a></span>fmaxl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmaxl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmax">https://en.cppreference.com/w/cpp/numeric/math/fmax</a> </p>

</div>
</div>
<a id="a7b6dcbdef161930c194abe91e999fa5a" name="a7b6dcbdef161930c194abe91e999fa5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6dcbdef161930c194abe91e999fa5a">&#9670;&#160;</a></span>fmin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="a97261b40d0dadb99feb19718529cb0a4" name="a97261b40d0dadb99feb19718529cb0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97261b40d0dadb99feb19718529cb0a4">&#9670;&#160;</a></span>fminf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fminf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="ab3f5a59fa8f7da66f4b0e8fe9c75eaa8" name="ab3f5a59fa8f7da66f4b0e8fe9c75eaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f5a59fa8f7da66f4b0e8fe9c75eaa8">&#9670;&#160;</a></span>fmin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="a3b7993c9e609fbaadfb6d3c8e2601edc" name="a3b7993c9e609fbaadfb6d3c8e2601edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7993c9e609fbaadfb6d3c8e2601edc">&#9670;&#160;</a></span>fmin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="af48da4e487f08e68385af8cd0fd1d5ac" name="af48da4e487f08e68385af8cd0fd1d5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48da4e487f08e68385af8cd0fd1d5ac">&#9670;&#160;</a></span>fminl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fminl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen) </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmin">https://en.cppreference.com/w/cpp/numeric/math/fmin</a> </p>

</div>
</div>
<a id="a1ed8605479832389e41046ec57b9ebf3" name="a1ed8605479832389e41046ec57b9ebf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed8605479832389e41046ec57b9ebf3">&#9670;&#160;</a></span>fmod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a> </p>

</div>
</div>
<a id="ad5edc9a4f5aaf05aaee40f53925a2907" name="ad5edc9a4f5aaf05aaee40f53925a2907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5edc9a4f5aaf05aaee40f53925a2907">&#9670;&#160;</a></span>fmodf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmodf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a> </p>

</div>
</div>
<a id="ab8cfcffa563969a705bb10c8a19708f0" name="ab8cfcffa563969a705bb10c8a19708f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cfcffa563969a705bb10c8a19708f0">&#9670;&#160;</a></span>fmod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a> </p>

</div>
</div>
<a id="a93062354e3cf23623c19cdf4e38e7379" name="a93062354e3cf23623c19cdf4e38e7379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93062354e3cf23623c19cdf4e38e7379">&#9670;&#160;</a></span>fmod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a> </p>

</div>
</div>
<a id="ae62dab0cf57549d61a2af609727b1a63" name="ae62dab0cf57549d61a2af609727b1a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62dab0cf57549d61a2af609727b1a63">&#9670;&#160;</a></span>fmodl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fmodl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/fmod">https://en.cppreference.com/w/cpp/numeric/math/fmod</a> </p>

</div>
</div>
<a id="a69fcd9a9618412844bfb6cb9790394b3" name="a69fcd9a9618412844bfb6cb9790394b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fcd9a9618412844bfb6cb9790394b3">&#9670;&#160;</a></span>hypot() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hypot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a48afde86c3996c23be30bae9346a7403" name="a48afde86c3996c23be30bae9346a7403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48afde86c3996c23be30bae9346a7403">&#9670;&#160;</a></span>hypotf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hypotf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a71f30dc3ac97f258a80f04b8ea39336b" name="a71f30dc3ac97f258a80f04b8ea39336b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f30dc3ac97f258a80f04b8ea39336b">&#9670;&#160;</a></span>hypot() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hypot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="abdda7a6eb1bcb8686e3769837c959f07" name="abdda7a6eb1bcb8686e3769837c959f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdda7a6eb1bcb8686e3769837c959f07">&#9670;&#160;</a></span>hypot() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hypot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a3aafdc892d2301b2f0a571692519ab0f" name="a3aafdc892d2301b2f0a571692519ab0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aafdc892d2301b2f0a571692519ab0f">&#9670;&#160;</a></span>hypotl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hypotl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a946e30be3d028206c7b77b42a718d305" name="a946e30be3d028206c7b77b42a718d305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946e30be3d028206c7b77b42a718d305">&#9670;&#160;</a></span>hypot() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hypot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="aa8b6df01c497a4410ee0c90dcac298cb" name="aa8b6df01c497a4410ee0c90dcac298cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b6df01c497a4410ee0c90dcac298cb">&#9670;&#160;</a></span>hypot() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hypot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a080df550166a2674a8353362f290a0b3" name="a080df550166a2674a8353362f290a0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080df550166a2674a8353362f290a0b3">&#9670;&#160;</a></span>hypot() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hypot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of the sum of the squares of x, y, and z, without undue overflow or underflow at intermediate stages of the computation. </p>
<ul>
<li>hypot(x,y) is INF if x or y is +INF or -INF; else</li>
<li>hypot(x,y) is NAN if x or y is NAN.</li>
</ul>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/hypot">https://en.cppreference.com/w/cpp/numeric/math/hypot</a> </p>

</div>
</div>
<a id="a80bf904f99630edb18fcb3a07117779f" name="a80bf904f99630edb18fcb3a07117779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bf904f99630edb18fcb3a07117779f">&#9670;&#160;</a></span>isfinite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isfinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/isfinite">https://en.cppreference.com/w/cpp/numeric/math/isfinite</a> </p>

</div>
</div>
<a id="a813ce51b2632847f81eed1858528ff8e" name="a813ce51b2632847f81eed1858528ff8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813ce51b2632847f81eed1858528ff8e">&#9670;&#160;</a></span>isfinite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isfinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae33b9666e620117df47e7cd5c2faae53" name="ae33b9666e620117df47e7cd5c2faae53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33b9666e620117df47e7cd5c2faae53">&#9670;&#160;</a></span>isfinite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isfinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47ef6491e0baea008f09e77e8bdd1893" name="a47ef6491e0baea008f09e77e8bdd1893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ef6491e0baea008f09e77e8bdd1893">&#9670;&#160;</a></span>isinf() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a positive or negative infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>true if arg is infinite, false otherwise</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/isinf">https://en.cppreference.com/w/cpp/numeric/math/isinf</a> </p>

</div>
</div>
<a id="a0bd9c92fc417d48f3b71a556c288f34d" name="a0bd9c92fc417d48f3b71a556c288f34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd9c92fc417d48f3b71a556c288f34d">&#9670;&#160;</a></span>isinf() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac63899ba5cdbbcbe25e867baaa11c8a" name="aac63899ba5cdbbcbe25e867baaa11c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac63899ba5cdbbcbe25e867baaa11c8a">&#9670;&#160;</a></span>isinf() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1a47d9c6cc8ec82135f104f9b5c5d6" name="a5d1a47d9c6cc8ec82135f104f9b5c5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1a47d9c6cc8ec82135f104f9b5c5d6">&#9670;&#160;</a></span>isinf() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a605d9e24e916cbbc8f38c7e377eb792d" name="a605d9e24e916cbbc8f38c7e377eb792d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605d9e24e916cbbc8f38c7e377eb792d">&#9670;&#160;</a></span>isnan() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a not-a-number (NaN) value. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/isnan">https://en.cppreference.com/w/cpp/numeric/math/isnan</a> </p>

</div>
</div>
<a id="ac4da86e5987c4a4fc2368f5195645c3f" name="ac4da86e5987c4a4fc2368f5195645c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4da86e5987c4a4fc2368f5195645c3f">&#9670;&#160;</a></span>isnan() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b1b06749558d3368fe928aba61d3b46" name="a5b1b06749558d3368fe928aba61d3b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1b06749558d3368fe928aba61d3b46">&#9670;&#160;</a></span>isnan() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e91eb4fc3291fad0f13f2c74c57cd8f" name="a3e91eb4fc3291fad0f13f2c74c57cd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e91eb4fc3291fad0f13f2c74c57cd8f">&#9670;&#160;</a></span>isnan() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a not-a-number (NaN) value. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/isnan">https://en.cppreference.com/w/cpp/numeric/math/isnan</a> </p>

</div>
</div>
<a id="ac6bb19442837ee1b2540b722ce1c342e" name="ac6bb19442837ee1b2540b722ce1c342e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bb19442837ee1b2540b722ce1c342e">&#9670;&#160;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point Float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Float</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Float</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Float</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a+t(ba), i.e. the linear interpolation between a and b for the parameter t (or extrapolation, when t is outside the range [0,1]). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/lerp">https://en.cppreference.com/w/cpp/numeric/lerp</a> </p>

</div>
</div>
<a id="a7c9b7f32c9ebfadabdad501a192d828c" name="a7c9b7f32c9ebfadabdad501a192d828c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9b7f32c9ebfadabdad501a192d828c">&#9670;&#160;</a></span>lgamma() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lgamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a655f9724695ea0b1ec56bbc092789817" name="a655f9724695ea0b1ec56bbc092789817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655f9724695ea0b1ec56bbc092789817">&#9670;&#160;</a></span>lgammaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lgammaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a4ea2c01b0ca8e4e672c7797bc873547e" name="a4ea2c01b0ca8e4e672c7797bc873547e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea2c01b0ca8e4e672c7797bc873547e">&#9670;&#160;</a></span>lgamma() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lgamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a6af7825a746fbacdf9c207c50b52328d" name="a6af7825a746fbacdf9c207c50b52328d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af7825a746fbacdf9c207c50b52328d">&#9670;&#160;</a></span>lgamma() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lgamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a9644a8b5362db2ea680cbe5c99b06b1c" name="a9644a8b5362db2ea680cbe5c99b06b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9644a8b5362db2ea680cbe5c99b06b1c">&#9670;&#160;</a></span>lgammal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lgammal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a0343114e62c2670e654d329ab0e1bdd0" name="a0343114e62c2670e654d329ab0e1bdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0343114e62c2670e654d329ab0e1bdd0">&#9670;&#160;</a></span>lgamma() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lgamma </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/lgamma">https://en.cppreference.com/w/cpp/numeric/math/lgamma</a> </p>

</div>
</div>
<a id="a4a169fd90c749bd105c7ed917785c555" name="a4a169fd90c749bd105c7ed917785c555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a169fd90c749bd105c7ed917785c555">&#9670;&#160;</a></span>log() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a57095382e9dbd0566b08e4928b380a0b" name="a57095382e9dbd0566b08e4928b380a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57095382e9dbd0566b08e4928b380a0b">&#9670;&#160;</a></span>logf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::logf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a572772bba893a4526620c49993f0ebfc" name="a572772bba893a4526620c49993f0ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572772bba893a4526620c49993f0ebfc">&#9670;&#160;</a></span>log() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a82265667a848fe03195c421e0d9fc14f" name="a82265667a848fe03195c421e0d9fc14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82265667a848fe03195c421e0d9fc14f">&#9670;&#160;</a></span>log() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a2e443c1bfefaffc909930e82ad506e9c" name="a2e443c1bfefaffc909930e82ad506e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e443c1bfefaffc909930e82ad506e9c">&#9670;&#160;</a></span>logl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::logl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a901ea4277603b09bc1fd59c203d1a5bb" name="a901ea4277603b09bc1fd59c203d1a5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901ea4277603b09bc1fd59c203d1a5bb">&#9670;&#160;</a></span>log() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log">https://en.cppreference.com/w/cpp/numeric/math/log</a> </p>

</div>
</div>
<a id="a7f12f27fcd6d0d687061563bf72ff1a1" name="a7f12f27fcd6d0d687061563bf72ff1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f12f27fcd6d0d687061563bf72ff1a1">&#9670;&#160;</a></span>log10() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a> </p>

</div>
</div>
<a id="a78fee06d1d407f722148dab0c23494b7" name="a78fee06d1d407f722148dab0c23494b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fee06d1d407f722148dab0c23494b7">&#9670;&#160;</a></span>log10f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log10f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a> </p>

</div>
</div>
<a id="ae4a3fb089d374229a5797e5bfef6ebf4" name="ae4a3fb089d374229a5797e5bfef6ebf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a3fb089d374229a5797e5bfef6ebf4">&#9670;&#160;</a></span>log10() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a> </p>

</div>
</div>
<a id="a48a16ee742583cc34fd0d79feeb82c3c" name="a48a16ee742583cc34fd0d79feeb82c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a16ee742583cc34fd0d79feeb82c3c">&#9670;&#160;</a></span>log10() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a> </p>

</div>
</div>
<a id="acacfe4fb5b126adc548949313389927b" name="acacfe4fb5b126adc548949313389927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacfe4fb5b126adc548949313389927b">&#9670;&#160;</a></span>log10l()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log10l </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a> </p>

</div>
</div>
<a id="ab1f5caf83538c35d9898a64b78f3d19d" name="ab1f5caf83538c35d9898a64b78f3d19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f5caf83538c35d9898a64b78f3d19d">&#9670;&#160;</a></span>log10() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log10 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-10) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log10">https://en.cppreference.com/w/cpp/numeric/math/log10</a> </p>

</div>
</div>
<a id="a498813413a98af25e2555e2c54c3256a" name="a498813413a98af25e2555e2c54c3256a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498813413a98af25e2555e2c54c3256a">&#9670;&#160;</a></span>log1p() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log1p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="a9b2b22c8715dcf83abd59bb75cb1cdde" name="a9b2b22c8715dcf83abd59bb75cb1cdde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2b22c8715dcf83abd59bb75cb1cdde">&#9670;&#160;</a></span>log1pf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log1pf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="aaf80a0d8a6fa5bfa402fc5423250e31f" name="aaf80a0d8a6fa5bfa402fc5423250e31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf80a0d8a6fa5bfa402fc5423250e31f">&#9670;&#160;</a></span>log1p() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log1p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="a20be7ea716031c69f74aebe909736eb7" name="a20be7ea716031c69f74aebe909736eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20be7ea716031c69f74aebe909736eb7">&#9670;&#160;</a></span>log1p() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log1p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="a25518821ccfbec031fc0d965aa7270bd" name="a25518821ccfbec031fc0d965aa7270bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25518821ccfbec031fc0d965aa7270bd">&#9670;&#160;</a></span>log1pl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log1pl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="ae364b66bba492ce1f0d8cf6cc89926ed" name="ae364b66bba492ce1f0d8cf6cc89926ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae364b66bba492ce1f0d8cf6cc89926ed">&#9670;&#160;</a></span>log1p() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log1p </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural (base e) logarithm of 1+arg. This function is more precise than the expression <a class="el" href="#a4a169fd90c749bd105c7ed917785c555" title="Computes the natural (base e) logarithm of arg.">etl::log</a>(1+arg) if arg is close to zero. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log1p">https://en.cppreference.com/w/cpp/numeric/math/log1p</a> </p>

</div>
</div>
<a id="a187674def6f3f8cb678932d3bae9cbec" name="a187674def6f3f8cb678932d3bae9cbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187674def6f3f8cb678932d3bae9cbec">&#9670;&#160;</a></span>log2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a> </p>

</div>
</div>
<a id="a032e2d84a89ad296cc05740845401979" name="a032e2d84a89ad296cc05740845401979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032e2d84a89ad296cc05740845401979">&#9670;&#160;</a></span>log2f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log2f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a> </p>

</div>
</div>
<a id="ad48c54e709d90829fb78c40b755c71c7" name="ad48c54e709d90829fb78c40b755c71c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48c54e709d90829fb78c40b755c71c7">&#9670;&#160;</a></span>log2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a> </p>

</div>
</div>
<a id="aa32086c2c749843ddb53344256a91fce" name="aa32086c2c749843ddb53344256a91fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32086c2c749843ddb53344256a91fce">&#9670;&#160;</a></span>log2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a> </p>

</div>
</div>
<a id="aa3fa117f9915cf0572aa57acab4fe659" name="aa3fa117f9915cf0572aa57acab4fe659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fa117f9915cf0572aa57acab4fe659">&#9670;&#160;</a></span>log2l()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log2l </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a> </p>

</div>
</div>
<a id="a9c53fd481eb75ee3e6bc3ab5cd1b307f" name="a9c53fd481eb75ee3e6bc3ab5cd1b307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c53fd481eb75ee3e6bc3ab5cd1b307f">&#9670;&#160;</a></span>log2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::log2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the binary (base-2) logarithm of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/log2">https://en.cppreference.com/w/cpp/numeric/math/log2</a> </p>

</div>
</div>
<a id="ad47ed33940ef738b996d13c4fe6b819a" name="ad47ed33940ef738b996d13c4fe6b819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47ed33940ef738b996d13c4fe6b819a">&#9670;&#160;</a></span>lrint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="aedd52080b573db11d8e765f46f8e7765" name="aedd52080b573db11d8e765f46f8e7765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd52080b573db11d8e765f46f8e7765">&#9670;&#160;</a></span>lrintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lrintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a974d3c30726d8fcb3d66b335f97b2db0" name="a974d3c30726d8fcb3d66b335f97b2db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974d3c30726d8fcb3d66b335f97b2db0">&#9670;&#160;</a></span>lrint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="ad9d8ad90ada2dcf269313c7d4cb1d088" name="ad9d8ad90ada2dcf269313c7d4cb1d088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d8ad90ada2dcf269313c7d4cb1d088">&#9670;&#160;</a></span>lrint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="ae9f3372f28a951d577490cd5afe08ff0" name="ae9f3372f28a951d577490cd5afe08ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f3372f28a951d577490cd5afe08ff0">&#9670;&#160;</a></span>lrintl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lrintl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a197984681c0d3089f3809b6769021ac0" name="a197984681c0d3089f3809b6769021ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197984681c0d3089f3809b6769021ac0">&#9670;&#160;</a></span>lrint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lrint </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="ad500c9f92de07b192872ebf1d8c85bbd" name="ad500c9f92de07b192872ebf1d8c85bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad500c9f92de07b192872ebf1d8c85bbd">&#9670;&#160;</a></span>llrint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::llrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="acfebe6109cc6e6cdf8f6910ef52966f4" name="acfebe6109cc6e6cdf8f6910ef52966f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfebe6109cc6e6cdf8f6910ef52966f4">&#9670;&#160;</a></span>llrintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::llrintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="ae026db8a513ac677c58931204032ea87" name="ae026db8a513ac677c58931204032ea87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae026db8a513ac677c58931204032ea87">&#9670;&#160;</a></span>llrint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::llrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a72786dec8ee1f7facc0e026e8793ea29" name="a72786dec8ee1f7facc0e026e8793ea29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72786dec8ee1f7facc0e026e8793ea29">&#9670;&#160;</a></span>llrint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::llrint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a06be44ea5149be36d471ea497927242b" name="a06be44ea5149be36d471ea497927242b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06be44ea5149be36d471ea497927242b">&#9670;&#160;</a></span>llrintl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::llrintl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="adcfc54e2b11311c629c920867ab2f0cb" name="adcfc54e2b11311c629c920867ab2f0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfc54e2b11311c629c920867ab2f0cb">&#9670;&#160;</a></span>llrint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::llrint </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value, using the current rounding mode. </p>

</div>
</div>
<a id="a21120c1b64cbc4c4d446f0859a011d82" name="a21120c1b64cbc4c4d446f0859a011d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21120c1b64cbc4c4d446f0859a011d82">&#9670;&#160;</a></span>nanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the implementation-defined character string arg into the corresponding quiet NaN value. </p>
<p>Returns the quiet NaN value that corresponds to the identifying string arg or zero if the implementation does not support quiet NaNs.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nan">https://en.cppreference.com/w/cpp/numeric/math/nan</a> </p>

</div>
</div>
<a id="a7e0c6b512cfa1423e392e02430121c44" name="a7e0c6b512cfa1423e392e02430121c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0c6b512cfa1423e392e02430121c44">&#9670;&#160;</a></span>nan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the implementation-defined character string arg into the corresponding quiet NaN value. </p>
<p>Returns the quiet NaN value that corresponds to the identifying string arg or zero if the implementation does not support quiet NaNs.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nan">https://en.cppreference.com/w/cpp/numeric/math/nan</a> </p>

</div>
</div>
<a id="ae289a4c91b473e5e1302aa1b0142b48d" name="ae289a4c91b473e5e1302aa1b0142b48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae289a4c91b473e5e1302aa1b0142b48d">&#9670;&#160;</a></span>nanl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nanl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the implementation-defined character string arg into the corresponding quiet NaN value. </p>
<p>Returns the quiet NaN value that corresponds to the identifying string arg or zero if the implementation does not support quiet NaNs.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nan">https://en.cppreference.com/w/cpp/numeric/math/nan</a> </p>

</div>
</div>
<a id="a59be8945c5efec1cdc9860dd0a8f04ed" name="a59be8945c5efec1cdc9860dd0a8f04ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59be8945c5efec1cdc9860dd0a8f04ed">&#9670;&#160;</a></span>nextafter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nextafter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next representable value of from in the direction of to. If from equals to, to is returned. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nextafter">https://en.cppreference.com/w/cpp/numeric/math/nextafter</a> </p>

</div>
</div>
<a id="a7c0420dd56139b0939734e1952cbb1c4" name="a7c0420dd56139b0939734e1952cbb1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0420dd56139b0939734e1952cbb1c4">&#9670;&#160;</a></span>nextafterf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nextafterf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next representable value of from in the direction of to. If from equals to, to is returned. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nextafter">https://en.cppreference.com/w/cpp/numeric/math/nextafter</a> </p>

</div>
</div>
<a id="a3f83e49db9982e87ce21075dc80cf9a5" name="a3f83e49db9982e87ce21075dc80cf9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f83e49db9982e87ce21075dc80cf9a5">&#9670;&#160;</a></span>nextafter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nextafter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next representable value of from in the direction of to. If from equals to, to is returned. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/nextafter">https://en.cppreference.com/w/cpp/numeric/math/nextafter</a> </p>

</div>
</div>
<a id="ad02a7e8321924bb554b336b84c2ee60d" name="ad02a7e8321924bb554b336b84c2ee60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02a7e8321924bb554b336b84c2ee60d">&#9670;&#160;</a></span>remainder() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a> </p>

</div>
</div>
<a id="a11dd6c6fa125a008a2226c4f2a8b225f" name="a11dd6c6fa125a008a2226c4f2a8b225f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dd6c6fa125a008a2226c4f2a8b225f">&#9670;&#160;</a></span>remainderf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remainderf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a> </p>

</div>
</div>
<a id="ad3bce49452ed33940fa9b1c8d2585072" name="ad3bce49452ed33940fa9b1c8d2585072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bce49452ed33940fa9b1c8d2585072">&#9670;&#160;</a></span>remainder() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a> </p>

</div>
</div>
<a id="a999d51f2384d0b2fbfd76288906b3e2d" name="a999d51f2384d0b2fbfd76288906b3e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999d51f2384d0b2fbfd76288906b3e2d">&#9670;&#160;</a></span>remainder() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remainder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a> </p>

</div>
</div>
<a id="a2f1521d8219ac8ccb84c5de502919411" name="a2f1521d8219ac8ccb84c5de502919411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1521d8219ac8ccb84c5de502919411">&#9670;&#160;</a></span>remainderl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::remainderl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of the floating point division operation x/y. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/remainder">https://en.cppreference.com/w/cpp/numeric/math/remainder</a> </p>

</div>
</div>
<a id="accd8b50cafa711d52c60a19ca80dee8f" name="accd8b50cafa711d52c60a19ca80dee8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd8b50cafa711d52c60a19ca80dee8f">&#9670;&#160;</a></span>rint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a285bdc5b020e3beb9ee509210e207dd5" name="a285bdc5b020e3beb9ee509210e207dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285bdc5b020e3beb9ee509210e207dd5">&#9670;&#160;</a></span>rintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a315cfa1d5908f72cf3aff4979a814dd3" name="a315cfa1d5908f72cf3aff4979a814dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315cfa1d5908f72cf3aff4979a814dd3">&#9670;&#160;</a></span>rint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a8c6deedd67292f24e059f4a0a6f62f1a" name="a8c6deedd67292f24e059f4a0a6f62f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6deedd67292f24e059f4a0a6f62f1a">&#9670;&#160;</a></span>rint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a36cb8315104a3f48b9fb3e304aa2a6dd" name="a36cb8315104a3f48b9fb3e304aa2a6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cb8315104a3f48b9fb3e304aa2a6dd">&#9670;&#160;</a></span>rintl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rintl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a1d6a250e98656b00833eb33ee493b12b" name="a1d6a250e98656b00833eb33ee493b12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6a250e98656b00833eb33ee493b12b">&#9670;&#160;</a></span>rint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rint </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds the floating-point argument arg to an integer value. </p>

</div>
</div>
<a id="a653865fab50c43932f405e8e140e1ced" name="a653865fab50c43932f405e8e140e1ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653865fab50c43932f405e8e140e1ced">&#9670;&#160;</a></span>round() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a8200750f9da147ccc3c2f647156ed7bb" name="a8200750f9da147ccc3c2f647156ed7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8200750f9da147ccc3c2f647156ed7bb">&#9670;&#160;</a></span>roundf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::roundf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a7e261cc501d3a147de6d342131c222af" name="a7e261cc501d3a147de6d342131c222af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e261cc501d3a147de6d342131c222af">&#9670;&#160;</a></span>round() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a5029f46266d011b01975c90e160ab5d9" name="a5029f46266d011b01975c90e160ab5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5029f46266d011b01975c90e160ab5d9">&#9670;&#160;</a></span>round() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a3ec2b94f73e269d1e72241957410aa01" name="a3ec2b94f73e269d1e72241957410aa01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec2b94f73e269d1e72241957410aa01">&#9670;&#160;</a></span>roundl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::roundl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="ae0f6ec1f24e0018a43cc5a4017ad7305" name="ae0f6ec1f24e0018a43cc5a4017ad7305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f6ec1f24e0018a43cc5a4017ad7305">&#9670;&#160;</a></span>round() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::round </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer value to arg (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/round">https://en.cppreference.com/w/cpp/numeric/math/round</a> </p>

</div>
</div>
<a id="a5ba0ce5c59de256a555eeaae79891ad0" name="a5ba0ce5c59de256a555eeaae79891ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba0ce5c59de256a555eeaae79891ad0">&#9670;&#160;</a></span>signbit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::signbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is negative. </p>
<p>This function detects the sign bit of zeroes, infinities, and NaNs. Along with <a class="el" href="group__cmath.html#ga17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a>, <a class="el" href="#a92f672431014d52f52f9ce327fd19b81">etl::signbit</a> is one of the only two portable ways to examine the sign of a NaN.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/signbit">https://en.cppreference.com/w/cpp/numeric/math/signbit</a> </p>

</div>
</div>
<a id="ae16ba0e54e5210e5103728c522ef59c1" name="ae16ba0e54e5210e5103728c522ef59c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16ba0e54e5210e5103728c522ef59c1">&#9670;&#160;</a></span>signbit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::signbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is negative. </p>
<p>This function detects the sign bit of zeroes, infinities, and NaNs. Along with <a class="el" href="group__cmath.html#ga17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a>, <a class="el" href="#a92f672431014d52f52f9ce327fd19b81">etl::signbit</a> is one of the only two portable ways to examine the sign of a NaN.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/signbit">https://en.cppreference.com/w/cpp/numeric/math/signbit</a> </p>

</div>
</div>
<a id="a6394d0dfcf05ed36d1a93ed7384b3ab4" name="a6394d0dfcf05ed36d1a93ed7384b3ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6394d0dfcf05ed36d1a93ed7384b3ab4">&#9670;&#160;</a></span>signbit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::signbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is negative. </p>
<p>This function detects the sign bit of zeroes, infinities, and NaNs. Along with <a class="el" href="group__cmath.html#ga17223939b148fdd815e90f732a5d2ed8" title="Composes a floating point value with the magnitude of mag and the sign of sgn.">etl::copysign</a>, <a class="el" href="#a92f672431014d52f52f9ce327fd19b81">etl::signbit</a> is one of the only two portable ways to examine the sign of a NaN.</p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/signbit">https://en.cppreference.com/w/cpp/numeric/math/signbit</a> </p>

</div>
</div>
<a id="a658bf05b8a1404b6e18366e9666a793b" name="a658bf05b8a1404b6e18366e9666a793b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658bf05b8a1404b6e18366e9666a793b">&#9670;&#160;</a></span>sin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine of num (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a> </p>

</div>
</div>
<a id="abdde537199b7bb6f4ec05ecb394cf2c9" name="abdde537199b7bb6f4ec05ecb394cf2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdde537199b7bb6f4ec05ecb394cf2c9">&#9670;&#160;</a></span>sinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine of num (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a> </p>

</div>
</div>
<a id="afed7450ee38549d51ff3c60fe2630530" name="afed7450ee38549d51ff3c60fe2630530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed7450ee38549d51ff3c60fe2630530">&#9670;&#160;</a></span>sin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine of num (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a> </p>

</div>
</div>
<a id="ad8903f152a43eb61c341a4e03221fa27" name="ad8903f152a43eb61c341a4e03221fa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8903f152a43eb61c341a4e03221fa27">&#9670;&#160;</a></span>sin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine of num (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a> </p>

</div>
</div>
<a id="a1243af94f0a71d9df38ea872c3c84632" name="a1243af94f0a71d9df38ea872c3c84632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1243af94f0a71d9df38ea872c3c84632">&#9670;&#160;</a></span>sinl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sinl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine of num (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a> </p>

</div>
</div>
<a id="a42714f17f2630f23993520d2052fab1a" name="a42714f17f2630f23993520d2052fab1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42714f17f2630f23993520d2052fab1a">&#9670;&#160;</a></span>sin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sin </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sine of num (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sin">https://en.cppreference.com/w/cpp/numeric/math/sin</a> </p>

</div>
</div>
<a id="a81ea280e9468d3bccca526a7cbc73651" name="a81ea280e9468d3bccca526a7cbc73651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ea280e9468d3bccca526a7cbc73651">&#9670;&#160;</a></span>sinh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a> </p>

</div>
</div>
<a id="a2410ac3995142466f68376374b9d4ec3" name="a2410ac3995142466f68376374b9d4ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2410ac3995142466f68376374b9d4ec3">&#9670;&#160;</a></span>sinhf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sinhf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a> </p>

</div>
</div>
<a id="a134b303ad71ff97a362470bf0d51aeea" name="a134b303ad71ff97a362470bf0d51aeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134b303ad71ff97a362470bf0d51aeea">&#9670;&#160;</a></span>sinh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a> </p>

</div>
</div>
<a id="ac254ab46d592daba270994a02a06afbb" name="ac254ab46d592daba270994a02a06afbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac254ab46d592daba270994a02a06afbb">&#9670;&#160;</a></span>sinh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a> </p>

</div>
</div>
<a id="ab2d2c54a18b0472cabe0c5a66b6daf30" name="ab2d2c54a18b0472cabe0c5a66b6daf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d2c54a18b0472cabe0c5a66b6daf30">&#9670;&#160;</a></span>sinhl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sinhl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a> </p>

</div>
</div>
<a id="ac40d2d23c8e8fccf96b3b782e667c210" name="ac40d2d23c8e8fccf96b3b782e667c210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40d2d23c8e8fccf96b3b782e667c210">&#9670;&#160;</a></span>sinh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sinh </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic sine of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sinh">https://en.cppreference.com/w/cpp/numeric/math/sinh</a> </p>

</div>
</div>
<a id="a2e6d19ae1f2df5e1e7f62db7a939946d" name="a2e6d19ae1f2df5e1e7f62db7a939946d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6d19ae1f2df5e1e7f62db7a939946d">&#9670;&#160;</a></span>sqrt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a> </p>

</div>
</div>
<a id="a5f9f94a766a382b51806352f5e757526" name="a5f9f94a766a382b51806352f5e757526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9f94a766a382b51806352f5e757526">&#9670;&#160;</a></span>sqrtf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sqrtf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a> </p>

</div>
</div>
<a id="a7e65e7903be2c1a9749a5249e6c790f8" name="a7e65e7903be2c1a9749a5249e6c790f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e65e7903be2c1a9749a5249e6c790f8">&#9670;&#160;</a></span>sqrt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a> </p>

</div>
</div>
<a id="a5c22d86b18b9a040289d082be62c4ec7" name="a5c22d86b18b9a040289d082be62c4ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c22d86b18b9a040289d082be62c4ec7">&#9670;&#160;</a></span>sqrt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a> </p>

</div>
</div>
<a id="a1b08acd2af82eed59a672ca38721e263" name="a1b08acd2af82eed59a672ca38721e263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b08acd2af82eed59a672ca38721e263">&#9670;&#160;</a></span>sqrtl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sqrtl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a> </p>

</div>
</div>
<a id="acb720e73aa27e1f9c5a3a2bc830bef84" name="acb720e73aa27e1f9c5a3a2bc830bef84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb720e73aa27e1f9c5a3a2bc830bef84">&#9670;&#160;</a></span>sqrt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sqrt </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square root of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/sqrt">https://en.cppreference.com/w/cpp/numeric/math/sqrt</a> </p>

</div>
</div>
<a id="aa3e43e254d59d4cd608b1d9f1399167d" name="aa3e43e254d59d4cd608b1d9f1399167d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e43e254d59d4cd608b1d9f1399167d">&#9670;&#160;</a></span>tan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a> </p>

</div>
</div>
<a id="ab7cd684aadcdf2df4696dd5c9ae99ea2" name="ab7cd684aadcdf2df4696dd5c9ae99ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cd684aadcdf2df4696dd5c9ae99ea2">&#9670;&#160;</a></span>tanf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a> </p>

</div>
</div>
<a id="a2e6be38a86dc3804ad690b2ea4f3c082" name="a2e6be38a86dc3804ad690b2ea4f3c082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6be38a86dc3804ad690b2ea4f3c082">&#9670;&#160;</a></span>tan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a> </p>

</div>
</div>
<a id="abf39aea93d6cef89e6b047068532251f" name="abf39aea93d6cef89e6b047068532251f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf39aea93d6cef89e6b047068532251f">&#9670;&#160;</a></span>tan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a> </p>

</div>
</div>
<a id="a8821d6a54a089020394afeddd92eb20c" name="a8821d6a54a089020394afeddd92eb20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8821d6a54a089020394afeddd92eb20c">&#9670;&#160;</a></span>tanl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tanl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a> </p>

</div>
</div>
<a id="a82108d39542689318c049d79b7a1443b" name="a82108d39542689318c049d79b7a1443b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82108d39542689318c049d79b7a1443b">&#9670;&#160;</a></span>tan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tan </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the tangent of arg (measured in radians). </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tan">https://en.cppreference.com/w/cpp/numeric/math/tan</a> </p>

</div>
</div>
<a id="a94a06c6155118cf0eea70d7f72e7ee26" name="a94a06c6155118cf0eea70d7f72e7ee26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a06c6155118cf0eea70d7f72e7ee26">&#9670;&#160;</a></span>tanh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a> </p>

</div>
</div>
<a id="a0b71e15eca59ee5d5814c5df7de5f540" name="a0b71e15eca59ee5d5814c5df7de5f540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b71e15eca59ee5d5814c5df7de5f540">&#9670;&#160;</a></span>tanhf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tanhf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a> </p>

</div>
</div>
<a id="a338f420d3e517380454cff3e76c275de" name="a338f420d3e517380454cff3e76c275de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338f420d3e517380454cff3e76c275de">&#9670;&#160;</a></span>tanh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a> </p>

</div>
</div>
<a id="abaa9bf0ccb082968efc0da1be519a4d3" name="abaa9bf0ccb082968efc0da1be519a4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa9bf0ccb082968efc0da1be519a4d3">&#9670;&#160;</a></span>tanh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a> </p>

</div>
</div>
<a id="a770ad213930a5de35a7e4d8efbb65c16" name="a770ad213930a5de35a7e4d8efbb65c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770ad213930a5de35a7e4d8efbb65c16">&#9670;&#160;</a></span>tanhl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tanhl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a> </p>

</div>
</div>
<a id="a9de6b5cc89e28e1ba7eac7465f380fba" name="a9de6b5cc89e28e1ba7eac7465f380fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de6b5cc89e28e1ba7eac7465f380fba">&#9670;&#160;</a></span>tanh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tanh </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hyperbolic tangent of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tanh">https://en.cppreference.com/w/cpp/numeric/math/tanh</a> </p>

</div>
</div>
<a id="a304d035a3a2740c7fef43426fcf3b9cb" name="a304d035a3a2740c7fef43426fcf3b9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304d035a3a2740c7fef43426fcf3b9cb">&#9670;&#160;</a></span>tgamma() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tgamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a> </p>

</div>
</div>
<a id="aba0533d6b346e372e13a35a00e4fe5ac" name="aba0533d6b346e372e13a35a00e4fe5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0533d6b346e372e13a35a00e4fe5ac">&#9670;&#160;</a></span>tgammaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tgammaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a> </p>

</div>
</div>
<a id="a8d14d3d27f8694d9d4b771100bd4c74e" name="a8d14d3d27f8694d9d4b771100bd4c74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d14d3d27f8694d9d4b771100bd4c74e">&#9670;&#160;</a></span>tgamma() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tgamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a> </p>

</div>
</div>
<a id="a7455e948ac61779dbd3be0c44190e569" name="a7455e948ac61779dbd3be0c44190e569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7455e948ac61779dbd3be0c44190e569">&#9670;&#160;</a></span>tgamma() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tgamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a> </p>

</div>
</div>
<a id="a6252e2a52632b3b841f2b21455c2fa7a" name="a6252e2a52632b3b841f2b21455c2fa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6252e2a52632b3b841f2b21455c2fa7a">&#9670;&#160;</a></span>tgammal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tgammal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a> </p>

</div>
</div>
<a id="ae31c7fddeeebae7fde466c96fafadd4c" name="ae31c7fddeeebae7fde466c96fafadd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31c7fddeeebae7fde466c96fafadd4c">&#9670;&#160;</a></span>tgamma() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tgamma </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/tgamma">https://en.cppreference.com/w/cpp/numeric/math/tgamma</a> </p>

</div>
</div>
<a id="a77e4586e25e102b1dcd61e06b661ac2d" name="a77e4586e25e102b1dcd61e06b661ac2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e4586e25e102b1dcd61e06b661ac2d">&#9670;&#160;</a></span>trunc() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::trunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a> </p>

</div>
</div>
<a id="a9c5336aa0b394c2196ad1b8f15b2441b" name="a9c5336aa0b394c2196ad1b8f15b2441b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5336aa0b394c2196ad1b8f15b2441b">&#9670;&#160;</a></span>truncf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::truncf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a> </p>

</div>
</div>
<a id="aa8316f5c97f691318a53cf91fd135894" name="aa8316f5c97f691318a53cf91fd135894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8316f5c97f691318a53cf91fd135894">&#9670;&#160;</a></span>trunc() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::trunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a> </p>

</div>
</div>
<a id="aa33b0697205c635cb1e294cfecbcfd46" name="aa33b0697205c635cb1e294cfecbcfd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33b0697205c635cb1e294cfecbcfd46">&#9670;&#160;</a></span>trunc() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::trunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a> </p>

</div>
</div>
<a id="aa86cd183532a15f7fb8fa893a9db7d44" name="aa86cd183532a15f7fb8fa893a9db7d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86cd183532a15f7fb8fa893a9db7d44">&#9670;&#160;</a></span>truncl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::truncl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a> </p>

</div>
</div>
<a id="af9896e22ccd29baf6a2bca31d48f6e4b" name="af9896e22ccd29baf6a2bca31d48f6e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9896e22ccd29baf6a2bca31d48f6e4b">&#9670;&#160;</a></span>trunc() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::trunc </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nearest integer not greater in magnitude than arg. </p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a> </p>

</div>
</div>
<a id="a1d038b8a789971cb7319f23919ae1d1f" name="a1d038b8a789971cb7319f23919ae1d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d038b8a789971cb7319f23919ae1d1f">&#9670;&#160;</a></span>is_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83376b31eb27942ae5c71f06c91decc8" name="a83376b31eb27942ae5c71f06c91decc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83376b31eb27942ae5c71f06c91decc8">&#9670;&#160;</a></span>is_neq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_neq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ec1b19096d66a3614daa7bc0ec0c564" name="a9ec1b19096d66a3614daa7bc0ec0c564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec1b19096d66a3614daa7bc0ec0c564">&#9670;&#160;</a></span>is_lt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46b3b676935f0ab36310d8f87b00da2d" name="a46b3b676935f0ab36310d8f87b00da2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b3b676935f0ab36310d8f87b00da2d">&#9670;&#160;</a></span>is_lteq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_lteq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52bd271610a81bd07da4d1f15f55ce2b" name="a52bd271610a81bd07da4d1f15f55ce2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bd271610a81bd07da4d1f15f55ce2b">&#9670;&#160;</a></span>is_gt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ff127460a7b71fec87f3156800a3972" name="a9ff127460a7b71fec87f3156800a3972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff127460a7b71fec87f3156800a3972">&#9670;&#160;</a></span>is_gteq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_gteq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td>          <td class="paramname"><span class="paramname"><em>cmp</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93401bd9402632426cada76f529d6b9f" name="a93401bd9402632426cada76f529d6b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93401bd9402632426cada76f529d6b9f">&#9670;&#160;</a></span>operator+() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa112bbaeebf7afad6d876c4291b195c8" name="aa112bbaeebf7afad6d876c4291b195c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa112bbaeebf7afad6d876c4291b195c8">&#9670;&#160;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a650bebf4618f883ada09c2039a4b725b" name="a650bebf4618f883ada09c2039a4b725b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650bebf4618f883ada09c2039a4b725b">&#9670;&#160;</a></span>operator+() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac21b902b9c3ad85f752def9d8b61e99c" name="ac21b902b9c3ad85f752def9d8b61e99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21b902b9c3ad85f752def9d8b61e99c">&#9670;&#160;</a></span>operator+() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4cbf5d3ec0e799c656a8c39087e0718" name="ac4cbf5d3ec0e799c656a8c39087e0718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cbf5d3ec0e799c656a8c39087e0718">&#9670;&#160;</a></span>operator+() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82931442d5539449fd23546e25bb86ae" name="a82931442d5539449fd23546e25bb86ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82931442d5539449fd23546e25bb86ae">&#9670;&#160;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a499c18a06cffd9fb9930ba800faa4801" name="a499c18a06cffd9fb9930ba800faa4801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499c18a06cffd9fb9930ba800faa4801">&#9670;&#160;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f5c49d6dab738f50f9729f5e38ffcb" name="a48f5c49d6dab738f50f9729f5e38ffcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f5c49d6dab738f50f9729f5e38ffcb">&#9670;&#160;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>- </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62d31064099961389d855da11c34cd31" name="a62d31064099961389d855da11c34cd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d31064099961389d855da11c34cd31">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dea59a34e6077f3bfdbf0bedc4bc6bf" name="a0dea59a34e6077f3bfdbf0bedc4bc6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dea59a34e6077f3bfdbf0bedc4bc6bf">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9e69e867df1a1b9564f6825a59062b8" name="ae9e69e867df1a1b9564f6825a59062b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e69e867df1a1b9564f6825a59062b8">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>* </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e1ecd06afff7b886ff8690bf298584" name="ae5e1ecd06afff7b886ff8690bf298584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e1ecd06afff7b886ff8690bf298584">&#9670;&#160;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a73215990ea73911836054392d33c25" name="a9a73215990ea73911836054392d33c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a73215990ea73911836054392d33c25">&#9670;&#160;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77987b5129ca33aaac1cc7f239d3f0ba" name="a77987b5129ca33aaac1cc7f239d3f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77987b5129ca33aaac1cc7f239d3f0ba">&#9670;&#160;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2e6646ea6ece6aac46299e9d0ae0204" name="ae2e6646ea6ece6aac46299e9d0ae0204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e6646ea6ece6aac46299e9d0ae0204">&#9670;&#160;</a></span>operator==() <span class="overload">[1/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1dbf6c912f63446fe62ca363ce14874" name="af1dbf6c912f63446fe62ca363ce14874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dbf6c912f63446fe62ca363ce14874">&#9670;&#160;</a></span>operator==() <span class="overload">[2/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89a8fc7be9c1bc3f843a73e0e4084a15" name="a89a8fc7be9c1bc3f843a73e0e4084a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a8fc7be9c1bc3f843a73e0e4084a15">&#9670;&#160;</a></span>operator==() <span class="overload">[3/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19652b6d64df0961e5821c4df232fcc5" name="a19652b6d64df0961e5821c4df232fcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19652b6d64df0961e5821c4df232fcc5">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf4c2db5ab66a07bf724a38c83659acd" name="aaf4c2db5ab66a07bf724a38c83659acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4c2db5ab66a07bf724a38c83659acd">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd1eb7312810a052d5df24b678a67965" name="abd1eb7312810a052d5df24b678a67965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1eb7312810a052d5df24b678a67965">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f88510fb558792c06ba4d60e131fdd1" name="a5f88510fb558792c06ba4d60e131fdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f88510fb558792c06ba4d60e131fdd1">&#9670;&#160;</a></span>to_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return Int(b);</code> </p>

</div>
</div>
<a id="a7f962a144b755b9ea24d08df7e0b0cac" name="a7f962a144b755b9ea24d08df7e0b0cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f962a144b755b9ea24d08df7e0b0cac">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return <a class="el" href="#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);</code> </p>

</div>
</div>
<a id="ab7c6aea683ce911a79e8e3e149bcbd0a" name="ab7c6aea683ce911a79e8e3e149bcbd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c6aea683ce911a79e8e3e149bcbd0a">&#9670;&#160;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return <a class="el" href="#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);</code> </p>

</div>
</div>
<a id="ab8b6a5afd1d4bfe41cd6e68c65e863b2" name="ab8b6a5afd1d4bfe41cd6e68c65e863b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b6a5afd1d4bfe41cd6e68c65e863b2">&#9670;&#160;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp;

</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return b = b &lt;&lt; shift;</code> </p>

</div>
</div>
<a id="a816d2bda5b74ad68f41da42d2103bd05" name="a816d2bda5b74ad68f41da42d2103bd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816d2bda5b74ad68f41da42d2103bd05">&#9670;&#160;</a></span>operator&gt;&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return b = b &gt;&gt; shift;</code> </p>

</div>
</div>
<a id="ab8162fc27033213c5febe33984fe4620" name="ab8162fc27033213c5febe33984fe4620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8162fc27033213c5febe33984fe4620">&#9670;&#160;</a></span>operator|() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) | static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="abd648029508f54a8dbc5a24527893329" name="abd648029508f54a8dbc5a24527893329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd648029508f54a8dbc5a24527893329">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) &amp; static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a13f4395e5d3ab16e3babc4d612575cf1" name="a13f4395e5d3ab16e3babc4d612575cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f4395e5d3ab16e3babc4d612575cf1">&#9670;&#160;</a></span>operator^() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) ^ static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a52840f1140aa019ed0075de67862a323" name="a52840f1140aa019ed0075de67862a323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52840f1140aa019ed0075de67862a323">&#9670;&#160;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> etl::operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(~static_cast&lt;unsigned int&gt;(b));</code> </p>

</div>
</div>
<a id="aa68cc74f5c18699cb47643078832090a" name="aa68cc74f5c18699cb47643078832090a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68cc74f5c18699cb47643078832090a">&#9670;&#160;</a></span>operator|=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs | rhs;</code> </p>

</div>
</div>
<a id="a5ca267dc51177e1d336cad3b8d675f85" name="a5ca267dc51177e1d336cad3b8d675f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca267dc51177e1d336cad3b8d675f85">&#9670;&#160;</a></span>operator&amp;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs &amp; rhs;</code> </p>

</div>
</div>
<a id="a4bc5fb1abc307dee4cb7c8b115ba159c" name="a4bc5fb1abc307dee4cb7c8b115ba159c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc5fb1abc307dee4cb7c8b115ba159c">&#9670;&#160;</a></span>operator^=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1static__vector.html">constexpr</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#a1d957fa8529e9617c445e42519518e5e">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs ^ rhs;</code> </p>

</div>
</div>
<a id="af70c570009ef313782a1d98cfdadb585" name="af70c570009ef313782a1d98cfdadb585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70c570009ef313782a1d98cfdadb585">&#9670;&#160;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::atof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>

</div>
</div>
<a id="a3c7960c7c5d175e0f3618b82c78bcdb2" name="a3c7960c7c5d175e0f3618b82c78bcdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7960c7c5d175e0f3618b82c78bcdb2">&#9670;&#160;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::atoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="ac7f3cb11f38d582981fb054f50f8a39c" name="ac7f3cb11f38d582981fb054f50f8a39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f3cb11f38d582981fb054f50f8a39c">&#9670;&#160;</a></span>atol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::atol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="afbc340d657073dbc2d05ea36759ac0e4" name="afbc340d657073dbc2d05ea36759ac0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc340d657073dbc2d05ea36759ac0e4">&#9670;&#160;</a></span>atoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::atoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="a1ac545280f6ddc88082f02e4a7db6736" name="a1ac545280f6ddc88082f02e4a7db6736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac545280f6ddc88082f02e4a7db6736">&#9670;&#160;</a></span>div() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1div__t.html">div_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a1b084ea5ad111474f8921643c3de3931" name="a1b084ea5ad111474f8921643c3de3931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b084ea5ad111474f8921643c3de3931">&#9670;&#160;</a></span>labs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::labs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a43b5e9350f1530967470589c83376b30" name="a43b5e9350f1530967470589c83376b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b5e9350f1530967470589c83376b30">&#9670;&#160;</a></span>div() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="ab7b706a74e1efaf3c98804627fba671c" name="ab7b706a74e1efaf3c98804627fba671c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b706a74e1efaf3c98804627fba671c">&#9670;&#160;</a></span>ldiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ldiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a03c11a988c576e5879aa5b6517da8d3e" name="a03c11a988c576e5879aa5b6517da8d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c11a988c576e5879aa5b6517da8d3e">&#9670;&#160;</a></span>llabs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::llabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a3ea0cf9ba86f1635030cb6a8f03c88b0" name="a3ea0cf9ba86f1635030cb6a8f03c88b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea0cf9ba86f1635030cb6a8f03c88b0">&#9670;&#160;</a></span>div() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="ac6958cfa96164c754c7859d22d8e5a95" name="ac6958cfa96164c754c7859d22d8e5a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6958cfa96164c754c7859d22d8e5a95">&#9670;&#160;</a></span>lldiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::lldiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a1305ac2417af24cbfd08da05eeb1c32d" name="a1305ac2417af24cbfd08da05eeb1c32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1305ac2417af24cbfd08da05eeb1c32d">&#9670;&#160;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strtod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4" name="aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf79aa8f8f4eb6b2d4a36e6c4bdd5d4">&#9670;&#160;</a></span>strtof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strtof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a4892f7bf3b9db8e5a5b3476de9f04c07" name="a4892f7bf3b9db8e5a5b3476de9f04c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4892f7bf3b9db8e5a5b3476de9f04c07">&#9670;&#160;</a></span>strtol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strtol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtol">https://en.cppreference.com/w/cpp/string/byte/strtol</a> </p>

</div>
</div>
<a id="a53416ace17ca278512fca91c7ba514a9" name="a53416ace17ca278512fca91c7ba514a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53416ace17ca278512fca91c7ba514a9">&#9670;&#160;</a></span>strtoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strtoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtol">https://en.cppreference.com/w/cpp/string/byte/strtol</a> </p>

</div>
</div>
<a id="af4b910e11532f3565d81bd36ff4e4c10" name="af4b910e11532f3565d81bd36ff4e4c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b910e11532f3565d81bd36ff4e4c10">&#9670;&#160;</a></span>strtold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strtold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a4e80359aae6a19c6d0dc9aee1ba6fcb5" name="a4e80359aae6a19c6d0dc9aee1ba6fcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e80359aae6a19c6d0dc9aee1ba6fcb5">&#9670;&#160;</a></span>strtoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strtoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtoul">https://en.cppreference.com/w/cpp/string/byte/strtoul</a> </p>

</div>
</div>
<a id="a760b4a7bd2816e64811c98ac8e21e5c3" name="a760b4a7bd2816e64811c98ac8e21e5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760b4a7bd2816e64811c98ac8e21e5c3">&#9670;&#160;</a></span>strtoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strtoull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtoul">https://en.cppreference.com/w/cpp/string/byte/strtoul</a> </p>

</div>
</div>
<a id="a652d4e77b1294b6c89f3b26e64390c60" name="a652d4e77b1294b6c89f3b26e64390c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652d4e77b1294b6c89f3b26e64390c60">&#9670;&#160;</a></span>memchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::memchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr. </p>
<p>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by ptr is smaller than count, but the match is found within the array, the behavior is well-defined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/memchr">https://en.cppreference.com/w/cpp/string/byte/memchr</a></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the location of the character, or a null pointer if no such character is found. </dd></dl>

</div>
</div>
<a id="a017dcc9819e43ade5bb455dda0ded667" name="a017dcc9819e43ade5bb455dda0ded667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017dcc9819e43ade5bb455dda0ded667">&#9670;&#160;</a></span>memchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::memchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr. </p>
<p>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by ptr is smaller than count, but the match is found within the array, the behavior is well-defined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/memchr">https://en.cppreference.com/w/cpp/string/byte/memchr</a></p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the location of the character, or a null pointer if no such character is found. </dd></dl>

</div>
</div>
<a id="a1a7fa1c3f3f946c9269a7aa241e3efcf" name="a1a7fa1c3f3f946c9269a7aa241e3efcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7fa1c3f3f946c9269a7aa241e3efcf">&#9670;&#160;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="#abfee8229e9528f5285c42fde7abbe4b6" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead. </p>

</div>
</div>
<a id="abfee8229e9528f5285c42fde7abbe4b6" name="abfee8229e9528f5285c42fde7abbe4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfee8229e9528f5285c42fde7abbe4b6">&#9670;&#160;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::memmove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap. </p>

</div>
</div>
<a id="a055dc327ea35a394f661ca98bf2b08ad" name="a055dc327ea35a394f661ca98bf2b08ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055dc327ea35a394f661ca98bf2b08ad">&#9670;&#160;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the value of c (converted to an unsigned char) into each of the rst n characters of the object pointed to by s. </p>

</div>
</div>
<a id="abbb9a3999d07c6ea33b804dc470d6db3" name="abbb9a3999d07c6ea33b804dc470d6db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb9a3999d07c6ea33b804dc470d6db3">&#9670;&#160;</a></span>strcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated. </p>
<p>The behavior is undefined if the destination array is not large enough for the contents of both src and dest and the terminating null character. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="ae924f4675f1be06ee9610b8998d20101" name="ae924f4675f1be06ee9610b8998d20101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae924f4675f1be06ee9610b8998d20101">&#9670;&#160;</a></span>strchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strchr">https://en.cppreference.com/w/cpp/string/byte/strchr</a> </p>

</div>
</div>
<a id="afdaf5ecef57c791ea8f5d102444af26f" name="afdaf5ecef57c791ea8f5d102444af26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaf5ecef57c791ea8f5d102444af26f">&#9670;&#160;</a></span>strchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a>* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strchr">https://en.cppreference.com/w/cpp/string/byte/strchr</a> </p>

</div>
</div>
<a id="a2b99355fef2ddb6740fbda691efe5591" name="a2b99355fef2ddb6740fbda691efe5591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b99355fef2ddb6740fbda691efe5591">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the C string lhs to the C string rhs. </p>
<p>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. </p>

</div>
</div>
<a id="ac72afd377245fa4f73d8c4c49b5e42fd" name="ac72afd377245fa4f73d8c4c49b5e42fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72afd377245fa4f73d8c4c49b5e42fd">&#9670;&#160;</a></span>strcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest. </p>
<p>The behavior is undefined if the dest array is not large enough. The behavior is undefined if the strings overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="a07b32f2701df8bd44d7cff9b1ea93c2c" name="a07b32f2701df8bd44d7cff9b1ea93c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b32f2701df8bd44d7cff9b1ea93c2c">&#9670;&#160;</a></span>strcspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strcspn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src. </p>
<p>The function name stands for "complementary span"</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strcspn">https://en.cppreference.com/w/cpp/string/byte/strcspn</a> </p>

</div>
</div>
<a id="a1f52f9a0c2a72681b011673eb4d16997" name="a1f52f9a0c2a72681b011673eb4d16997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f52f9a0c2a72681b011673eb4d16997">&#9670;&#160;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the C string str. </p>

</div>
</div>
<a id="a3a52c188c85f66642fdcd0b2a5c0f343" name="a3a52c188c85f66642fdcd0b2a5c0f343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a52c188c85f66642fdcd0b2a5c0f343">&#9670;&#160;</a></span>strncat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strncat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated. </p>
<p>The destination byte string must have enough space for the contents of both dest and src plus the terminating null character, except that the size of src is limited to count. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="a86ea9bb99dc7df1c93691e27036d4e4c" name="a86ea9bb99dc7df1c93691e27036d4e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ea9bb99dc7df1c93691e27036d4e4c">&#9670;&#160;</a></span>strncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared. </p>
<p>The behavior is undefined when access occurs past the end of either array lhs or rhs. The behavior is undefined when either lhs or rhs is the null pointer. </p>

</div>
</div>
<a id="a591fc182edd0e8beef7af369c2dd772f" name="a591fc182edd0e8beef7af369c2dd772f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591fc182edd0e8beef7af369c2dd772f">&#9670;&#160;</a></span>strncpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strncpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest. </p>
<p>If count is reached before the entire string src was copied, the resulting character array is not null-terminated. If, after copying the terminating null character from src, count is not reached, additional null characters are written to dest until the total of count characters have been written. If the strings overlap, the behavior is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="af7504aaa95975de1bb831366bbd2c4c7" name="af7504aaa95975de1bb831366bbd2c4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7504aaa95975de1bb831366bbd2c4c7">&#9670;&#160;</a></span>strpbrk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strpbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strpbrk">https://en.cppreference.com/w/cpp/string/byte/strpbrk</a> </p>

</div>
</div>
<a id="aa2e3a1713cb32006d461f6cacaa45938" name="aa2e3a1713cb32006d461f6cacaa45938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e3a1713cb32006d461f6cacaa45938">&#9670;&#160;</a></span>strpbrk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strpbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strpbrk">https://en.cppreference.com/w/cpp/string/byte/strpbrk</a> </p>

</div>
</div>
<a id="aa1aa1bb3b20e18932c57369e8dd367ce" name="aa1aa1bb3b20e18932c57369e8dd367ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1aa1bb3b20e18932c57369e8dd367ce">&#9670;&#160;</a></span>strrchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strrchr">https://en.cppreference.com/w/cpp/string/byte/strrchr</a> </p>

</div>
</div>
<a id="a5f722dadf4562da90ec04a75000dca60" name="a5f722dadf4562da90ec04a75000dca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f722dadf4562da90ec04a75000dca60">&#9670;&#160;</a></span>strrchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str. </p>
<p>The terminating null character is considered to be a part of the string and can be found if searching for '\0'.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strrchr">https://en.cppreference.com/w/cpp/string/byte/strrchr</a> </p>

</div>
</div>
<a id="aef81a9b0d796d2bbac780bd021b75d5a" name="aef81a9b0d796d2bbac780bd021b75d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef81a9b0d796d2bbac780bd021b75d5a">&#9670;&#160;</a></span>strspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strspn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strspn">https://en.cppreference.com/w/cpp/string/byte/strspn</a> </p>

</div>
</div>
<a id="abda82eb09b8ee508deb730a58e8e1ad0" name="abda82eb09b8ee508deb730a58e8e1ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda82eb09b8ee508deb730a58e8e1ad0">&#9670;&#160;</a></span>strstr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared. </p>

</div>
</div>
<a id="a0dedeb847abd763b3016a290b6efd87e" name="a0dedeb847abd763b3016a290b6efd87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dedeb847abd763b3016a290b6efd87e">&#9670;&#160;</a></span>strstr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::strstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared. </p>

</div>
</div>
<a id="afb64ccab832f8ed29a305df495394bd8" name="afb64ccab832f8ed29a305df495394bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb64ccab832f8ed29a305df495394bd8">&#9670;&#160;</a></span>wcscat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcscat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated. </p>
<p>The behavior is undefined if the destination array is not large enough for the contents of both src and dest and the terminating null character. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="ab4f3717d1befc65ded1e73b0dc19405b" name="ab4f3717d1befc65ded1e73b0dc19405b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f3717d1befc65ded1e73b0dc19405b">&#9670;&#160;</a></span>wcschr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcschr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcschr">https://en.cppreference.com/w/cpp/string/wide/wcschr</a> </p>

</div>
</div>
<a id="afcc2ac1163d4f8e69b06785a16903b92" name="afcc2ac1163d4f8e69b06785a16903b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc2ac1163d4f8e69b06785a16903b92">&#9670;&#160;</a></span>wcschr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcschr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcschr">https://en.cppreference.com/w/cpp/string/wide/wcschr</a> </p>

</div>
</div>
<a id="a8dacca606e09097af1b0d48826fbbaf8" name="a8dacca606e09097af1b0d48826fbbaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dacca606e09097af1b0d48826fbbaf8">&#9670;&#160;</a></span>wcscmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcscmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two null-terminated wide strings lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</p>
<p>The behavior is undefined if lhs or rhs are not pointers to null-terminated wide strings. </p>

</div>
</div>
<a id="a777b53d3246198c5cbf458e59cbd05bf" name="a777b53d3246198c5cbf458e59cbd05bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777b53d3246198c5cbf458e59cbd05bf">&#9670;&#160;</a></span>wcscpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcscpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest. </p>
<p>The behavior is undefined if the dest array is not large enough. The behavior is undefined if the strings overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="af4a295816ea0a099202fb0dca32be52c" name="af4a295816ea0a099202fb0dca32be52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a295816ea0a099202fb0dca32be52c">&#9670;&#160;</a></span>wcscspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcscspn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcscspn">https://en.cppreference.com/w/cpp/string/wide/wcscspn</a> </p>

</div>
</div>
<a id="a52365d01da2db57b4fd8ab457fde90d4" name="a52365d01da2db57b4fd8ab457fde90d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52365d01da2db57b4fd8ab457fde90d4">&#9670;&#160;</a></span>wcslen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcslen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character. </p>

</div>
</div>
<a id="a31d334b345c8ec3b4df9ed3017e1a0e9" name="a31d334b345c8ec3b4df9ed3017e1a0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d334b345c8ec3b4df9ed3017e1a0e9">&#9670;&#160;</a></span>wcsncat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcsncat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1). </p>
<p>The destination byte string must have enough space for the contents of both dest and src plus the terminating null character, except that the size of src is limited to count. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="ad6cb809db1b2078c2f3a183d9cf15fe6" name="ad6cb809db1b2078c2f3a183d9cf15fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cb809db1b2078c2f3a183d9cf15fe6">&#9670;&#160;</a></span>wcsncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcsncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</p>
<p>The behavior is undefined if lhs or rhs are not pointers to null-terminated strings. </p>

</div>
</div>
<a id="a3df6765439e9363b7bd6b29c16e9ad1e" name="a3df6765439e9363b7bd6b29c16e9ad1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df6765439e9363b7bd6b29c16e9ad1e">&#9670;&#160;</a></span>wcsncpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcsncpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest. </p>
<p>If count is reached before the entire string src was copied, the resulting character array is not null-terminated. If, after copying the terminating null character from src, count is not reached, additional null characters are written to dest until the total of count characters have been written. If the strings overlap, the behavior is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="a543232e434a1cf41ac373bb986dd6761" name="a543232e434a1cf41ac373bb986dd6761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543232e434a1cf41ac373bb986dd6761">&#9670;&#160;</a></span>wcspbrk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcspbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a8b719c7d907c831543f6a36d7c03c358" name="a8b719c7d907c831543f6a36d7c03c358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b719c7d907c831543f6a36d7c03c358">&#9670;&#160;</a></span>wcspbrk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcspbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a5cde920ef4c8b78dad83887cf67520dd" name="a5cde920ef4c8b78dad83887cf67520dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cde920ef4c8b78dad83887cf67520dd">&#9670;&#160;</a></span>wcsrchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcsrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsrchr">https://en.cppreference.com/w/cpp/string/wide/wcsrchr</a> </p>

</div>
</div>
<a id="a1b66e9eebb616eadbab0b3001b1e9660" name="a1b66e9eebb616eadbab0b3001b1e9660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b66e9eebb616eadbab0b3001b1e9660">&#9670;&#160;</a></span>wcsrchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcsrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsrchr">https://en.cppreference.com/w/cpp/string/wide/wcsrchr</a> </p>

</div>
</div>
<a id="a51c979220a7a1ae7a993a34cce85292a" name="a51c979220a7a1ae7a993a34cce85292a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c979220a7a1ae7a993a34cce85292a">&#9670;&#160;</a></span>wcsspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcsspn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsspn">https://en.cppreference.com/w/cpp/string/wide/wcsspn</a> </p>

</div>
</div>
<a id="a32485447cbd1674e0686656279ec028c" name="a32485447cbd1674e0686656279ec028c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32485447cbd1674e0686656279ec028c">&#9670;&#160;</a></span>wcsstr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcsstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a074c0611a936348d0a6ca7ddc93df74a" name="a074c0611a936348d0a6ca7ddc93df74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074c0611a936348d0a6ca7ddc93df74a">&#9670;&#160;</a></span>wcsstr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wcsstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a2e196f654f32975356c8fba3537a39de" name="a2e196f654f32975356c8fba3537a39de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e196f654f32975356c8fba3537a39de">&#9670;&#160;</a></span>wmemchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wmemchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr. </p>
<p>If count is zero, the function returns a null pointer.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemchr">https://en.cppreference.com/w/cpp/string/wide/wmemchr</a> </p>

</div>
</div>
<a id="ae467dc0a0abf29b78d47c3b475ecb5ba" name="ae467dc0a0abf29b78d47c3b475ecb5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae467dc0a0abf29b78d47c3b475ecb5ba">&#9670;&#160;</a></span>wmemchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wmemchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr. </p>
<p>If count is zero, the function returns a null pointer.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemchr">https://en.cppreference.com/w/cpp/string/wide/wmemchr</a> </p>

</div>
</div>
<a id="a379cf75ba2d4c066193884e36556cf04" name="a379cf75ba2d4c066193884e36556cf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379cf75ba2d4c066193884e36556cf04">&#9670;&#160;</a></span>wmemcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wmemcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared. If count is zero, the function does nothing.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemcmp">https://en.cppreference.com/w/cpp/string/wide/wmemcmp</a> </p>

</div>
</div>
<a id="a1d687ebc1e3e94aa01302127c3eb8400" name="a1d687ebc1e3e94aa01302127c3eb8400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d687ebc1e3e94aa01302127c3eb8400">&#9670;&#160;</a></span>wmemcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wmemcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemcpy">https://en.cppreference.com/w/cpp/string/wide/wmemcpy</a> </p>

</div>
</div>
<a id="a87cdeb9c67af4a7dfe7cc7ab4c88e390" name="a87cdeb9c67af4a7dfe7cc7ab4c88e390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cdeb9c67af4a7dfe7cc7ab4c88e390">&#9670;&#160;</a></span>wmemmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wmemmove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. </p>
<p>If count is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to dest. This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it copies: nulls as well as invalid characters are copied too.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemmove">https://en.cppreference.com/w/cpp/string/wide/wmemmove</a> </p>

</div>
</div>
<a id="a24a108d16f8cd8006676972370a2b2ed" name="a24a108d16f8cd8006676972370a2b2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a108d16f8cd8006676972370a2b2ed">&#9670;&#160;</a></span>wmemset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::wmemset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest. </p>
<p>If overflow occurs, the behavior is undefined. If count is zero, the function does nothing.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemset">https://en.cppreference.com/w/cpp/string/wide/wmemset</a> </p>

</div>
</div>
<a id="adf33590c450c820a71740fa96d4fd8bf" name="adf33590c450c820a71740fa96d4fd8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf33590c450c820a71740fa96d4fd8bf">&#9670;&#160;</a></span>iswalnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswalnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswalnum">https://en.cppreference.com/w/cpp/string/wide/iswalnum</a> </p>

</div>
</div>
<a id="a50bb7228a1ec4507b17c3800ae7edaad" name="a50bb7228a1ec4507b17c3800ae7edaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bb7228a1ec4507b17c3800ae7edaad">&#9670;&#160;</a></span>iswalpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswalpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswalpha">https://en.cppreference.com/w/cpp/string/wide/iswalpha</a> </p>

</div>
</div>
<a id="ace8266a2249c1038e8be09fc34571aa3" name="ace8266a2249c1038e8be09fc34571aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8266a2249c1038e8be09fc34571aa3">&#9670;&#160;</a></span>iswblank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswblank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswblank">https://en.cppreference.com/w/cpp/string/wide/iswblank</a> </p>

</div>
</div>
<a id="aa16fb2c6452c7d592f75fad4c301f65f" name="aa16fb2c6452c7d592f75fad4c301f65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16fb2c6452c7d592f75fad4c301f65f">&#9670;&#160;</a></span>iswcntrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswcntrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/iscntrl">https://en.cppreference.com/w/cpp/string/byte/iscntrl</a> </p>

</div>
</div>
<a id="a91a984673da6b8253c14ef105d4ecabe" name="a91a984673da6b8253c14ef105d4ecabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a984673da6b8253c14ef105d4ecabe">&#9670;&#160;</a></span>iswdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswdigit">https://en.cppreference.com/w/cpp/string/wide/iswdigit</a> </p>

</div>
</div>
<a id="af1f830b2cf289299d90d426cdec407ee" name="af1f830b2cf289299d90d426cdec407ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f830b2cf289299d90d426cdec407ee">&#9670;&#160;</a></span>iswgraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~) or any graphical character specific to the current C locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswgraph">https://en.cppreference.com/w/cpp/string/wide/iswgraph</a> </p>

</div>
</div>
<a id="a18eb7b15acffae2d169a7eaed66d9ba8" name="a18eb7b15acffae2d169a7eaed66d9ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18eb7b15acffae2d169a7eaed66d9ba8">&#9670;&#160;</a></span>iswlower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswlower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswlower">https://en.cppreference.com/w/cpp/string/wide/iswlower</a> </p>

</div>
</div>
<a id="a92c5da6eb3f6bb1409caaf48fe877d11" name="a92c5da6eb3f6bb1409caaf48fe877d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c5da6eb3f6bb1409caaf48fe877d11">&#9670;&#160;</a></span>iswprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswprint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~), space or any printable character specific to the current C locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswprint">https://en.cppreference.com/w/cpp/string/wide/iswprint</a> </p>

</div>
</div>
<a id="ace0e85b2a576c543e973d860e1c1295f" name="ace0e85b2a576c543e973d860e1c1295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0e85b2a576c543e973d860e1c1295f">&#9670;&#160;</a></span>iswpunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswpunct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a punctuation character, i.e. it is one of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ or any punctuation character specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswpunct">https://en.cppreference.com/w/cpp/string/wide/iswpunct</a> </p>

</div>
</div>
<a id="a38dbfeff185b4dad6a13d3c3e891f366" name="a38dbfeff185b4dad6a13d3c3e891f366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dbfeff185b4dad6a13d3c3e891f366">&#9670;&#160;</a></span>iswspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following: </p>
<pre class="fragment">- space (0x20, ' ')
- form feed (0x0c, '\f')
- line feed (0x0a, '\n')
- carriage return (0x0d, '\r')
- horizontal tab (0x09, '\t')
- vertical tab (0x0b, '\v')
</pre><p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswspace">https://en.cppreference.com/w/cpp/string/wide/iswspace</a> </p>

</div>
</div>
<a id="ae31f677c72798a1e14ebb84dc2672e21" name="ae31f677c72798a1e14ebb84dc2672e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31f677c72798a1e14ebb84dc2672e21">&#9670;&#160;</a></span>iswupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswupper">https://en.cppreference.com/w/cpp/string/wide/iswupper</a> </p>

</div>
</div>
<a id="ac809578dc97747348dcc5795cbfa86ff" name="ac809578dc97747348dcc5795cbfa86ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac809578dc97747348dcc5795cbfa86ff">&#9670;&#160;</a></span>iswxdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::iswxdigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/iswxdigit">https://en.cppreference.com/w/cpp/string/wide/iswxdigit</a> </p>

</div>
</div>
<a id="a84de6738bfdc87aa9da8b107db172a43" name="a84de6738bfdc87aa9da8b107db172a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84de6738bfdc87aa9da8b107db172a43">&#9670;&#160;</a></span>towlower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::towlower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given wide character to lowercase, if possible. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/towlower">https://en.cppreference.com/w/cpp/string/wide/towlower</a> </p>

</div>
</div>
<a id="a0a9a0766e4327d94f39e77acc5a88bbc" name="a0a9a0766e4327d94f39e77acc5a88bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9a0766e4327d94f39e77acc5a88bbc">&#9670;&#160;</a></span>towupper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::towupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a2057177bf6f151716e055fc52a2fb9e7">wint_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given wide character to uppercase, if possible. </p>
<p>If the value of ch is neither representable as a wchar_t nor equal to the value of the macro WEOF, the behavior is undefined.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/towupper">https://en.cppreference.com/w/cpp/string/wide/towupper</a> </p>

</div>
</div>
<a id="a4cc789d7f68f903e899cff481cd71d1c" name="a4cc789d7f68f903e899cff481cd71d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc789d7f68f903e899cff481cd71d1c">&#9670;&#160;</a></span>breakpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::breakpoint </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a181e440953b961dd37846ec6cfc1727d" name="a181e440953b961dd37846ec6cfc1727d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181e440953b961dd37846ec6cfc1727d">&#9670;&#160;</a></span>breakpoint_if_debugging()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::breakpoint_if_debugging </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3eebb4ba67500e7280f6a5fe320c696" name="ad3eebb4ba67500e7280f6a5fe320c696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3eebb4ba67500e7280f6a5fe320c696">&#9670;&#160;</a></span>is_debugger_present()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_debugger_present </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf97f58690e1661fa4c536e2a89c9b52" name="aaf97f58690e1661fa4c536e2a89c9b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf97f58690e1661fa4c536e2a89c9b52">&#9670;&#160;</a></span>raise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Exception</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#abb156b0e852ad82749ae42934d3b4dbf">TETL_NO_INLINE</a> <a class="el" href="attributes_8hpp.html#af0eb4be3e44a6a8a9235265e12ad89a7">TETL_COLD</a> <a class="el" href="structetl_1_1static__vector.html">auto</a> etl::raise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">char</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af11c4b54fda6c14f1df7ee9acbb8990b" name="af11c4b54fda6c14f1df7ee9acbb8990b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11c4b54fda6c14f1df7ee9acbb8990b">&#9670;&#160;</a></span>unexpected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">E</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::unexpected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">E</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  unexpected&lt; <a class="el" href="structetl_1_1static__vector.html">E</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e4a29ac6268a32d655a572bc728d561" name="a2e4a29ac6268a32d655a572bc728d561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4a29ac6268a32d655a572bc728d561">&#9670;&#160;</a></span>operator==() <span class="overload">[4/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb7776985e823982b6dd579ea9446a5" name="adbb7776985e823982b6dd579ea9446a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb7776985e823982b6dd579ea9446a5">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f9846352e3d467e86fb4172d2637104" name="a0f9846352e3d467e86fb4172d2637104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9846352e3d467e86fb4172d2637104">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0f945b742cbe77cd2922aca6e578b56" name="ac0f945b742cbe77cd2922aca6e578b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f945b742cbe77cd2922aca6e578b56">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a105dc9103728fcd8f416fecb9b356558" name="a105dc9103728fcd8f416fecb9b356558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105dc9103728fcd8f416fecb9b356558">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9c01f47f59173080b54d4233235e144" name="ad9c01f47f59173080b54d4233235e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c01f47f59173080b54d4233235e144">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d1cbfaeb551a2e0c9a49d4bb500bc98" name="a2d1cbfaeb551a2e0c9a49d4bb500bc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">&#9670;&#160;</a></span>swap() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">flat_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Container</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a7">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afd52266a9a948c41abe1558e71ac0c95" name="afd52266a9a948c41abe1558e71ac0c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd52266a9a948c41abe1558e71ac0c95">&#9670;&#160;</a></span>format_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::format_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format args according to the format string fmt, and write the result to the output iterator out. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/format_to">https://en.cppreference.com/w/cpp/utility/format/format_to</a> </p>

</div>
</div>
<a id="aca222d51d5032dd1702938d3a603d705" name="aca222d51d5032dd1702938d3a603d705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca222d51d5032dd1702938d3a603d705">&#9670;&#160;</a></span>format_to_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::format_to_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIter</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1ccda852d9fec850405ea795d8c58e8f">diff_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">OutputIter</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a>&lt;<a class="el" href="structetl_1_1static__vector.html">OutputIter</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format args according to the format string fmt, and write the result to the output iterator out. At most n characters are written. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/format_to_n">https://en.cppreference.com/w/cpp/utility/format/format_to_n</a> </p>

</div>
</div>
<a id="aa401a56ff8788d235f9da9eae62db565" name="aa401a56ff8788d235f9da9eae62db565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa401a56ff8788d235f9da9eae62db565">&#9670;&#160;</a></span>make_format_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Context</a>  = etl::format_context, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::make_format_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; detail::format_arg_store&lt;<a class="el" href="structetl_1_1static__vector.html">Context</a>, Args...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b34548f40179d322193dd18148c65c5" name="a2b34548f40179d322193dd18148c65c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b34548f40179d322193dd18148c65c5">&#9670;&#160;</a></span>make_wformat_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::make_wformat_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; detail::format_arg_store&lt;<a class="el" href="#af14a1ebd9061ef0ef02d67e436e4fcd4">wformat_context</a>, Args...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacd3b8fb66cfa5b161911b9be0d00726" name="aacd3b8fb66cfa5b161911b9be0d00726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd3b8fb66cfa5b161911b9be0d00726">&#9670;&#160;</a></span>vformat_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OutputIt</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::vformat_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5ca9dac165db8a73a0cd16ab2677fabc">format_args</a></td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">OutputIt</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a817e57a985d0eab0156aa074d1928761" name="a817e57a985d0eab0156aa074d1928761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817e57a985d0eab0156aa074d1928761">&#9670;&#160;</a></span>bind_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Func</a> , typename... BoundArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::bind_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Func</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BoundArgs</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>boundArgs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args. In other words, bind_front(f,
bound_args...)(call_args...) is equivalent to invoke(f, bound_args..., call_args....). </p>
<p>Copied implementation from paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0356r5.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0356r5.html</a> </p>

</div>
</div>
<a id="afb3b5926a2945bf5dfa04525b2b3a11b" name="afb3b5926a2945bf5dfa04525b2b3a11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3b5926a2945bf5dfa04525b2b3a11b">&#9670;&#160;</a></span>function_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::function_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">R</a>(*</td>          <td class="paramname"><span class="paramname"><em>&#160;</em></span>)(Args...)</td><td>)</td>
          <td> -&gt;  function_ref&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47d8f8d75e5381d2407570b4d97eaf0a" name="a47d8f8d75e5381d2407570b4d97eaf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d8f8d75e5381d2407570b4d97eaf0a">&#9670;&#160;</a></span>swap() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the <a class="el" href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">etl::swap</a> algorithm for <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs). </p>

</div>
</div>
<a id="aba26643439d5c5c17e5ef7c933528775" name="aba26643439d5c5c17e5ef7c933528775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba26643439d5c5c17e5ef7c933528775">&#9670;&#160;</a></span>operator==() <span class="overload">[5/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="aac8c2f711706013a2f8a700a95963fd4" name="aac8c2f711706013a2f8a700a95963fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8c2f711706013a2f8a700a95963fd4">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a785630c163ba404876a31053f863b666" name="a785630c163ba404876a31053f863b666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785630c163ba404876a31053f863b666">&#9670;&#160;</a></span>operator==() <span class="overload">[6/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a71ee6cdf5477e76b8281dd0e20976012" name="a71ee6cdf5477e76b8281dd0e20976012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ee6cdf5477e76b8281dd0e20976012">&#9670;&#160;</a></span>operator!=() <span class="overload">[6/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , typename... Args, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0838d3bb433682c6c13b31dbd1c27f4a">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1static__vector.html">R</a>(Args...), <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Alignment</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a0bd726a99d25fb6e96ef3527de8a0164" name="a0bd726a99d25fb6e96ef3527de8a0164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd726a99d25fb6e96ef3527de8a0164">&#9670;&#160;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="#ad47ced64dcc2c2322893df26022403c5">etl::invoke_result_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>, Args...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo</a></b></dt><dd>Add noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;) </dd></dl>

</div>
</div>
<a id="a818edb1bc7d4fc7b0dab4127a65f3369" name="a818edb1bc7d4fc7b0dab4127a65f3369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818edb1bc7d4fc7b0dab4127a65f3369">&#9670;&#160;</a></span>invoke_r()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Args&gt; <br />
requires (<a class="el" href="#af8a1ef24a3b6eb7a38ad1307015c2c09">etl::is_invocable_r_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R</a>, <a class="el" href="structetl_1_1static__vector.html">F</a>, Args...&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::invoke_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">R</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo</a></b></dt><dd>Add noexcept(is_nothrow_invocable_r_v&lt;R, F, Args...&gt;) </dd></dl>

</div>
</div>
<a id="abca76f56fc5629be9476b2fd3a153a6e" name="abca76f56fc5629be9476b2fd3a153a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca76f56fc5629be9476b2fd3a153a6e">&#9670;&#160;</a></span>not_fn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::not_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> -&gt; detail::not_fn_t&lt;<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">etl::decay_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">F</a>&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cfabb170ba259721f7f4c19febd88c5" name="a3cfabb170ba259721f7f4c19febd88c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfabb170ba259721f7f4c19febd88c5">&#9670;&#160;</a></span>not_fn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> ConstFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::not_fn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; detail::stateless_not_fn&lt;<a class="el" href="structetl_1_1static__vector.html">ConstFn</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeba1ef9fae68ae0f78265ecaa8a3d598" name="aeba1ef9fae68ae0f78265ecaa8a3d598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba1ef9fae68ae0f78265ecaa8a3d598">&#9670;&#160;</a></span>reference_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::reference_wrapper </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  reference_wrapper&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a481b27ca7cd9de96cb435adc8a761b2a" name="a481b27ca7cd9de96cb435adc8a761b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481b27ca7cd9de96cb435adc8a761b2a">&#9670;&#160;</a></span>ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ref </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. </p>

</div>
</div>
<a id="a1f67da318f2742930e9485ebba9b075b" name="a1f67da318f2742930e9485ebba9b075b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f67da318f2742930e9485ebba9b075b">&#9670;&#160;</a></span>ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. </p>

</div>
</div>
<a id="a00752f4906d9b6f07d99ee2eb2719a09" name="a00752f4906d9b6f07d99ee2eb2719a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00752f4906d9b6f07d99ee2eb2719a09">&#9670;&#160;</a></span>cref() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cref </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T <a class="el" href="structetl_1_1static__vector.html">const</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. module Utility. </p>

</div>
</div>
<a id="abfb738286bec1789f1f3c417e6e5e600" name="abfb738286bec1789f1f3c417e6e5e600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb738286bec1789f1f3c417e6e5e600">&#9670;&#160;</a></span>cref() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T <a class="el" href="structetl_1_1static__vector.html">const</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82a6667d8776c1662f72e69e5b6a6ae2" name="a82a6667d8776c1662f72e69e5b6a6ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a6667d8776c1662f72e69e5b6a6ae2">&#9670;&#160;</a></span>cref() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">void</a> etl::cref </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac45065b143a47fb9249bda8d57ccca63" name="ac45065b143a47fb9249bda8d57ccca63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45065b143a47fb9249bda8d57ccca63">&#9670;&#160;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">It</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Distance</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">It</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Distance</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined. </p>
<p><a href="https://en.cppreference.com/w/cpp/iterator/advance">https://en.cppreference.com/w/cpp/iterator/advance</a> </p>

</div>
</div>
<a id="ab4ea18354d7bfc7358bf9c13004f0233" name="ab4ea18354d7bfc7358bf9c13004f0233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ea18354d7bfc7358bf9c13004f0233">&#9670;&#160;</a></span>back_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::back_inserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Container</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>back_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">back_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="a3031e070c39546444bdd5fda57ead3d2" name="a3031e070c39546444bdd5fda57ead3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3031e070c39546444bdd5fda57ead3d2">&#9670;&#160;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the given container c or array array. These templates rely on <code>C::begin()</code> having a reasonable implementation. Returns exactly c.begin(), which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns <code>C::iterator</code> when c is not const-qualified, and <code>C::const_iterator</code> otherwise. Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="#a3031e070c39546444bdd5fda57ead3d2" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated. </p>

</div>
</div>
<a id="a62a601a1d87c13d9bcf1d4b0e2cf6c1c" name="a62a601a1d87c13d9bcf1d4b0e2cf6c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a601a1d87c13d9bcf1d4b0e2cf6c1c">&#9670;&#160;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.begin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0330eb79a39a00af31e79ece021f90f" name="ab0330eb79a39a00af31e79ece021f90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0330eb79a39a00af31e79ece021f90f">&#9670;&#160;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::begin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a085b23b10e801da02c5711b10f67141e" name="a085b23b10e801da02c5711b10f67141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085b23b10e801da02c5711b10f67141e">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#a3031e070c39546444bdd5fda57ead3d2">begin</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a259846a061a975e4b40bc6f370701ac6" name="a259846a061a975e4b40bc6f370701ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259846a061a975e4b40bc6f370701ac6">&#9670;&#160;</a></span>data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.data())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the block of memory containing the elements of the container. </p>

</div>
</div>
<a id="a76360f238bdab5ae903a7b8b987ab5ac" name="a76360f238bdab5ae903a7b8b987ab5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76360f238bdab5ae903a7b8b987ab5ac">&#9670;&#160;</a></span>data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.data())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94411a453e2a44d4e6b6bf3160b4cf0" name="ad94411a453e2a44d4e6b6bf3160b4cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94411a453e2a44d4e6b6bf3160b4cf0">&#9670;&#160;</a></span>data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::data </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af296e322933205aa92418d74103df68c" name="af296e322933205aa92418d74103df68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af296e322933205aa92418d74103df68c">&#9670;&#160;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">It</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">It</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">It</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;<a class="el" href="structetl_1_1static__vector.html">It</a>&gt;::difference_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of hops from first to last. </p>
<p><a href="https://en.cppreference.com/w/cpp/iterator/distance">https://en.cppreference.com/w/cpp/iterator/distance</a> </p>

</div>
</div>
<a id="ab0a91f34436b98eaaeaf7e4ae5e19afa" name="ab0a91f34436b98eaaeaf7e4ae5e19afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a91f34436b98eaaeaf7e4ae5e19afa">&#9670;&#160;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.empty())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given container is empty. </p>

</div>
</div>
<a id="a3868c40892e752ac869410ba4b0f0407" name="a3868c40892e752ac869410ba4b0f0407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3868c40892e752ac869410ba4b0f0407">&#9670;&#160;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::empty </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf9eb859a31968a9179b29b638cd054b" name="abf9eb859a31968a9179b29b638cd054b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9eb859a31968a9179b29b638cd054b">&#9670;&#160;</a></span>end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on. </p>

</div>
</div>
<a id="acd63b79cae3d16f47089c029f77e7152" name="acd63b79cae3d16f47089c029f77e7152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd63b79cae3d16f47089c029f77e7152">&#9670;&#160;</a></span>end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.end())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f5d203d41447f951c386a27ef969327" name="a6f5d203d41447f951c386a27ef969327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5d203d41447f951c386a27ef969327">&#9670;&#160;</a></span>end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::end </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41acb03578faec2a550c4830c1dd2071" name="a41acb03578faec2a550c4830c1dd2071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41acb03578faec2a550c4830c1dd2071">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#abf9eb859a31968a9179b29b638cd054b">end</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ba99d783e3591913ef343af35fa0c7a" name="a7ba99d783e3591913ef343af35fa0c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba99d783e3591913ef343af35fa0c7a">&#9670;&#160;</a></span>front_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::front_inserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Container</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>front_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="ad833bc2bd06b05dd97d5c1ede8dde609" name="ad833bc2bd06b05dd97d5c1ede8dde609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad833bc2bd06b05dd97d5c1ede8dde609">&#9670;&#160;</a></span>full() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.full())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given container is full. </p>

</div>
</div>
<a id="adfd013eaad14533bf9fba4c179c07fb1" name="adfd013eaad14533bf9fba4c179c07fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd013eaad14533bf9fba4c179c07fb1">&#9670;&#160;</a></span>full() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::full </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7891ee1f2ce336c151274551bef111d1" name="a7891ee1f2ce336c151274551bef111d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7891ee1f2ce336c151274551bef111d1">&#9670;&#160;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">InputIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the nth successor of iterator it. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a2">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3dd767893eec07cc5b92348b4bb72ee8" name="a3dd767893eec07cc5b92348b4bb72ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd767893eec07cc5b92348b4bb72ee8">&#9670;&#160;</a></span>prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">BidirIt</a></td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">BidirIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the nth predecessor of iterator it. </p>

</div>
</div>
<a id="a31aadf1fc327da2eaac11d7e6e8617a8" name="a31aadf1fc327da2eaac11d7e6e8617a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31aadf1fc327da2eaac11d7e6e8617a8">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rbegin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-beginning of the given container. </p>

</div>
</div>
<a id="a12f3dc4db837147a9d8d28d3f18b40f5" name="a12f3dc4db837147a9d8d28d3f18b40f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f3dc4db837147a9d8d28d3f18b40f5">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rbegin())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36cec4638c522ca6b45b99da908aa1b7" name="a36cec4638c522ca6b45b99da908aa1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cec4638c522ca6b45b99da908aa1b7">&#9670;&#160;</a></span>rbegin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rbegin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;T*&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39cf5b617456b93d23184aaa8495c411" name="a39cf5b617456b93d23184aaa8495c411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cf5b617456b93d23184aaa8495c411">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::crbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#a31aadf1fc327da2eaac11d7e6e8617a8">rbegin</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3db12aaf2a7b1819d28995d635d91954" name="a3db12aaf2a7b1819d28995d635d91954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db12aaf2a7b1819d28995d635d91954">&#9670;&#160;</a></span>rend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rend())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-end of the given container. </p>

</div>
</div>
<a id="a75830ae03ce26ca2ea7289cc7d83a761" name="a75830ae03ce26ca2ea7289cc7d83a761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75830ae03ce26ca2ea7289cc7d83a761">&#9670;&#160;</a></span>rend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.rend())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94d4f59f901468f3a8d07e91a27e2ae2" name="a94d4f59f901468f3a8d07e91a27e2ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d4f59f901468f3a8d07e91a27e2ae2">&#9670;&#160;</a></span>rend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::rend </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;T*&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04738c0a8b5aa6e0211bbd7a4aa586e7" name="a04738c0a8b5aa6e0211bbd7a4aa586e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04738c0a8b5aa6e0211bbd7a4aa586e7">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::crend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="#a3db12aaf2a7b1819d28995d635d91954">rend</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the reverse-end of the given container. </p>

</div>
</div>
<a id="a56fd86ba568b1c1665502fcb72ed4327" name="a56fd86ba568b1c1665502fcb72ed4327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fd86ba568b1c1665502fcb72ed4327">&#9670;&#160;</a></span>make_reverse_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::make_reverse_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Iter</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function template that constructs a <a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">etl::reverse_iterator</a> for the given iterator i (which must be a LegacyBidirectionalIterator) with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="a6ed8eb1bf308acc967006e8073f5a132" name="a6ed8eb1bf308acc967006e8073f5a132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed8eb1bf308acc967006e8073f5a132">&#9670;&#160;</a></span>operator==() <span class="overload">[7/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="ab35badce959782a6ae934df29db1e063" name="ab35badce959782a6ae934df29db1e063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35badce959782a6ae934df29db1e063">&#9670;&#160;</a></span>operator!=() <span class="overload">[7/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a354acf1f357eacd402309c32fd4d5508" name="a354acf1f357eacd402309c32fd4d5508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354acf1f357eacd402309c32fd4d5508">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a6c13e3aeec42ad159690a49c03ea7f19" name="a6c13e3aeec42ad159690a49c03ea7f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c13e3aeec42ad159690a49c03ea7f19">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="ac1ba00e40d7921ce12fde9c0c231e4c2" name="ac1ba00e40d7921ce12fde9c0c231e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ba00e40d7921ce12fde9c0c231e4c2">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a9a2457527f749e948ff13abbd95621c9" name="a9a2457527f749e948ff13abbd95621c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2457527f749e948ff13abbd95621c9">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a341ce51287200d6d284558bf674303a1" name="a341ce51287200d6d284558bf674303a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341ce51287200d6d284558bf674303a1">&#9670;&#160;</a></span>operator+() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iter</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Iter</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator it incremented by n. </p>

</div>
</div>
<a id="ae07adb06319a1e865f85ac0caed0820a" name="ae07adb06319a1e865f85ac0caed0820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07adb06319a1e865f85ac0caed0820a">&#9670;&#160;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iterator1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Iterator2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iterator1</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Iterator2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(rhs.base() - lhs.base())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between two iterator adaptors. </p>

</div>
</div>
<a id="af3008e042f920b06e2a67b1aa31a1803" name="af3008e042f920b06e2a67b1aa31a1803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3008e042f920b06e2a67b1aa31a1803">&#9670;&#160;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.size())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the given container c or array array. Returns c.size(), converted to the return type if necessary. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a8">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab2e3325c99005cfa2cad0752fe472c61" name="ab2e3325c99005cfa2cad0752fe472c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e3325c99005cfa2cad0752fe472c61">&#9670;&#160;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::size </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> (&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d1396c492b6b649f093736eaba1f92c" name="a4d1396c492b6b649f093736eaba1f92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1396c492b6b649f093736eaba1f92c">&#9670;&#160;</a></span>ssize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ssize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">C</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a1049bbee37ab0c1445bcd7f020d6ce0c">common_type_t</a>&lt;<a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a>, <a class="el" href="#ace93b7d8b1e564390c651a2e9a3a11f0">make_signed_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">decltype</a>(c.size())&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdfe3fbc79d8c1cf42b007bed4267257" name="abdfe3fbc79d8c1cf42b007bed4267257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfe3fbc79d8c1cf42b007bed4267257">&#9670;&#160;</a></span>ssize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ssize </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> (&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[static_cast&lt; size_t &gt;(N)]</td><td>)</td>
          <td> -&gt; <a class="el" href="#a1630ee9e07d0d32697249d7a63e131c1">ptrdiff_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29f4f3470cc94fc51e21ebfa58e3292a" name="a29f4f3470cc94fc51e21ebfa58e3292a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f4f3470cc94fc51e21ebfa58e3292a">&#9670;&#160;</a></span>abs() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a67112d360fce8458db9b33c097b809b5" name="a67112d360fce8458db9b33c097b809b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67112d360fce8458db9b33c097b809b5">&#9670;&#160;</a></span>abs() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28f2cb4cae4a97ae3b4736ff1aa6b176" name="a28f2cb4cae4a97ae3b4736ff1aa6b176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f2cb4cae4a97ae3b4736ff1aa6b176">&#9670;&#160;</a></span>abs() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a528fb6eadbb2c38e178a60155197d6ac" name="a528fb6eadbb2c38e178a60155197d6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528fb6eadbb2c38e178a60155197d6ac">&#9670;&#160;</a></span>abs() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5868e5a9aa938b596cd0d8d04d3ecb96" name="a5868e5a9aa938b596cd0d8d04d3ecb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5868e5a9aa938b596cd0d8d04d3ecb96">&#9670;&#160;</a></span>abs() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b1dae41b3151e867f898e88be2e250b" name="a1b1dae41b3151e867f898e88be2e250b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1dae41b3151e867f898e88be2e250b">&#9670;&#160;</a></span>abs() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3f57c390bca894ba9abb01107b367fb" name="aa3f57c390bca894ba9abb01107b367fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f57c390bca894ba9abb01107b367fb">&#9670;&#160;</a></span>fabs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a934ff8b65786c53d2df66654258fb9d4" name="a934ff8b65786c53d2df66654258fb9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934ff8b65786c53d2df66654258fb9d4">&#9670;&#160;</a></span>fabsf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fabsf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc8c16e1d3253b423b905f31cf7267b" name="aebc8c16e1d3253b423b905f31cf7267b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc8c16e1d3253b423b905f31cf7267b">&#9670;&#160;</a></span>fabs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab973f9ba5bac126e950c7ff7e1b45dcb" name="ab973f9ba5bac126e950c7ff7e1b45dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab973f9ba5bac126e950c7ff7e1b45dcb">&#9670;&#160;</a></span>fabs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af57fa73cac5bc77be92e61c2cea2fa4b" name="af57fa73cac5bc77be92e61c2cea2fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57fa73cac5bc77be92e61c2cea2fa4b">&#9670;&#160;</a></span>fabsl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::fabsl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68d6a400b03bbbcc87b81f9a8f70a4e5" name="a68d6a400b03bbbcc87b81f9a8f70a4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d6a400b03bbbcc87b81f9a8f70a4e5">&#9670;&#160;</a></span>ilog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ilog2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cbcb6eba04cb025fe9ca378236adee0" name="a4cbcb6eba04cb025fe9ca378236adee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbcb6eba04cb025fe9ca378236adee0">&#9670;&#160;</a></span>ipow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ipow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80dd0445f4a32857d03ee0b802a2af19" name="a80dd0445f4a32857d03ee0b802a2af19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dd0445f4a32857d03ee0b802a2af19">&#9670;&#160;</a></span>ipow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> Base&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ipow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">Base</a>)</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">Base</a>)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc9186fde8e2d9973c0a6d7b0c5370c9" name="afc9186fde8e2d9973c0a6d7b0c5370c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9186fde8e2d9973c0a6d7b0c5370c9">&#9670;&#160;</a></span>extents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Integrals&gt; <br />
requires (<a class="el" href="#aa15279e84c7ec40ef8a2d460b81b7fb7">etl::is_convertible_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Integrals</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> ...)</div>
      <table class="memname">
        <tr>
          <td class="memname">etl::extents </td>
          <td>(</td>
          <td class="paramtype">Integrals...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  extents&lt; <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>((<a class="el" href="structetl_1_1static__vector.html">Integrals</a>(), <a class="el" href="#ae174223df490e6263d4648a86326c902">etl::dynamic_extent</a>))... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe3a844784b8e330377ef20a6d1f5ec3" name="afe3a844784b8e330377ef20a6d1f5ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3a844784b8e330377ef20a6d1f5ec3">&#9670;&#160;</a></span>mdspan() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CArray</a> &gt; <br />
requires (<a class="el" href="#afaa46050181985a6156a6c800c86a7d8">is_array_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CArray</a>&gt; &amp;&amp; <a class="el" href="#a4229d4171b460abc833736d622ce9745">rank_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CArray</a>&gt; == 1)</div>
      <table class="memname">
        <tr>
          <td class="memname">etl::mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  mdspan&lt; <a class="el" href="#a90a0440e799b90521d5959686b4282fb">remove_all_extents_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CArray</a> &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a>, <a class="el" href="#a115f1cea7fc27ee979afae4871d03a03">extent_v</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CArray</a>, 0 &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d9a30f2d782abb51c2c1a482f7e70c9" name="a6d9a30f2d782abb51c2c1a482f7e70c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9a30f2d782abb51c2c1a482f7e70c9">&#9670;&#160;</a></span>mdspan() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Pointer</a> &gt; <br />
requires (<a class="el" href="#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a>&lt;<a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Pointer</a>&gt;&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">etl::mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Pointer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  mdspan&lt; <a class="el" href="#a8897fe2703cfaabd33c46ba2ae13b5e2">remove_pointer_t</a>&lt; <a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Pointer</a> &gt; &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a698e5b24b2544f42552e4eb245912d40" name="a698e5b24b2544f42552e4eb245912d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698e5b24b2544f42552e4eb245912d40">&#9670;&#160;</a></span>mdspan() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , typename... Integrals&gt; <br />
requires ((<a class="el" href="#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Integrals</a>, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a>&gt; &amp;&amp; ...) &amp;&amp; sizeof...(<a class="el" href="structetl_1_1static__vector.html">Integrals</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integrals...</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="#ad27430ad24df2ec00864b7184d731465">dextents</a>&lt; <a class="el" href="#a49823583370a499813db70f494111109">size_t</a>, sizeof...(<a class="el" href="structetl_1_1static__vector.html">Integrals</a>)&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa733eabfa7d494cd6e626e58a2d56234" name="aa733eabfa7d494cd6e626e58a2d56234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa733eabfa7d494cd6e626e58a2d56234">&#9670;&#160;</a></span>mdspan() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexType</a> , size_t... ExtentsPack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexType</a>, ExtentsPack... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexType</a>, ExtentsPack... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ca494e42ded1eb56cf815c645ab4bfe" name="a7ca494e42ded1eb56cf815c645ab4bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca494e42ded1eb56cf815c645ab4bfe">&#9670;&#160;</a></span>mdspan() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ElementType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">MappingType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">MappingType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">ElementType</a>, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::layout_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a536af133718ba537fce35662e803b0e7" name="a536af133718ba537fce35662e803b0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536af133718ba537fce35662e803b0e7">&#9670;&#160;</a></span>mdspan() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">MappingType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">typename</a> AccessorType::data_handle_type <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">MappingType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">AccessorType</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1static__vector.html">typename</a> AccessorType::element_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1static__vector.html">typename</a> MappingType::layout_type, <a class="el" href="structetl_1_1static__vector.html">AccessorType</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa94f2f8d645ecda437b8b417399a808a" name="aa94f2f8d645ecda437b8b417399a808a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94f2f8d645ecda437b8b417399a808a">&#9670;&#160;</a></span>strided_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">OffsetType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ExtentType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">StrideType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::strided_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">OffsetType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ExtentType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">StrideType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  strided_slice&lt; <a class="el" href="structetl_1_1static__vector.html">OffsetType</a>, <a class="el" href="structetl_1_1static__vector.html">ExtentType</a>, <a class="el" href="structetl_1_1static__vector.html">StrideType</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb29174c026eeabd294649480e7d00b1" name="abb29174c026eeabd294649480e7d00b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb29174c026eeabd294649480e7d00b1">&#9670;&#160;</a></span>submdspan_extents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">IndexT</a> , etl::size_t... Extents, typename... SliceSpecifiers&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1static__vector.html">slices</a>) == <a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt;<a class="el" href="structetl_1_1static__vector.html">IndexT</a>, Extents...&gt;::rank())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::submdspan_extents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt; <a class="el" href="structetl_1_1static__vector.html">IndexT</a>, Extents... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceSpecifiers...</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99d4abdc9048a47e79b90addc653b930" name="a99d4abdc9048a47e79b90addc653b930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d4abdc9048a47e79b90addc653b930">&#9670;&#160;</a></span>addressof() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;. </p>

</div>
</div>
<a id="a351af276db5fcca32408696c2a4f8be6" name="a351af276db5fcca32408696c2a4f8be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351af276db5fcca32408696c2a4f8be6">&#9670;&#160;</a></span>addressof() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a63efd09c0ee7195824be65423adadedc">is_object_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;. </p>

</div>
</div>
<a id="a13856fe74510e89b04a2310cbc9bde59" name="a13856fe74510e89b04a2310cbc9bde59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13856fe74510e89b04a2310cbc9bde59">&#9670;&#160;</a></span>addressof() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::addressof </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb3d4ba5bde672b48bdaa4fd9eec249e" name="afb3d4ba5bde672b48bdaa4fd9eec249e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3d4ba5bde672b48bdaa4fd9eec249e">&#9670;&#160;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">void</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>space</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned. </p>
<p>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns nullptr.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if alignment is not a power of two. </dd></dl>

</div>
</div>
<a id="abfe56da868069c04217458df6422d084" name="abfe56da868069c04217458df6422d084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe56da868069c04217458df6422d084">&#9670;&#160;</a></span>assume_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N, <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::assume_aligned </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned. </p>
<p>The program is ill-formed if N is not a power of 2. The behavior is undefined if ptr does not point to an object of type T (ignoring cv-qualification at every level), or if the object's alignment is not at least N.</p>
<p><a href="https://en.cppreference.com/w/cpp/memory/assume_aligned">https://en.cppreference.com/w/cpp/memory/assume_aligned</a> </p>

</div>
</div>
<a id="aa85baa0db208bd4de142559c20735f41" name="aa85baa0db208bd4de142559c20735f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85baa0db208bd4de142559c20735f41">&#9670;&#160;</a></span>construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args, <a class="el" href="structetl_1_1static__vector.html">typename</a>  = decltype(::new(etl::declval&lt;void*&gt;()) T(etl::declval&lt;Args&gt;()...))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::construct_at </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a T object initialized with arguments args... at given address p. </p>

</div>
</div>
<a id="ab44bc4884adc1e9dc20ddf2363f3da66" name="ab44bc4884adc1e9dc20ddf2363f3da66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44bc4884adc1e9dc20ddf2363f3da66">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the objects in the range [first, last). </p>

</div>
</div>
<a id="a1709580f4bcc18d6efb2b7e4d5c1b728" name="a1709580f4bcc18d6efb2b7e4d5c1b728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1709580f4bcc18d6efb2b7e4d5c1b728">&#9670;&#160;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling destroy(begin(*p), end(*p)). </p>

</div>
</div>
<a id="a440d38af8f9b00df3d5c1369450ba44a" name="a440d38af8f9b00df3d5c1369450ba44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440d38af8f9b00df3d5c1369450ba44a">&#9670;&#160;</a></span>destroy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::destroy_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the n objects in the range starting at first. </p>

</div>
</div>
<a id="aa686fb94d6fbf9538a40cf4040a6ac81" name="aa686fb94d6fbf9538a40cf4040a6ac81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa686fb94d6fbf9538a40cf4040a6ac81">&#9670;&#160;</a></span>to_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Ptr</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Ptr</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by p without forming a reference to the object pointed to by p. </p>
<p>Fancy pointer overload: If the expression pointer_traits&lt;Ptr&gt;::to_address(p) is well-formed, returns the result of that expression. Otherwise, returns to_address(p.operator-&gt;()). </p>

</div>
</div>
<a id="a22eb660431c56725c86c7f2f1e7164d3" name="a22eb660431c56725c86c7f2f1e7164d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22eb660431c56725c86c7f2f1e7164d3">&#9670;&#160;</a></span>to_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#aec3b44fa05f956c1efc4f34af98bd1f0">is_function_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_address </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by p without forming a reference to the object pointed to by p. </p>
<p>Raw pointer overload: If T is a function type, the program is ill-formed. Otherwise, returns p unmodified. </p>

</div>
</div>
<a id="aac9b77066dce89b6c75251e5179805f6" name="aac9b77066dce89b6c75251e5179805f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9b77066dce89b6c75251e5179805f6">&#9670;&#160;</a></span>uninitialized_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">ForwardIt</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::uninitialized_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66b0627d3000daa570306e2c95d25db1" name="a66b0627d3000daa570306e2c95d25db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b0627d3000daa570306e2c95d25db1">&#9670;&#160;</a></span>swap() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Mutex</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">void</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1unique__lock.html">unique_lock</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Mutex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1unique__lock.html">unique_lock</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Mutex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a>. Exchanges the state of lhs with that of rhs. </p>

</div>
</div>
<a id="a0df599327b8ca16e8018e4e941f1f749" name="a0df599327b8ca16e8018e4e941f1f749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df599327b8ca16e8018e4e941f1f749">&#9670;&#160;</a></span>make_optional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::make_optional </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt;<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">etl::decay_t</a>&lt;T&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optional object from value. </p>

</div>
</div>
<a id="a596e87d0c3bd7cc7e9d514639b141b04" name="a596e87d0c3bd7cc7e9d514639b141b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596e87d0c3bd7cc7e9d514639b141b04">&#9670;&#160;</a></span>make_optional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::make_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1optional.html">etl::optional</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an optional object constructed in-place from args... </p>

</div>
</div>
<a id="ae75cac911cf6d9b9b3b37254bc227e53" name="ae75cac911cf6d9b9b3b37254bc227e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75cac911cf6d9b9b3b37254bc227e53">&#9670;&#160;</a></span>optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::optional </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  optional&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ba6597548d02352070810c2d6c92e1a" name="a8ba6597548d02352070810c2d6c92e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba6597548d02352070810c2d6c92e1a">&#9670;&#160;</a></span>swap() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the <a class="el" href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">etl::swap</a> algorithm for <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs). </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/swap2">https://en.cppreference.com/w/cpp/utility/optional/swap2</a> </p>

</div>
</div>
<a id="a5d1cc2f7a422e0cadab9361b16f7e875" name="a5d1cc2f7a422e0cadab9361b16f7e875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1cc2f7a422e0cadab9361b16f7e875">&#9670;&#160;</a></span>operator==() <span class="overload">[8/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a0199291e596a6580c028a4fbb4c1a439" name="a0199291e596a6580c028a4fbb4c1a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0199291e596a6580c028a4fbb4c1a439">&#9670;&#160;</a></span>operator!=() <span class="overload">[8/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="ad2dad36bf3c15c14d239e80047211e27" name="ad2dad36bf3c15c14d239e80047211e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dad36bf3c15c14d239e80047211e27">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="aa8cfb4c68d3b5bf2a12e64973a9ee892" name="aa8cfb4c68d3b5bf2a12e64973a9ee892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cfb4c68d3b5bf2a12e64973a9ee892">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="abc6d41e110c97a6f118fac996337da06" name="abc6d41e110c97a6f118fac996337da06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6d41e110c97a6f118fac996337da06">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a4cd1c4702ae19a08b1aa3f03807f1267" name="a4cd1c4702ae19a08b1aa3f03807f1267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd1c4702ae19a08b1aa3f03807f1267">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="afbb0eb100ae57232d484215f1b4315d6" name="afbb0eb100ae57232d484215f1b4315d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb0eb100ae57232d484215f1b4315d6">&#9670;&#160;</a></span>operator==() <span class="overload">[9/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a55bdc0584358e44c777f1ff6dd845026" name="a55bdc0584358e44c777f1ff6dd845026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bdc0584358e44c777f1ff6dd845026">&#9670;&#160;</a></span>operator==() <span class="overload">[10/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a8e737d88ff2f1d432403026a91a24766" name="a8e737d88ff2f1d432403026a91a24766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e737d88ff2f1d432403026a91a24766">&#9670;&#160;</a></span>operator!=() <span class="overload">[9/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="ad6bf68822d73dd9f0d84b6a5aa3f3618" name="ad6bf68822d73dd9f0d84b6a5aa3f3618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bf68822d73dd9f0d84b6a5aa3f3618">&#9670;&#160;</a></span>operator!=() <span class="overload">[10/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a7d07feb0fa4c7f8287a166fbbe4975ee" name="a7d07feb0fa4c7f8287a166fbbe4975ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d07feb0fa4c7f8287a166fbbe4975ee">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a0b91acd82b61f0b96647711aa1414b71" name="a0b91acd82b61f0b96647711aa1414b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b91acd82b61f0b96647711aa1414b71">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a0ffa5aed44c30aae39950e0d82c7a256" name="a0ffa5aed44c30aae39950e0d82c7a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffa5aed44c30aae39950e0d82c7a256">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a3003b74d5cf5363cb983a63f0beaa5b8" name="a3003b74d5cf5363cb983a63f0beaa5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3003b74d5cf5363cb983a63f0beaa5b8">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="aa2ec0f3b39223f0c48dcae6bf744ac8f" name="aa2ec0f3b39223f0c48dcae6bf744ac8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ec0f3b39223f0c48dcae6bf744ac8f">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a070d0943c411911df11ac5176fa48016" name="a070d0943c411911df11ac5176fa48016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d0943c411911df11ac5176fa48016">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="ad322ae7ca3d230a2cfb6aae8d633356b" name="ad322ae7ca3d230a2cfb6aae8d633356b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad322ae7ca3d230a2cfb6aae8d633356b">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a8fe18304d67bab939fd57ac52900323a" name="a8fe18304d67bab939fd57ac52900323a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe18304d67bab939fd57ac52900323a">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a975270db4255209c6d0a1664d9072560" name="a975270db4255209c6d0a1664d9072560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975270db4255209c6d0a1664d9072560">&#9670;&#160;</a></span>operator==() <span class="overload">[11/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a5311a7c4d14b66f603c0fff05bb0670f" name="a5311a7c4d14b66f603c0fff05bb0670f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5311a7c4d14b66f603c0fff05bb0670f">&#9670;&#160;</a></span>operator==() <span class="overload">[12/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="ad955578770fdb3a931ddd25d78ed03de" name="ad955578770fdb3a931ddd25d78ed03de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad955578770fdb3a931ddd25d78ed03de">&#9670;&#160;</a></span>operator!=() <span class="overload">[11/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a86505f8f0a3853f5fd106b17b367ebd0" name="a86505f8f0a3853f5fd106b17b367ebd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86505f8f0a3853f5fd106b17b367ebd0">&#9670;&#160;</a></span>operator!=() <span class="overload">[12/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a5d356ce4c5ed39ba60230ccb9bcdc76a" name="a5d356ce4c5ed39ba60230ccb9bcdc76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d356ce4c5ed39ba60230ccb9bcdc76a">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a683d8509d04f83a6cb7061df789c630c" name="a683d8509d04f83a6cb7061df789c630c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683d8509d04f83a6cb7061df789c630c">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a83a59b23e259ef7140b324f681aa07dd" name="a83a59b23e259ef7140b324f681aa07dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a59b23e259ef7140b324f681aa07dd">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="abf4a6c0e67c15c1663f2cf60e9281833" name="abf4a6c0e67c15c1663f2cf60e9281833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4a6c0e67c15c1663f2cf60e9281833">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a270636ff7b3f10c31fea081efff5be7e" name="a270636ff7b3f10c31fea081efff5be7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270636ff7b3f10c31fea081efff5be7e">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="af60f7a5afa042d61659f05a0810ac1cd" name="af60f7a5afa042d61659f05a0810ac1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60f7a5afa042d61659f05a0810ac1cd">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a315cb53ac332644f510d613388dc9403" name="a315cb53ac332644f510d613388dc9403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315cb53ac332644f510d613388dc9403">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; T &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="a1e08e7d4bbce49c0f236c523f6ca908a" name="a1e08e7d4bbce49c0f236c523f6ca908a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e08e7d4bbce49c0f236c523f6ca908a">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1optional.html">optional</a>&lt; U &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional/operator_cmp">https://en.cppreference.com/w/cpp/utility/optional/operator_cmp</a> </p>

</div>
</div>
<a id="aeb8f753ac26046a2f64b357e73ca88a4" name="aeb8f753ac26046a2f64b357e73ca88a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8f753ac26046a2f64b357e73ca88a4">&#9670;&#160;</a></span>decay_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::decay_copy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4936d228847b9e7bb245a6f6d2a0064c" name="a4936d228847b9e7bb245a6f6d2a0064c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4936d228847b9e7bb245a6f6d2a0064c">&#9670;&#160;</a></span>scope_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">FuncT</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::scope_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">FuncT</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  scope_exit&lt; <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1static__vector.html">FuncT</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16898ab8f9b95de51802d2ac8840c5cb" name="a16898ab8f9b95de51802d2ac8840c5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16898ab8f9b95de51802d2ac8840c5cb">&#9670;&#160;</a></span>operator==() <span class="overload">[13/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="aeb5ef95c5d2a3f3b77b9d48b0ee394c6" name="aeb5ef95c5d2a3f3b77b9d48b0ee394c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5ef95c5d2a3f3b77b9d48b0ee394c6">&#9670;&#160;</a></span>operator!=() <span class="overload">[13/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="aa51f4f81c713960abeab665d097df056" name="aa51f4f81c713960abeab665d097df056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51f4f81c713960abeab665d097df056">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="ac570ea8aff6b11f4ff8930690e4c5a8e" name="ac570ea8aff6b11f4ff8930690e4c5a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac570ea8aff6b11f4ff8930690e4c5a8e">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="af1767a8d6dec411f212efe9a29c8e0b3" name="af1767a8d6dec411f212efe9a29c8e0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1767a8d6dec411f212efe9a29c8e0b3">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="afb1c3dfb9a3684b8b5905335affb701f" name="afb1c3dfb9a3684b8b5905335affb701f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1c3dfb9a3684b8b5905335affb701f">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Comp</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="adbdaddf256aba01af62859d1d068472d" name="adbdaddf256aba01af62859d1d068472d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdaddf256aba01af62859d1d068472d">&#9670;&#160;</a></span>swap() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Key</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Key</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs). </p>

</div>
</div>
<a id="a7ae916c7bad3feb7fd82e7f7932d5bb1" name="a7ae916c7bad3feb7fd82e7f7932d5bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae916c7bad3feb7fd82e7f7932d5bb1">&#9670;&#160;</a></span>as_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::as_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1span.html">span</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt;<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">byte</a> <a class="el" href="structetl_1_1static__vector.html">const</a>, detail::span_as_bytes_size&lt;T, <a class="el" href="structetl_1_1static__vector.html">N</a>&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a view to the object representation of the elements of the span s. </p>
<p>If N is dynamic_extent, the extent of the returned span S is also dynamic_extent; otherwise it is sizeof(T) * N. </p>

</div>
</div>
<a id="ab25fa4eb811ee0ab2d424da51a7925c1" name="ab25fa4eb811ee0ab2d424da51a7925c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25fa4eb811ee0ab2d424da51a7925c1">&#9670;&#160;</a></span>as_writable_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; <br />
requires (<a class="el" href="structetl_1_1static__vector.html">not</a> <a class="el" href="#a40862de0c689f5281b8d680741bc7cf9">is_const_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::as_writable_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1span.html">span</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">N</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1span.html">span</a>&lt;<a class="el" href="#a1d957fa8529e9617c445e42519518e5e">byte</a>, detail::span_as_bytes_size&lt;T, <a class="el" href="structetl_1_1static__vector.html">N</a>&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains a view to the object representation of the elements of the span s. </p>
<p>If N is dynamic_extent, the extent of the returned span S is also dynamic_extent; otherwise it is sizeof(T) * N. Only participates in overload resolution if is_const_v&lt;T&gt; is false. </p>

</div>
</div>
<a id="a0da3a02a79034271cbc560bc94dbe2cd" name="a0da3a02a79034271cbc560bc94dbe2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da3a02a79034271cbc560bc94dbe2cd">&#9670;&#160;</a></span>span() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Extent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Type</a>(&amp;)</td>          <td class="paramname"><span class="paramname"><em></em></span>[Extent]</td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Extent</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6ab2c6a5bc678d0ca3f5137c4004543" name="ac6ab2c6a5bc678d0ca3f5137c4004543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ab2c6a5bc678d0ca3f5137c4004543">&#9670;&#160;</a></span>span() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5667307c6ae6ae51fa6d1488fbab93b" name="aa5667307c6ae6ae51fa6d1488fbab93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5667307c6ae6ae51fa6d1488fbab93b">&#9670;&#160;</a></span>span() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Type</a> <a class="el" href="structetl_1_1static__vector.html">const</a>, <a class="el" href="structetl_1_1static__vector.html">Size</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e186959b2d5132ab142843576d30048" name="a9e186959b2d5132ab142843576d30048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e186959b2d5132ab142843576d30048">&#9670;&#160;</a></span>span() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Element</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc55cb127ec094c3dbdec3ed03452ebc" name="adc55cb127ec094c3dbdec3ed03452ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc55cb127ec094c3dbdec3ed03452ebc">&#9670;&#160;</a></span>span() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1static__vector.html">Element</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab57d951f6a467976762f8f57f9b49cee" name="ab57d951f6a467976762f8f57f9b49cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57d951f6a467976762f8f57f9b49cee">&#9670;&#160;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Container</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  stack&lt; <a class="el" href="structetl_1_1static__vector.html">typename</a> Container::value_type, <a class="el" href="structetl_1_1static__vector.html">Container</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a731b8a1123b0ae68ac65b81165953715" name="a731b8a1123b0ae68ac65b81165953715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731b8a1123b0ae68ac65b81165953715">&#9670;&#160;</a></span>swap() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; <br />
requires (<a class="el" href="#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">C</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">C</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for stack. Swaps the contents of lhs and rhs. This overload only participates in overload resolution if is_swappable&lt;C&gt;::value is true. </p>

</div>
</div>
<a id="a550be74a772ee835b7969103906449d0" name="a550be74a772ee835b7969103906449d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550be74a772ee835b7969103906449d0">&#9670;&#160;</a></span>operator+() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a8f68785d405ab507029b4dc21d784f32" name="a8f68785d405ab507029b4dc21d784f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f68785d405ab507029b4dc21d784f32">&#9670;&#160;</a></span>operator+() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a3730f573680ab7ee2848994263888494" name="a3730f573680ab7ee2848994263888494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3730f573680ab7ee2848994263888494">&#9670;&#160;</a></span>operator+() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a0402f15f7abdd70ed375cfc0c967739a" name="a0402f15f7abdd70ed375cfc0c967739a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0402f15f7abdd70ed375cfc0c967739a">&#9670;&#160;</a></span>operator+() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a1e6e97ff485e83eeab3a47dda30b592b" name="a1e6e97ff485e83eeab3a47dda30b592b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6e97ff485e83eeab3a47dda30b592b">&#9670;&#160;</a></span>operator+() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a1d6b52bf4545c553a814d0bdb36cfc3b" name="a1d6b52bf4545c553a814d0bdb36cfc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6b52bf4545c553a814d0bdb36cfc3b">&#9670;&#160;</a></span>operator==() <span class="overload">[14/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="afd7dc7e7afd9ab5389cf089585ecb7ff" name="afd7dc7e7afd9ab5389cf089585ecb7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7dc7e7afd9ab5389cf089585ecb7ff">&#9670;&#160;</a></span>operator==() <span class="overload">[15/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a1f7c985efe97b9de9bcb2fd57ed62f63" name="a1f7c985efe97b9de9bcb2fd57ed62f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7c985efe97b9de9bcb2fd57ed62f63">&#9670;&#160;</a></span>operator==() <span class="overload">[16/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="af595ea9358f1b118453f23ce14c7c539" name="af595ea9358f1b118453f23ce14c7c539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af595ea9358f1b118453f23ce14c7c539">&#9670;&#160;</a></span>operator!=() <span class="overload">[14/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a9556a73ed76342b9e3acbfde9f9cdac8" name="a9556a73ed76342b9e3acbfde9f9cdac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9556a73ed76342b9e3acbfde9f9cdac8">&#9670;&#160;</a></span>operator!=() <span class="overload">[15/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a2996ca93f7497f0f26bc52448cbc3a87" name="a2996ca93f7497f0f26bc52448cbc3a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2996ca93f7497f0f26bc52448cbc3a87">&#9670;&#160;</a></span>operator!=() <span class="overload">[16/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="ac484f684a7e23d519733aa7a1dfdd2cc" name="ac484f684a7e23d519733aa7a1dfdd2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac484f684a7e23d519733aa7a1dfdd2cc">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a25f66fcbe677016753265cda13588a02" name="a25f66fcbe677016753265cda13588a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f66fcbe677016753265cda13588a02">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a834f76d59c40a1aaa9b9f45222a5815c" name="a834f76d59c40a1aaa9b9f45222a5815c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834f76d59c40a1aaa9b9f45222a5815c">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a105ce49011cd77ed4c6e3b72390ed12b" name="a105ce49011cd77ed4c6e3b72390ed12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105ce49011cd77ed4c6e3b72390ed12b">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a24dc9a85456db0c3b0085526ad74898c" name="a24dc9a85456db0c3b0085526ad74898c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dc9a85456db0c3b0085526ad74898c">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ad3378b9bc8853f3e35709acd2a945d2a" name="ad3378b9bc8853f3e35709acd2a945d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3378b9bc8853f3e35709acd2a945d2a">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a07dbbab6f8321779c8eb9b3b173cb34e" name="a07dbbab6f8321779c8eb9b3b173cb34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07dbbab6f8321779c8eb9b3b173cb34e">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="af8fe899d26d372e2f56cbe8fa4551770" name="af8fe899d26d372e2f56cbe8fa4551770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fe899d26d372e2f56cbe8fa4551770">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="abd663da7cd107379f89f863f44d18d7c" name="abd663da7cd107379f89f863f44d18d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd663da7cd107379f89f863f44d18d7c">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a0e94a2069d38ef480a1f723e594c4f60" name="a0e94a2069d38ef480a1f723e594c4f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e94a2069d38ef480a1f723e594c4f60">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity1, <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity1</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity2</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a1fe7782ee247113a01628108deed5640" name="a1fe7782ee247113a01628108deed5640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe7782ee247113a01628108deed5640">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ada97bd78bce6e3f4b4181a18403077da" name="ada97bd78bce6e3f4b4181a18403077da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada97bd78bce6e3f4b4181a18403077da">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">CharT</a> <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ad9897e71535e601101f19e29b7fb9c82" name="ad9897e71535e601101f19e29b7fb9c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9897e71535e601101f19e29b7fb9c82">&#9670;&#160;</a></span>swap() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">etl::basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the <a class="el" href="#a2d1cbfaeb551a2e0c9a49d4bb500bc98">etl::swap</a> algorithm for <a class="el" href="structetl_1_1basic__static__string.html" title="basic_static_string class with fixed size capacity.">etl::basic_static_string</a>. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs). </p>

</div>
</div>
<a id="a21cf7e5dcda9f55d609ec4236a37c3b0" name="a21cf7e5dcda9f55d609ec4236a37c3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cf7e5dcda9f55d609ec4236a37c3b0">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that compare equal to value from the container. </p>

</div>
</div>
<a id="ae5b84ee8ace15469eade7ad329497759" name="ae5b84ee8ace15469eade7ad329497759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b84ee8ace15469eade7ad329497759">&#9670;&#160;</a></span>erase_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1basic__static__string.html">basic_static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate pred from the container. </p>

</div>
</div>
<a id="a7b5346fd1e1c69c9da34adc6ba0d875b" name="a7b5346fd1e1c69c9da34adc6ba0d875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5346fd1e1c69c9da34adc6ba0d875b">&#9670;&#160;</a></span>stof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="a03247c5be7114ad3402fea1ac09a5323" name="a03247c5be7114ad3402fea1ac09a5323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03247c5be7114ad3402fea1ac09a5323">&#9670;&#160;</a></span>stod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="ad2d8c5321a6401ffca589167c2f5200c" name="ad2d8c5321a6401ffca589167c2f5200c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d8c5321a6401ffca589167c2f5200c">&#9670;&#160;</a></span>stold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">static_string</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to integer to store the number of characters used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string converted to the specified floating point type. </dd></dl>

</div>
</div>
<a id="ad67d02a60ed99d7b4f7caa47c456418c" name="ad67d02a60ed99d7b4f7caa47c456418c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67d02a60ed99d7b4f7caa47c456418c">&#9670;&#160;</a></span>stoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="ac5e713476eeb2d06c599abb03b3c81da" name="ac5e713476eeb2d06c599abb03b3c81da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e713476eeb2d06c599abb03b3c81da">&#9670;&#160;</a></span>stol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a3e6979ddaeccf0df75fc74642fad0938" name="a3e6979ddaeccf0df75fc74642fad0938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6979ddaeccf0df75fc74642fad0938">&#9670;&#160;</a></span>stoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="aab5ca51303826f354fffce9e40115186" name="aab5ca51303826f354fffce9e40115186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5ca51303826f354fffce9e40115186">&#9670;&#160;</a></span>stoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a5fff36f8d372c069a8335afa15afab5d" name="a5fff36f8d372c069a8335afa15afab5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fff36f8d372c069a8335afa15afab5d">&#9670;&#160;</a></span>stoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::stoull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aafbf680e76b153b8a596435b6059846b">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1static__vector.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="aefef503dc1f63ba2e9183e92350a35d6" name="aefef503dc1f63ba2e9183e92350a35d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefef503dc1f63ba2e9183e92350a35d6">&#9670;&#160;</a></span>operator==() <span class="overload">[17/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , CharT... Chars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, Chars... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, Chars... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06688b616d203a7f05d1902d4e9e9ae6" name="a06688b616d203a7f05d1902d4e9e9ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06688b616d203a7f05d1902d4e9e9ae6">&#9670;&#160;</a></span>operator==() <span class="overload">[18/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , CharT... CharsL, CharT... CharsR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, CharsL... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, CharsR... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3175965fb95cd90d46d8741581b050a9" name="a3175965fb95cd90d46d8741581b050a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3175965fb95cd90d46d8741581b050a9">&#9670;&#160;</a></span>to_string() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">int</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a0ae1922b9fe325bc073f9157245ea62f" name="a0ae1922b9fe325bc073f9157245ea62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae1922b9fe325bc073f9157245ea62f">&#9670;&#160;</a></span>to_string() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a866ea97f8268ee79e420deb4e7d0b5c8" name="a866ea97f8268ee79e420deb4e7d0b5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866ea97f8268ee79e420deb4e7d0b5c8">&#9670;&#160;</a></span>to_string() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a76cec2c910331a0348fbc177f79fb5d7" name="a76cec2c910331a0348fbc177f79fb5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cec2c910331a0348fbc177f79fb5d7">&#9670;&#160;</a></span>to_string() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a1591359f7f91cee90f3670ee200fd71e" name="a1591359f7f91cee90f3670ee200fd71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1591359f7f91cee90f3670ee200fd71e">&#9670;&#160;</a></span>to_string() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a316c748b2a3e782707bf5f99266226ce" name="a316c748b2a3e782707bf5f99266226ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316c748b2a3e782707bf5f99266226ce">&#9670;&#160;</a></span>to_string() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">unsigned</a> <a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a3de851aa9fa43387b4735c74a2e913ac" name="a3de851aa9fa43387b4735c74a2e913ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de851aa9fa43387b4735c74a2e913ac">&#9670;&#160;</a></span>to_string() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">float</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="ad12fe48f1155730f6d6beed4ac618c03" name="ad12fe48f1155730f6d6beed4ac618c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fe48f1155730f6d6beed4ac618c03">&#9670;&#160;</a></span>to_string() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="a252c37b56c955507d6f799b10f6d7bf8" name="a252c37b56c955507d6f799b10f6d7bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252c37b56c955507d6f799b10f6d7bf8">&#9670;&#160;</a></span>to_string() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">long</a> <a class="el" href="structetl_1_1static__vector.html">double</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9">etl::static_string</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#a9b6783d01d27625ab2919f8254ad76f9" title="Typedef for a basic_static_string using &#39;char&#39;.">etl::static_string</a>. </p>

</div>
</div>
<a id="ab7e970cc5b5992d8eb7ac649c247c62c" name="ab7e970cc5b5992d8eb7ac649c247c62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e970cc5b5992d8eb7ac649c247c62c">&#9670;&#160;</a></span>operator==() <span class="overload">[19/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a43931ca9d54ef886964eed7b4bc14d63" name="a43931ca9d54ef886964eed7b4bc14d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43931ca9d54ef886964eed7b4bc14d63">&#9670;&#160;</a></span>operator==() <span class="overload">[20/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86e5027c4f68ca37175378f38f9118d7" name="a86e5027c4f68ca37175378f38f9118d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e5027c4f68ca37175378f38f9118d7">&#9670;&#160;</a></span>operator==() <span class="overload">[21/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac75a10e3bbd7b95eda40943d83c2c213" name="ac75a10e3bbd7b95eda40943d83c2c213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75a10e3bbd7b95eda40943d83c2c213">&#9670;&#160;</a></span>operator!=() <span class="overload">[17/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="ad86a94a336ccbaa866716958140a221f" name="ad86a94a336ccbaa866716958140a221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86a94a336ccbaa866716958140a221f">&#9670;&#160;</a></span>operator!=() <span class="overload">[18/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5676aa014a2ce611e045553339c23ea" name="aa5676aa014a2ce611e045553339c23ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5676aa014a2ce611e045553339c23ea">&#9670;&#160;</a></span>operator!=() <span class="overload">[19/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc5e98d445c114716af566d56c8846de" name="adc5e98d445c114716af566d56c8846de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5e98d445c114716af566d56c8846de">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a5b9340746d2b31deae49c0079c6a1393" name="a5b9340746d2b31deae49c0079c6a1393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9340746d2b31deae49c0079c6a1393">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02d40be1a03198a33e40d2deb6727f3b" name="a02d40be1a03198a33e40d2deb6727f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d40be1a03198a33e40d2deb6727f3b">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeda576b0bc560a8f6d7fe3ab07ee4f80" name="aeda576b0bc560a8f6d7fe3ab07ee4f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda576b0bc560a8f6d7fe3ab07ee4f80">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a1fc2112c91d1850707c947cfde474606" name="a1fc2112c91d1850707c947cfde474606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc2112c91d1850707c947cfde474606">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe770e6fbd84cf40351c0d39a6f09a24" name="abe770e6fbd84cf40351c0d39a6f09a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe770e6fbd84cf40351c0d39a6f09a24">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5a16921121279f4b613b0c0228f839b" name="ae5a16921121279f4b613b0c0228f839b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a16921121279f4b613b0c0228f839b">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a3c15495d593a5126ee28f51f045404a9" name="a3c15495d593a5126ee28f51f045404a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c15495d593a5126ee28f51f045404a9">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a810842dd51a024da236472a9b4530d00" name="a810842dd51a024da236472a9b4530d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810842dd51a024da236472a9b4530d00">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e8245ad8d38c37448fb6f2b289695f3" name="a1e8245ad8d38c37448fb6f2b289695f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8245ad8d38c37448fb6f2b289695f3">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharType</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharType</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a6b2ffff69037efea21229e2041a41f5c" name="a6b2ffff69037efea21229e2041a41f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2ffff69037efea21229e2041a41f5c">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae56b3763d8f4d6a4cbda61095d8b9cfc" name="ae56b3763d8f4d6a4cbda61095d8b9cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56b3763d8f4d6a4cbda61095d8b9cfc">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">CharT</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Traits</a> , <a class="el" href="structetl_1_1static__vector.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1static__vector.html">CharT</a>, <a class="el" href="structetl_1_1static__vector.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a974fb6faa222ecb40a59180647ccb79d" name="a974fb6faa222ecb40a59180647ccb79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974fb6faa222ecb40a59180647ccb79d">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Tuple</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">auto</a>)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ed3d4879ef8b1df2012935a3022f720" name="a0ed3d4879ef8b1df2012935a3022f720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed3d4879ef8b1df2012935a3022f720">&#9670;&#160;</a></span>forward_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::forward_as_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Types</a>&amp;&amp;...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members. </p>

</div>
</div>
<a id="a722cde6b61e815e5a032f34f922c3e99" name="a722cde6b61e815e5a032f34f922c3e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722cde6b61e815e5a032f34f922c3e99">&#9670;&#160;</a></span>make_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tuple</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::make_from_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Tuple</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7e0097403ec5f189d1192cca821a7e4" name="aa7e0097403ec5f189d1192cca821a7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e0097403ec5f189d1192cca821a7e4">&#9670;&#160;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::make_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tuple object, deducing the target type from the types of arguments. </p>

</div>
</div>
<a id="ada3ddae955d45b6a63298906227f2f60" name="ada3ddae955d45b6a63298906227f2f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3ddae955d45b6a63298906227f2f60">&#9670;&#160;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Args</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Args</a>&amp;...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7332293756222129bddd488f2be46c89" name="a7332293756222129bddd488f2be46c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7332293756222129bddd488f2be46c89">&#9670;&#160;</a></span>get() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3910901935da4bd1aa0404bb8e4344cd" name="a3910901935da4bd1aa0404bb8e4344cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3910901935da4bd1aa0404bb8e4344cd">&#9670;&#160;</a></span>get() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44d05954af24fa3a51c81a56eac04b53" name="a44d05954af24fa3a51c81a56eac04b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d05954af24fa3a51c81a56eac04b53">&#9670;&#160;</a></span>get() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca389dd668b413db5163594031d441dc" name="aca389dd668b413db5163594031d441dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca389dd668b413db5163594031d441dc">&#9670;&#160;</a></span>get() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae88a49cfacc8c17b0b3dc1091e82b6d3" name="ae88a49cfacc8c17b0b3dc1091e82b6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88a49cfacc8c17b0b3dc1091e82b6d3">&#9670;&#160;</a></span>operator==() <span class="overload">[22/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Us&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1static__vector.html">Ts</a>) == sizeof...(<a class="el" href="structetl_1_1static__vector.html">Us</a>))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Us... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a308b29ca423e2fd99cd291d2f7ac00af" name="a308b29ca423e2fd99cd291d2f7ac00af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308b29ca423e2fd99cd291d2f7ac00af">&#9670;&#160;</a></span>tuple_cat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::tuple_like... Tuples&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tuple_cat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Tuples</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a1c3baeebc248b3f787a308af595c6a" name="a0a1c3baeebc248b3f787a308af595c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1c3baeebc248b3f787a308af595c6a">&#9670;&#160;</a></span>swap() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const -&gt;  <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="a27a1a97135d4a41771948063bd8c3a90" name="a27a1a97135d4a41771948063bd8c3a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a1a97135d4a41771948063bd8c3a90">&#9670;&#160;</a></span>declval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::declval </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  etl::add_rvalue_reference_t&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57b9b4f72a823403539ecfc03192012e" name="a57b9b4f72a823403539ecfc03192012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b9b4f72a823403539ecfc03192012e">&#9670;&#160;</a></span>operator+() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">decltype</a>(<a class="el" href="structetl_1_1static__vector.html">L</a> + <a class="el" href="structetl_1_1static__vector.html">R</a>), <a class="el" href="structetl_1_1static__vector.html">L</a> + <a class="el" href="structetl_1_1static__vector.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b41a63ce6030e00a502be9c802192dc" name="a9b41a63ce6030e00a502be9c802192dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b41a63ce6030e00a502be9c802192dc">&#9670;&#160;</a></span>operator==() <span class="overload">[23/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> == <a class="el" href="structetl_1_1static__vector.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a043a792e889d30e7160364a8a4670297" name="a043a792e889d30e7160364a8a4670297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043a792e889d30e7160364a8a4670297">&#9670;&#160;</a></span>operator!=() <span class="overload">[20/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Rhs</a> , <a class="el" href="structetl_1_1static__vector.html">Rhs</a> R, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Lhs</a> , <a class="el" href="structetl_1_1static__vector.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Rhs</a>, <a class="el" href="structetl_1_1static__vector.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1static__vector.html">Lhs</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">bool</a>, <a class="el" href="structetl_1_1static__vector.html">L</a> != <a class="el" href="structetl_1_1static__vector.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ec5c14f53ef79e0b6debfffb6ce947f" name="a4ec5c14f53ef79e0b6debfffb6ce947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5c14f53ef79e0b6debfffb6ce947f">&#9670;&#160;</a></span>is_constant_evaluated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_constant_evaluated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_constant_evaluated">https://en.cppreference.com/w/cpp/types/is_constant_evaluated</a> </p>

</div>
</div>
<a id="a5d2a8839b0088ceabc861e39e5a15daa" name="a5d2a8839b0088ceabc861e39e5a15daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2a8839b0088ceabc861e39e5a15daa">&#9670;&#160;</a></span>test_implicit_default_constructible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">void</a> etl::test_implicit_default_constructible </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22e832bccac59295eb90e8d9fad5614c" name="a22e832bccac59295eb90e8d9fad5614c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e832bccac59295eb90e8d9fad5614c">&#9670;&#160;</a></span>swap() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const -&gt;  <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="ae88ceada984879d542eb815dfb0a8d83" name="ae88ceada984879d542eb815dfb0a8d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88ceada984879d542eb815dfb0a8d83">&#9670;&#160;</a></span>swap() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="structetl_1_1is__swappable.html">etl::is_swappable</a>&lt;T&gt;::value)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>a</em></span>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>b</em></span>[N]&#160;) -&gt;  <a class="el" href="structetl_1_1static__vector.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa180d468fdf2378d57e100ab2bd37ccc" name="aa180d468fdf2378d57e100ab2bd37ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa180d468fdf2378d57e100ab2bd37ccc">&#9670;&#160;</a></span>as_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::as_const </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; add_const_t&lt;T&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms lvalue reference to const type of t. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a0">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a467b2ed1f8f9d51ceb6786d6f6cd2c1d" name="a467b2ed1f8f9d51ceb6786d6f6cd2c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467b2ed1f8f9d51ceb6786d6f6cd2c1d">&#9670;&#160;</a></span>as_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::as_const </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">void</a>=<a class="el" href="structetl_1_1static__vector.html">delete</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a742e008686e62913e47c8505cba405" name="a6a742e008686e62913e47c8505cba405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a742e008686e62913e47c8505cba405">&#9670;&#160;</a></span>cmp_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cmp_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a1">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad080d4f56f57aee81f93bf37b9599f95" name="ad080d4f56f57aee81f93bf37b9599f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad080d4f56f57aee81f93bf37b9599f95">&#9670;&#160;</a></span>cmp_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cmp_greater </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a134f08c8956146e4c44840cd7e9391d1" name="a134f08c8956146e4c44840cd7e9391d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134f08c8956146e4c44840cd7e9391d1">&#9670;&#160;</a></span>cmp_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cmp_greater_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a14b2305599709550b391642927bba54f" name="a14b2305599709550b391642927bba54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b2305599709550b391642927bba54f">&#9670;&#160;</a></span>cmp_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cmp_less </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type).</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="af861969a29a90c954b15c74f8c483e94" name="af861969a29a90c954b15c74f8c483e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af861969a29a90c954b15c74f8c483e94">&#9670;&#160;</a></span>cmp_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cmp_less_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a13f934565a407af9752f6792d80720e4" name="a13f934565a407af9752f6792d80720e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f934565a407af9752f6792d80720e4">&#9670;&#160;</a></span>cmp_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::cmp_not_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a2">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abab9c512cd288c92340c8a957b3742fe" name="abab9c512cd288c92340c8a957b3742fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab9c512cd288c92340c8a957b3742fe">&#9670;&#160;</a></span>exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::exchange </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the value of obj with new_value and returns the old value of obj. </p>
<dl class="section return"><dt>Returns</dt><dd>The old value of obj. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a3">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aed541bafacdd55b5d4bd723e6b9bb91f" name="aed541bafacdd55b5d4bd723e6b9bb91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed541bafacdd55b5d4bd723e6b9bb91f">&#9670;&#160;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards lvalues as either lvalues or as rvalues, depending on T. When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/forward">https://en.cppreference.com/w/cpp/utility/forward</a> </p>

</div>
</div>
<a id="a7788668573df04d891d55b5433f6e49b" name="a7788668573df04d891d55b5433f6e49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7788668573df04d891d55b5433f6e49b">&#9670;&#160;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">remove_reference_t</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9eb59d3fc5e1767148b6803b4b3a1ba4" name="a9eb59d3fc5e1767148b6803b4b3a1ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb59d3fc5e1767148b6803b4b3a1ba4">&#9670;&#160;</a></span>forward_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::forward_like </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">auto</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acce870bde6a96dc0634f235573439dd1" name="acce870bde6a96dc0634f235573439dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce870bde6a96dc0634f235573439dd1">&#9670;&#160;</a></span>ignore_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::ignore_unused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Types</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly ignore arguments or variables. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_struct" href="structetl_1_1static__vector.html">main</a>(<span class="keywordtype">int</span> <a class="code hl_struct" href="structetl_1_1static__vector.html">argc</a>, <span class="keywordtype">char</span>** <a class="code hl_struct" href="structetl_1_1static__vector.html">argv</a>) -&gt; <span class="keywordtype">int</span></div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="#acce870bde6a96dc0634f235573439dd1">etl::ignore_unused</a>(<a class="code hl_struct" href="structetl_1_1static__vector.html">argc</a>, <a class="code hl_struct" href="structetl_1_1static__vector.html">argv</a>);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceetl_html_acce870bde6a96dc0634f235573439dd1"><div class="ttname"><a href="#acce870bde6a96dc0634f235573439dd1">etl::ignore_unused</a></div><div class="ttdeci">constexpr auto ignore_unused(Types &amp;&amp;...) -&gt; void</div><div class="ttdoc">Explicitly ignore arguments or variables.</div><div class="ttdef"><b>Definition</b> ignore_unused.hpp:17</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2b0f06f15831068e00de541ddb64433f" name="a2b0f06f15831068e00de541ddb64433f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0f06f15831068e00de541ddb64433f">&#9670;&#160;</a></span>in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires etl::detail::integer_and_not_char&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::in_range </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss. </p>
<p>It is a compile-time error if either T or R is not a signed or unsigned integer type (including standard integer type and extended integer type). This function cannot be used with <a class="el" href="#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>, char, char8_t, char16_t, char32_t, wchar_t and bool.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/in_range">https://en.cppreference.com/w/cpp/utility/in_range</a> </p>

</div>
</div>
<a id="a4c81fb3d2e0ae2e41e87e2381bd9776a" name="a4c81fb3d2e0ae2e41e87e2381bd9776a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c81fb3d2e0ae2e41e87e2381bd9776a">&#9670;&#160;</a></span>move() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t</a>&lt;T&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type. </p>
<dl class="section return"><dt>Returns</dt><dd><code>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t)</code> </dd></dl>

</div>
</div>
<a id="afdd2f9cfbab270ff115707284d5c73a7" name="afdd2f9cfbab270ff115707284d5c73a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd2f9cfbab270ff115707284d5c73a7">&#9670;&#160;</a></span>move_if_noexcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::move_if_noexcept </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ab39305667768a11caaca93abf03c21ce">etl::conditional_t</a>&lt;!<a class="el" href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#a045ef39158833b2ba6592fa8a1d0ebc1">etl::is_copy_constructible_v</a>&lt;T&gt;, T <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;, T&amp;&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally convert a value to an rvalue. </p>
<p>Same as <a class="el" href="#a1b8df3814fc65f04932c2f0d09a56107" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> unless the type's move constructor could throw and the type is copyable, in which case an lvalue-reference is returned instead. </p>

</div>
</div>
<a id="a53eed856cd0d950a984b3f7b4bed78b4" name="a53eed856cd0d950a984b3f7b4bed78b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53eed856cd0d950a984b3f7b4bed78b4">&#9670;&#160;</a></span>pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">T1</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">T2</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  pair&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa50aa68713ac9f56128ad9c0406b737" name="aaa50aa68713ac9f56128ad9c0406b737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa50aa68713ac9f56128ad9c0406b737">&#9670;&#160;</a></span>swap() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of x and y. Equivalent to x.swap(y). </p>

</div>
</div>
<a id="ad6d50e8f816232b73e33c92b7f022699" name="ad6d50e8f816232b73e33c92b7f022699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d50e8f816232b73e33c92b7f022699">&#9670;&#160;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::make_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">T1</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">T2</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>&gt;, <a class="el" href="#ac731e2d13871fb7848c6f0ccde332949">decay_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments. </p>
<p>The deduced types V1 and V2 are <a class="el" href="structetl_1_1decay.html#a06c8e67bfa3289a9f9bf3a45c62d020f">etl::decay&lt;T1&gt;::type</a> and <a class="el" href="structetl_1_1decay.html#a06c8e67bfa3289a9f9bf3a45c62d020f">etl::decay&lt;T2&gt;::type</a> (the usual type transformations applied to arguments of functions passed by value).</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/pair/make_pair">https://en.cppreference.com/w/cpp/utility/pair/make_pair</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a5">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aca122149a06ebd4ab08b8ed486df0198" name="aca122149a06ebd4ab08b8ed486df0198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca122149a06ebd4ab08b8ed486df0198">&#9670;&#160;</a></span>operator==() <span class="overload">[24/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second. </p>

</div>
</div>
<a id="a30eb6d42bd94db249c6bb61f3b07ca8b" name="a30eb6d42bd94db249c6bb61f3b07ca8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30eb6d42bd94db249c6bb61f3b07ca8b">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a880fb1e1ee9736f911f931c4f10e4a1c" name="a880fb1e1ee9736f911f931c4f10e4a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880fb1e1ee9736f911f931c4f10e4a1c">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a9fc0b3aadb4525efaf31a9e8d62acc46" name="a9fc0b3aadb4525efaf31a9e8d62acc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc0b3aadb4525efaf31a9e8d62acc46">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a110f9b6f4b39272ee65e708330f7905a" name="a110f9b6f4b39272ee65e708330f7905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110f9b6f4b39272ee65e708330f7905a">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a91adb4adaf07aefbd39d4e39c7e58bd0" name="a91adb4adaf07aefbd39d4e39c7e58bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91adb4adaf07aefbd39d4e39c7e58bd0">&#9670;&#160;</a></span>get() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="ad76a94bc8cf735d9d2d1820a3c472cdf" name="ad76a94bc8cf735d9d2d1820a3c472cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76a94bc8cf735d9d2d1820a3c472cdf">&#9670;&#160;</a></span>get() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="acb8980f3eee6ed4cb54eacd20d86193d" name="acb8980f3eee6ed4cb54eacd20d86193d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8980f3eee6ed4cb54eacd20d86193d">&#9670;&#160;</a></span>get() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="a731452106e6fad9a1630d20ab204689c" name="a731452106e6fad9a1630d20ab204689c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731452106e6fad9a1630d20ab204689c">&#9670;&#160;</a></span>get() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T1</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ac95a227784ffb2786ffbff1dda6a9935">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1static__vector.html">T1</a>, <a class="el" href="structetl_1_1static__vector.html">T2</a>&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="a4da3c5e232d1dfb7eef6e49bc5de33aa" name="a4da3c5e232d1dfb7eef6e49bc5de33aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da3c5e232d1dfb7eef6e49bc5de33aa">&#9670;&#160;</a></span>swap() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">and</a> <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="a32960cfb5370eebeb6deb98ca9d3ee26" name="a32960cfb5370eebeb6deb98ca9d3ee26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32960cfb5370eebeb6deb98ca9d3ee26">&#9670;&#160;</a></span>swap() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="#a46cb1671f31576cce07cf1bac1e99f7c">etl::is_swappable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>a</em></span>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>b</em></span>[N]&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad81467d3810ee7b1ebc9c41ebd6941a1" name="ad81467d3810ee7b1ebc9c41ebd6941a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81467d3810ee7b1ebc9c41ebd6941a1">&#9670;&#160;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Enum</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::to_underlying </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Enum</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ac73e7dfe08364dfb94ca2fafa560a559">underlying_type_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Enum</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an enumeration to its underlying type. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/to_underlying">https://en.cppreference.com/w/cpp/utility/to_underlying</a> </p>

</div>
</div>
<a id="addaf10daac93eed1add86c6ca8317c29" name="addaf10daac93eed1add86c6ca8317c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaf10daac93eed1add86c6ca8317c29">&#9670;&#160;</a></span>unreachable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unreachable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd3b824f87ab3ce98ad82b777b551b2d" name="abd3b824f87ab3ce98ad82b777b551b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3b824f87ab3ce98ad82b777b551b2d">&#9670;&#160;</a></span>overload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">etl::overload </td>
          <td>(</td>
          <td class="paramtype">Functor...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  overload&lt; Functor... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5de48e614d4f8453bb551220e84d9e2d" name="a5de48e614d4f8453bb551220e84d9e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de48e614d4f8453bb551220e84d9e2d">&#9670;&#160;</a></span>swap() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; <br />
requires (detail::enable_variant_swap&lt;Ts...&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the swap algorithm for variant. Effectively calls lhs.swap(rhs). </p>
<p>This overload participates in overload resolution only if is_move_constructible_v&lt;T_i&gt; and is_swappable_v&lt;T_i&gt; are both true for all T_i in Ts... </p>

</div>
</div>
<a id="a863041a1cb8498c8853e859e29367241" name="a863041a1cb8498c8853e859e29367241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863041a1cb8498c8853e859e29367241">&#9670;&#160;</a></span>operator==() <span class="overload">[25/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for variants: </p>
<ul>
<li>If lhs.index() != rhs.index(), returns false;</li>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(lhs) == get&lt;lhs.index()&gt;(rhs) </li>
</ul>

</div>
</div>
<a id="add5ac4ee748bb8b9017c1a38e275a288" name="add5ac4ee748bb8b9017c1a38e275a288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5ac4ee748bb8b9017c1a38e275a288">&#9670;&#160;</a></span>operator!=() <span class="overload">[21/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for variants: </p>
<ul>
<li>If lhs.index() != rhs.index(), returns true;</li>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(lhs) != get&lt;lhs.index()&gt;(rhs) </li>
</ul>

</div>
</div>
<a id="a254c3da6eb0085b05cecc9c4c7586758" name="a254c3da6eb0085b05cecc9c4c7586758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254c3da6eb0085b05cecc9c4c7586758">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator for variants: </p>
<ul>
<li>If rhs.valueless_by_exception(), returns false;</li>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &lt; get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="a97a1ddfed1011b3663a305e72aca1fe0" name="a97a1ddfed1011b3663a305e72aca1fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1ddfed1011b3663a305e72aca1fe0">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-equal operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns true;</li>
<li>If rhs.valueless_by_exception(), returns false;</li>
<li>If lhs.index() &lt; rhs.index(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &lt;= get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="afe841983c5c96ec128c540e07d8ae590" name="afe841983c5c96ec128c540e07d8ae590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe841983c5c96ec128c540e07d8ae590">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>If rhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &gt; get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="ae46d330593ce07ddecb63c78618e1f73" name="ae46d330593ce07ddecb63c78618e1f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46d330593ce07ddecb63c78618e1f73">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-equal operator for variants: </p>
<ul>
<li>If lhs.valueless_by_exception(), returns false;</li>
<li>If rhs.valueless_by_exception(), returns true;</li>
<li>If lhs.index() &gt; rhs.index(), returns true;</li>
<li>If lhs.index() &lt; rhs.index(), returns false;</li>
<li>Otherwise returns get&lt;lhs.index()&gt;(v) &gt;= get&lt;lhs.index()&gt;(w) </li>
</ul>

</div>
</div>
<a id="aaf81f6c62201f50e40031c362915e191" name="aaf81f6c62201f50e40031c362915e191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf81f6c62201f50e40031c362915e191">&#9670;&#160;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::holds_alternative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Ts... </p>

</div>
</div>
<a id="a7f35bc3fbdafc55d32dfd35bf1f7d446" name="a7f35bc3fbdafc55d32dfd35bf1f7d446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f35bc3fbdafc55d32dfd35bf1f7d446">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="a3c84339b3f6aa69a3df586dc2a5b1f69" name="a3c84339b3f6aa69a3df586dc2a5b1f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c84339b3f6aa69a3df586dc2a5b1f69">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="ab54d98119a0f0e56078324af917a37e7" name="ab54d98119a0f0e56078324af917a37e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54d98119a0f0e56078324af917a37e7">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="abf7502c4e6253168a35b9f80528d9264" name="abf7502c4e6253168a35b9f80528d9264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7502c4e6253168a35b9f80528d9264">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the object stored in the variant. </p>
<dl class="section pre"><dt>Precondition</dt><dd>v.index() == I </dd></dl>

</div>
</div>
<a id="aa9910dcb967e65b0a22ccd44afa94d37" name="aa9910dcb967e65b0a22ccd44afa94d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9910dcb967e65b0a22ccd44afa94d37">&#9670;&#160;</a></span>get_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt; add_pointer_t&lt;<a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant. </p>
<p>Type-based non-throwing accessor: The call is ill-formed if T is not a unique element of Ts.... </p>

</div>
</div>
<a id="a3bc1de0794c709d6e34006e8d77e8777" name="a3bc1de0794c709d6e34006e8d77e8777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc1de0794c709d6e34006e8d77e8777">&#9670;&#160;</a></span>get_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt; add_pointer_t&lt;<a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant. </p>
<p>Type-based non-throwing accessor: The call is ill-formed if T is not a unique element of Ts.... </p>

</div>
</div>
<a id="a11ae7d5a6472050c47066e83c7c8ce15" name="a11ae7d5a6472050c47066e83c7c8ce15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ae7d5a6472050c47066e83c7c8ce15">&#9670;&#160;</a></span>get() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a72ab22ab939eed35b82e1f4b4125dcb6" name="a72ab22ab939eed35b82e1f4b4125dcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ab22ab939eed35b82e1f4b4125dcb6">&#9670;&#160;</a></span>get() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a9a8a7b28c60246ca5eae2e499467e4a1" name="a9a8a7b28c60246ca5eae2e499467e4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8a7b28c60246ca5eae2e499467e4a1">&#9670;&#160;</a></span>get() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a65dd3494ef27567671c9d7046e78e2bd" name="a65dd3494ef27567671c9d7046e78e2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dd3494ef27567671c9d7046e78e2bd">&#9670;&#160;</a></span>get() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad029dc8759242c03cbb2d3507ccb0f4e">variant_alternative_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>, <a class="el" href="structetl_1_1variant.html">variant</a>&lt;Ts...&gt;&gt; <a class="el" href="structetl_1_1static__vector.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based value accessor. </p>
<p>Type-based value accessor.</p>
<p>If v.index() == I, returns a reference to the value stored in v. Otherwise, raises a <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if I is not a valid index in the variant.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a></p>
<p>If v holds the alternative T, returns a reference to the value stored in v. Otherwise, throws <a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">bad_variant_access</a>. The call is ill-formed if T is not a unique element of Ts....</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/variant/get">https://en.cppreference.com/w/cpp/utility/variant/get</a> </p>

</div>
</div>
<a id="a6f4d75c3208d681357d77774b729444d" name="a6f4d75c3208d681357d77774b729444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4d75c3208d681357d77774b729444d">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaa90ac4a6cf3911ab23789c9af4d089" name="aeaa90ac4a6cf3911ab23789c9af4d089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa90ac4a6cf3911ab23789c9af4d089">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c39898b60620723d80247080de0439d" name="a3c39898b60620723d80247080de0439d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c39898b60620723d80247080de0439d">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ec2c2a52094776da58ed54719f0bcbd" name="a9ec2c2a52094776da58ed54719f0bcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec2c2a52094776da58ed54719f0bcbd">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant2.html">variant2</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeffc9f0ae12737a221731fd43249e944" name="aeffc9f0ae12737a221731fd43249e944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffc9f0ae12737a221731fd43249e944">&#9670;&#160;</a></span>get_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt;  add_pointer_t&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32dbeed267147923b02448b493be930d" name="a32dbeed267147923b02448b493be930d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dbeed267147923b02448b493be930d">&#9670;&#160;</a></span>get_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt;  add_pointer_t&lt; T <a class="el" href="structetl_1_1static__vector.html">const</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa43fcb4942d4cec1824f6e38edce9981" name="aa43fcb4942d4cec1824f6e38edce9981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43fcb4942d4cec1824f6e38edce9981">&#9670;&#160;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">F</a> , typename... Vs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Vs</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>vs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the visitor vis (Callable that can be called with any combination of types from variants) to the variants vars. </p>
<p>Every type in <a class="el" href="#aa53ab28b069b34ebab412b775f8999ab">etl::remove_reference_t&lt;Variants&gt;</a>... may be a (possibly const-qualified) specialization of <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>. It is unspecified whether other argument types, e.g. a class derived from a <a class="el" href="structetl_1_1variant.html" title="The class template variant represents a type-safe union. An instance of variant at any given time eit...">etl::variant</a>, are supported.</p>
<p>Copied from <a href="https://github.com/rollbear/visit">https://github.com/rollbear/visit</a> <a href="https://github.com/rollbear/visit/blob/master/LICENSE.txt">https://github.com/rollbear/visit/blob/master/LICENSE.txt</a> </p>

</div>
</div>
<a id="ac1c5f129858d55474d1d7ae92c374456" name="ac1c5f129858d55474d1d7ae92c374456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c5f129858d55474d1d7ae92c374456">&#9670;&#160;</a></span>swap() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">static_vector</a>. Swaps the contents of lhs and rhs. </p>

</div>
</div>
<a id="a9d3aa3446aca179d812252faf83360c6" name="a9d3aa3446aca179d812252faf83360c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3aa3446aca179d812252faf83360c6">&#9670;&#160;</a></span>operator==() <span class="overload">[26/27]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="a3d2867e9d12d25137a50a1b3aee3c5a7" name="a3d2867e9d12d25137a50a1b3aee3c5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2867e9d12d25137a50a1b3aee3c5a7">&#9670;&#160;</a></span>operator!=() <span class="overload">[22/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0dfb93223a9c8e4413fe9368cd36046" name="ab0dfb93223a9c8e4413fe9368cd36046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dfb93223a9c8e4413fe9368cd36046">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a715395c53fa693969e269ef5af1972e6" name="a715395c53fa693969e269ef5af1972e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715395c53fa693969e269ef5af1972e6">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4fd2ea0cf33ad9339a54469a92f5121" name="ad4fd2ea0cf33ad9339a54469a92f5121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fd2ea0cf33ad9339a54469a92f5121">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebf47ed021fd1e8bfbc389525967e551" name="aebf47ed021fd1e8bfbc389525967e551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf47ed021fd1e8bfbc389525967e551">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6028d08459dc299edcae40876481fca" name="ab6028d08459dc299edcae40876481fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6028d08459dc299edcae40876481fca">&#9670;&#160;</a></span>erase_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate pred from the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of erased elements.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/erase2">https://en.cppreference.com/w/cpp/container/vector/erase2</a> </p>

</div>
</div>
<a id="a7eea328e45af7e2f0cba2ecf9bfae03e" name="a7eea328e45af7e2f0cba2ecf9bfae03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eea328e45af7e2f0cba2ecf9bfae03e">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="#a49823583370a499813db70f494111109">size_t</a> Capacity, <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1static__vector.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">Capacity</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47b8bc94405a580d276749fde24834f7" name="a47b8bc94405a580d276749fde24834f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b8bc94405a580d276749fde24834f7">&#9670;&#160;</a></span>is_hosted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_hosted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">consteval</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0643ba313eeb2da0a37a713fa74cb5f" name="ae0643ba313eeb2da0a37a713fa74cb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0643ba313eeb2da0a37a713fa74cb5f">&#9670;&#160;</a></span>is_freestanding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_freestanding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">consteval</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b353c6f122b14a8e9b78c453d8fa381" name="a7b353c6f122b14a8e9b78c453d8fa381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b353c6f122b14a8e9b78c453d8fa381">&#9670;&#160;</a></span>operator==() <span class="overload">[27/27]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares language_standards. </p>

</div>
</div>
<a id="a0be806bd6b96b20e9313a7e398cc5783" name="a0be806bd6b96b20e9313a7e398cc5783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be806bd6b96b20e9313a7e398cc5783">&#9670;&#160;</a></span>operator!=() <span class="overload">[23/23]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb2e2b8ee1daac1fdf220e6aad21fbea" name="afb2e2b8ee1daac1fdf220e6aad21fbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2e2b8ee1daac1fdf220e6aad21fbea">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ff7b111685f53a1a28d184323c9a7c3" name="a6ff7b111685f53a1a28d184323c9a7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff7b111685f53a1a28d184323c9a7c3">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5748614e8daf5563998666a4584ee575" name="a5748614e8daf5563998666a4584ee575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5748614e8daf5563998666a4584ee575">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00deb6a88953ac9fe457f6f79b347152" name="a00deb6a88953ac9fe457f6f79b347152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00deb6a88953ac9fe457f6f79b347152">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> <a class="el" href="structetl_1_1static__vector.html">etl::operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1static__vector.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aedb63d88f3219c350ab03af8bd0adb5a" name="aedb63d88f3219c350ab03af8bd0adb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb63d88f3219c350ab03af8bd0adb5a">&#9670;&#160;</a></span>is_bitmask_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_bitmask_type_v = <a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8cc35f4fca27a07908f67b7ef595cd3" name="ab8cc35f4fca27a07908f67b7ef595cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cc35f4fca27a07908f67b7ef595cd3">&#9670;&#160;</a></span>binary</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::binary = <a class="el" href="structetl_1_1binary__t.html">binary_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d957fa8529e9617c445e42519518e5e" name="a1d957fa8529e9617c445e42519518e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d957fa8529e9617c445e42519518e5e">&#9670;&#160;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">enum</a> <a class="el" href="attributes_8hpp.html#a6cf990edeb7f9f6f1b5928471cef5e56">TETL_MAY_ALIAS</a> etl::byte</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#a1d957fa8529e9617c445e42519518e5e" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a> is a distinct type that implements the concept of byte as specified in the C++ language definition. </p>
<p>Like char and unsigned char, it can be used to access raw memory occupied by other objects, but unlike those types, it is not a character type and is not an arithmetic type. A byte is only a collection of bits, and the only operators defined for it are the bitwise ones.</p>
<p><a href="https://en.cppreference.com/w/cpp/types/byte">https://en.cppreference.com/w/cpp/types/byte</a> </p>

</div>
</div>
<a id="a2932a67109d86a3d3414866785f19613" name="a2932a67109d86a3d3414866785f19613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2932a67109d86a3d3414866785f19613">&#9670;&#160;</a></span>unexpect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::unexpect = <a class="el" href="structetl_1_1unexpect__t.html">unexpect_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3206db2ddd4b49017ef0d257ca69a515" name="a3206db2ddd4b49017ef0d257ca69a515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3206db2ddd4b49017ef0d257ca69a515">&#9670;&#160;</a></span>sorted_unique</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::sorted_unique = <a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5ecf4e1b001cdba463b17849f4b55e4" name="ad5ecf4e1b001cdba463b17849f4b55e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ecf4e1b001cdba463b17849f4b55e4">&#9670;&#160;</a></span>is_placeholder_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">int</a> etl::is_placeholder_v = <a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a751416861268d9328aa2a7263fd85e1b" name="a751416861268d9328aa2a7263fd85e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751416861268d9328aa2a7263fd85e1b">&#9670;&#160;</a></span>full_extent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::full_extent = <a class="el" href="structetl_1_1full__extent__t.html">full_extent_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74fea0e76b0257b8f9ffbca0b6de6aaa" name="a74fea0e76b0257b8f9ffbca0b6de6aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fea0e76b0257b8f9ffbca0b6de6aaa">&#9670;&#160;</a></span>allocator_arg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a> etl::allocator_arg {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocator_arg is a constant of type <a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects. </p>

</div>
</div>
<a id="a16cf19d8af06969d839fa909ad6e184f" name="a16cf19d8af06969d839fa909ad6e184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cf19d8af06969d839fa909ad6e184f">&#9670;&#160;</a></span>uses_allocator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::uses_allocator_v = <a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Type</a>, <a class="el" href="structetl_1_1static__vector.html">Alloc</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false. </p>

</div>
</div>
<a id="a3e9e177fde5dc55ea58bb3771c37051a" name="a3e9e177fde5dc55ea58bb3771c37051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9e177fde5dc55ea58bb3771c37051a">&#9670;&#160;</a></span>defer_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a> etl::defer_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1defer__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">defer_lock_t</a>. </p>

</div>
</div>
<a id="a086e79db17e8b72ae86d834fad514b2e" name="a086e79db17e8b72ae86d834fad514b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086e79db17e8b72ae86d834fad514b2e">&#9670;&#160;</a></span>try_to_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a> etl::try_to_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1try__to__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">try_to_lock_t</a>. </p>

</div>
</div>
<a id="a03ee00292ff760cd8ecf8b41bb4de696" name="a03ee00292ff760cd8ecf8b41bb4de696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ee00292ff760cd8ecf8b41bb4de696">&#9670;&#160;</a></span>adopt_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a> etl::adopt_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1adopt__lock__t.html" title="Empty struct tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock,...">adopt_lock_t</a>. </p>

</div>
</div>
<a id="ac7234bd8fd6d2e05055093f7a4bb53d7" name="ac7234bd8fd6d2e05055093f7a4bb53d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7234bd8fd6d2e05055093f7a4bb53d7">&#9670;&#160;</a></span>destroying_delete</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::destroying_delete = <a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag type used to identify the destroying delete form of operator delete. </p>

</div>
</div>
<a id="a20ecb067c83bfce58af4f03457f15c8c" name="a20ecb067c83bfce58af4f03457f15c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ecb067c83bfce58af4f03457f15c8c">&#9670;&#160;</a></span>hardware_constructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hardware_constructive_interference_size = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum offset between two objects to avoid false sharing. Guaranteed to be at least alignof(max_align_t). </p>

</div>
</div>
<a id="abc217ae19afd481b0993696cbb1729bf" name="abc217ae19afd481b0993696cbb1729bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc217ae19afd481b0993696cbb1729bf">&#9670;&#160;</a></span>hardware_destructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::hardware_destructive_interference_size = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least alignof(max_align_t). </p>

</div>
</div>
<a id="a8a1ead4c5ac981fe88bcd71d1aba1d61" name="a8a1ead4c5ac981fe88bcd71d1aba1d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1ead4c5ac981fe88bcd71d1aba1d61">&#9670;&#160;</a></span>nothrow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nothrow = <a class="el" href="structetl_1_1nothrow__t.html">etl::nothrow_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#a8a1ead4c5ac981fe88bcd71d1aba1d61" title="etl::nothrow is a constant of type etl::nothrow_t used to disambiguate the overloads of throwing and ...">etl::nothrow</a> is a constant of type <a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> used to disambiguate the overloads of throwing and non-throwing allocation functions. </p>

</div>
</div>
<a id="a93d7a7601aedf2ce125a34a9d83b80a7" name="a93d7a7601aedf2ce125a34a9d83b80a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d7a7601aedf2ce125a34a9d83b80a7">&#9670;&#160;</a></span>nullopt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nullopt = <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>{{}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#a93d7a7601aedf2ce125a34a9d83b80a7" title="etl::nullopt is a constant of type etl::nullopt_t that is used to indicate optional type with uniniti...">etl::nullopt</a> is a constant of type <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> that is used to indicate optional type with uninitialized state. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="optional_8cpp-example.html#a0">optional.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a92b2aa1aec32660fd5004c4847957f20" name="a92b2aa1aec32660fd5004c4847957f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b2aa1aec32660fd5004c4847957f20">&#9670;&#160;</a></span>element_aligned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1element__aligned__tag.html">element_aligned_tag</a> etl::element_aligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae57e9c30285b23943d7021abf09160e1" name="ae57e9c30285b23943d7021abf09160e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57e9c30285b23943d7021abf09160e1">&#9670;&#160;</a></span>vector_aligned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1vector__aligned__tag.html">vector_aligned_tag</a> etl::vector_aligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9312dc46a8d75ebd1d2ac9315c09bf57" name="a9312dc46a8d75ebd1d2ac9315c09bf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9312dc46a8d75ebd1d2ac9315c09bf57">&#9670;&#160;</a></span>overaligned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1overaligned__tag.html">overaligned_tag</a>&lt;<a class="el" href="structetl_1_1static__vector.html">N</a>&gt; etl::overaligned {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae174223df490e6263d4648a86326c902" name="ae174223df490e6263d4648a86326c902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae174223df490e6263d4648a86326c902">&#9670;&#160;</a></span>dynamic_extent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::dynamic_extent = <a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>&gt;<a class="el" href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">::max</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#ae174223df490e6263d4648a86326c902" title="etl::dynamic_extent is a constant of type etl::size_t that is used to differentiate etl::span of stat...">etl::dynamic_extent</a> is a constant of type <a class="el" href="#a49823583370a499813db70f494111109" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> that is used to differentiate <a class="el" href="structetl_1_1span.html" title="A non-owning view over a contiguous sequence of objects.">etl::span</a> of static and dynamic extent. </p>

</div>
</div>
<a id="ad8a0374b0fe975ab01bcc129d60f5d03" name="ad8a0374b0fe975ab01bcc129d60f5d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a0374b0fe975ab01bcc129d60f5d03">&#9670;&#160;</a></span>ignore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">struct</a> etl::ignore etl::ignore</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3e2b2e600cad8b86cd15cb73d7f0a4c" name="ac3e2b2e600cad8b86cd15cb73d7f0a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e2b2e600cad8b86cd15cb73d7f0a4c">&#9670;&#160;</a></span>is_tuple_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_tuple_like&lt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt; Ts... &gt; &gt; = <a class="el" href="structetl_1_1static__vector.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93d0a5fb70cb82c336299812b04498f8" name="a93d0a5fb70cb82c336299812b04498f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d0a5fb70cb82c336299812b04498f8">&#9670;&#160;</a></span>tuple_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::tuple_size_v = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a76e66c3ede7a3c2d993850cd16d1b4e3" name="a76e66c3ede7a3c2d993850cd16d1b4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e66c3ede7a3c2d993850cd16d1b4e3">&#9670;&#160;</a></span>alignment_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> etl::alignment_of_v = <a class="el" href="structetl_1_1alignment__of.html">etl::alignment_of</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a815380448fc90ab014b40a47938372f9" name="a815380448fc90ab014b40a47938372f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815380448fc90ab014b40a47938372f9">&#9670;&#160;</a></span>always_false</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::always_false = <a class="el" href="structetl_1_1static__vector.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0d9f32a20bf813fd8ce025d0aebbff5" name="af0d9f32a20bf813fd8ce025d0aebbff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d9f32a20bf813fd8ce025d0aebbff5">&#9670;&#160;</a></span>conjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::conjunction_v = (B::value &amp;&amp; ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29f460d9cd9dc39f08fc926828d8b442" name="a29f460d9cd9dc39f08fc926828d8b442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f460d9cd9dc39f08fc926828d8b442">&#9670;&#160;</a></span>disjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::disjunction_v = (B::value || ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a115f1cea7fc27ee979afae4871d03a03" name="a115f1cea7fc27ee979afae4871d03a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115f1cea7fc27ee979afae4871d03a03">&#9670;&#160;</a></span>extent_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">unsigned</a> N = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::extent_v = <a class="el" href="structetl_1_1static__vector.html">static_cast</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">size_t</a>&gt;(<a class="el" href="structetl_1_1extent.html">extent</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">N</a>&gt;::value)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a60e01980cd945b387ffc47f44eccf" name="a66a60e01980cd945b387ffc47f44eccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a60e01980cd945b387ffc47f44eccf">&#9670;&#160;</a></span>has_unique_object_representations_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::has_unique_object_representations_v = <a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46f3f4c2468d1d1f33a449bf167efbbc" name="a46f3f4c2468d1d1f33a449bf167efbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f3f4c2468d1d1f33a449bf167efbbc">&#9670;&#160;</a></span>has_virtual_destructor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::has_virtual_destructor_v = <a class="el" href="structetl_1_1static__vector.html">__has_virtual_destructor</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a> </p>

</div>
</div>
<a id="af27862efe6b9f1ba007a712b5e2a6e8a" name="af27862efe6b9f1ba007a712b5e2a6e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27862efe6b9f1ba007a712b5e2a6e8a">&#9670;&#160;</a></span>index_c</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::index_c = <a class="el" href="#aa8298a20279ec5d2a5df508272115cc3">etl::index_constant</a>&lt;<a class="el" href="structetl_1_1static__vector.html">I</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad586ed3dee38cd4cc1b409e607230ffb" name="ad586ed3dee38cd4cc1b409e607230ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad586ed3dee38cd4cc1b409e607230ffb">&#9670;&#160;</a></span>is_abstract_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_abstract_v = <a class="el" href="structetl_1_1static__vector.html">__is_abstract</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afacace2162b09f525f4baff15548ecda" name="afacace2162b09f525f4baff15548ecda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacace2162b09f525f4baff15548ecda">&#9670;&#160;</a></span>is_aggregate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_aggregate_v = <a class="el" href="structetl_1_1static__vector.html">__is_aggregate</a>(<a class="el" href="#a7d3ea939d0e932fceedbae01d7a3af90">remove_cv_t</a>&lt;T&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0de9ab0c91e46602a77993e77ec8a6d" name="ad0de9ab0c91e46602a77993e77ec8a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0de9ab0c91e46602a77993e77ec8a6d">&#9670;&#160;</a></span>is_any_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_any_of_v = <a class="el" href="#a29f460d9cd9dc39f08fc926828d8b442">disjunction_v</a>&lt;<a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, <a class="el" href="structetl_1_1static__vector.html">Types</a>&gt;...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a105e2a5ac8fc634dcc71675e27e3f95e" name="a105e2a5ac8fc634dcc71675e27e3f95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105e2a5ac8fc634dcc71675e27e3f95e">&#9670;&#160;</a></span>is_arithmetic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_arithmetic_v = <a class="el" href="#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;T&gt; <a class="el" href="structetl_1_1static__vector.html">or</a> <a class="el" href="#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afaa46050181985a6156a6c800c86a7d8" name="afaa46050181985a6156a6c800c86a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa46050181985a6156a6c800c86a7d8">&#9670;&#160;</a></span>is_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_array_v = <a class="el" href="structetl_1_1is__array.html">etl::is_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae630f4cbcf30c3c7912d50547711e86d" name="ae630f4cbcf30c3c7912d50547711e86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae630f4cbcf30c3c7912d50547711e86d">&#9670;&#160;</a></span>is_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_assignable_v = <a class="el" href="structetl_1_1static__vector.html">__is_assignable</a>(T, U)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af00bab8d0b02bcb2974969b9d69639bb" name="af00bab8d0b02bcb2974969b9d69639bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00bab8d0b02bcb2974969b9d69639bb">&#9670;&#160;</a></span>is_base_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Base</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Derived</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_base_of_v = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Base</a>, <a class="el" href="structetl_1_1static__vector.html">Derived</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d2eef20a4d7f2fcfb333c7e5c23444" name="ae6d2eef20a4d7f2fcfb333c7e5c23444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d2eef20a4d7f2fcfb333c7e5c23444">&#9670;&#160;</a></span>is_bounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_bounded_array_v = <a class="el" href="structetl_1_1is__bounded__array.html">etl::is_bounded_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8d441fab48eb459b77f6f5829f7fc75" name="af8d441fab48eb459b77f6f5829f7fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d441fab48eb459b77f6f5829f7fc75">&#9670;&#160;</a></span>is_class_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_class_v = <a class="el" href="structetl_1_1static__vector.html">__is_class</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab45e49677aea4d7ed533e7c73ea7f2b6" name="ab45e49677aea4d7ed533e7c73ea7f2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e49677aea4d7ed533e7c73ea7f2b6">&#9670;&#160;</a></span>is_compound_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_compound_v = !<a class="el" href="#af6b1115f04c131e47ab31a50aa2194b2">etl::is_fundamental_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40862de0c689f5281b8d680741bc7cf9" name="a40862de0c689f5281b8d680741bc7cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40862de0c689f5281b8d680741bc7cf9">&#9670;&#160;</a></span>is_const_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_const_v = <a class="el" href="structetl_1_1is__const.html">etl::is_const</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a4">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1ab616d6855ca5fc60968a153587b2b4" name="a1ab616d6855ca5fc60968a153587b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab616d6855ca5fc60968a153587b2b4">&#9670;&#160;</a></span>is_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_constructible_v = <a class="el" href="#a43743001594f300bde6a116196b1a2b8">is_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa15279e84c7ec40ef8a2d460b81b7fb7" name="aa15279e84c7ec40ef8a2d460b81b7fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15279e84c7ec40ef8a2d460b81b7fb7">&#9670;&#160;</a></span>is_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_convertible_v = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;<a class="el" href="structetl_1_1static__vector.html">From</a>, <a class="el" href="structetl_1_1static__vector.html">To</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17e13a2d8cce95954bee3d62ec059851" name="a17e13a2d8cce95954bee3d62ec059851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e13a2d8cce95954bee3d62ec059851">&#9670;&#160;</a></span>is_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_copy_assignable_v = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a045ef39158833b2ba6592fa8a1d0ebc1" name="a045ef39158833b2ba6592fa8a1d0ebc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045ef39158833b2ba6592fa8a1d0ebc1">&#9670;&#160;</a></span>is_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_copy_constructible_v = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0093a625b8acbeac1878b9a9668a2563" name="a0093a625b8acbeac1878b9a9668a2563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0093a625b8acbeac1878b9a9668a2563">&#9670;&#160;</a></span>is_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_default_constructible_v = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34ff2b6f5e9a98730031297120e28af4" name="a34ff2b6f5e9a98730031297120e28af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ff2b6f5e9a98730031297120e28af4">&#9670;&#160;</a></span>is_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_destructible_v = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a258143fbbaaef57434ff042f35db08a6" name="a258143fbbaaef57434ff042f35db08a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258143fbbaaef57434ff042f35db08a6">&#9670;&#160;</a></span>is_empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_empty_v = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4784b73e6d758a37358b62211a308ef" name="aa4784b73e6d758a37358b62211a308ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4784b73e6d758a37358b62211a308ef">&#9670;&#160;</a></span>is_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_enum_v = <a class="el" href="structetl_1_1static__vector.html">__is_enum</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b8c484a0ff37fdfc1fc2c47b092ade2" name="a0b8c484a0ff37fdfc1fc2c47b092ade2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8c484a0ff37fdfc1fc2c47b092ade2">&#9670;&#160;</a></span>is_final_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_final_v = <a class="el" href="structetl_1_1static__vector.html">__is_final</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cf273d19443134cffcd66310d027ae4" name="a5cf273d19443134cffcd66310d027ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf273d19443134cffcd66310d027ae4">&#9670;&#160;</a></span>is_floating_point_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_floating_point_v = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec3b44fa05f956c1efc4f34af98bd1f0" name="aec3b44fa05f956c1efc4f34af98bd1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3b44fa05f956c1efc4f34af98bd1f0">&#9670;&#160;</a></span>is_function_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_function_v = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether T is a function type. Types like etl::function, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false. </p>
<p>The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__function.html">is_function</a> or is_function_v is undefined. </p>

</div>
</div>
<a id="af6b1115f04c131e47ab31a50aa2194b2" name="af6b1115f04c131e47ab31a50aa2194b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b1115f04c131e47ab31a50aa2194b2">&#9670;&#160;</a></span>is_fundamental_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_fundamental_v = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a750d61c5b9f6964af8d9465794b92953" name="a750d61c5b9f6964af8d9465794b92953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750d61c5b9f6964af8d9465794b92953">&#9670;&#160;</a></span>is_implicit_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_implicit_default_constructible_v = <a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ef2a50a29c8803d461abedd7437effd" name="a0ef2a50a29c8803d461abedd7437effd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef2a50a29c8803d461abedd7437effd">&#9670;&#160;</a></span>is_integral_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_integral_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= is_any_of_v&lt;remove_cv_t&lt;T&gt;,</div>
<div class="line">        bool,</div>
<div class="line">        char,</div>
<div class="line">        <span class="keywordtype">signed</span> char,</div>
<div class="line">        <span class="keywordtype">unsigned</span> char,</div>
<div class="line">        wchar_t,</div>
<div class="line">        char8_t,</div>
<div class="line">        char16_t,</div>
<div class="line">        char32_t,</div>
<div class="line">        short,</div>
<div class="line">        <span class="keywordtype">unsigned</span> short,</div>
<div class="line">        int,</div>
<div class="line">        <span class="keywordtype">unsigned</span> int,</div>
<div class="line">        long,</div>
<div class="line">        <span class="keywordtype">unsigned</span> long,</div>
<div class="line">        <span class="keywordtype">long</span> long,</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span></div>
<div class="line">    &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="abcda8292d5b910aed63532a701d39e87" name="abcda8292d5b910aed63532a701d39e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcda8292d5b910aed63532a701d39e87">&#9670;&#160;</a></span>is_invocable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Fn</a> , typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_invocable_v = <a class="el" href="structetl_1_1is__invocable.html">is_invocable</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Fn</a>, ArgTypes...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8a1ef24a3b6eb7a38ad1307015c2c09" name="af8a1ef24a3b6eb7a38ad1307015c2c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a1ef24a3b6eb7a38ad1307015c2c09">&#9670;&#160;</a></span>is_invocable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">R</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Fn</a> , typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_invocable_r_v = <a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a>&lt;<a class="el" href="structetl_1_1static__vector.html">R</a>, <a class="el" href="structetl_1_1static__vector.html">Fn</a>, ArgTypes...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdf67506d7e83cba3f386c212a824e9c" name="abdf67506d7e83cba3f386c212a824e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf67506d7e83cba3f386c212a824e9c">&#9670;&#160;</a></span>is_lvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_lvalue_reference_v = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a690a598d20472c340a3e6969d5fe58af" name="a690a598d20472c340a3e6969d5fe58af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690a598d20472c340a3e6969d5fe58af">&#9670;&#160;</a></span>is_member_function_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_member_function_pointer_v = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05fe5ff6b0b6727ff7c98a53e5eb1c80" name="a05fe5ff6b0b6727ff7c98a53e5eb1c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fe5ff6b0b6727ff7c98a53e5eb1c80">&#9670;&#160;</a></span>is_member_object_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_member_object_pointer_v = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbaaa5057d498812ee848f491a20649a" name="adbaaa5057d498812ee848f491a20649a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaaa5057d498812ee848f491a20649a">&#9670;&#160;</a></span>is_member_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_member_pointer_v = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad208b3b6c99d59cdc5d698310e59143e" name="ad208b3b6c99d59cdc5d698310e59143e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad208b3b6c99d59cdc5d698310e59143e">&#9670;&#160;</a></span>is_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_move_assignable_v = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82b776d5da5e25514489bfd330d7940d" name="a82b776d5da5e25514489bfd330d7940d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b776d5da5e25514489bfd330d7940d">&#9670;&#160;</a></span>is_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_move_constructible_v = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a865b2c54ee24d227ee6f222e49fd076c" name="a865b2c54ee24d227ee6f222e49fd076c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865b2c54ee24d227ee6f222e49fd076c">&#9670;&#160;</a></span>is_nothrow_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_assignable_v = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ff5fc00d3b16aa2421ea49dae4e864e" name="a4ff5fc00d3b16aa2421ea49dae4e864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff5fc00d3b16aa2421ea49dae4e864e">&#9670;&#160;</a></span>is_nothrow_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_constructible_v = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2efb1cd1aad111e64a98e89322815a8f" name="a2efb1cd1aad111e64a98e89322815a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efb1cd1aad111e64a98e89322815a8f">&#9670;&#160;</a></span>is_nothrow_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">From</a> , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">To</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_convertible_v = <a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a>&lt;<a class="el" href="structetl_1_1static__vector.html">From</a>, <a class="el" href="structetl_1_1static__vector.html">To</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5684c28598fd5bde573fccdf36cccda9" name="a5684c28598fd5bde573fccdf36cccda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5684c28598fd5bde573fccdf36cccda9">&#9670;&#160;</a></span>is_nothrow_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_copy_assignable_v = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab05ca75073ae3731fef7c09200d9f693" name="ab05ca75073ae3731fef7c09200d9f693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05ca75073ae3731fef7c09200d9f693">&#9670;&#160;</a></span>is_nothrow_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_copy_constructible_v = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12e312d7578609fe1f21277a6d7a1606" name="a12e312d7578609fe1f21277a6d7a1606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e312d7578609fe1f21277a6d7a1606">&#9670;&#160;</a></span>is_nothrow_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_default_constructible_v = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92bb068a979f4237eb8c218d4f0112f2" name="a92bb068a979f4237eb8c218d4f0112f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bb068a979f4237eb8c218d4f0112f2">&#9670;&#160;</a></span>is_nothrow_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_destructible_v = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5d18b577003e8d090a82e4c6d497cdd" name="ab5d18b577003e8d090a82e4c6d497cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d18b577003e8d090a82e4c6d497cdd">&#9670;&#160;</a></span>is_nothrow_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_move_assignable_v = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00f5b3ced7a1f4ebd3e7b1119a4c12a" name="ac00f5b3ced7a1f4ebd3e7b1119a4c12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">&#9670;&#160;</a></span>is_nothrow_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_move_constructible_v = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fe0a7655d7b161139e48f8eb34838ac" name="a4fe0a7655d7b161139e48f8eb34838ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe0a7655d7b161139e48f8eb34838ac">&#9670;&#160;</a></span>is_nothrow_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_swappable_v = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d458068230554e22227d91a28708809" name="a8d458068230554e22227d91a28708809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d458068230554e22227d91a28708809">&#9670;&#160;</a></span>is_nothrow_swappable_with_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_nothrow_swappable_with_v = <a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a016c8419365e8e3697a56040d335bca4" name="a016c8419365e8e3697a56040d335bca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016c8419365e8e3697a56040d335bca4">&#9670;&#160;</a></span>is_null_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_null_pointer_v = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63efd09c0ee7195824be65423adadedc" name="a63efd09c0ee7195824be65423adadedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63efd09c0ee7195824be65423adadedc">&#9670;&#160;</a></span>is_object_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_object_v = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00eca7d51c4d2c1021402ee9a70f03c" name="ac00eca7d51c4d2c1021402ee9a70f03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00eca7d51c4d2c1021402ee9a70f03c">&#9670;&#160;</a></span>is_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_pointer_v = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca8f73739262829ccbc6f7400f3b2601" name="aca8f73739262829ccbc6f7400f3b2601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8f73739262829ccbc6f7400f3b2601">&#9670;&#160;</a></span>is_polymorphic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_polymorphic_v = <a class="el" href="structetl_1_1static__vector.html">__is_polymorphic</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22294e9170ea0547c68724eabe0c8c5a" name="a22294e9170ea0547c68724eabe0c8c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22294e9170ea0547c68724eabe0c8c5a">&#9670;&#160;</a></span>is_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_reference_v = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73c52ea67297deb4aba0a1d7abb142f5" name="a73c52ea67297deb4aba0a1d7abb142f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c52ea67297deb4aba0a1d7abb142f5">&#9670;&#160;</a></span>is_reference_wrapper_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_reference_wrapper_v = <a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2cba0c4e29fbd91ba77cbf6b9744ebc" name="af2cba0c4e29fbd91ba77cbf6b9744ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cba0c4e29fbd91ba77cbf6b9744ebc">&#9670;&#160;</a></span>is_rvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_rvalue_reference_v = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f74da2365a9a6f68d472686fd0f1666" name="a3f74da2365a9a6f68d472686fd0f1666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f74da2365a9a6f68d472686fd0f1666">&#9670;&#160;</a></span>is_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_same_v = <a class="el" href="structetl_1_1static__vector.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a699a4890b6c210a9503c517082e10e6c" name="a699a4890b6c210a9503c517082e10e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699a4890b6c210a9503c517082e10e6c">&#9670;&#160;</a></span>is_same_v&lt; T, T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> <a class="el" href="#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt; T, T &gt; = <a class="el" href="structetl_1_1static__vector.html">true</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab43d223a689de0810df63d7c223d4228" name="ab43d223a689de0810df63d7c223d4228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43d223a689de0810df63d7c223d4228">&#9670;&#160;</a></span>is_scalar_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_scalar_v = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3e458f80e6889b85b2e3bf2ee84360b" name="af3e458f80e6889b85b2e3bf2ee84360b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e458f80e6889b85b2e3bf2ee84360b">&#9670;&#160;</a></span>is_scoped_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_scoped_enum_v = <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether T is an scoped enumeration type. Provides the member constant value which is equal to true, if T is an scoped enumeration type. Otherwise, value is equal to false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a> or is_scoped_enum_v is undefined. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_scoped_enum">https://en.cppreference.com/w/cpp/types/is_scoped_enum</a> </p>

</div>
</div>
<a id="aff3fadd2a1e349c45f524ab5444220ff" name="aff3fadd2a1e349c45f524ab5444220ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3fadd2a1e349c45f524ab5444220ff">&#9670;&#160;</a></span>is_signed_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_signed_v = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68efadb1ffae420e853d78309b080bb5" name="a68efadb1ffae420e853d78309b080bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efadb1ffae420e853d78309b080bb5">&#9670;&#160;</a></span>is_specialized_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">template</a>&lt; typename... &gt; <a class="el" href="structetl_1_1static__vector.html">typename</a> Template, <a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Tag</a>  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_specialized_v = <a class="el" href="structetl_1_1is__specialized.html">etl::is_specialized</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Template</a>, T, <a class="el" href="structetl_1_1static__vector.html">Tag</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0627b73385571d2f5b0bb7b5f23d0c4e" name="a0627b73385571d2f5b0bb7b5f23d0c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0627b73385571d2f5b0bb7b5f23d0c4e">&#9670;&#160;</a></span>is_standard_layout_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_standard_layout_v = <a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46cb1671f31576cce07cf1bac1e99f7c" name="a46cb1671f31576cce07cf1bac1e99f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cb1671f31576cce07cf1bac1e99f7c">&#9670;&#160;</a></span>is_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_swappable_v = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7be84147dabbe2371aec6974e74d0f77" name="a7be84147dabbe2371aec6974e74d0f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be84147dabbe2371aec6974e74d0f77">&#9670;&#160;</a></span>is_swappable_with_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_swappable_with_v = <a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dc5a4c4924b529a3f8760925c283ce6" name="a1dc5a4c4924b529a3f8760925c283ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5a4c4924b529a3f8760925c283ce6">&#9670;&#160;</a></span>is_trivial_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivial_v = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2cfce5bc9de7ea45285ad503a807a9b" name="ad2cfce5bc9de7ea45285ad503a807a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cfce5bc9de7ea45285ad503a807a9b">&#9670;&#160;</a></span>is_trivially_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , <a class="el" href="structetl_1_1static__vector.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivially_assignable_v = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a74c34b46b65c2b8fa633d1e6211b25" name="a0a74c34b46b65c2b8fa633d1e6211b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a74c34b46b65c2b8fa633d1e6211b25">&#9670;&#160;</a></span>is_trivially_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivially_constructible_v = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4028d9154b8d629e56fd488b33587786" name="a4028d9154b8d629e56fd488b33587786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4028d9154b8d629e56fd488b33587786">&#9670;&#160;</a></span>is_trivially_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivially_copy_assignable_v = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac56b91d45ec88c108b77f55e9f6bc187" name="ac56b91d45ec88c108b77f55e9f6bc187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56b91d45ec88c108b77f55e9f6bc187">&#9670;&#160;</a></span>is_trivially_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivially_copy_constructible_v = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3b937c99443cbaf5f1817d061261bd" name="a5b3b937c99443cbaf5f1817d061261bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3b937c99443cbaf5f1817d061261bd">&#9670;&#160;</a></span>is_trivially_copyable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivially_copyable_v = <a class="el" href="structetl_1_1static__vector.html">__is_trivially_copyable</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f37ab88cda78781a7aca13f18adac97" name="a6f37ab88cda78781a7aca13f18adac97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f37ab88cda78781a7aca13f18adac97">&#9670;&#160;</a></span>is_trivially_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivially_default_constructible_v = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11b9d2d77f59d05a317cc9715ac7aa8c" name="a11b9d2d77f59d05a317cc9715ac7aa8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b9d2d77f59d05a317cc9715ac7aa8c">&#9670;&#160;</a></span>is_trivially_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivially_destructible_v = <a class="el" href="structetl_1_1static__vector.html">__has_trivial_destructor</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3673480825caede3c2d5095f8a39fe0d" name="a3673480825caede3c2d5095f8a39fe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3673480825caede3c2d5095f8a39fe0d">&#9670;&#160;</a></span>is_trivially_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_trivially_move_assignable_v = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef6928ba542ac2317ce2796c3a71a9b7" name="aef6928ba542ac2317ce2796c3a71a9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6928ba542ac2317ce2796c3a71a9b7">&#9670;&#160;</a></span>is_trivially_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::is_trivially_move_constructible_v = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">etl::is_trivially_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00c65af89fc55014250b54559626d075" name="a00c65af89fc55014250b54559626d075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c65af89fc55014250b54559626d075">&#9670;&#160;</a></span>is_unbounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_unbounded_array_v = <a class="el" href="structetl_1_1is__unbounded__array.html">etl::is_unbounded_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51d4c31d288adf2cb4c5d7fd14c32f00" name="a51d4c31d288adf2cb4c5d7fd14c32f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d4c31d288adf2cb4c5d7fd14c32f00">&#9670;&#160;</a></span>is_union_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_union_v = <a class="el" href="structetl_1_1static__vector.html">__is_union</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bbd05dc09b68b19c63d7b4fbf6f1108" name="a3bbd05dc09b68b19c63d7b4fbf6f1108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbd05dc09b68b19c63d7b4fbf6f1108">&#9670;&#160;</a></span>is_unsigned_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_unsigned_v = <a class="el" href="structetl_1_1is__unsigned.html">etl::is_unsigned</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a149f8ba4063995f2c8ed7248d93a4d9e" name="a149f8ba4063995f2c8ed7248d93a4d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149f8ba4063995f2c8ed7248d93a4d9e">&#9670;&#160;</a></span>is_void_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_void_v = <a class="el" href="#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt;<a class="el" href="structetl_1_1static__vector.html">void</a>, <a class="el" href="#a7d3ea939d0e932fceedbae01d7a3af90">etl::remove_cv_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa76b943cef158f554f60c8d61b6835bc" name="aa76b943cef158f554f60c8d61b6835bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76b943cef158f554f60c8d61b6835bc">&#9670;&#160;</a></span>is_volatile_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::is_volatile_v = <a class="el" href="structetl_1_1is__volatile.html">etl::is_volatile</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e0422e10e238c05956150aa5f4ed77e" name="a2e0422e10e238c05956150aa5f4ed77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0422e10e238c05956150aa5f4ed77e">&#9670;&#160;</a></span>negation_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">B</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">bool</a> etl::negation_v = !<a class="el" href="structetl_1_1static__vector.html">bool</a>(B::value)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4229d4171b460abc833736d622ce9745" name="a4229d4171b460abc833736d622ce9745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4229d4171b460abc833736d622ce9745">&#9670;&#160;</a></span>rank_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">Type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a49823583370a499813db70f494111109">size_t</a> etl::rank_v = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;<a class="el" href="structetl_1_1static__vector.html">Type</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53057a1d7b9d22a69eb3e40fdc44eb3d" name="a53057a1d7b9d22a69eb3e40fdc44eb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53057a1d7b9d22a69eb3e40fdc44eb3d">&#9670;&#160;</a></span>nontype</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">auto</a> V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::nontype = <a class="el" href="structetl_1_1nontype__t.html">etl::nontype_t</a>&lt;<a class="el" href="structetl_1_1static__vector.html">V</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29815251de01b00c45a0bb62678930c5" name="a29815251de01b00c45a0bb62678930c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29815251de01b00c45a0bb62678930c5">&#9670;&#160;</a></span>piecewise_construct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::piecewise_construct = <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constant <a class="el" href="#a29815251de01b00c45a0bb62678930c5" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>. </p>

</div>
</div>
<a id="a28d369052fc23b452882a9fd514abb87" name="a28d369052fc23b452882a9fd514abb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d369052fc23b452882a9fd514abb87">&#9670;&#160;</a></span>variant_npos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::variant_npos = <a class="el" href="structetl_1_1numeric__limits.html">etl::numeric_limits</a>&lt;<a class="el" href="#a49823583370a499813db70f494111109">etl::size_t</a>&gt;<a class="el" href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">::max</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a special value equal to the largest value representable by the type size_t, used as the return value of index() when valueless_by_exception() is true. </p>

</div>
</div>
<a id="a9289432c6100af2ec8b2563959f2c261" name="a9289432c6100af2ec8b2563959f2c261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9289432c6100af2ec8b2563959f2c261">&#9670;&#160;</a></span>variant_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1static__vector.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::variant_size_v = <a class="el" href="structetl_1_1variant__size.html">variant_size</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8047ec1fd97af797afb4226eba8bd80f" name="a8047ec1fd97af797afb4226eba8bd80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8047ec1fd97af797afb4226eba8bd80f">&#9670;&#160;</a></span>current_implementation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::current_implementation = <a class="el" href="#a035e7d2ea0f6aebad724e7fab40495d5aed920a9dd5bae2e1c4f11aab8f5784e1">implementation::freestanding</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb1c600f9a9722bf7bef4af93af1d5ca" name="afb1c600f9a9722bf7bef4af93af1d5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1c600f9a9722bf7bef4af93af1d5ca">&#9670;&#160;</a></span>current_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1static__vector.html">auto</a> etl::current_standard = <a class="el" href="#a2f63a594bf7e2b29cb07e1868483ee53af94629088b2e56f93753526b629a62ff">language_standard::cpp_26</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently configured C++ standard. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
