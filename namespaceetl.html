<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tetl: etl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tetl<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Embedded Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceetl.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">etl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1chrono.html">chrono</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html">chrono_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html">complex_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1execution.html">execution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1meta.html">meta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1numbers.html">numbers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1ranges.html">ranges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1string__view__literals.html">string_view_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1strings.html">strings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swap__no__throw.html">_swap_no_throw</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swappable__with__helper.html">_swappable_with_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1__swappable__with__helper_3_01T_00_01U_00_01void__t_3_01decltype_07swap_07declval_3a85b88c6bbfa63467fd799de16a3d15b.html">_swappable_with_helper&lt; T, U, void_t&lt; decltype(swap(declval&lt; T &gt;(), declval&lt; U &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__const.html">add_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const.  <a href="structetl_1_1add__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__cv.html">add_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile.  <a href="structetl_1_1add__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a lvalue reference type of T.  <a href="structetl_1_1add__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__pointer.html">add_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined.  <a href="structetl_1_1add__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rvalue reference type of T.  <a href="structetl_1_1add__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__volatile.html">add_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile.  <a href="structetl_1_1add__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1adopt__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align. The default value of Align is the most stringent (the largest) alignment requirement for any object whose size is at most Len. If the default value is not used, Align must be the value of alignof(T) for some type T, or the behavior is undefined.  <a href="structetl_1_1aligned__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__union.html">aligned_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitable for use as uninitialized storage for an object of any of the types listed in Types. The size of the storage is at least Len. <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> also determines the strictest (largest) alignment requirement among all Types and makes it available as the constant alignment_value. If sizeof...(Types) == 0 or if any of the types in Types is not a complete object type, the behavior is undefined. It is implementation-defined whether any extended alignment is supported. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1aligned__union.html" title="Provides the nested type type, which is a trivial standard-layout type of a size and alignment suitab...">aligned_union</a> is undefined.  <a href="structetl_1_1aligned__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1alignment__of.html">alignment_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1alignment__of.html" title="alignment_of">alignment_of</a>  <a href="structetl_1_1alignment__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects.  <a href="structetl_1_1allocator__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that encapsulates fixed size arrays.  <a href="structetl_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1assert__msg.html">assert_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Payload for an assertion.  <a href="structetl_1_1assert__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a LegacyOutputIterator that appends to a container for which it was constructed. The container's push_back() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a no-op.  <a href="structetl_1_1back__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__function__call.html">bad_function_call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__optional__access.html">bad_optional_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a type of object to be thrown by etl::optional::value when accessing an optional object that does not contain a value.  <a href="structetl_1_1bad__optional__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bad__variant__access.html">bad_variant_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1bad__variant__access.html" title="etl::bad_variant_access is the type of the exception thrown in the following situations: (1) etl::get...">etl::bad_variant_access</a> is the type of the exception thrown in the following situations: (1) etl::get(etl::variant) called with an index or type that does not match the currently active alternative. (2) etl::visit called to visit a variant that is valueless_by_exception  <a href="structetl_1_1bad__variant__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__bitset.html">basic_bitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__common__reference.html">basic_common_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="structetl_1_1basic__common__reference.html" title="The class template basic_common_reference is a customization point that allows users to influence the...">basic_common_reference</a> is a customization point that allows users to influence the result of <a class="el" href="structetl_1_1common__reference.html" title="Determines the common reference type of the types T..., that is, the type to which all the types in T...">common_reference</a> for user-defined types (typically proxy references). The primary template is empty.  <a href="structetl_1_1basic__common__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__common__reference_3_01pair_3_01T1_00_01T2_01_4_00_01pair_3_01U1_00_01U2_01_4_00_01TQual_00_01UQual_01_4.html">basic_common_reference&lt; pair&lt; T1, T2 &gt;, pair&lt; U1, U2 &gt;, TQual, UQual &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__arg.html">basic_format_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to formatting state consisting of the formatting arguments and the output iterator.  <a href="structetl_1_1basic__format__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1basic__inplace__string.html" title="basic_inplace_string class with fixed size capacity.">basic_inplace_string</a> class with fixed size capacity.  <a href="structetl_1_1basic__inplace__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="structetl_1_1basic__string__view.html" title="The class template basic_string_view describes an object that can refer to a constant contiguous sequ...">basic_string_view</a> describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. A typical implementation holds only two members: a pointer to constant CharType and a size.  <a href="structetl_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bernoulli__distribution.html">bernoulli_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1bidirectional__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1binary__t.html">binary_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and.html">bit_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise AND. Effectively calls <code>operator&amp;</code> on type T.  <a href="structetl_1_1bit__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and_3_01void_01_4.html">bit_and&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not.html">bit_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise NOT. Effectively calls <code>operator~</code> on type T.  <a href="structetl_1_1bit__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not_3_01void_01_4.html">bit_not&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or.html">bit_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise OR. Effectively calls operator| on type T.  <a href="structetl_1_1bit__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or_3_01void_01_4.html">bit_or&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor.html">bit_xor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise XOR. Effectively calls operator^ on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/bit_xor">https://en.cppreference.com/w/cpp/utility/functional/bit_xor</a>.  <a href="structetl_1_1bit__xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor_3_01void_01_4.html">bit_xor&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators.  <a href="structetl_1_1bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits.html">char_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class. The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types. If an operation on traits emits an exception, the behavior is undefined.  <a href="structetl_1_1char__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html">char_traits&lt; char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char.  <a href="structetl_1_1char__traits_3_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01wchar__t_01_4.html">char_traits&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__comparison__category.html">common_comparison_category</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference.html">common_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common reference type of the types T..., that is, the type to which all the types in T... can be converted or bound. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. The behavior is undefined if any of the types in T... is an incomplete type other than (possibly cv-qualified) void.  <a href="structetl_1_1common__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_01T_01_4.html">common_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_01T_00_01U_01_4.html">common_reference&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__reference_3_4.html">common_reference&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type.html">common_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common type among all types <code>T...</code>, that is the type all <code>T...</code> can be implicitly converted to. If such a type exists, the member type names that type. Otherwise, there is no member type.  <a href="structetl_1_1common__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html">common_type&lt; chrono::duration&lt; Rep1, Period1 &gt;, chrono::duration&lt; Rep2, Period2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two etl::chrono::durations, whose period is the greatest common divisor of Period1 and Period2.  <a href="structetl_1_1common__type_3_01chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01chrono_1_1durat4fc2dee09f301ff098a97ea2485d2b03.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html">common_type&lt; chrono::time_point&lt; Clock, Duration1 &gt;, chrono::time_point&lt; Clock, Duration2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two chrono::time_points.  <a href="structetl_1_1common__type_3_01chrono_1_1time__point_3_01Clock_00_01Duration1_01_4_00_01chrono_1_ca83745423d4bfe5bc518c116bc7e175.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T_01_4.html">common_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html">common_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html">common_type&lt; T1, T2, R... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1compare__three__way__result.html">compare_three_way_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1compare__three__way__result_3_01T_00_01U_01_4.html">compare_three_way_result&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1complex.html">complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A complex number.  <a href="structetl_1_1complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional.html">conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.  <a href="structetl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html">conditional&lt; false, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits.  <a href="structetl_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1contiguous__iterator__tag.html">contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1contiguous__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1coroutine__handle.html">coroutine_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1coroutine__handle_3_01void_01_4.html">coroutine_handle&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1coroutine__traits.html">coroutine_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1decay.html">decay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type.  <a href="structetl_1_1decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__accessor.html">default_accessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__delete.html">default_delete</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__delete_3_01T_0f_0e_4.html">default_delete&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1default__searcher.html">default_searcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default searcher. A class suitable for use with Searcher overload of <a class="el" href="group__algorithm.html#gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e">etl::search</a> that delegates the search operation to the pre-C++17 standard library's <a class="el" href="group__algorithm.html#gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e">etl::search</a>.  <a href="structetl_1_1default__searcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1defer__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to identify the destroying delete form of operator delete.  <a href="structetl_1_1destroying__delete__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits.  <a href="structetl_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1div__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides.html">divides</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing division. Effectively calls operator/ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/divides">https://en.cppreference.com/w/cpp/utility/functional/divides</a>.  <a href="structetl_1_1divides.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides_3_01void_01_4.html">divides&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1domain__error.html">domain_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1dynamic__array.html">dynamic_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1empty__c__array.html">empty_c_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html">enable_if&lt; true, Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator== on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/equal_to">https://en.cppreference.com/w/cpp/utility/functional/equal_to</a>.  <a href="structetl_1_1equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to_3_01void_01_4.html">equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1exception.html">exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1expected.html">expected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent.html">extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array type, provides the member constant value equal to the number of elements along the Nth dimension of the array, if N is in [0, rank_v&lt;T&gt;). For any other type, or if T is an array of unknown bound along its first dimension and N is 0, value is 0.  <a href="structetl_1_1extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_010_01_4.html">extent&lt; T[], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0f_0e_00_01N_01_4.html">extent&lt; T[], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_010_01_4.html">extent&lt; T[I], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T_0fI_0e_00_01N_01_4.html">extent&lt; T[I], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extents.html">extents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1flat__set.html">flat_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> is a container adaptor that provides an associative container interface that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves. <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a> supports random access iterators. Any sequence container supporting random access iteration can be used to instantiate <a class="el" href="structetl_1_1flat__set.html" title="A flat_set is a container adaptor that provides an associative container interface that supports uniq...">flat_set</a>.  <a href="structetl_1_1flat__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1format__to__n__result.html" title="etl::format_to_n_result has no base classes, or members other than out, size and implicitly declared ...">etl::format_to_n_result</a> has no base classes, or members other than out, size and implicitly declared special member functions.  <a href="structetl_1_1format__to__n__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter.html">formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enabled specializations of formatter define formatting rules for a given type. Enabled specializations meet the Formatter requirements.  <a href="structetl_1_1formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_01const_01_5_00_01char_01_4.html">formatter&lt; char const *, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_00_01char_01_4.html">formatter&lt; char, char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard specializations for basic type char.  <a href="structetl_1_1formatter_3_01char_00_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01char_0fN_0e_00_01char_01_4.html">formatter&lt; char[N], char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01etl_1_1inplace__string_3_01Capacity_01_4_00_01char_01_4.html">formatter&lt; etl::inplace_string&lt; Capacity &gt;, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01etl_1_1string__view_00_01char_01_4.html">formatter&lt; etl::string_view, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01int_00_01char_01_4.html">formatter&lt; int, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01long_01long_00_01char_01_4.html">formatter&lt; long long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01long_00_01char_01_4.html">formatter&lt; long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01short_00_01char_01_4.html">formatter&lt; short, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_01long_00_01char_01_4.html">formatter&lt; unsigned long long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01long_00_01char_01_4.html">formatter&lt; unsigned long, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_01short_00_01char_01_4.html">formatter&lt; unsigned short, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1formatter_3_01unsigned_00_01char_01_4.html">formatter&lt; unsigned, char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1forward__iterator__tag.html">forward_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1forward__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive numerical input conversion.  <a href="structetl_1_1from__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is an LegacyOutputIterator that prepends elements to a container for which it was constructed. The container's push_front() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> is a no-op.  <a href="structetl_1_1front__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1full__extent__t.html">full_extent_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning view of a callable.  <a href="structetl_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_01noexcept_01_4.html">function_ref&lt; R(Args...) noexcept &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1function__ref_3_01R_07Args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater.html">greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater">https://en.cppreference.com/w/cpp/utility/functional/greater</a>.  <a href="structetl_1_1greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater_3_01void_01_4.html">greater&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal.html">greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/greater_equal">https://en.cppreference.com/w/cpp/utility/functional/greater_equal</a>.  <a href="structetl_1_1greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal_3_01void_01_4.html">greater_equal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1half.html">half</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TriviallyCopyable and if any two objects of type T with the same value have the same object representation, provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1has__unique__object__representations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__virtual__destructor.html">has_virtual_destructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <a href="structetl_1_1has__virtual__destructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash  <a href="structetl_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01bool_01_4.html">hash&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char_01_4.html">hash&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char16__t_01_4.html">hash&lt; char16_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char32__t_01_4.html">hash&lt; char32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01char8__t_01_4.html">hash&lt; char8_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01coroutine__handle_3_01T_01_4_01_4.html">hash&lt; coroutine_handle&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01double_01_4.html">hash&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01etl_1_1nullptr__t_01_4.html">hash&lt; etl::nullptr_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html">hash&lt; etl::optional&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template specialization of <a class="el" href="structetl_1_1hash.html" title="hash">etl::hash</a> for the <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> class allows users to obtain hashes of the values contained in optional objects.  <a href="structetl_1_1hash_3_01etl_1_1optional_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01float_01_4.html">hash&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01int_01_4.html">hash&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01_4.html">hash&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01double_01_4.html">hash&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01long_01long_01_4.html">hash&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01short_01_4.html">hash&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01signed_01char_01_4.html">hash&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01T_01_5_01_4.html">hash&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01char_01_4.html">hash&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01int_01_4.html">hash&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01_4.html">hash&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01long_01long_01_4.html">hash&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01unsigned_01short_01_4.html">hash&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1hash_3_01wchar__t_01_4.html">hash&lt; wchar_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1identity.html" title="etl::identity is a function object type whose operator() returns its argument unchanged.">etl::identity</a> is a function object type whose operator() returns its argument unchanged.  <a href="structetl_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ignore.html">ignore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with <a class="el" href="#a0d1ede89bcd679cdd58f45d98b785cd8">etl::tie</a> when unpacking a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>, as a placeholder for the arguments that are not used.  <a href="structetl_1_1ignore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1imaxdiv__t.html">imaxdiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1imaxdiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <code>optional</code>, <code>variant</code>, and <code>any</code> to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a>, <a class="el" href="structetl_1_1variant.html">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits.html">incrementable_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_5_01_4.html">incrementable_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01_4.html">incrementable_traits&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1incrementable__traits_3_01T_01const_01_4.html">incrementable_traits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits.html">indirectly_readable_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01I_01_4.html">indirectly_readable_traits&lt; I &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_5_01_4.html">indirectly_readable_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01_4.html">indirectly_readable_traits&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1indirectly__readable__traits_3_01T_01const_01_4.html">indirectly_readable_traits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__function_3_01R_07Args_8_8_8_08_00_01Capacity_00_01Alignment_01_4.html">inplace_function&lt; R(Args...), Capacity, Alignment &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__vector.html">inplace_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1inplace__vector_3_01T_00_010_01_4.html">inplace_vector&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1input__iterator__tag.html">input_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1input__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integer__sequence.html">integer_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1invalid__argument.html">invalid_argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1invoke__result.html">invoke_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the return type of an INVOKE expression at compile time.  <a href="structetl_1_1invoke__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__abstract.html">is_abstract</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__aggregate.html">is_aggregate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined.  <a href="structetl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false.  <a href="structetl_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T_0f_0e_4.html">is_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T_0fN_0e_4.html">is_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__assignable.html">is_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval&lt;T&gt;()</a> = <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__base__of.html">is_base_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of known bound. Provides the member constant value which is equal to true, if T is an array type of known bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__bounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array_3_01T_0fN_0e_4.html">is_bounded_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__integer.html">is_builtin_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__signed__integer.html">is_builtin_signed_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__builtin__unsigned__integer.html">is_builtin_unsigned_integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if T is <code>unsigned char</code> or <code>unsigned short</code> or <code>unsigned int</code> or <code>unsigned long</code> or <code>unsigned long long</code>  <a href="structetl_1_1is__builtin__unsigned__integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__class.html">is_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__compound.html">is_compound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__compound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const.html">is_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const_3_01T_01const_01_4.html">is_const&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the imaginary function definition <code>To test() { return <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a>&lt;From&gt;(); }</code> is well-formed, (that is, either <code><a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a>&lt;From&gt;()</code> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <code><a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a></code> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered.  <a href="structetl_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_constructible&lt;T, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible.html">is_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.  <a href="structetl_1_1is__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01Type_0f_0e_4.html">is_destructible&lt; Type[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01void_01_4.html">is_destructible&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__empty.html">is_empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f T is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__enum.html">is_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum.html">is_error_condition_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum_3_01errc_01_4.html">is_error_condition_enum&lt; errc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__execution__policy.html">is_execution_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a standard or implementation-defined execution policy type.  <a href="structetl_1_1is__execution__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__execution__policy_3_01etl_1_1execution_1_1sequenced__policy_01_4.html">is_execution_policy&lt; etl::execution::sequenced_policy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__execution__policy_3_01etl_1_1execution_1_1unsequenced__policy_01_4.html">is_execution_policy&lt; etl::execution::unsequenced_policy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__final.html">is_final</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a final class (that is, a class declared with the final specifier), provides the member constant value equal true. For any other type, value is false. If T is a class type, T shall be a complete type; otherwise, the behavior is undefined.  <a href="structetl_1_1is__final.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false.  <a href="structetl_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__function.html">is_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a fundamental type (that is, arithmetic type, void, or nullptr_t), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__fundamental.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_374fbed591f2848368bdbdd39f8c8e31.html">is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), false_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__implicit__default__constructible_3_01T_00_01decltype_07test__implicit__default_63505ad1d5845f9b40fca2dabe8d3bef.html">is_implicit_default_constructible&lt; T, decltype(test_implicit_default_constructible&lt; T const &amp; &gt;({})), true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__integral.html">is_integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__invocable.html">is_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a lvalue reference type. Provides the member constant value which is equal to true, if T is a lvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference_3_01T_01_6_01_4.html">is_lvalue_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__object__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function,...">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined.  <a href="structetl_1_1is__member__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval&lt;T&gt;()</a> = <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__nothrow__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable_3_01T_00_01U_01_4.html">is_nothrow_assignable&lt; T, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__nothrow__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__convertible_3_01From_00_01To_01_4.html">is_nothrow_convertible&lt; From, To &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_nothrow_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_nothrow_constructible&lt;T, T const&amp;&gt;.  <a href="structetl_1_1is__nothrow__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__nothrow__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__nothrow__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_01_4.html">is_nothrow_destructible&lt; Type &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_6_01_4.html">is_nothrow_destructible&lt; Type &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_0fN_0e_4.html">is_nothrow_destructible&lt; Type[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable__with.html">is_nothrow_swappable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__object.html">is_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_placeholder&lt; detail::placeholder_type&lt; N &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01_4.html">is_placeholder&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01const_01volatile_01_4.html">is_placeholder&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__placeholder_3_01T_01volatile_01_4.html">is_placeholder&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__polymorphic.html">is_polymorphic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference.html">is_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type (lvalue reference or rvalue reference), provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__reference.html" title="If T is a reference type (lvalue reference or rvalue reference), provides the member constant value e...">is_reference</a> or is_reference_v is undefined.  <a href="structetl_1_1is__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html">is_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html">is_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference__wrapper_3_01reference__wrapper_3_01U_01_4_01_4.html">is_reference_wrapper&lt; reference_wrapper&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a rvalue reference type. Provides the member constant value which is equal to true, if T is a rvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference_3_01T_01_6_6_01_4.html">is_rvalue_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scoped__enum_3_01T_01_4.html">is_scoped_enum&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__signed.html">is_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false.  <a href="structetl_1_1is__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__specialized.html">is_specialized</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__specialized_3_01Template_00_01T_00_01void__t_3_01decltype_07Template_3_01T_01_4_02_03_08_4_01_4.html">is_specialized&lt; Template, T, void_t&lt; decltype(Template&lt; T &gt;{})&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__standard__layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable.html">is_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_swappable_with&lt;T&amp;, T&amp;&gt;::value</a>.  <a href="structetl_1_1is__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivial.html">is_trivial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TrivialType (that is, a scalar type, a trivially copyable class with a trivial default constructor, or array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__trivial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval&lt;T&gt;()</a> = <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__trivially__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__trivially__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_trivially_assignable&lt;T&amp;, T const&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_trivially_constructible&lt;T, T const&amp;&gt;.  <a href="structetl_1_1is__trivially__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copyable.html">is_trivially_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a TriviallyCopyable type, provides the member constant value equal to true. For any other type, value is false. The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly cv-qualified). group is_trivial_copyable.  <a href="structetl_1_1is__trivially__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__trivially__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__destructible.html">is_trivially_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage occupied by trivially destructible objects may be reused without calling the destructor.  <a href="structetl_1_1is__trivially__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#a9aa864e6c9ea467ce3878df4ca8e8571">etl::is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__typename.html">is_typename</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of unknown bound. Provides the member constant value which is equal to true, if T is an array type of unknown bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__unbounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array_3_01T_0f_0e_4.html">is_unbounded_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__union.html">is_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined.  <a href="structetl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__void.html">is_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile.html">is_volatile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile_3_01T_01volatile_01_4.html">is_volatile&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1iterator__traits.html" title="iterator_traits is the type trait class that provides uniform interface to the properties of LegacyIt...">iterator_traits</a> is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators.  <a href="structetl_1_1iterator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits_3_01T_01_5_01_4.html">iterator_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__left.html">layout_left</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__right.html">layout_right</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1layout__stride.html">layout_stride</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1ldiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1length__error.html">length_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less.html">less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less">https://en.cppreference.com/w/cpp/utility/functional/less</a>.  <a href="structetl_1_1less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less_3_01void_01_4.html">less&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal.html">less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/less_equal">https://en.cppreference.com/w/cpp/utility/functional/less_equal</a>.  <a href="structetl_1_1less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal_3_01void_01_4.html">less_equal&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for div, ldiv, lldiv &amp; imaxdiv.  <a href="structetl_1_1lldiv__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1lock__guard.html">lock_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block. When a <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> object was created, the <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> is destructed and the mutex is released. The <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">lock_guard</a> struct is non-copyable.  <a href="structetl_1_1lock__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logic__error.html">logic_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and.html">logical_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_and">https://en.cppreference.com/w/cpp/utility/functional/logical_and</a>.  <a href="structetl_1_1logical__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and_3_01void_01_4.html">logical_and&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not.html">logical_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_not">https://en.cppreference.com/w/cpp/utility/functional/logical_not</a>.  <a href="structetl_1_1logical__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not_3_01void_01_4.html">logical_not&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or.html">logical_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/logical_or">https://en.cppreference.com/w/cpp/utility/functional/logical_or</a>.  <a href="structetl_1_1logical__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or_3_01void_01_4.html">logical_or&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__signed.html">make_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__signed.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_signed</a> is undefined.  <a href="structetl_1_1make__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined.  <a href="structetl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1max__align__t.html">max_align_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1max__align__t.html" title="etl::max_align_t is a trivial standard-layout type whose alignment requirement is at least as strict ...">etl::max_align_t</a> is a trivial standard-layout type whose alignment requirement is at least as strict (as large) as that of every scalar type.  <a href="structetl_1_1max__align__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1mdarray.html">mdarray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1mdspan.html">mdspan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus.html">minus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing subtraction. Effectively calls operator- on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/minus">https://en.cppreference.com/w/cpp/utility/functional/minus</a>.  <a href="structetl_1_1minus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus_3_01void_01_4.html">minus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus.html">modulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for computing remainders of divisions. Implements operator% for type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/modulus">https://en.cppreference.com/w/cpp/utility/functional/modulus</a>.  <a href="structetl_1_1modulus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus_3_01void_01_4.html">modulus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit type intended for use as a well-behaved empty alternative in <a class="el" href="structetl_1_1variant.html">etl::variant</a>. In particular, a variant of non-default-constructible types may list <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular,...">etl::monostate</a> as its first alternative: this makes the variant itself default-constructible.  <a href="structetl_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monotonic__allocator.html">monotonic_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies.html">multiplies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing multiplication. Effectively calls operator* on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/multiplies">https://en.cppreference.com/w/cpp/utility/functional/multiplies</a>.  <a href="structetl_1_1multiplies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies_3_01void_01_4.html">multiplies&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate.html">negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing negation. Effectively calls operator- on an instance of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/negate">https://en.cppreference.com/w/cpp/utility/functional/negate</a>.  <a href="structetl_1_1negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate_3_01void_01_4.html">negate&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical negation of the type trait B.  <a href="structetl_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nontype__t.html">nontype_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to.html">not_equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator!= on type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/not_equal_to">https://en.cppreference.com/w/cpp/utility/functional/not_equal_to</a>.  <a href="structetl_1_1not__equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to_3_01void_01_4.html">not_equal_to&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nothrow__t.html">nothrow_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> is an empty class type used to disambiguate the overloads of throwing and non-throwing allocation functions.  <a href="structetl_1_1nothrow__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">etl::nullopt_t</a> is an empty class type used to indicate optional type with uninitialized state. In particular, <a class="el" href="structetl_1_1optional.html" title="The class template optional manages an optional contained value, i.e. a value that may or may not be ...">etl::optional</a> has a constructor with <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state....">nullopt_t</a> as a single argument, which creates an optional that does not contain a value.  <a href="structetl_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01bool_01_4.html">numeric_limits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01char_01_4.html">numeric_limits&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01char8__t_01_4.html">numeric_limits&lt; char8_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01double_01_4.html">numeric_limits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01float_01_4.html">numeric_limits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01int_01_4.html">numeric_limits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01_4.html">numeric_limits&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01double_01_4.html">numeric_limits&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01long_01long_01_4.html">numeric_limits&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01short_01_4.html">numeric_limits&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01signed_01char_01_4.html">numeric_limits&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01_4.html">numeric_limits&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01const_01volatile_01_4.html">numeric_limits&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01T_01volatile_01_4.html">numeric_limits&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01char_01_4.html">numeric_limits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01int_01_4.html">numeric_limits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01long_01_4.html">numeric_limits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01long_01long_01_4.html">numeric_limits&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1numeric__limits_3_01unsigned_01short_01_4.html">numeric_limits&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template optional manages an optional contained value, i.e. a value that may or may not be present.  <a href="structetl_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1optional_3_01T_01_6_01_4.html">optional&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1out__of__range.html">out_of_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1output__iterator__tag.html">output_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1output__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overflow__error.html">overflow_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1overload.html">overload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a> with two elements. If neither T1 nor T2 is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of pair is trivial.  <a href="structetl_1_1pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a> is an empty class tag type used to disambiguate between different functions that take two tuple arguments.  <a href="structetl_1_1piecewise__construct__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus.html">plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing addition. Effectively calls operator+ on two instances of type T. <a href="https://en.cppreference.com/w/cpp/utility/functional/plus">https://en.cppreference.com/w/cpp/utility/functional/plus</a>.  <a href="structetl_1_1plus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus_3_01void_01_4.html">plus&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__int__pair.html">pointer_int_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct implements a pair of a pointer and small integer. It is designed to represent this in the space required by one pointer by bitmangling the integer into the low part of the pointer. This can only be done for small integers: typically up to 3 bits, but it depends on the number of bits available according to <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for the type.  <a href="structetl_1_1pointer__int__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__int__pair__info.html">pointer_int_pair_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits.html">pointer_like_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits type that is used to handle pointer types and things that are just wrappers for pointers as a uniform entity.  <a href="structetl_1_1pointer__like__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01pointer__int__pair_3_01PtrT_00_01IntBits_00_01IntT_00_01PtrTraits_01_4_01_4.html">pointer_like_traits&lt; pointer_int_pair&lt; PtrT, IntBits, IntT, PtrTraits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html">pointer_like_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for non-cvr pointers.  <a href="structetl_1_1pointer__like__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html">pointer_like_traits&lt; T const * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const pointers.  <a href="structetl_1_1pointer__like__traits_3_01T_01const_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html">pointer_like_traits&lt; T const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for const things.  <a href="structetl_1_1pointer__like__traits_3_01T_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html">pointer_like_traits&lt; uintptr_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide <a class="el" href="structetl_1_1pointer__like__traits.html" title="A traits type that is used to handle pointer types and things that are just wrappers for pointers as ...">pointer_like_traits</a> for uintptr_t.  <a href="structetl_1_1pointer__like__traits_3_01uintptr__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__traits.html">pointer_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types.  <a href="structetl_1_1pointer__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html">pointer_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1pointer__traits.html" title="The pointer_traits class template provides the standardized way to access certain properties of point...">pointer_traits</a> class template provides the standardized way to access certain properties of pointer-like types.  <a href="structetl_1_1pointer__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1random__access__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1range__error.html">range_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank.html">rank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined.  <a href="structetl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T_0f_0e_4.html">rank&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T_0fN_0e_4.html">rank&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The typename template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t.  <a href="structetl_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less.html">ratio_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__not__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">etl::static_vector</a>) which cannot normally hold references. Specifically, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is a CopyConstructible and CopyAssignable wrapper around a reference to object or reference to function of type T. Instances of <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> are objects (they can be copied or stored in containers) but they are implicitly convertible to T&amp;, so that they can be used as arguments with the functions that take the underlying type by reference. If the stored reference is Callable, <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a> is callable with the same arguments.  <a href="structetl_1_1reference__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X,...">remove_all_extents</a> is undefined.  <a href="structetl_1_1remove__all__extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T_0f_0e_4.html">remove_all_extents&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T_0fN_0e_4.html">remove_all_extents&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const.html">remove_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const.  <a href="structetl_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html">remove_const&lt; Type const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present.  <a href="structetl_1_1remove__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type T is a reference type, provides the member typedef type which is the type referred to by T with its topmost cv-qualifiers removed. Otherwise type is T with its topmost cv-qualifiers removed.  <a href="structetl_1_1remove__cvref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent.html">remove_extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T....">remove_extent</a> is undefined.  <a href="structetl_1_1remove__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T_0f_0e_4.html">remove_extent&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T_0fN_0e_4.html">remove_extent&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer, then type is the same as T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__pointer.html" title="Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer,...">remove_pointer</a> is undefined.  <a href="structetl_1_1remove__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5_01_4.html">remove_pointer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01_4.html">remove_pointer&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01volatile_01_4.html">remove_pointer&lt; T *const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5volatile_01_4.html">remove_pointer&lt; T *volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html">remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html">remove_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile.  <a href="structetl_1_1remove__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html">remove_volatile&lt; Type volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a> is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, <code><a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">reverse_iterator</a></code> produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator. This is the iterator returned by member functions <code><a class="el" href="group__iterator.html#gaef0e9ff3b7516f90525a93acb5fccc8e" title="Returns an iterator to the reverse-beginning of the given container.">rbegin()</a></code> and <code><a class="el" href="group__iterator.html#gab55d22696b4d22653a103d0726157a18" title="Returns an iterator to the reverse-end of the given container.">rend()</a></code> of the standard library containers.  <a href="structetl_1_1reverse__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1runtime__error.html">runtime_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1scope__exit.html">scope_exit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <code><a class="el" href="structetl_1_1scope__exit.html" title="The class template scope_exit is a general-purpose scope guard intended to call its exit function whe...">scope_exit</a></code> is a general-purpose scope guard intended to call its exit function when a scope is exited.  <a href="structetl_1_1scope__exit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1small__ptr.html">small_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed pointer to specified size. Intended to be used as a drop in replacement for native pointers.  <a href="structetl_1_1small__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1source__location.html">source_location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing information about the source code, such as file names, line numbers, and function names.  <a href="structetl_1_1source__location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning view over a contiguous sequence of objects.  <a href="structetl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1stack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stack class is a container adapter that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.  <a href="structetl_1_1stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__set.html">static_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1static__set.html" title="static_set is an associative container that contains a sorted set of unique objects of type Key....">static_set</a> is an associative container that contains a sorted set of unique objects of type Key. Sorting is done using the key comparison function Compare.  <a href="structetl_1_1static__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically-resizable fixed-capacity vector.  <a href="structetl_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1strided__slice.html">strided_slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1string__constant.html">string_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1strong__ordering.html">strong_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1submdspan__mapping__result.html">submdspan_mapping_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1suspend__always.html">suspend_always</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1suspend__never.html">suspend_never</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1timespec.html">timespec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tm.html">tm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive numerical output conversion.  <a href="structetl_1_1to__chars__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag types used to specify locking strategy for <a class="el" href="structetl_1_1lock__guard.html" title="The struct lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a...">etl::lock_guard</a>, etl::scoped_lock, <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">etl::unique_lock</a>, and etl::shared_lock.  <a href="structetl_1_1try__to__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element.html">tuple_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface.  <a href="structetl_1_1tuple__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01array_3_01T_00_01N_01_4_01_4.html">tuple_element&lt; I, array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01etl_1_1complex_3_01T_01_4_01_4.html">tuple_element&lt; I, etl::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_element&lt; I, pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specializations of <a class="el" href="structetl_1_1tuple__element.html" title="Provides compile-time indexed access to the type of the elements of the array using tuple-like interf...">tuple_element</a> for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if I &gt;= 2.  <a href="structetl_1_1tuple__element_3_01I_00_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01_4.html">tuple_element&lt; I, T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01const_01volatile_01_4.html">tuple_element&lt; I, T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01T_01volatile_01_4.html">tuple_element&lt; I, T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01tuple_3_01Ts_8_8_8_01_4_01_4.html">tuple_element&lt; I, tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size.html">tuple_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html">tuple_size&lt; array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the number of elements in an array as a compile-time constant expression.  <a href="structetl_1_1tuple__size_3_01array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1complex_3_01T_01_4_01_4.html">tuple_size&lt; etl::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_size&lt; pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The partial specialization of <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a> for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.  <a href="structetl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01_4.html">tuple_size&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01const_01volatile_01_4.html">tuple_size&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01T_01volatile_01_4.html">tuple_size&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01tuple_3_01Ts_8_8_8_01_4_01_4.html">tuple_size&lt; tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1underflow__error.html">underflow_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1underlying__type.html">underlying_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type of an enum.  <a href="structetl_1_1underlying__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unexpect__t.html">unexpect_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unexpected.html">unexpected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uniform__int__distribution.html">uniform_int_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uniform__real__distribution.html">uniform_real_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__array.html">uninitialized_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__array_3_01T_00_01Size_01_4.html">uninitialized_array&lt; T, Size &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uninitialized__union.html">uninitialized_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unique__lock.html">unique_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct <a class="el" href="structetl_1_1unique__lock.html" title="The struct unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a> is a general-purpose mutex ownership wrapper allowing deferred locking, time-constrained attempts at locking, recursive locking, transfer of lock ownership, and use with condition variables.  <a href="structetl_1_1unique__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__ref__decay.html">unwrap_ref_decay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__reference.html">unwrap_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1unwrap__reference_3_01reference__wrapper_3_01T_01_4_01_4.html">unwrap_reference&lt; reference_wrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false.  <a href="structetl_1_1uses__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionetl_1_1variadic__union.html">variadic_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionetl_1_1variadic__union_3_01T_00_01Ts_8_8_8_01_4.html">variadic_union&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant.html">variant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.  <a href="structetl_1_1variant__alternative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01_4.html">variant_alternative&lt; Idx, T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01const_01volatile_01_4.html">variant_alternative&lt; Idx, T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01T_01volatile_01_4.html">variant_alternative&lt; Idx, T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01Idx_00_01variant_3_01Ts_8_8_8_01_4_01_4.html">variant_alternative&lt; Idx, variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size.html">variant_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01const_01_4.html">variant_size&lt; T const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01const_01volatile_01_4.html">variant_size&lt; T const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01T_01volatile_01_4.html">variant_size&lt; T volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__size_3_01variant_3_01Ts_8_8_8_01_4_01_4.html">variant_size&lt; variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1weak__ordering.html">weak_ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xorshift.html">xorshift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>  <a href="structetl_1_1xorshift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128plus.html">xoshiro128plus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128plusplus.html">xoshiro128plusplus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1xoshiro128starstar.html">xoshiro128starstar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1bitmask__type.html">bitmask_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1three__way__comparable.html">three_way_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1assignable__from.html">assignable_from</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1boolean__testable.html">boolean_testable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__integer.html">builtin_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__signed__integer.html">builtin_signed_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">builtin_unsigned_integer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1common__reference__with.html">common_reference_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1common__with.html">common_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1constructible__from.html">constructible_from</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructible_from concept specifies that a variable of type T can be initialized with the given set of argument types Args.... <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1convertible__to.html">convertible_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept convertible_to&lt;From, To&gt; specifies that an expression of the same type and value category as those of declval&lt;From&gt;() can be implicitly and explicitly converted to the type To, and the two forms of conversion are equivalent. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1copy__constructible.html">copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept copy_constructible is satisfied if T is an lvalue reference type, or if it is a move_constructible object type where an object of that type can constructed from a (possibly const) lvalue or const rvalue of that type in both direct- and copy-initialization contexts with the usual semantics (a copy is constructed with the source unchanged). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1copyable.html">copyable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1default__initializable.html">default_initializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default_initializable concept checks whether variables of type T can be value-initialized (T() is well-formed); direct-list-initialized from an empty initializer list (T{} is well-formed); and default-initialized (T t; is well-formed). Access checking is performed as if in a context unrelated to T. Only the validity of the immediate context of the variable initialization is considered. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1derived__from.html">derived_from</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept derived_from&lt;Derived, Base&gt; is satisfied if and only if Base is a class type that is either Derived or a public and unambiguous base of Derived, ignoring cv-qualifiers. Note that this behaviour is different to is_base_of when Base is a private or protected base of Derived. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1destructible.html">destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept destructible specifies the concept of all types whose instances can safely be destroyed at the end of their lifetime (including reference types). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1equality__comparable.html">equality_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1equivalence__relation.html">equivalence_relation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1floating__point.html">floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept floating_point&lt;T&gt; is satisfied if and only if T is a floating-point type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1integral.html">integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept integral&lt;T&gt; is satisfied if and only if T is an integral type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1invocable.html">invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1movable.html">movable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1move__constructible.html">move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept move_constructible is satisfied if T is a reference type, or if it is an object type where an object of that type can be constructed from an rvalue of that type in both direct- and copy-initialization contexts, with the usual semantics. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1predicate.html">predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1referenceable.html">referenceable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1regular.html">regular</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1regular__invocable.html">regular_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1relation.html">relation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1same__as.html">same_as</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept same_as&lt;T, U&gt; is satisfied if and only if T and U denote the same type. same_as&lt;T, U&gt; subsumes same_as&lt;U, T&gt; and vice versa. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1semiregular.html">semiregular</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1signed__integral.html">signed_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept signed_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_signed_v&lt;T&gt; is true. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1strict__weak__order.html">strict_weak_order</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1swappable.html">swappable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1unsigned__integral.html">unsigned_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept unsigned_integral&lt;T&gt; is satisfied if and only if T is an integral type and is_unsigned_v&lt;T&gt; is true. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1weakly__equality__comparable__with.html">weakly_equality_comparable_with</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1execution__policy.html">execution_policy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1incrementable.html">incrementable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__readable.html">indirectly_readable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__regular__unary__invocable.html">indirectly_regular_unary_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1indirectly__unary__invocable.html">indirectly_unary_invocable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1input__or__output__iterator.html">input_or_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__bidirectional__iterator.html">legacy_bidirectional_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__forward__iterator.html">legacy_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__input__iterator.html">legacy_input_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1legacy__iterator.html">legacy_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1sentinel__for.html">sentinel_for</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1weakly__incrementable.html">weakly_incrementable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1pair__like.html">pair_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptetl_1_1tuple__like.html">tuple_like</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae1bfcd9586bbb9936d7eb2d2ea32bc8e" id="r_ae1bfcd9586bbb9936d7eb2d2ea32bc8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Len, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Align = alignof(detail::aligned_storage_impl&lt;Len&gt;)&gt; </td></tr>
<tr class="memitem:ae1bfcd9586bbb9936d7eb2d2ea32bc8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae1bfcd9586bbb9936d7eb2d2ea32bc8e">aligned_storage_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a>&lt;<a class="el" href="structetl_1_1bitset.html">Len</a>, <a class="el" href="structetl_1_1bitset.html">Align</a>&gt;::type</td></tr>
<tr class="separator:ae1bfcd9586bbb9936d7eb2d2ea32bc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5f392ace63d0a89352f050a2104edc" id="r_aaf5f392ace63d0a89352f050a2104edc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Len, typename... Types&gt; </td></tr>
<tr class="memitem:aaf5f392ace63d0a89352f050a2104edc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf5f392ace63d0a89352f050a2104edc">aligned_union_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1aligned__union.html">aligned_union</a>&lt;<a class="el" href="structetl_1_1bitset.html">Len</a>, Types...&gt;::type</td></tr>
<tr class="separator:aaf5f392ace63d0a89352f050a2104edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c90336c94cb0db8abdd10603a3c7cc" id="r_ac5c90336c94cb0db8abdd10603a3c7cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">bool</a> B&gt; </td></tr>
<tr class="memitem:ac5c90336c94cb0db8abdd10603a3c7cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">bool</a>, <a class="el" href="structetl_1_1bitset.html">B</a>&gt;</td></tr>
<tr class="separator:ac5c90336c94cb0db8abdd10603a3c7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1693d67d03475372752f9e6973d67a8d" id="r_ga1693d67d03475372752f9e6973d67a8d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ValueType</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:ga1693d67d03475372752f9e6973d67a8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array.html#ga1693d67d03475372752f9e6973d67a8d">c_array</a> = <a class="el" href="structetl_1_1bitset.html">ValueType</a>[<a class="el" href="structetl_1_1bitset.html">Size</a>]</td></tr>
<tr class="separator:ga1693d67d03475372752f9e6973d67a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cb041233ab00ef4358f99afedca8d0" id="r_a78cb041233ab00ef4358f99afedca8d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78cb041233ab00ef4358f99afedca8d0">clock_t</a> = <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="separator:a78cb041233ab00ef4358f99afedca8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1164daef675b01dddc89c2b7c28d80" id="r_afe1164daef675b01dddc89c2b7c28d80"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:afe1164daef675b01dddc89c2b7c28d80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe1164daef675b01dddc89c2b7c28d80">common_reference_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1common__reference.html">common_reference</a>&lt;T...&gt;::type</td></tr>
<tr class="separator:afe1164daef675b01dddc89c2b7c28d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f7a81113943dc723a4e4751c342144" id="r_ac0f7a81113943dc723a4e4751c342144"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ac0f7a81113943dc723a4e4751c342144"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0f7a81113943dc723a4e4751c342144">common_type_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1common__type.html">common_type</a>&lt;T...&gt;::type</td></tr>
<tr class="separator:ac0f7a81113943dc723a4e4751c342144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b715f3a9d55a158e1659f797689b0c" id="r_ga08b715f3a9d55a158e1659f797689b0c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U  = T&gt; </td></tr>
<tr class="memitem:ga08b715f3a9d55a158e1659f797689b0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compare.html#ga08b715f3a9d55a158e1659f797689b0c">compare_three_way_result_t</a> = <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a>&lt;<a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">etl::remove_reference_t</a>&lt;T&gt; <a class="el" href="structetl_1_1bitset.html">const</a>&amp;&gt;() &lt;=&gt; <a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a>&lt;<a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">etl::remove_reference_t</a>&lt;U&gt; <a class="el" href="structetl_1_1bitset.html">const</a>&amp;&gt;())</td></tr>
<tr class="separator:ga08b715f3a9d55a158e1659f797689b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d091a01d0f719c0e795ed347e18a6d" id="r_a09d091a01d0f719c0e795ed347e18a6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">bool</a> B, <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> &gt; </td></tr>
<tr class="memitem:a09d091a01d0f719c0e795ed347e18a6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09d091a01d0f719c0e795ed347e18a6d">conditional_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1conditional.html">conditional</a>&lt;<a class="el" href="structetl_1_1bitset.html">B</a>, T, <a class="el" href="structetl_1_1bitset.html">F</a>&gt;::type</td></tr>
<tr class="separator:a09d091a01d0f719c0e795ed347e18a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f3c9ab2c53f9192c2899fc8efb263d" id="r_a24f3c9ab2c53f9192c2899fc8efb263d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a24f3c9ab2c53f9192c2899fc8efb263d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a24f3c9ab2c53f9192c2899fc8efb263d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53bcc0a66170293af1f9319d4663d1a" id="r_ac53bcc0a66170293af1f9319d4663d1a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">IndexType</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Rank&gt; </td></tr>
<tr class="memitem:ac53bcc0a66170293af1f9319d4663d1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac53bcc0a66170293af1f9319d4663d1a">dextents</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> detail::dextents_impl&lt;<a class="el" href="structetl_1_1bitset.html">IndexType</a>, <a class="el" href="#a3c526d8179a55ec15611d7627272e067">etl::make_index_sequence</a>&lt;<a class="el" href="structetl_1_1bitset.html">Rank</a>&gt;&gt;::type</td></tr>
<tr class="separator:ac53bcc0a66170293af1f9319d4663d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dfe0d6b5c463f72f72a6bf14e21b0f" id="r_a05dfe0d6b5c463f72f72a6bf14e21b0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; </td></tr>
<tr class="memitem:a05dfe0d6b5c463f72f72a6bf14e21b0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">diff_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;<a class="el" href="#a13534b69c91b07e4add5cea854cfedd8">etl::remove_cvref_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Iter</a>&gt;&gt;::difference_type</td></tr>
<tr class="separator:a05dfe0d6b5c463f72f72a6bf14e21b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0daa9c087aab901d5a05c155b62581" id="r_ga8b0daa9c087aab901d5a05c155b62581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8b0daa9c087aab901d5a05c155b62581">double_t</a> = <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga8b0daa9c087aab901d5a05c155b62581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as double.  <br /></td></tr>
<tr class="separator:ga8b0daa9c087aab901d5a05c155b62581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e9cb7fadbcfaa2afb5b94058b8e34c" id="r_a93e9cb7fadbcfaa2afb5b94058b8e34c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">bool</a> B, <a class="el" href="structetl_1_1bitset.html">typename</a> T  = void&gt; </td></tr>
<tr class="memitem:a93e9cb7fadbcfaa2afb5b94058b8e34c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structetl_1_1bitset.html">B</a>, T&gt;::type</td></tr>
<tr class="separator:a93e9cb7fadbcfaa2afb5b94058b8e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15d3ff5d80b8c8c22e9ce862353ba55" id="r_ad15d3ff5d80b8c8c22e9ce862353ba55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad15d3ff5d80b8c8c22e9ce862353ba55">false_type</a> = <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">false</a>&gt;</td></tr>
<tr class="separator:ad15d3ff5d80b8c8c22e9ce862353ba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef34e23d4cca9aba8d78eeb0ae8fcd2e" id="r_gaef34e23d4cca9aba8d78eeb0ae8fcd2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaef34e23d4cca9aba8d78eeb0ae8fcd2e">float_t</a> = <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:gaef34e23d4cca9aba8d78eeb0ae8fcd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as float.  <br /></td></tr>
<tr class="separator:gaef34e23d4cca9aba8d78eeb0ae8fcd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8c737296655b44480da4fb422add24" id="r_abd8c737296655b44480da4fb422add24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd8c737296655b44480da4fb422add24">format_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">format_context</a>&gt;</td></tr>
<tr class="separator:abd8c737296655b44480da4fb422add24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadb6bf7ddccdb7fc0a95da5b0b911ef" id="r_afadb6bf7ddccdb7fc0a95da5b0b911ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">format_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1bitset.html">char</a>&gt;&gt;, <a class="el" href="structetl_1_1bitset.html">char</a>&gt;</td></tr>
<tr class="memdesc:afadb6bf7ddccdb7fc0a95da5b0b911ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to formatting state consisting of the formatting arguments and the output iterator.  <br /></td></tr>
<tr class="separator:afadb6bf7ddccdb7fc0a95da5b0b911ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f31f076b2eb408741895533f9222baa" id="r_a7f31f076b2eb408741895533f9222baa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f31f076b2eb408741895533f9222baa">format_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>&gt;</td></tr>
<tr class="separator:a7f31f076b2eb408741895533f9222baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a828fb91283babdb0eef8e0d9010cb" id="r_a56a828fb91283babdb0eef8e0d9010cb"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a56a828fb91283babdb0eef8e0d9010cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56a828fb91283babdb0eef8e0d9010cb">format_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>, <a class="el" href="group__type__traits.html#gaca42c1976d1b12998afcabf8f39e8c23">type_identity_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Args</a>&gt;...&gt;</td></tr>
<tr class="separator:a56a828fb91283babdb0eef8e0d9010cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc29a848c78949599ea12f9b9827fd3" id="r_a0fc29a848c78949599ea12f9b9827fd3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I&gt; </td></tr>
<tr class="memitem:a0fc29a848c78949599ea12f9b9827fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0fc29a848c78949599ea12f9b9827fd3">index_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, <a class="el" href="structetl_1_1bitset.html">I</a>&gt;</td></tr>
<tr class="separator:a0fc29a848c78949599ea12f9b9827fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c41ad6b9af06544b52833e235bb14dd" id="r_a6c41ad6b9af06544b52833e235bb14dd"><td class="memTemplParams" colspan="2">template&lt;etl::size_t... Ints&gt; </td></tr>
<tr class="memitem:a6c41ad6b9af06544b52833e235bb14dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c41ad6b9af06544b52833e235bb14dd">index_sequence</a> = <a class="el" href="structetl_1_1integer__sequence.html">etl::integer_sequence</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, Ints...&gt;</td></tr>
<tr class="separator:a6c41ad6b9af06544b52833e235bb14dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26496b89801597f0e24f146bc25bb3ca" id="r_a26496b89801597f0e24f146bc25bb3ca"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a26496b89801597f0e24f146bc25bb3ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26496b89801597f0e24f146bc25bb3ca">index_sequence_for</a> = <a class="el" href="#a3c526d8179a55ec15611d7627272e067">etl::make_index_sequence</a>&lt;sizeof...(T)&gt;</td></tr>
<tr class="separator:a26496b89801597f0e24f146bc25bb3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad753b7ec242604e8139a352b4d049398" id="r_gad753b7ec242604e8139a352b4d049398"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> , typename... Iters&gt; </td></tr>
<tr class="memitem:gad753b7ec242604e8139a352b4d049398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gad753b7ec242604e8139a352b4d049398">indirect_result_t</a> = etl::invoke_result_t&lt;<a class="el" href="structetl_1_1bitset.html">F</a>, <a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">etl::iter_reference_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Iters</a>&gt;...&gt;</td></tr>
<tr class="separator:gad753b7ec242604e8139a352b4d049398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a7ab76e5b59bba68d1362a0cbff96c" id="r_ad8a7ab76e5b59bba68d1362a0cbff96c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ad8a7ab76e5b59bba68d1362a0cbff96c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">inplace_string</a> = <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;</td></tr>
<tr class="memdesc:ad8a7ab76e5b59bba68d1362a0cbff96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="structetl_1_1basic__inplace__string.html" title="basic_inplace_string class with fixed size capacity.">basic_inplace_string</a> using 'char'.  <br /></td></tr>
<tr class="separator:ad8a7ab76e5b59bba68d1362a0cbff96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4d364842c4ff48aed1de99ba3cf122" id="r_a9e4d364842c4ff48aed1de99ba3cf122"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a9e4d364842c4ff48aed1de99ba3cf122"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e4d364842c4ff48aed1de99ba3cf122">inplace_wstring</a> = <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">wchar_t</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;</td></tr>
<tr class="memdesc:a9e4d364842c4ff48aed1de99ba3cf122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a <a class="el" href="structetl_1_1basic__inplace__string.html" title="basic_inplace_string class with fixed size capacity.">basic_inplace_string</a> using 'wchar_t'.  <br /></td></tr>
<tr class="separator:a9e4d364842c4ff48aed1de99ba3cf122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962db76b841f05bb03ac61766d75d791" id="r_a962db76b841f05bb03ac61766d75d791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a962db76b841f05bb03ac61766d75d791">int16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a962db76b841f05bb03ac61766d75d791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 16 bits.  <br /></td></tr>
<tr class="separator:a962db76b841f05bb03ac61766d75d791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e2791ab5c84359b03776662eb994b6" id="r_a07e2791ab5c84359b03776662eb994b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07e2791ab5c84359b03776662eb994b6">int32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:a07e2791ab5c84359b03776662eb994b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 32 bits.  <br /></td></tr>
<tr class="separator:a07e2791ab5c84359b03776662eb994b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bed93ea1d934540fd05d361a6fc7c5e" id="r_a3bed93ea1d934540fd05d361a6fc7c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bed93ea1d934540fd05d361a6fc7c5e">int64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:a3bed93ea1d934540fd05d361a6fc7c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 64 bits.  <br /></td></tr>
<tr class="separator:a3bed93ea1d934540fd05d361a6fc7c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ed057e79c7de5d1451928e10dcf46d" id="r_a52ed057e79c7de5d1451928e10dcf46d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52ed057e79c7de5d1451928e10dcf46d">int8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:a52ed057e79c7de5d1451928e10dcf46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of exactly 8 bits.  <br /></td></tr>
<tr class="separator:a52ed057e79c7de5d1451928e10dcf46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4c952a1c7a141ed7115060bf4c22b0" id="r_a4b4c952a1c7a141ed7115060bf4c22b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b4c952a1c7a141ed7115060bf4c22b0">int_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a4b4c952a1c7a141ed7115060bf4c22b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a4b4c952a1c7a141ed7115060bf4c22b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32de47c4408fa865e1b8b99eb992d458" id="r_a32de47c4408fa865e1b8b99eb992d458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32de47c4408fa865e1b8b99eb992d458">int_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:a32de47c4408fa865e1b8b99eb992d458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:a32de47c4408fa865e1b8b99eb992d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff54514318ff648eb363a442f171c06" id="r_abff54514318ff648eb363a442f171c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abff54514318ff648eb363a442f171c06">int_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:abff54514318ff648eb363a442f171c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:abff54514318ff648eb363a442f171c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e8ca666d23e897fd1d9f8411c6ca8" id="r_a711e8ca666d23e897fd1d9f8411c6ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a711e8ca666d23e897fd1d9f8411c6ca8">int_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:a711e8ca666d23e897fd1d9f8411c6ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:a711e8ca666d23e897fd1d9f8411c6ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb2df1d7cc3d4d2c87221169156614f" id="r_a5cb2df1d7cc3d4d2c87221169156614f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cb2df1d7cc3d4d2c87221169156614f">int_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td></tr>
<tr class="memdesc:a5cb2df1d7cc3d4d2c87221169156614f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a5cb2df1d7cc3d4d2c87221169156614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce02c549a43d9c5f85a2b39b7c8c4b" id="r_ae2ce02c549a43d9c5f85a2b39b7c8c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2ce02c549a43d9c5f85a2b39b7c8c4b">int_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td></tr>
<tr class="memdesc:ae2ce02c549a43d9c5f85a2b39b7c8c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:ae2ce02c549a43d9c5f85a2b39b7c8c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a53a2f96f40b0aeddf74828d71712e" id="r_a85a53a2f96f40b0aeddf74828d71712e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a53a2f96f40b0aeddf74828d71712e">int_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td></tr>
<tr class="memdesc:a85a53a2f96f40b0aeddf74828d71712e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:a85a53a2f96f40b0aeddf74828d71712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff47f46aff9c632e1283854fda8dc0e1" id="r_aff47f46aff9c632e1283854fda8dc0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff47f46aff9c632e1283854fda8dc0e1">int_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td></tr>
<tr class="memdesc:aff47f46aff9c632e1283854fda8dc0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:aff47f46aff9c632e1283854fda8dc0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64887361e0411caef7d81a411f3a6868" id="r_a64887361e0411caef7d81a411f3a6868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64887361e0411caef7d81a411f3a6868">intmax_t</a> = <a class="el" href="builtin__types_8hpp.html#ad8678dda9c4b939fee5244864c53ada1">TETL_BUILTIN_INTMAX</a></td></tr>
<tr class="memdesc:a64887361e0411caef7d81a411f3a6868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum-width signed integer type.  <br /></td></tr>
<tr class="separator:a64887361e0411caef7d81a411f3a6868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd46e49593ca8eb7a2a60667662abf4" id="r_a3fd46e49593ca8eb7a2a60667662abf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd46e49593ca8eb7a2a60667662abf4">intptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a021098c463419df8b156d80c9153387e">TETL_BUILTIN_INTPTR</a></td></tr>
<tr class="memdesc:a3fd46e49593ca8eb7a2a60667662abf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type capable of holding a pointer.  <br /></td></tr>
<tr class="separator:a3fd46e49593ca8eb7a2a60667662abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5e3d94685880c2a0635ecd8f07b27f" id="r_aef5e3d94685880c2a0635ecd8f07b27f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:aef5e3d94685880c2a0635ecd8f07b27f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef5e3d94685880c2a0635ecd8f07b27f">is_constructible</a> = detail::is_constructible_helper&lt;<a class="el" href="group__type__traits.html#gab8ddf9531fc4ac7ce28574db20c8f20e">void_t</a>&lt;&gt;, T, Args...&gt;</td></tr>
<tr class="separator:aef5e3d94685880c2a0635ecd8f07b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa4cba4e97f7e0ff2dbb2f8238d5734" id="r_ga7aa4cba4e97f7e0ff2dbb2f8238d5734"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> T&gt; </td></tr>
<tr class="memitem:ga7aa4cba4e97f7e0ff2dbb2f8238d5734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga7aa4cba4e97f7e0ff2dbb2f8238d5734">iter_common_reference_t</a> = <a class="el" href="#afe1164daef675b01dddc89c2b7c28d80">etl::common_reference_t</a>&lt;<a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">etl::iter_reference_t</a>&lt;T&gt;, <a class="el" href="#afe275d17dd765cd278253e72900c895f">etl::iter_value_t</a>&lt;T&gt;&amp;&gt;</td></tr>
<tr class="separator:ga7aa4cba4e97f7e0ff2dbb2f8238d5734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89bccf0617839402578ce56ea06409b5" id="r_ga89bccf0617839402578ce56ea06409b5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga89bccf0617839402578ce56ea06409b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga89bccf0617839402578ce56ea06409b5">iter_difference_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> detail::iter_difference&lt;T&gt;::type</td></tr>
<tr class="separator:ga89bccf0617839402578ce56ea06409b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c2555dd1910c170ae137cc8cdceb7" id="r_ad39c2555dd1910c170ae137cc8cdceb7"><td class="memTemplParams" colspan="2">template&lt;etl::detail::dereferenceable T&gt; </td></tr>
<tr class="memitem:ad39c2555dd1910c170ae137cc8cdceb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">iter_reference_t</a> = <a class="el" href="structetl_1_1bitset.html">decltype</a>(*<a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a>&lt;T&amp;&gt;())</td></tr>
<tr class="separator:ad39c2555dd1910c170ae137cc8cdceb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bec1ad7f12ec0170c07608d82af228" id="r_ac0bec1ad7f12ec0170c07608d82af228"><td class="memTemplParams" colspan="2">template&lt;etl::detail::dereferenceable T&gt; </td></tr>
<tr class="memitem:ac0bec1ad7f12ec0170c07608d82af228"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0bec1ad7f12ec0170c07608d82af228">iter_rvalue_reference_t</a> = <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="group__iterator.html#ga78d082ea4928d84830a8184d72aedca6">etl::ranges::iter_move</a>(<a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a>&lt;T&amp;&gt;()))</td></tr>
<tr class="separator:ac0bec1ad7f12ec0170c07608d82af228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe275d17dd765cd278253e72900c895f" id="r_afe275d17dd765cd278253e72900c895f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afe275d17dd765cd278253e72900c895f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe275d17dd765cd278253e72900c895f">iter_value_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> detail::iter_value&lt;T&gt;::type</td></tr>
<tr class="separator:afe275d17dd765cd278253e72900c895f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c526d8179a55ec15611d7627272e067" id="r_a3c526d8179a55ec15611d7627272e067"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:a3c526d8179a55ec15611d7627272e067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c526d8179a55ec15611d7627272e067">make_index_sequence</a> = <a class="el" href="#a4c97ecfe358afc1b3c226c0d7036da95">etl::make_integer_sequence</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="structetl_1_1bitset.html">Size</a>&gt;</td></tr>
<tr class="separator:a3c526d8179a55ec15611d7627272e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c97ecfe358afc1b3c226c0d7036da95" id="r_a4c97ecfe358afc1b3c226c0d7036da95"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , T Size&gt; </td></tr>
<tr class="memitem:a4c97ecfe358afc1b3c226c0d7036da95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c97ecfe358afc1b3c226c0d7036da95">make_integer_sequence</a> = <a class="el" href="builtin__functions_8hpp.html#a303c6144751de3e45c44990112e8b1cb">TETL_BUILTIN_INT_SEQ</a>(T, <a class="el" href="structetl_1_1bitset.html">Size</a>)</td></tr>
<tr class="separator:a4c97ecfe358afc1b3c226c0d7036da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd5f69b53391404e954cf610afa6c54" id="r_aafd5f69b53391404e954cf610afa6c54"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aafd5f69b53391404e954cf610afa6c54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt;T&gt;::type</td></tr>
<tr class="separator:aafd5f69b53391404e954cf610afa6c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeda2fce2dea6fa29533488400dd386" id="r_aabeda2fce2dea6fa29533488400dd386"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aabeda2fce2dea6fa29533488400dd386"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aabeda2fce2dea6fa29533488400dd386">make_unsigned_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td></tr>
<tr class="separator:aabeda2fce2dea6fa29533488400dd386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f26afef63b527bf205bb01455a515b" id="r_aa2f26afef63b527bf205bb01455a515b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2f26afef63b527bf205bb01455a515b">new_handler</a> = <a class="el" href="structetl_1_1bitset.html">void</a> (*)()</td></tr>
<tr class="memdesc:aa2f26afef63b527bf205bb01455a515b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aa2f26afef63b527bf205bb01455a515b" title="etl::new_handler is the function pointer type (pointer to function that takes no arguments and return...">etl::new_handler</a> is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions etl::set_new_handler and etl::get_new_handler  <br /></td></tr>
<tr class="separator:aa2f26afef63b527bf205bb01455a515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2c9350d32e78a0e4c960b9859ccb40" id="r_afb2c9350d32e78a0e4c960b9859ccb40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a> = <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">nullptr</a>)</td></tr>
<tr class="memdesc:afb2c9350d32e78a0e4c960b9859ccb40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type.  <br /></td></tr>
<tr class="separator:afb2c9350d32e78a0e4c960b9859ccb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6729ebb98236f93b98f0492cb3415fb7" id="r_ga6729ebb98236f93b98f0492cb3415fb7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1indirectly__readable.html">etl::indirectly_readable</a> Iter, <a class="el" href="conceptetl_1_1indirectly__regular__unary__invocable.html">etl::indirectly_regular_unary_invocable</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; Proj&gt; </td></tr>
<tr class="memitem:ga6729ebb98236f93b98f0492cb3415fb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga6729ebb98236f93b98f0492cb3415fb7">projected</a> = etl::detail::projected_impl&lt;<a class="el" href="structetl_1_1bitset.html">Iter</a>, <a class="el" href="structetl_1_1bitset.html">Proj</a>&gt;::type</td></tr>
<tr class="separator:ga6729ebb98236f93b98f0492cb3415fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac63559b08846022abfeabda8583ed87" id="r_aac63559b08846022abfeabda8583ed87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a> = <a class="el" href="builtin__types_8hpp.html#a19bfe4995271e67306bab6dc974ed002">TETL_BUILTIN_PTRDIFF</a></td></tr>
<tr class="memdesc:aac63559b08846022abfeabda8583ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aac63559b08846022abfeabda8583ed87" title="etl::ptrdiff_t is the signed integer type of the result of subtracting two pointers.">etl::ptrdiff_t</a> is the signed integer type of the result of subtracting two pointers.  <br /></td></tr>
<tr class="separator:aac63559b08846022abfeabda8583ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355c433e6d91bee78ed9c6448e77aeb4" id="r_ga355c433e6d91bee78ed9c6448e77aeb4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga355c433e6d91bee78ed9c6448e77aeb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga355c433e6d91bee78ed9c6448e77aeb4">ratio_add</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga355c433e6d91bee78ed9c6448e77aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_add denotes the result of adding two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga355c433e6d91bee78ed9c6448e77aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a3d5969bc4fe12c5f31a130821b9ce" id="r_gac1a3d5969bc4fe12c5f31a130821b9ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R2</a> &gt; </td></tr>
<tr class="memitem:gac1a3d5969bc4fe12c5f31a130821b9ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#gac1a3d5969bc4fe12c5f31a130821b9ce">ratio_divide</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den, R1::den * R2::num&gt;</td></tr>
<tr class="memdesc:gac1a3d5969bc4fe12c5f31a130821b9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_divide denotes the result of dividing two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:gac1a3d5969bc4fe12c5f31a130821b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471b6ab570a3512d31a677dc0ab4743d" id="r_ga471b6ab570a3512d31a677dc0ab4743d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga471b6ab570a3512d31a677dc0ab4743d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga471b6ab570a3512d31a677dc0ab4743d">ratio_multiply</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::num, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga471b6ab570a3512d31a677dc0ab4743d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_multiply denotes the result of multiplying two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga471b6ab570a3512d31a677dc0ab4743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bcee71a1ca1a48e5c5485d3aaad395" id="r_ga25bcee71a1ca1a48e5c5485d3aaad395"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga25bcee71a1ca1a48e5c5485d3aaad395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga25bcee71a1ca1a48e5c5485d3aaad395">ratio_subtract</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;</td></tr>
<tr class="memdesc:ga25bcee71a1ca1a48e5c5485d3aaad395"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template ratio_subtract denotes the result of subtracting two exact rational fractions represented by the ratio specializations R1 and R2.  <br /></td></tr>
<tr class="separator:ga25bcee71a1ca1a48e5c5485d3aaad395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffde65d0200b12233a0dff1979cc210" id="r_a0ffde65d0200b12233a0dff1979cc210"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0ffde65d0200b12233a0dff1979cc210"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ffde65d0200b12233a0dff1979cc210">remove_all_extents_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a0ffde65d0200b12233a0dff1979cc210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ab6c9a804ec997a6e8cb9c5b36c3e4" id="r_a75ab6c9a804ec997a6e8cb9c5b36c3e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a75ab6c9a804ec997a6e8cb9c5b36c3e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75ab6c9a804ec997a6e8cb9c5b36c3e4">remove_const_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__const.html">remove_const</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a75ab6c9a804ec997a6e8cb9c5b36c3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d58de8ee9130049557265efc11802c" id="r_a57d58de8ee9130049557265efc11802c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a57d58de8ee9130049557265efc11802c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57d58de8ee9130049557265efc11802c">remove_cv_t</a> = <a class="el" href="#a75ab6c9a804ec997a6e8cb9c5b36c3e4">remove_const_t</a>&lt;<a class="el" href="group__type__traits.html#ga52b035d7a0227468261ee211d61d7abf">remove_volatile_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a57d58de8ee9130049557265efc11802c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13534b69c91b07e4add5cea854cfedd8" id="r_a13534b69c91b07e4add5cea854cfedd8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a13534b69c91b07e4add5cea854cfedd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13534b69c91b07e4add5cea854cfedd8">remove_cvref_t</a> = <a class="el" href="#a57d58de8ee9130049557265efc11802c">remove_cv_t</a>&lt;<a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a13534b69c91b07e4add5cea854cfedd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3a021106d8984e6a7283adfcae4117" id="r_aff3a021106d8984e6a7283adfcae4117"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aff3a021106d8984e6a7283adfcae4117"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff3a021106d8984e6a7283adfcae4117">remove_extent_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__extent.html">remove_extent</a>&lt;T&gt;::type</td></tr>
<tr class="separator:aff3a021106d8984e6a7283adfcae4117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cba9b583535ccfde0e7eb172bbec71" id="r_a81cba9b583535ccfde0e7eb172bbec71"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a81cba9b583535ccfde0e7eb172bbec71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81cba9b583535ccfde0e7eb172bbec71">remove_pointer_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a>&lt;T&gt;::type</td></tr>
<tr class="separator:a81cba9b583535ccfde0e7eb172bbec71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5993e4587ccd2777e95893329360358a" id="r_ga5993e4587ccd2777e95893329360358a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga5993e4587ccd2777e95893329360358a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__reference.html">remove_reference</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ga5993e4587ccd2777e95893329360358a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b035d7a0227468261ee211d61d7abf" id="r_ga52b035d7a0227468261ee211d61d7abf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga52b035d7a0227468261ee211d61d7abf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#ga52b035d7a0227468261ee211d61d7abf">remove_volatile_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ga52b035d7a0227468261ee211d61d7abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee50235c04ef643cb7502785393220fe" id="r_aee50235c04ef643cb7502785393220fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> = <a class="el" href="builtin__types_8hpp.html#ab236bea848bc390350ba3fc38ae07819">TETL_BUILTIN_SIZET</a></td></tr>
<tr class="memdesc:aee50235c04ef643cb7502785393220fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aee50235c04ef643cb7502785393220fe" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> is the unsigned integer type of the result of the sizeof operator.  <br /></td></tr>
<tr class="separator:aee50235c04ef643cb7502785393220fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa3ee2a2bd4938f2e8f2f7e00117be6" id="r_ga0fa3ee2a2bd4938f2e8f2f7e00117be6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> N&gt; </td></tr>
<tr class="memitem:ga0fa3ee2a2bd4938f2e8f2f7e00117be6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#ga0fa3ee2a2bd4938f2e8f2f7e00117be6">smallest_size_t</a></td></tr>
<tr class="memdesc:ga0fa3ee2a2bd4938f2e8f2f7e00117be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest unsigned integer type that can represent values in the range [0, N].  <br /></td></tr>
<tr class="separator:ga0fa3ee2a2bd4938f2e8f2f7e00117be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b66173615e2c5f0568adb2cae8739f" id="r_a66b66173615e2c5f0568adb2cae8739f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b66173615e2c5f0568adb2cae8739f">streamoff</a> = <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="separator:a66b66173615e2c5f0568adb2cae8739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcecc45ff4539025dd0eb1cea84021f9" id="r_afcecc45ff4539025dd0eb1cea84021f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcecc45ff4539025dd0eb1cea84021f9">streamsize</a> = <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt;</td></tr>
<tr class="separator:afcecc45ff4539025dd0eb1cea84021f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7f02db9e66eaec8dccdca2f4e98a2f" id="r_a6f7f02db9e66eaec8dccdca2f4e98a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">string_view</a> = <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>&gt;&gt;</td></tr>
<tr class="memdesc:a6f7f02db9e66eaec8dccdca2f4e98a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedefs for common character type.  <br /></td></tr>
<tr class="separator:a6f7f02db9e66eaec8dccdca2f4e98a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62da72e20fc89d790a5f88420496d0d7" id="r_a62da72e20fc89d790a5f88420496d0d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62da72e20fc89d790a5f88420496d0d7">time_t</a> = <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:a62da72e20fc89d790a5f88420496d0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic type capable of representing times.  <br /></td></tr>
<tr class="separator:a62da72e20fc89d790a5f88420496d0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e9c28fa52ab73ef48e5cbed20c66fd" id="r_aa4e9c28fa52ab73ef48e5cbed20c66fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4e9c28fa52ab73ef48e5cbed20c66fd">true_type</a> = <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">true</a>&gt;</td></tr>
<tr class="separator:aa4e9c28fa52ab73ef48e5cbed20c66fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88df1a5f5c335cb6cf4909b47882e53" id="r_ae88df1a5f5c335cb6cf4909b47882e53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae88df1a5f5c335cb6cf4909b47882e53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>, T&gt;::type</td></tr>
<tr class="separator:ae88df1a5f5c335cb6cf4909b47882e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca42c1976d1b12998afcabf8f39e8c23" id="r_gaca42c1976d1b12998afcabf8f39e8c23"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaca42c1976d1b12998afcabf8f39e8c23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#gaca42c1976d1b12998afcabf8f39e8c23">type_identity_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1type__identity.html">type_identity</a>&lt;T&gt;::type</td></tr>
<tr class="separator:gaca42c1976d1b12998afcabf8f39e8c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46518a317507676ba5887e53ca4bf5bd" id="r_a46518a317507676ba5887e53ca4bf5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46518a317507676ba5887e53ca4bf5bd">uint16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a46518a317507676ba5887e53ca4bf5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 16 bits.  <br /></td></tr>
<tr class="separator:a46518a317507676ba5887e53ca4bf5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac524e3389ea120063f493b23ce5ba2a6" id="r_ac524e3389ea120063f493b23ce5ba2a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac524e3389ea120063f493b23ce5ba2a6">uint32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:ac524e3389ea120063f493b23ce5ba2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 32 bits.  <br /></td></tr>
<tr class="separator:ac524e3389ea120063f493b23ce5ba2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbbc3f006120acc1de719e7d8ee6f40" id="r_a5bbbc3f006120acc1de719e7d8ee6f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bbbc3f006120acc1de719e7d8ee6f40">uint64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a5bbbc3f006120acc1de719e7d8ee6f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 64 bits.  <br /></td></tr>
<tr class="separator:a5bbbc3f006120acc1de719e7d8ee6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71924434159564bc3aa4bd2930947053" id="r_a71924434159564bc3aa4bd2930947053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71924434159564bc3aa4bd2930947053">uint8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:a71924434159564bc3aa4bd2930947053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type with width of exactly 8 bits.  <br /></td></tr>
<tr class="separator:a71924434159564bc3aa4bd2930947053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516df22f1e6a839bc251cc699c90ab56" id="r_a516df22f1e6a839bc251cc699c90ab56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a516df22f1e6a839bc251cc699c90ab56">uint_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:a516df22f1e6a839bc251cc699c90ab56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:a516df22f1e6a839bc251cc699c90ab56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ae5542021173d59890b67e0f5dcd20" id="r_a39ae5542021173d59890b67e0f5dcd20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ae5542021173d59890b67e0f5dcd20">uint_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:a39ae5542021173d59890b67e0f5dcd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:a39ae5542021173d59890b67e0f5dcd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b174a549a84b470b20998da935f674" id="r_a49b174a549a84b470b20998da935f674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49b174a549a84b470b20998da935f674">uint_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:a49b174a549a84b470b20998da935f674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:a49b174a549a84b470b20998da935f674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8e71ca66f676d88d4bfc4023421cd9" id="r_aba8e71ca66f676d88d4bfc4023421cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba8e71ca66f676d88d4bfc4023421cd9">uint_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:aba8e71ca66f676d88d4bfc4023421cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:aba8e71ca66f676d88d4bfc4023421cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce3c5bd0ff2f44caabd1b4d707887fc" id="r_acce3c5bd0ff2f44caabd1b4d707887fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acce3c5bd0ff2f44caabd1b4d707887fc">uint_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td></tr>
<tr class="memdesc:acce3c5bd0ff2f44caabd1b4d707887fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 16 bits.  <br /></td></tr>
<tr class="separator:acce3c5bd0ff2f44caabd1b4d707887fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35f8b747d163b033b7d4bf5b18b2f61" id="r_ad35f8b747d163b033b7d4bf5b18b2f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad35f8b747d163b033b7d4bf5b18b2f61">uint_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td></tr>
<tr class="memdesc:ad35f8b747d163b033b7d4bf5b18b2f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 32 bits.  <br /></td></tr>
<tr class="separator:ad35f8b747d163b033b7d4bf5b18b2f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace30aa068da2786e3178c001a9dcb45f" id="r_ace30aa068da2786e3178c001a9dcb45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace30aa068da2786e3178c001a9dcb45f">uint_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td></tr>
<tr class="memdesc:ace30aa068da2786e3178c001a9dcb45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 64 bits.  <br /></td></tr>
<tr class="separator:ace30aa068da2786e3178c001a9dcb45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9da1f87db9cd7b9d1f76ade9b44c94" id="r_a3e9da1f87db9cd7b9d1f76ade9b44c94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e9da1f87db9cd7b9d1f76ade9b44c94">uint_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td></tr>
<tr class="memdesc:a3e9da1f87db9cd7b9d1f76ade9b44c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer type with width of at least 8 bits.  <br /></td></tr>
<tr class="separator:a3e9da1f87db9cd7b9d1f76ade9b44c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05138bec421765330b01b925aae5d89f" id="r_a05138bec421765330b01b925aae5d89f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05138bec421765330b01b925aae5d89f">uintmax_t</a> = <a class="el" href="builtin__types_8hpp.html#a64175350ea04c19125422816cd6184e1">TETL_BUILTIN_UINTMAX</a></td></tr>
<tr class="memdesc:a05138bec421765330b01b925aae5d89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum-width unsigned integer type.  <br /></td></tr>
<tr class="separator:a05138bec421765330b01b925aae5d89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d944a371245d51e3b9ea011f7b97f43" id="r_a1d944a371245d51e3b9ea011f7b97f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d944a371245d51e3b9ea011f7b97f43">uintptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a3b013e093af0767d757a3606463295d9">TETL_BUILTIN_UINTPTR</a></td></tr>
<tr class="memdesc:a1d944a371245d51e3b9ea011f7b97f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type capable of holding a pointer.  <br /></td></tr>
<tr class="separator:a1d944a371245d51e3b9ea011f7b97f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e4463cad64a4fb5f8e4cf7acafec27" id="r_ga23e4463cad64a4fb5f8e4cf7acafec27"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga23e4463cad64a4fb5f8e4cf7acafec27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#ga23e4463cad64a4fb5f8e4cf7acafec27">underlying_type_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1underlying__type.html">underlying_type</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ga23e4463cad64a4fb5f8e4cf7acafec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50d469d33ed56a0ce32f87d03ac5f10" id="r_ab50d469d33ed56a0ce32f87d03ac5f10"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab50d469d33ed56a0ce32f87d03ac5f10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab50d469d33ed56a0ce32f87d03ac5f10">unwrap_ref_decay_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1unwrap__ref__decay.html">unwrap_ref_decay</a>&lt;T&gt;::type</td></tr>
<tr class="separator:ab50d469d33ed56a0ce32f87d03ac5f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b611e97373f7c9c739f58a942f9de05" id="r_a7b611e97373f7c9c739f58a942f9de05"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7b611e97373f7c9c739f58a942f9de05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>, T&gt;::type</td></tr>
<tr class="separator:a7b611e97373f7c9c739f58a942f9de05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ddf9531fc4ac7ce28574db20c8f20e" id="r_gab8ddf9531fc4ac7ce28574db20c8f20e"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:gab8ddf9531fc4ac7ce28574db20c8f20e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__traits.html#gab8ddf9531fc4ac7ce28574db20c8f20e">void_t</a> = <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:gab8ddf9531fc4ac7ce28574db20c8f20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff8faaf423d40e312921ee1506eaf5b" id="r_afff8faaf423d40e312921ee1506eaf5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff8faaf423d40e312921ee1506eaf5b">wformat_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a>&gt;</td></tr>
<tr class="separator:afff8faaf423d40e312921ee1506eaf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b255764cde83db44d0e61eebc55d36" id="r_a03b255764cde83db44d0e61eebc55d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1bitset.html">wchar_t</a>&gt;&gt;, <a class="el" href="structetl_1_1bitset.html">wchar_t</a>&gt;</td></tr>
<tr class="separator:a03b255764cde83db44d0e61eebc55d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a60587ace165efab2fc40bddf69c89c" id="r_a9a60587ace165efab2fc40bddf69c89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a60587ace165efab2fc40bddf69c89c">wformat_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1bitset.html">wchar_t</a>&gt;</td></tr>
<tr class="separator:a9a60587ace165efab2fc40bddf69c89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c1b057042c87184f2220c79696ef73" id="r_a69c1b057042c87184f2220c79696ef73"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a69c1b057042c87184f2220c79696ef73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69c1b057042c87184f2220c79696ef73">wformat_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">wchar_t</a>, <a class="el" href="group__type__traits.html#gaca42c1976d1b12998afcabf8f39e8c23">type_identity_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Args</a>&gt;...&gt;</td></tr>
<tr class="separator:a69c1b057042c87184f2220c79696ef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4e6bc2deecad0fb678bfe7c838df5e" id="r_afb4e6bc2deecad0fb678bfe7c838df5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> = <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="separator:afb4e6bc2deecad0fb678bfe7c838df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac437d8206f0e17da3a896c5f4d17f95a" id="r_ac437d8206f0e17da3a896c5f4d17f95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac437d8206f0e17da3a896c5f4d17f95a">atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000'000&gt;</td></tr>
<tr class="separator:ac437d8206f0e17da3a896c5f4d17f95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626e7a2087ed63adf28928bc61505210" id="r_a626e7a2087ed63adf28928bc61505210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a626e7a2087ed63adf28928bc61505210">femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000&gt;</td></tr>
<tr class="separator:a626e7a2087ed63adf28928bc61505210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1999fbf9a32aa8544e0ffa747d47518d" id="r_a1999fbf9a32aa8544e0ffa747d47518d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1999fbf9a32aa8544e0ffa747d47518d">pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000&gt;</td></tr>
<tr class="separator:a1999fbf9a32aa8544e0ffa747d47518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1718104bd02150cc3a553b7289ea2d2d" id="r_a1718104bd02150cc3a553b7289ea2d2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1718104bd02150cc3a553b7289ea2d2d">nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000&gt;</td></tr>
<tr class="separator:a1718104bd02150cc3a553b7289ea2d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b69df89587850ded6209b864e7569" id="r_af06b69df89587850ded6209b864e7569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af06b69df89587850ded6209b864e7569">micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000&gt;</td></tr>
<tr class="separator:af06b69df89587850ded6209b864e7569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10931e9eceef3f81bae9ea43bdd8e89" id="r_ab10931e9eceef3f81bae9ea43bdd8e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10931e9eceef3f81bae9ea43bdd8e89">milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000&gt;</td></tr>
<tr class="separator:ab10931e9eceef3f81bae9ea43bdd8e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037ed5d2bc56f378210678d84bcc854b" id="r_a037ed5d2bc56f378210678d84bcc854b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a037ed5d2bc56f378210678d84bcc854b">centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td></tr>
<tr class="separator:a037ed5d2bc56f378210678d84bcc854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c874769f867849c115ae2d1867a02" id="r_a5e1c874769f867849c115ae2d1867a02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e1c874769f867849c115ae2d1867a02">deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td></tr>
<tr class="separator:a5e1c874769f867849c115ae2d1867a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb47ecbe72de3b6984811c6a1c8c6d5b" id="r_aeb47ecbe72de3b6984811c6a1c8c6d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb47ecbe72de3b6984811c6a1c8c6d5b">deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td></tr>
<tr class="separator:aeb47ecbe72de3b6984811c6a1c8c6d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee06e415331cdede5a5e81a37ae91014" id="r_aee06e415331cdede5a5e81a37ae91014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee06e415331cdede5a5e81a37ae91014">hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td></tr>
<tr class="separator:aee06e415331cdede5a5e81a37ae91014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118ab5d9112082a698afa3512c99a46e" id="r_a118ab5d9112082a698afa3512c99a46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a118ab5d9112082a698afa3512c99a46e">kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000, 1&gt;</td></tr>
<tr class="separator:a118ab5d9112082a698afa3512c99a46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7fbb2fd3099cd6e2bb5a712becf41c" id="r_a8b7fbb2fd3099cd6e2bb5a712becf41c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b7fbb2fd3099cd6e2bb5a712becf41c">mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000, 1&gt;</td></tr>
<tr class="separator:a8b7fbb2fd3099cd6e2bb5a712becf41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0782f438fdf0a5e815bb88d8116543a" id="r_aa0782f438fdf0a5e815bb88d8116543a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0782f438fdf0a5e815bb88d8116543a">giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000, 1&gt;</td></tr>
<tr class="separator:aa0782f438fdf0a5e815bb88d8116543a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0850018459aaecf06435ee5eb9f0d8" id="r_abb0850018459aaecf06435ee5eb9f0d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb0850018459aaecf06435ee5eb9f0d8">tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:abb0850018459aaecf06435ee5eb9f0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e47bd1a852d56651ef8b41a86a86fa8" id="r_a8e47bd1a852d56651ef8b41a86a86fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e47bd1a852d56651ef8b41a86a86fa8">peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:a8e47bd1a852d56651ef8b41a86a86fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe49b8885eb17fdade12acd5f37acad" id="r_aabe49b8885eb17fdade12acd5f37acad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabe49b8885eb17fdade12acd5f37acad">exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000'000, 1&gt;</td></tr>
<tr class="separator:aabe49b8885eb17fdade12acd5f37acad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8c9590e0d8ba5b7b8a2d709113c3e7bb" id="r_a8c9590e0d8ba5b7b8a2d709113c3e7bb"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c9590e0d8ba5b7b8a2d709113c3e7bb">align_val_t</a> : etl::size_t </td></tr>
<tr class="memdesc:a8c9590e0d8ba5b7b8a2d709113c3e7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than the default, pass that alignment requirement as an argument of type align_val_t to the selected allocation/deallocation function.  <a href="#a8c9590e0d8ba5b7b8a2d709113c3e7bb">More...</a><br /></td></tr>
<tr class="separator:a8c9590e0d8ba5b7b8a2d709113c3e7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc55212e09044ea8a258cd3a53d90dde" id="r_abc55212e09044ea8a258cd3a53d90dde"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc55212e09044ea8a258cd3a53d90dde">chars_format</a> : etl::uint8_t { <a class="el" href="#abc55212e09044ea8a258cd3a53d90ddea55a95650a66b53ecbb960b53d985b964">scientific</a> = 0x1
, <a class="el" href="#abc55212e09044ea8a258cd3a53d90ddeacec315e3d0975e5cc2811d5d8725f149">fixed</a> = 0x2
, <a class="el" href="#abc55212e09044ea8a258cd3a53d90ddeab8d1b43eae73587ba56baef574709ecb">hex</a> = 0x4
, <a class="el" href="#abc55212e09044ea8a258cd3a53d90ddea958153f1b8b96ec4c4eb2147429105d9">general</a> = fixed | scientific
 }</td></tr>
<tr class="memdesc:abc55212e09044ea8a258cd3a53d90dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BitmaskType used to specify floating-point formatting for to_chars and from_chars.  <a href="#abc55212e09044ea8a258cd3a53d90dde">More...</a><br /></td></tr>
<tr class="separator:abc55212e09044ea8a258cd3a53d90dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb52d5e58265d474290d1e17bcf1716" id="r_gaceb52d5e58265d474290d1e17bcf1716"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bit.html#gaceb52d5e58265d474290d1e17bcf1716">endian</a> { <a class="el" href="group__bit.html#ggaceb52d5e58265d474290d1e17bcf1716aaae6635e044ac56046b2893a529b5114">little</a> = implementation defined
, <a class="el" href="group__bit.html#ggaceb52d5e58265d474290d1e17bcf1716ad861877da56b8b4ceb35c8cbfdf65bb4">big</a> = implementation defined
, <a class="el" href="group__bit.html#ggaceb52d5e58265d474290d1e17bcf1716a8e5f3adee38c8fccc13c1f3be0143796">native</a> = implementation defined
 }</td></tr>
<tr class="memdesc:gaceb52d5e58265d474290d1e17bcf1716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the endianness of all scalar types. If all scalar types are little-endian, <code>endian::native</code> equals <code>endian::little</code>. If all scalar types are big-endian, <code>endian::native</code> equals <code>endian::big</code>.  <a href="group__bit.html#gaceb52d5e58265d474290d1e17bcf1716">More...</a><br /></td></tr>
<tr class="separator:gaceb52d5e58265d474290d1e17bcf1716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31f743d6273b64f3e8a3121813ea243" id="r_aa31f743d6273b64f3e8a3121813ea243"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa31f743d6273b64f3e8a3121813ea243">errc</a> { <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a8ab69162f060cc46b805b3265ad1cdf1">address_family_not_supported</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a8e2bc80599069d337b43dff6edfb6891">address_in_use</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a20abf2ffbf6e82e36405843f269d6438">address_not_available</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ab5580b198f691ab2df12f5e2ab974373">already_connected</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a1b245b26b5ea3428c050d7f1503d7715">argument_list_too_long</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a4b82222a0895b538d0597092b3ceab3e">argument_out_of_domain</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aaf169f73a82794128aa491c4b4f1c071">bad_address</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a9941c5c8c58ff058b870e94e96ac38e1">bad_file_descriptor</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ac7944ab5d2e25bf75b267d070b506d1c">bad_message</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a2f0338eed54503152be1d31c93c9c2f1">broken_pipe</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a2f8f27a7eef1ad585c7ab6f25a6c2c79">connection_aborted</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a81cf222a9b1530171fdfd66c3f734989">connection_already_in_progress</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a53793ee58fc24168a0d6549c3cb2df8e">connection_refused</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243abf39bfc8665384194e343c08ab344405">connection_reset</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6177070a517d51a4382ab0d7c88e5b58">cross_device_link</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a326032e01f2a5e14c7f730f4d03d753a">destination_address_required</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ab3ab5338a00f49c4451851cc5442f370">device_or_resource_busy</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6a336135d33e62f49edc55f29354e12e">directory_not_empty</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a4dfaf9c996cf045f32d17edc9754fc95">executable_format_error</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a41edf636e3c7b59f797348fc58472258">file_exists</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aa1e14bfb89b41ddf654b1772c8fd2e74">file_too_large</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6e56e6ed055b9771b8192a4f229fee27">filename_too_long</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aa33c516bbdfb179cef733c8daeb97bed">function_not_supported</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243afe2377fbd16d7f335474e1df7d6376bf">host_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a054e5b4ff59331386872de744d661719">identifier_removed</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a53a9e57a679708b2d8ff0ccd8ec96b18">illegal_byte_sequence</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a45fe7da1767194b580aeba752d7b44ae">inappropriate_io_control_operation</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243afadb76763385627e57ec386c9b6038f0">interrupted</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ae55d43eabeefe5a8271b4a3c898bd18f">invalid_argument</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243abd86a2c65caf6a270b916234ab321ce3">invalid_seek</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243acccc32f2a5f7dc7b87d2f85daea66789">io_error</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243af3c51d7ea75a76f26c0a2bdc00c4e006">is_a_directory</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ade5f4bc2f8a4690176e22e83196b9fd3">message_size</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a93b16d34b1689f66f0cfed60e99c0009">network_down</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a0e1d200ae35ede416bf85f84093ce37a">network_reset</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a608a68344b4eb1fe0690861a83828816">network_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a618ead44397b73cf0baa08b460b66c39">no_buffer_space</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ad08d4c854a6810cebd2a8ab61876f919">no_child_process</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243add431dfaf61ea842693dca8be1ebcaf7">no_link</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a58688487c3e24313637a76bd29881e64">no_lock_available</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aeec0f03ad92584c78835c10ab79d7f42">no_message_available</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243acec935db07cfc57caafa37e98eafb213">no_message</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243abed8a9032d9366c28582a0ad59a31525">no_protocol_option</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a1a5334dd8d1ca56e33887bd44630641b">no_space_on_device</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ad8b1d94a0ac09c6d55b2ed68f0836142">no_stream_resources</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a5c83a012eac17bbf458df5804801e373">no_such_device_or_address</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243af42b2e58729e2783b683c8610977fc22">no_such_device</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a2e70fc89b08f26fa3fc77694c91e8f7a">no_such_file_or_directory</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ad91a9b8a734f2bef4b778f89806cbab7">no_such_process</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a21e867ca95e1dfecff4701863547dcec">not_a_directory</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a22ac64bb14c46bcbc338a21950b6e722">not_a_socket</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6e752b7a04543e5052b2d0dd05eca0fa">not_a_stream</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a69c2dbb5917ca550a862e9c1c839bca1">not_connected</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aafdb5594dc3e484fc1bfd7c564d550c1">not_enough_memory</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aa55e82356e9721946aa9ba954733c6f0">not_supported</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243afd3d0bdcc9eb9e68534b7d055c5fe586">operation_canceled</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a4c7eb50b6d86ac8a130ebebc18dbe263">operation_in_progress</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a8344b3d509942f035d5e303022f9b986">operation_not_permitted</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a69bf074bf052ee4c9047b62fe7c24569">operation_not_supported</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a738abdaead9cd7b2e2ea19a34764b385">operation_would_block</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a2abac2fa6722c56b2ea17ac6c4097f68">owner_dead</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ae8ee838822072f02738dbd7d97ea03fc">permission_denied</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a9665c745d0a9132d8da6ed55e89a0564">protocol_error</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aa2635acef8b9a3e1c40923829722d472">protocol_not_supported</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a06108efce8ef1cd8aa4cc440f8b4317f">read_only_file_system</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aed65f7649c6f0e365673d65a9d8119d8">resource_deadlock_would_occur</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ae46a97ea2906921c8c626890bde832cf">resource_unavailable_try_again</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a8e0fafb181567cc468e1ee81983d739d">result_out_of_range</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a6805059549401365b824b54573a6f46e">state_not_recoverable</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ac1a620a30954dc9402a811453c2c3e3f">stream_timeout</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243ad2f80f12d22bb099fcf1062db660b567">text_file_busy</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a56c27b1ab1a5a5a0eae853cabb4dc0c1">timed_out</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a3130d1d4e000cdc1e7c47013e313c10e">too_many_files_open_in_system</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243aed2c33c8fe874cfeba6f4a7747c62d05">too_many_files_open</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243abfe22fc9b27a8ff13186aba60b6bc5c8">too_many_links</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a33c78baca1480479c88aa4d50cb68206">too_many_symbolic_link_levels</a>
, <br />
&#160;&#160;<a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a143653b075bff946193644ba6d97fa5d">value_too_large</a>
, <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243a81cac28a38438710de9856af4a8bcd0b">wrong_protocol_type</a>
<br />
 }</td></tr>
<tr class="memdesc:aa31f743d6273b64f3e8a3121813ea243"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scoped enumeration <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes.  <a href="#aa31f743d6273b64f3e8a3121813ea243">More...</a><br /></td></tr>
<tr class="separator:aa31f743d6273b64f3e8a3121813ea243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592fe78d9bf66455d12aa075f36313b6" id="r_a592fe78d9bf66455d12aa075f36313b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a592fe78d9bf66455d12aa075f36313b6">float_denorm_style</a> { <a class="el" href="#a592fe78d9bf66455d12aa075f36313b6ae6e5a92659b76e353da685746ec7a715">denorm_indeterminate</a> = -1
, <a class="el" href="#a592fe78d9bf66455d12aa075f36313b6ae1126f121e8e78fad4c2ea93b9154f70">denorm_absent</a> = 0
, <a class="el" href="#a592fe78d9bf66455d12aa075f36313b6ace9911a51bfc23dca58b86c67b0adfac">denorm_present</a> = 1
 }</td></tr>
<tr class="separator:a592fe78d9bf66455d12aa075f36313b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdaf6c7e8a65859bf550443989c5a66" id="r_a3bdaf6c7e8a65859bf550443989c5a66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66">float_round_style</a> { <br />
&#160;&#160;<a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66aef8e73dd0b0f1899790b6ba2bb47be7d">round_indeterminate</a> = -1
, <a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66a2378935a2849c4d049d5e5a01324e827">round_toward_zero</a> = 0
, <a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66aae97e229f8502c244371d7f7e3105afc">round_to_nearest</a> = 1
, <a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66a33f65225750a8f3edc0b6601fa7bcd52">round_toward_infinity</a> = 2
, <br />
&#160;&#160;<a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66ad9c511acb4735515f2402087641e9725">round_toward_neg_infinity</a> = 3
<br />
 }</td></tr>
<tr class="separator:a3bdaf6c7e8a65859bf550443989c5a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5c92ae723acdba8ce0f48be8530154" id="r_a6a5c92ae723acdba8ce0f48be8530154"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154">implementation</a> { <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1">freestanding</a> = 0
, <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154a734d3030ff72ad8d9678efa82b1db7d2">hosted</a> = 1
 }</td></tr>
<tr class="separator:a6a5c92ae723acdba8ce0f48be8530154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72411d869deb28d3d6a0f7d0d77dd1de" id="r_a72411d869deb28d3d6a0f7d0d77dd1de"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> : unsigned char { <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1dea6289bbfa378818f7066ccad5847da5a2">cpp_17</a> = 17
, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1dea4c7aabdc3eb0d845c62edfb822b0fe5a">cpp_20</a> = 20
, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1deaf7d98f68372c9de30cc2d571b75b19d7">cpp_23</a> = 23
, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff">cpp_26</a> = 26
 }</td></tr>
<tr class="memdesc:a72411d869deb28d3d6a0f7d0d77dd1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for the currently selected C++ standard version. Unlike the official macro <code>__cplusplus</code>, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips.  <a href="#a72411d869deb28d3d6a0f7d0d77dd1de">More...</a><br /></td></tr>
<tr class="separator:a72411d869deb28d3d6a0f7d0d77dd1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabe732728abf637284509396f07e7e428" id="r_gabe732728abf637284509396f07e7e428"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gabe732728abf637284509396f07e7e428"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gabe732728abf637284509396f07e7e428">abs</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) -&gt; T</td></tr>
<tr class="separator:gabe732728abf637284509396f07e7e428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d44cf8dff1d93939ca2e9adeec696a7" id="r_a5d44cf8dff1d93939ca2e9adeec696a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d44cf8dff1d93939ca2e9adeec696a7">abs</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:a5d44cf8dff1d93939ca2e9adeec696a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6fd8ce3d926357e36de32769335251" id="r_aee6fd8ce3d926357e36de32769335251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee6fd8ce3d926357e36de32769335251">abs</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:aee6fd8ce3d926357e36de32769335251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2bd83e2ec37c5b1298fae188a15607" id="r_a5e2bd83e2ec37c5b1298fae188a15607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e2bd83e2ec37c5b1298fae188a15607">abs</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:a5e2bd83e2ec37c5b1298fae188a15607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a5e2bd83e2ec37c5b1298fae188a15607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ed298b66e9f2fdd041b0fa9c5df301" id="r_a71ed298b66e9f2fdd041b0fa9c5df301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71ed298b66e9f2fdd041b0fa9c5df301">abs</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:a71ed298b66e9f2fdd041b0fa9c5df301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342a8a68c9a0f5c3ff1b3d5857553906" id="r_a342a8a68c9a0f5c3ff1b3d5857553906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a342a8a68c9a0f5c3ff1b3d5857553906">abs</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="separator:a342a8a68c9a0f5c3ff1b3d5857553906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e1eb0ffb77caba7f8242da4a5d7470" id="r_a51e1eb0ffb77caba7f8242da4a5d7470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e1eb0ffb77caba7f8242da4a5d7470">abs</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="separator:a51e1eb0ffb77caba7f8242da4a5d7470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga446d7a4c7b401cc37781c997c2c27666" id="r_ga446d7a4c7b401cc37781c997c2c27666"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> &gt; </td></tr>
<tr class="memitem:ga446d7a4c7b401cc37781c997c2c27666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga446d7a4c7b401cc37781c997c2c27666">abs</a> (<a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">input</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a></td></tr>
<tr class="memdesc:ga446d7a4c7b401cc37781c997c2c27666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value.  <br /></td></tr>
<tr class="separator:ga446d7a4c7b401cc37781c997c2c27666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb8f915bbbbe802e8277bc6c7334bbd1" id="r_gabb8f915bbbbe802e8277bc6c7334bbd1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> &gt; </td></tr>
<tr class="memitem:gabb8f915bbbbe802e8277bc6c7334bbd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gabb8f915bbbbe802e8277bc6c7334bbd1">accumulate</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Type</a> init) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a></td></tr>
<tr class="memdesc:gabb8f915bbbbe802e8277bc6c7334bbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gabb8f915bbbbe802e8277bc6c7334bbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424ee2f8a4a9c6883035310032321524" id="r_ga424ee2f8a4a9c6883035310032321524"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga424ee2f8a4a9c6883035310032321524"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga424ee2f8a4a9c6883035310032321524">accumulate</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Type</a> init, <a class="el" href="structetl_1_1bitset.html">BinaryOperation</a> <a class="el" href="structetl_1_1bitset.html">op</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a></td></tr>
<tr class="memdesc:ga424ee2f8a4a9c6883035310032321524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga424ee2f8a4a9c6883035310032321524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c9d06efc6545df1f62f896f3039ec0" id="r_ga99c9d06efc6545df1f62f896f3039ec0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__integer.html">etl::builtin_integer</a> Int&gt; </td></tr>
<tr class="memitem:ga99c9d06efc6545df1f62f896f3039ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga99c9d06efc6545df1f62f896f3039ec0">add_sat</a> (<a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">Int</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a></td></tr>
<tr class="separator:ga99c9d06efc6545df1f62f896f3039ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ae02f44cb9f415d79d030c8ceb8c16" id="r_a21ae02f44cb9f415d79d030c8ceb8c16"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a21ae02f44cb9f415d79d030c8ceb8c16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21ae02f44cb9f415d79d030c8ceb8c16">addressof</a> (T &amp;<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a21ae02f44cb9f415d79d030c8ceb8c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;.  <br /></td></tr>
<tr class="separator:a21ae02f44cb9f415d79d030c8ceb8c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8d9c987fb1214a1989a00c3ac4d175" id="r_a2b8d9c987fb1214a1989a00c3ac4d175"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a2b8d9c987fb1214a1989a00c3ac4d175"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b8d9c987fb1214a1989a00c3ac4d175">addressof</a> (T &amp;<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a2b8d9c987fb1214a1989a00c3ac4d175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;.  <br /></td></tr>
<tr class="separator:a2b8d9c987fb1214a1989a00c3ac4d175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951855af4ae6cd241993c4f6bde82de5" id="r_a951855af4ae6cd241993c4f6bde82de5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a951855af4ae6cd241993c4f6bde82de5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a951855af4ae6cd241993c4f6bde82de5">addressof</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;)=<a class="el" href="structetl_1_1bitset.html">delete</a></td></tr>
<tr class="separator:a951855af4ae6cd241993c4f6bde82de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644b57c780b4aaa5d094ceec2f74e4de" id="r_ga644b57c780b4aaa5d094ceec2f74e4de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga644b57c780b4aaa5d094ceec2f74e4de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga644b57c780b4aaa5d094ceec2f74e4de">adjacent_difference</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:ga644b57c780b4aaa5d094ceec2f74e4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e312ccaf077fc1515c569cbd885794" id="r_ga83e312ccaf077fc1515c569cbd885794"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga83e312ccaf077fc1515c569cbd885794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga83e312ccaf077fc1515c569cbd885794">adjacent_difference</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, <a class="el" href="structetl_1_1bitset.html">BinaryOperation</a> <a class="el" href="structetl_1_1bitset.html">op</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga83e312ccaf077fc1515c569cbd885794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between the second and the first of each adjacent pair of elements of the range [first, last) and writes them to the range beginning at destination + 1. An unmodified copy of *first is written to *destination.  <br /></td></tr>
<tr class="separator:ga83e312ccaf077fc1515c569cbd885794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad815b7c902d91f337c10cb8c6876e87" id="r_gaad815b7c902d91f337c10cb8c6876e87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">It</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Distance</a> &gt; </td></tr>
<tr class="memitem:gaad815b7c902d91f337c10cb8c6876e87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gaad815b7c902d91f337c10cb8c6876e87">advance</a> (<a class="el" href="structetl_1_1bitset.html">It</a> &amp;<a class="el" href="structetl_1_1bitset.html">it</a>, <a class="el" href="structetl_1_1bitset.html">Distance</a> <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:gaad815b7c902d91f337c10cb8c6876e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments given iterator it by n elements.  <br /></td></tr>
<tr class="separator:gaad815b7c902d91f337c10cb8c6876e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410a978255250c24ca74fad8f26910d9" id="r_a410a978255250c24ca74fad8f26910d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a410a978255250c24ca74fad8f26910d9">align</a> (<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> alignment, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__iterator.html#gae8701f2e299015f92e83f375a604ef61">size</a>, <a class="el" href="structetl_1_1bitset.html">void</a> *&amp;ptr, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> &amp;<a class="el" href="structetl_1_1bitset.html">space</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">void</a> *</td></tr>
<tr class="memdesc:a410a978255250c24ca74fad8f26910d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.  <br /></td></tr>
<tr class="separator:a410a978255250c24ca74fad8f26910d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7d8fa4cd29bfaa5efc2ced210dd105" id="r_a0f7d8fa4cd29bfaa5efc2ced210dd105"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Tuple</a> &gt; </td></tr>
<tr class="memitem:a0f7d8fa4cd29bfaa5efc2ced210dd105"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f7d8fa4cd29bfaa5efc2ced210dd105">apply</a> (<a class="el" href="structetl_1_1bitset.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1bitset.html">Tuple</a> &amp;&amp;<a class="el" href="structetl_1_1bitset.html">t</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">auto</a>)</td></tr>
<tr class="separator:a0f7d8fa4cd29bfaa5efc2ced210dd105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c18e9f715e3983b7a71347ce6e0e2c1" id="r_ga0c18e9f715e3983b7a71347ce6e0e2c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga0c18e9f715e3983b7a71347ce6e0e2c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; T</td></tr>
<tr class="separator:ga0c18e9f715e3983b7a71347ce6e0e2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab9ee42ec06396333a752c794ead0bb" id="r_ga1ab9ee42ec06396333a752c794ead0bb"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:ga1ab9ee42ec06396333a752c794ead0bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga1ab9ee42ec06396333a752c794ead0bb">arg</a> (<a class="el" href="structetl_1_1bitset.html">Float</a> f) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">Float</a> &gt;</td></tr>
<tr class="separator:ga1ab9ee42ec06396333a752c794ead0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede2a350f60d965adc98d8c1ca1da6b2" id="r_gaede2a350f60d965adc98d8c1ca1da6b2"><td class="memTemplParams" colspan="2">template&lt;integral Integer&gt; </td></tr>
<tr class="memitem:gaede2a350f60d965adc98d8c1ca1da6b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gaede2a350f60d965adc98d8c1ca1da6b2">arg</a> (<a class="el" href="structetl_1_1bitset.html">Integer</a> <a class="el" href="structetl_1_1bitset.html">i</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">double</a> &gt;</td></tr>
<tr class="separator:gaede2a350f60d965adc98d8c1ca1da6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087e608dcade676ed1707b2780820b4b" id="r_a087e608dcade676ed1707b2780820b4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a087e608dcade676ed1707b2780820b4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a087e608dcade676ed1707b2780820b4b">as_const</a> (T &amp;<a class="el" href="structetl_1_1bitset.html">t</a>) noexcept -&gt; add_const_t&lt; T &gt; &amp;</td></tr>
<tr class="memdesc:a087e608dcade676ed1707b2780820b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms lvalue reference to const type of t.  <br /></td></tr>
<tr class="separator:a087e608dcade676ed1707b2780820b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fcc8395221077570ae4d49d16fdfb5" id="r_a73fcc8395221077570ae4d49d16fdfb5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a73fcc8395221077570ae4d49d16fdfb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73fcc8395221077570ae4d49d16fdfb5">as_const</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>=<a class="el" href="structetl_1_1bitset.html">delete</a></td></tr>
<tr class="separator:a73fcc8395221077570ae4d49d16fdfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdd4cbf8740ceb15439f10eee6080ee" id="r_afcdd4cbf8740ceb15439f10eee6080ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Assertion</a> &gt; </td></tr>
<tr class="memitem:afcdd4cbf8740ceb15439f10eee6080ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afcdd4cbf8740ceb15439f10eee6080ee">assert_handler</a> (<a class="el" href="structetl_1_1bitset.html">Assertion</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">msg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:afcdd4cbf8740ceb15439f10eee6080ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867798dd2ddddb86806aa99a0ae9101" id="r_ae867798dd2ddddb86806aa99a0ae9101"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N, <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae867798dd2ddddb86806aa99a0ae9101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae867798dd2ddddb86806aa99a0ae9101">assume_aligned</a> (T *ptr) -&gt; T *</td></tr>
<tr class="memdesc:ae867798dd2ddddb86806aa99a0ae9101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned.  <br /></td></tr>
<tr class="separator:ae867798dd2ddddb86806aa99a0ae9101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bf898417a69084f2e08aa12510db7d" id="r_a27bf898417a69084f2e08aa12510db7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27bf898417a69084f2e08aa12510db7d">atof</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:a27bf898417a69084f2e08aa12510db7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a27bf898417a69084f2e08aa12510db7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b33a1df966c3e01d825b336211e3ef" id="r_ae6b33a1df966c3e01d825b336211e3ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b33a1df966c3e01d825b336211e3ef">atoi</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ae6b33a1df966c3e01d825b336211e3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:ae6b33a1df966c3e01d825b336211e3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699027607c1a0d56baf456931b915e76" id="r_a699027607c1a0d56baf456931b915e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a699027607c1a0d56baf456931b915e76">atol</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a699027607c1a0d56baf456931b915e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:a699027607c1a0d56baf456931b915e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f1052e901c72fde401b3019f9437b1" id="r_aa7f1052e901c72fde401b3019f9437b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7f1052e901c72fde401b3019f9437b1">atoll</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:aa7f1052e901c72fde401b3019f9437b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value.  <br /></td></tr>
<tr class="separator:aa7f1052e901c72fde401b3019f9437b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80a7746c87d52a34bfff83262802d0d" id="r_ae80a7746c87d52a34bfff83262802d0d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:ae80a7746c87d52a34bfff83262802d0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae80a7746c87d52a34bfff83262802d0d">back_inserter</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> &amp;<a class="el" href="structetl_1_1bitset.html">container</a>) -&gt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Container</a> &gt;</td></tr>
<tr class="memdesc:ae80a7746c87d52a34bfff83262802d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">back_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">back_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:ae80a7746c87d52a34bfff83262802d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb088ae74a2ec53c8c206de329935df4" id="r_gaeb088ae74a2ec53c8c206de329935df4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:gaeb088ae74a2ec53c8c206de329935df4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gaeb088ae74a2ec53c8c206de329935df4">begin</a> (<a class="el" href="structetl_1_1bitset.html">C</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.begin())</td></tr>
<tr class="memdesc:gaeb088ae74a2ec53c8c206de329935df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the given container c or array array. These templates rely on <code>C::begin()</code> having a reasonable implementation. Returns exactly c.begin(), which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns <code>C::iterator</code> when c is not const-qualified, and <code>C::const_iterator</code> otherwise. Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="group__iterator.html#gaeb088ae74a2ec53c8c206de329935df4" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated.  <br /></td></tr>
<tr class="separator:gaeb088ae74a2ec53c8c206de329935df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67e324a8e2e3cc38ad6445c05a28ff7" id="r_gae67e324a8e2e3cc38ad6445c05a28ff7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:gae67e324a8e2e3cc38ad6445c05a28ff7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gae67e324a8e2e3cc38ad6445c05a28ff7">begin</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.begin())</td></tr>
<tr class="separator:gae67e324a8e2e3cc38ad6445c05a28ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e8d50b9cb9fdffd5bbaeedcb74d2f1" id="r_gaf8e8d50b9cb9fdffd5bbaeedcb74d2f1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:gaf8e8d50b9cb9fdffd5bbaeedcb74d2f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gaf8e8d50b9cb9fdffd5bbaeedcb74d2f1">begin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:gaf8e8d50b9cb9fdffd5bbaeedcb74d2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa615187d5a248ab9e6493944c709279e" id="r_aa615187d5a248ab9e6493944c709279e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Func</a> , typename... BoundArgs&gt; </td></tr>
<tr class="memitem:aa615187d5a248ab9e6493944c709279e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa615187d5a248ab9e6493944c709279e">bind_front</a> (<a class="el" href="structetl_1_1bitset.html">Func</a> &amp;&amp;func, <a class="el" href="structetl_1_1bitset.html">BoundArgs</a> &amp;&amp;... <a class="el" href="structetl_1_1bitset.html">boundArgs</a>)</td></tr>
<tr class="memdesc:aa615187d5a248ab9e6493944c709279e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args. In other words, bind_front(f,
bound_args...)(call_args...) is equivalent to invoke(f, bound_args..., call_args....).  <br /></td></tr>
<tr class="separator:aa615187d5a248ab9e6493944c709279e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2498c6989c510ee8806df8ac266b6305" id="r_ga2498c6989c510ee8806df8ac266b6305"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">To</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">From</a> &gt; <br />
requires (detail::bit_castable_types&lt;<a class="el" href="structetl_1_1bitset.html">To</a>, <a class="el" href="structetl_1_1bitset.html">From</a>&gt;)</td></tr>
<tr class="memitem:ga2498c6989c510ee8806df8ac266b6305"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga2498c6989c510ee8806df8ac266b6305">bit_cast</a> (<a class="el" href="structetl_1_1bitset.html">From</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">src</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">To</a></td></tr>
<tr class="memdesc:ga2498c6989c510ee8806df8ac266b6305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from.  <br /></td></tr>
<tr class="separator:ga2498c6989c510ee8806df8ac266b6305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5006351c988afecab30821e1ee41f2ed" id="r_ga5006351c988afecab30821e1ee41f2ed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga5006351c988afecab30821e1ee41f2ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga5006351c988afecab30821e1ee41f2ed">bit_ceil</a> (UInt <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga5006351c988afecab30821e1ee41f2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the smallest integral power of two that is not smaller than x. If that value is not representable in UInt, the behavior is undefined. Call to this function is permitted in constant evaluation only if the undefined behavior does not occur.  <br /></td></tr>
<tr class="separator:ga5006351c988afecab30821e1ee41f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa305e9d1d725f6dfaebce56120c9f45d" id="r_gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaa305e9d1d725f6dfaebce56120c9f45d">bit_floor</a> (UInt <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the largest integral power of two that is not greater than x. If x is zero, returns zero.  <br /></td></tr>
<tr class="separator:gaa305e9d1d725f6dfaebce56120c9f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31295beb3cd3da128d5df9392b56816" id="r_gae31295beb3cd3da128d5df9392b56816"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gae31295beb3cd3da128d5df9392b56816"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gae31295beb3cd3da128d5df9392b56816">bit_width</a> (UInt <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gae31295beb3cd3da128d5df9392b56816"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the number of bits needed to store the value x, that is, 1+⌊log2(x)⌋. If x is zero, returns zero.  <br /></td></tr>
<tr class="separator:gae31295beb3cd3da128d5df9392b56816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1617ac5647781dfed036ade2fdb9c8" id="r_ga7a1617ac5647781dfed036ade2fdb9c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debugging.html#ga7a1617ac5647781dfed036ade2fdb9c8">breakpoint</a> () noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga7a1617ac5647781dfed036ade2fdb9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditional breakpoint: attempts to temporarily halt the execution of the program and transfer control to the debugger.  <br /></td></tr>
<tr class="separator:ga7a1617ac5647781dfed036ade2fdb9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a2659c0357fb2180dab051dfe348eb" id="r_gad9a2659c0357fb2180dab051dfe348eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debugging.html#gad9a2659c0357fb2180dab051dfe348eb">breakpoint_if_debugging</a> () noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:gad9a2659c0357fb2180dab051dfe348eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional breakpoint: attempts to temporarily halt the execution of the program and transfer control to the debugger if it were able to determine that the debugger is present. Acts as a no-op otherwise.  <br /></td></tr>
<tr class="separator:gad9a2659c0357fb2180dab051dfe348eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cd46acc36e47b8dd8e0db497b856cb" id="r_ga56cd46acc36e47b8dd8e0db497b856cb"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:ga56cd46acc36e47b8dd8e0db497b856cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga56cd46acc36e47b8dd8e0db497b856cb">byteswap</a> (<a class="el" href="structetl_1_1bitset.html">Int</a> val) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a></td></tr>
<tr class="memdesc:ga56cd46acc36e47b8dd8e0db497b856cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the bytes in the given integer value n.  <br /></td></tr>
<tr class="separator:ga56cd46acc36e47b8dd8e0db497b856cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ff9f99fa557857de8d9e6a4829d752" id="r_gab8ff9f99fa557857de8d9e6a4829d752"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:gab8ff9f99fa557857de8d9e6a4829d752"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gab8ff9f99fa557857de8d9e6a4829d752">cbegin</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) noexcept(noexcept(<a class="el" href="group__iterator.html#gaeb088ae74a2ec53c8c206de329935df4">begin</a>(c))) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="group__iterator.html#gaeb088ae74a2ec53c8c206de329935df4">begin</a>(c))</td></tr>
<tr class="separator:gab8ff9f99fa557857de8d9e6a4829d752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab385b9f70c785ceb3a5b986f745ca81d" id="r_gab385b9f70c785ceb3a5b986f745ca81d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:gab385b9f70c785ceb3a5b986f745ca81d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gab385b9f70c785ceb3a5b986f745ca81d">cend</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) noexcept(noexcept(<a class="el" href="group__iterator.html#gaa26698de685cc42e99c0c560d05ca93c">end</a>(c))) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="group__iterator.html#gaa26698de685cc42e99c0c560d05ca93c">end</a>(c))</td></tr>
<tr class="separator:gab385b9f70c785ceb3a5b986f745ca81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc67214aa9016de19ce8c56cacf050f" id="r_affc67214aa9016de19ce8c56cacf050f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:affc67214aa9016de19ce8c56cacf050f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affc67214aa9016de19ce8c56cacf050f">cmp_equal</a> (T <a class="el" href="structetl_1_1bitset.html">t</a>, U <a class="el" href="structetl_1_1bitset.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:affc67214aa9016de19ce8c56cacf050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:affc67214aa9016de19ce8c56cacf050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f8a2ce45cfed83d620b12d6271272f" id="r_ad7f8a2ce45cfed83d620b12d6271272f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:ad7f8a2ce45cfed83d620b12d6271272f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7f8a2ce45cfed83d620b12d6271272f">cmp_greater</a> (T <a class="el" href="structetl_1_1bitset.html">t</a>, U <a class="el" href="structetl_1_1bitset.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ad7f8a2ce45cfed83d620b12d6271272f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:ad7f8a2ce45cfed83d620b12d6271272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdcd304a94bdadbaa2c7d6fb267e05b" id="r_a6fdcd304a94bdadbaa2c7d6fb267e05b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:a6fdcd304a94bdadbaa2c7d6fb267e05b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fdcd304a94bdadbaa2c7d6fb267e05b">cmp_greater_equal</a> (T <a class="el" href="structetl_1_1bitset.html">t</a>, U <a class="el" href="structetl_1_1bitset.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a6fdcd304a94bdadbaa2c7d6fb267e05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:a6fdcd304a94bdadbaa2c7d6fb267e05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af465587d2f32a80939be1fad202d81a8" id="r_af465587d2f32a80939be1fad202d81a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:af465587d2f32a80939be1fad202d81a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af465587d2f32a80939be1fad202d81a8">cmp_less</a> (T <a class="el" href="structetl_1_1bitset.html">t</a>, U <a class="el" href="structetl_1_1bitset.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:af465587d2f32a80939be1fad202d81a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:af465587d2f32a80939be1fad202d81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae910ff92e0c20546b3798e7acf0f62a4" id="r_ae910ff92e0c20546b3798e7acf0f62a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:ae910ff92e0c20546b3798e7acf0f62a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae910ff92e0c20546b3798e7acf0f62a4">cmp_less_equal</a> (T <a class="el" href="structetl_1_1bitset.html">t</a>, U <a class="el" href="structetl_1_1bitset.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ae910ff92e0c20546b3798e7acf0f62a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:ae910ff92e0c20546b3798e7acf0f62a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693945b83d4561846bbf0b5944d0296e" id="r_a693945b83d4561846bbf0b5944d0296e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</td></tr>
<tr class="memitem:a693945b83d4561846bbf0b5944d0296e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a693945b83d4561846bbf0b5944d0296e">cmp_not_equal</a> (T <a class="el" href="structetl_1_1bitset.html">t</a>, U <a class="el" href="structetl_1_1bitset.html">u</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a693945b83d4561846bbf0b5944d0296e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <br /></td></tr>
<tr class="separator:a693945b83d4561846bbf0b5944d0296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdff3d2b9cf188d6aa0ab6981b9b2463" id="r_gacdff3d2b9cf188d6aa0ab6981b9b2463"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gacdff3d2b9cf188d6aa0ab6981b9b2463"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gacdff3d2b9cf188d6aa0ab6981b9b2463">conj</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gacdff3d2b9cf188d6aa0ab6981b9b2463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9041e83e16d94cac9b790e1702f4265" id="r_gad9041e83e16d94cac9b790e1702f4265"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:gad9041e83e16d94cac9b790e1702f4265"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gad9041e83e16d94cac9b790e1702f4265">conj</a> (<a class="el" href="structetl_1_1bitset.html">Float</a> f) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">Float</a> &gt;</td></tr>
<tr class="separator:gad9041e83e16d94cac9b790e1702f4265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac231e4f9522b79e03e8595f296e13ff4" id="r_gac231e4f9522b79e03e8595f296e13ff4"><td class="memTemplParams" colspan="2">template&lt;integral Integer&gt; </td></tr>
<tr class="memitem:gac231e4f9522b79e03e8595f296e13ff4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac231e4f9522b79e03e8595f296e13ff4">conj</a> (<a class="el" href="structetl_1_1bitset.html">Integer</a> <a class="el" href="structetl_1_1bitset.html">i</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">double</a> &gt;</td></tr>
<tr class="separator:gac231e4f9522b79e03e8595f296e13ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ec2df5d7caffa501049e08c135fc1" id="r_a7f5ec2df5d7caffa501049e08c135fc1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args, <a class="el" href="structetl_1_1bitset.html">typename</a>  = decltype(::new(etl::declval&lt;void*&gt;()) T(etl::declval&lt;Args&gt;()...))&gt; </td></tr>
<tr class="memitem:a7f5ec2df5d7caffa501049e08c135fc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f5ec2df5d7caffa501049e08c135fc1">construct_at</a> (T *p, <a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;... args) -&gt; T *</td></tr>
<tr class="memdesc:a7f5ec2df5d7caffa501049e08c135fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a T object initialized with arguments args... at given address p.  <br /></td></tr>
<tr class="separator:a7f5ec2df5d7caffa501049e08c135fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9b625e56c5ddcc87c1b813687215cd" id="r_ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga9f9b625e56c5ddcc87c1b813687215cd">copy</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:ga9f9b625e56c5ddcc87c1b813687215cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3807f7eadedf61cbd5fcbed1fd59d087" id="r_ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt2</a> &gt; </td></tr>
<tr class="memitem:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga3807f7eadedf61cbd5fcbed1fd59d087">copy_backward</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt1</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt1</a> last, <a class="el" href="structetl_1_1bitset.html">BidirIt2</a> <a class="el" href="structetl_1_1bitset.html">dLast</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">BidirIt2</a></td></tr>
<tr class="memdesc:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by <code>[first, last)</code>, to another range ending at <code>dLast</code>. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:ga3807f7eadedf61cbd5fcbed1fd59d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed613dd207fcb8dad486fd471d90af0" id="r_ga0ed613dd207fcb8dad486fd471d90af0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Pred</a> &gt; </td></tr>
<tr class="memitem:ga0ed613dd207fcb8dad486fd471d90af0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga0ed613dd207fcb8dad486fd471d90af0">copy_if</a> (<a class="el" href="structetl_1_1bitset.html">InIt</a> first, <a class="el" href="structetl_1_1bitset.html">InIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutIt</a> <a class="el" href="structetl_1_1bitset.html">dFirst</a>, <a class="el" href="structetl_1_1bitset.html">Pred</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutIt</a></td></tr>
<tr class="memdesc:ga0ed613dd207fcb8dad486fd471d90af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by <code>[first, last)</code>, to another range beginning at destination.  <br /></td></tr>
<tr class="separator:ga0ed613dd207fcb8dad486fd471d90af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae848a2fb9566a7471c52d02d108a87e6" id="r_gae848a2fb9566a7471c52d02d108a87e6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Size</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:gae848a2fb9566a7471c52d02d108a87e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gae848a2fb9566a7471c52d02d108a87e6">copy_n</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">Size</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">result</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:gae848a2fb9566a7471c52d02d108a87e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer <code>0 &lt;= i &lt; count</code>, performs <code>*(result + i) = *(first + i)</code>. Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <br /></td></tr>
<tr class="separator:gae848a2fb9566a7471c52d02d108a87e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7510fce65931a22907d309fb6276e0f" id="r_gac7510fce65931a22907d309fb6276e0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gac7510fce65931a22907d309fb6276e0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac7510fce65931a22907d309fb6276e0f">cos</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gac7510fce65931a22907d309fb6276e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23006d21b437c40597aaee7a84424b7" id="r_gac23006d21b437c40597aaee7a84424b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gac23006d21b437c40597aaee7a84424b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac23006d21b437c40597aaee7a84424b7">cosh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gac23006d21b437c40597aaee7a84424b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf27092e22460faafdb958cac56c6fec" id="r_gacf27092e22460faafdb958cac56c6fec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gacf27092e22460faafdb958cac56c6fec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1bitset.html">InputIt</a> &gt;::difference_type</td></tr>
<tr class="memdesc:gacf27092e22460faafdb958cac56c6fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts the elements that are equal to value.  <br /></td></tr>
<tr class="separator:gacf27092e22460faafdb958cac56c6fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf36ef6fdcb46c9ad8060d4520016096" id="r_gadf36ef6fdcb46c9ad8060d4520016096"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gadf36ef6fdcb46c9ad8060d4520016096"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gadf36ef6fdcb46c9ad8060d4520016096">count_if</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1bitset.html">InputIt</a> &gt;::difference_type</td></tr>
<tr class="memdesc:gadf36ef6fdcb46c9ad8060d4520016096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range <code>[first, last)</code> satisfying specific criteria. Counts elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:gadf36ef6fdcb46c9ad8060d4520016096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ff4047b7f7215764870239e29f7647" id="r_gaa8ff4047b7f7215764870239e29f7647"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa8ff4047b7f7215764870239e29f7647"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaa8ff4047b7f7215764870239e29f7647">countl_one</a> (UInt <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gaa8ff4047b7f7215764870239e29f7647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left").  <br /></td></tr>
<tr class="separator:gaa8ff4047b7f7215764870239e29f7647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120e955a7d833bee8e6c68c6a5639ca3" id="r_ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga120e955a7d833bee8e6c68c6a5639ca3">countl_zero</a> (UInt <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left").  <br /></td></tr>
<tr class="separator:ga120e955a7d833bee8e6c68c6a5639ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e62f92367cf6ac4c456e52924e0814" id="r_gac7e62f92367cf6ac4c456e52924e0814"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gac7e62f92367cf6ac4c456e52924e0814"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gac7e62f92367cf6ac4c456e52924e0814">countr_one</a> (UInt <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gac7e62f92367cf6ac4c456e52924e0814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 bits in the value of x, starting from the least significant bit ("right").  <br /></td></tr>
<tr class="separator:gac7e62f92367cf6ac4c456e52924e0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a2e4bffa2cb54b6a5b018cbe2724690" id="r_ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga8a2e4bffa2cb54b6a5b018cbe2724690">countr_zero</a> (UInt <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the least significant bit ("right").  <br /></td></tr>
<tr class="separator:ga8a2e4bffa2cb54b6a5b018cbe2724690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111d4cb9659c433d9702a48913416699" id="r_ga111d4cb9659c433d9702a48913416699"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:ga111d4cb9659c433d9702a48913416699"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga111d4cb9659c433d9702a48913416699">crbegin</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="group__iterator.html#gaef0e9ff3b7516f90525a93acb5fccc8e">rbegin</a>(c))</td></tr>
<tr class="separator:ga111d4cb9659c433d9702a48913416699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dede0554b7d9e1163a2be7f26702258" id="r_a3dede0554b7d9e1163a2be7f26702258"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3dede0554b7d9e1163a2be7f26702258"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3dede0554b7d9e1163a2be7f26702258">cref</a> (<a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T <a class="el" href="structetl_1_1bitset.html">const</a> &gt;</td></tr>
<tr class="separator:a3dede0554b7d9e1163a2be7f26702258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ad6e6c525e1d3fb61aa60cab9f9dc3" id="r_af5ad6e6c525e1d3fb61aa60cab9f9dc3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af5ad6e6c525e1d3fb61aa60cab9f9dc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5ad6e6c525e1d3fb61aa60cab9f9dc3">cref</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;)=<a class="el" href="structetl_1_1bitset.html">delete</a></td></tr>
<tr class="separator:af5ad6e6c525e1d3fb61aa60cab9f9dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ebab5fc63c081909c10f9255347efb" id="r_a09ebab5fc63c081909c10f9255347efb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a09ebab5fc63c081909c10f9255347efb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09ebab5fc63c081909c10f9255347efb">cref</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T <a class="el" href="structetl_1_1bitset.html">const</a> &gt;</td></tr>
<tr class="memdesc:a09ebab5fc63c081909c10f9255347efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. module Utility.  <br /></td></tr>
<tr class="separator:a09ebab5fc63c081909c10f9255347efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4853c0824b6cd2040223f031d427fab" id="r_gac4853c0824b6cd2040223f031d427fab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:gac4853c0824b6cd2040223f031d427fab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gac4853c0824b6cd2040223f031d427fab">crend</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="group__iterator.html#gab55d22696b4d22653a103d0726157a18">rend</a>(c))</td></tr>
<tr class="memdesc:gac4853c0824b6cd2040223f031d427fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-end of the given container.  <br /></td></tr>
<tr class="separator:gac4853c0824b6cd2040223f031d427fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22f9a30542666ba39fdc715089588b3" id="r_gac22f9a30542666ba39fdc715089588b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:gac22f9a30542666ba39fdc715089588b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gac22f9a30542666ba39fdc715089588b3">data</a> (<a class="el" href="structetl_1_1bitset.html">C</a> &amp;c) noexcept(noexcept(c.data())) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.data())</td></tr>
<tr class="memdesc:gac22f9a30542666ba39fdc715089588b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the block of memory containing the elements of the container.  <br /></td></tr>
<tr class="separator:gac22f9a30542666ba39fdc715089588b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525de672ed02219aff7c50e11401eb92" id="r_ga525de672ed02219aff7c50e11401eb92"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:ga525de672ed02219aff7c50e11401eb92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga525de672ed02219aff7c50e11401eb92">data</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) noexcept(noexcept(c.data())) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.data())</td></tr>
<tr class="separator:ga525de672ed02219aff7c50e11401eb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae957b7252fd3e8ed42a5ed5e4e745fcd" id="r_gae957b7252fd3e8ed42a5ed5e4e745fcd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:gae957b7252fd3e8ed42a5ed5e4e745fcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gae957b7252fd3e8ed42a5ed5e4e745fcd">data</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:gae957b7252fd3e8ed42a5ed5e4e745fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634128d2b51dd1677291370fa7276399" id="r_ga634128d2b51dd1677291370fa7276399"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga634128d2b51dd1677291370fa7276399"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ranges.html#ga634128d2b51dd1677291370fa7276399">decay_copy</a> (T &amp;&amp;<a class="el" href="structetl_1_1bitset.html">t</a>) noexcept(<a class="el" href="#af70f6258c3e925eeb2d27b652374660d">is_nothrow_convertible_v</a>&lt; T, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; T &gt; &gt;) -&gt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; T &gt;</td></tr>
<tr class="separator:ga634128d2b51dd1677291370fa7276399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b47f7719fd7b8373b49b15d5f701fb" id="r_a22b47f7719fd7b8373b49b15d5f701fb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a22b47f7719fd7b8373b49b15d5f701fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">declval</a> () noexcept -&gt; add_rvalue_reference_t&lt; T &gt;</td></tr>
<tr class="separator:a22b47f7719fd7b8373b49b15d5f701fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad349bf22ae9342501dceb73d04bfcb7e" id="r_ad349bf22ae9342501dceb73d04bfcb7e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ad349bf22ae9342501dceb73d04bfcb7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad349bf22ae9342501dceb73d04bfcb7e">destroy</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ad349bf22ae9342501dceb73d04bfcb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the objects in the range [first, last).  <br /></td></tr>
<tr class="separator:ad349bf22ae9342501dceb73d04bfcb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14a8af642cc7dc92cca033c1eff9fad" id="r_ae14a8af642cc7dc92cca033c1eff9fad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae14a8af642cc7dc92cca033c1eff9fad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae14a8af642cc7dc92cca033c1eff9fad">destroy_at</a> (T *p) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ae14a8af642cc7dc92cca033c1eff9fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling destroy(begin(*p), end(*p)).  <br /></td></tr>
<tr class="separator:ae14a8af642cc7dc92cca033c1eff9fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9f1ed59c6342c3bcd7f4ed746a0dda" id="r_a6d9f1ed59c6342c3bcd7f4ed746a0dda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Size</a> &gt; </td></tr>
<tr class="memitem:a6d9f1ed59c6342c3bcd7f4ed746a0dda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d9f1ed59c6342c3bcd7f4ed746a0dda">destroy_n</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">Size</a> <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:a6d9f1ed59c6342c3bcd7f4ed746a0dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the n objects in the range starting at first.  <br /></td></tr>
<tr class="separator:a6d9f1ed59c6342c3bcd7f4ed746a0dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba994bcf39b8b428fec5852ea0cc728c" id="r_gaba994bcf39b8b428fec5852ea0cc728c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">It</a> &gt; </td></tr>
<tr class="memitem:gaba994bcf39b8b428fec5852ea0cc728c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gaba994bcf39b8b428fec5852ea0cc728c">distance</a> (<a class="el" href="structetl_1_1bitset.html">It</a> first, <a class="el" href="structetl_1_1bitset.html">It</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1bitset.html">It</a> &gt;::difference_type</td></tr>
<tr class="memdesc:gaba994bcf39b8b428fec5852ea0cc728c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of hops from first to last.  <br /></td></tr>
<tr class="separator:gaba994bcf39b8b428fec5852ea0cc728c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2d6bdea1596be40cc1f1965d14d3a7" id="r_a2a2d6bdea1596be40cc1f1965d14d3a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a2d6bdea1596be40cc1f1965d14d3a7">div</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">int</a> y) noexcept -&gt; <a class="el" href="structetl_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:a2a2d6bdea1596be40cc1f1965d14d3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a2a2d6bdea1596be40cc1f1965d14d3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6482fb76727697ae2e8c3d2da7de28d7" id="r_a6482fb76727697ae2e8c3d2da7de28d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6482fb76727697ae2e8c3d2da7de28d7">div</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:a6482fb76727697ae2e8c3d2da7de28d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a6482fb76727697ae2e8c3d2da7de28d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe969af8a9f77fea0bb9e0d7a82c5b3f" id="r_afe969af8a9f77fea0bb9e0d7a82c5b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe969af8a9f77fea0bb9e0d7a82c5b3f">div</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:afe969af8a9f77fea0bb9e0d7a82c5b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:afe969af8a9f77fea0bb9e0d7a82c5b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga314873517bdae4e131a403c322a9763f" id="r_ga314873517bdae4e131a403c322a9763f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:ga314873517bdae4e131a403c322a9763f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga314873517bdae4e131a403c322a9763f">empty</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) noexcept(noexcept(c.empty())) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.empty())</td></tr>
<tr class="memdesc:ga314873517bdae4e131a403c322a9763f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is empty.  <br /></td></tr>
<tr class="separator:ga314873517bdae4e131a403c322a9763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7550de636fcc027498049a1d22c7bc9" id="r_gad7550de636fcc027498049a1d22c7bc9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:gad7550de636fcc027498049a1d22c7bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gad7550de636fcc027498049a1d22c7bc9">empty</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">N</a>]) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gad7550de636fcc027498049a1d22c7bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is empty.  <br /></td></tr>
<tr class="separator:gad7550de636fcc027498049a1d22c7bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa26698de685cc42e99c0c560d05ca93c" id="r_gaa26698de685cc42e99c0c560d05ca93c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:gaa26698de685cc42e99c0c560d05ca93c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gaa26698de685cc42e99c0c560d05ca93c">end</a> (<a class="el" href="structetl_1_1bitset.html">C</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.end())</td></tr>
<tr class="memdesc:gaa26698de685cc42e99c0c560d05ca93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on.  <br /></td></tr>
<tr class="separator:gaa26698de685cc42e99c0c560d05ca93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364b7fbf24361dad9b16ea5968b95c42" id="r_ga364b7fbf24361dad9b16ea5968b95c42"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:ga364b7fbf24361dad9b16ea5968b95c42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga364b7fbf24361dad9b16ea5968b95c42">end</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.end())</td></tr>
<tr class="separator:ga364b7fbf24361dad9b16ea5968b95c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7e5135fa0834bba2c1b028850ba144" id="r_gafa7e5135fa0834bba2c1b028850ba144"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:gafa7e5135fa0834bba2c1b028850ba144"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gafa7e5135fa0834bba2c1b028850ba144">end</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">N</a>]) noexcept -&gt; T *</td></tr>
<tr class="separator:gafa7e5135fa0834bba2c1b028850ba144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fb0dac9928f1cf33cc07f069cac971" id="r_ga13fb0dac9928f1cf33cc07f069cac971"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:ga13fb0dac9928f1cf33cc07f069cac971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga13fb0dac9928f1cf33cc07f069cac971">equal</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga13fb0dac9928f1cf33cc07f069cac971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb7da13869cc2911d1dd3ebfbc49681" id="r_ga8cb7da13869cc2911d1dd3ebfbc49681"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:ga8cb7da13869cc2911d1dd3ebfbc49681"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga8cb7da13869cc2911d1dd3ebfbc49681">equal</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga8cb7da13869cc2911d1dd3ebfbc49681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79340eb0330b4f112afc47f71e3d844" id="r_gab79340eb0330b4f112afc47f71e3d844"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gab79340eb0330b4f112afc47f71e3d844"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gab79340eb0330b4f112afc47f71e3d844">equal</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gab79340eb0330b4f112afc47f71e3d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a8919c2c9cca7f4eb38f2199797c37" id="r_gad2a8919c2c9cca7f4eb38f2199797c37"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gad2a8919c2c9cca7f4eb38f2199797c37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gad2a8919c2c9cca7f4eb38f2199797c37">equal</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gad2a8919c2c9cca7f4eb38f2199797c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range <code>[first1, last1)</code> is equal to the range <code>[first2, first2 + (last1 - first1))</code>, and false otherwise.  <br /></td></tr>
<tr class="separator:gad2a8919c2c9cca7f4eb38f2199797c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7225526a11c7ee4454afce37e9bfd031" id="r_ga7225526a11c7ee4454afce37e9bfd031"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga7225526a11c7ee4454afce37e9bfd031"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7225526a11c7ee4454afce37e9bfd031">equal_range</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt;</td></tr>
<tr class="separator:ga7225526a11c7ee4454afce37e9bfd031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0065deb93b945a04f6875db16eba3fd3" id="r_ga0065deb93b945a04f6875db16eba3fd3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga0065deb93b945a04f6875db16eba3fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga0065deb93b945a04f6875db16eba3fd3">equal_range</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:ga0065deb93b945a04f6875db16eba3fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga0065deb93b945a04f6875db16eba3fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0457bf90404832209a27ed391d14e9f" id="r_ad0457bf90404832209a27ed391d14e9f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ad0457bf90404832209a27ed391d14e9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0457bf90404832209a27ed391d14e9f">erase</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &amp;c, U <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;::size_type</td></tr>
<tr class="memdesc:ad0457bf90404832209a27ed391d14e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that compare equal to value from the container.  <br /></td></tr>
<tr class="separator:ad0457bf90404832209a27ed391d14e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e72fc74a7231310049a5cb0790c765" id="r_ab2e72fc74a7231310049a5cb0790c765"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ab2e72fc74a7231310049a5cb0790c765"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2e72fc74a7231310049a5cb0790c765">erase</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; &amp;c, U <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt;::size_type</td></tr>
<tr class="separator:ab2e72fc74a7231310049a5cb0790c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5826b2aecc2787206e14b1db8db393f" id="r_ad5826b2aecc2787206e14b1db8db393f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ad5826b2aecc2787206e14b1db8db393f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5826b2aecc2787206e14b1db8db393f">erase_if</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &amp;c, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;::size_type</td></tr>
<tr class="memdesc:ad5826b2aecc2787206e14b1db8db393f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container.  <br /></td></tr>
<tr class="separator:ad5826b2aecc2787206e14b1db8db393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89568833148c25f186a180cef490087" id="r_ad89568833148c25f186a180cef490087"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Pred</a> &gt; </td></tr>
<tr class="memitem:ad89568833148c25f186a180cef490087"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad89568833148c25f186a180cef490087">erase_if</a> (<a class="el" href="structetl_1_1flat__set.html">etl::flat_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Container</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; &amp;c, <a class="el" href="structetl_1_1bitset.html">Pred</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1flat__set.html">etl::flat_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Container</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt;::size_type</td></tr>
<tr class="separator:ad89568833148c25f186a180cef490087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae66b21dd10f996a2782e6e8b604593" id="r_a9ae66b21dd10f996a2782e6e8b604593"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a9ae66b21dd10f996a2782e6e8b604593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ae66b21dd10f996a2782e6e8b604593">erase_if</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; &amp;c, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt;::size_type</td></tr>
<tr class="memdesc:a9ae66b21dd10f996a2782e6e8b604593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements that satisfy the predicate pred from the container.  <br /></td></tr>
<tr class="separator:a9ae66b21dd10f996a2782e6e8b604593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1576e57ae3b113a38b8a9793bb4074" id="r_a7c1576e57ae3b113a38b8a9793bb4074"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U  = T&gt; </td></tr>
<tr class="memitem:a7c1576e57ae3b113a38b8a9793bb4074"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c1576e57ae3b113a38b8a9793bb4074">exchange</a> (T &amp;<a class="el" href="structetl_1_1bitset.html">obj</a>, U &amp;&amp;<a class="el" href="structetl_1_1bitset.html">newValue</a>) noexcept(<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="#ac0c249b3afd84019ec11170a1e06d267">etl::is_nothrow_assignable_v</a>&lt; T &amp;, U &gt;) -&gt; T</td></tr>
<tr class="memdesc:a7c1576e57ae3b113a38b8a9793bb4074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the value of obj with new_value and returns the old value of obj.  <br /></td></tr>
<tr class="separator:a7c1576e57ae3b113a38b8a9793bb4074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9378dad55c6bc1835467e35f3d096808" id="r_ga9378dad55c6bc1835467e35f3d096808"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ga9378dad55c6bc1835467e35f3d096808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga9378dad55c6bc1835467e35f3d096808">exchange_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga9378dad55c6bc1835467e35f3d096808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga9378dad55c6bc1835467e35f3d096808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d64a767f3a1408540f8d99f0da4cf68" id="r_ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4d64a767f3a1408540f8d99f0da4cf68">exchange_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga4d64a767f3a1408540f8d99f0da4cf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8161915e533ff99801f4017d6737d978" id="r_a8161915e533ff99801f4017d6737d978"><td class="memTemplParams" colspan="2">template&lt;typename... Integrals&gt; <br />
requires (<a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">etl::is_convertible_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">Integrals</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&gt; <a class="el" href="structetl_1_1bitset.html">and</a> ...)</td></tr>
<tr class="memitem:a8161915e533ff99801f4017d6737d978"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8161915e533ff99801f4017d6737d978">extents</a> (Integrals...) -&gt; extents&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>((<a class="el" href="structetl_1_1bitset.html">Integrals</a>(), <a class="el" href="group__span.html#ga22e7be40fea564f0c1fe3d11229ef0f8">etl::dynamic_extent</a>))... &gt;</td></tr>
<tr class="separator:a8161915e533ff99801f4017d6737d978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2dd0f4e4c727042a49eb7a07534b4d" id="r_abc2dd0f4e4c727042a49eb7a07534b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc2dd0f4e4c727042a49eb7a07534b4d">fabs</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:abc2dd0f4e4c727042a49eb7a07534b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1cf30946e4d50ba41f9328a82e2e62" id="r_aad1cf30946e4d50ba41f9328a82e2e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad1cf30946e4d50ba41f9328a82e2e62">fabs</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:aad1cf30946e4d50ba41f9328a82e2e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fbc2879eaeb897fcaf8de7bd117125" id="r_af3fbc2879eaeb897fcaf8de7bd117125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3fbc2879eaeb897fcaf8de7bd117125">fabs</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:af3fbc2879eaeb897fcaf8de7bd117125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9183bd4ec44e90e6830581cf15f8d165" id="r_a9183bd4ec44e90e6830581cf15f8d165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9183bd4ec44e90e6830581cf15f8d165">fabsf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:a9183bd4ec44e90e6830581cf15f8d165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01976f0c02d8a34fad11dff21277f288" id="r_a01976f0c02d8a34fad11dff21277f288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01976f0c02d8a34fad11dff21277f288">fabsl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:a01976f0c02d8a34fad11dff21277f288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7166349fd110372de5c865fe5767f97" id="r_gad7166349fd110372de5c865fe5767f97"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gad7166349fd110372de5c865fe5767f97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gad7166349fd110372de5c865fe5767f97">fill</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:gad7166349fd110372de5c865fe5767f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gad7166349fd110372de5c865fe5767f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae52b4d387889126b64b88ca2150c6ddc" id="r_gae52b4d387889126b64b88ca2150c6ddc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Size</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gae52b4d387889126b64b88ca2150c6ddc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gae52b4d387889126b64b88ca2150c6ddc">fill_n</a> (<a class="el" href="structetl_1_1bitset.html">OutputIt</a> first, <a class="el" href="structetl_1_1bitset.html">Size</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:gae52b4d387889126b64b88ca2150c6ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the first count elements in the range beginning at <code>first</code> if <code>count &gt; 0</code>. Does nothing otherwise.  <br /></td></tr>
<tr class="separator:gae52b4d387889126b64b88ca2150c6ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf123f494fccf3d1e9420928c32915189" id="r_gaf123f494fccf3d1e9420928c32915189"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaf123f494fccf3d1e9420928c32915189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaf123f494fccf3d1e9420928c32915189">find</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">InputIt</a></td></tr>
<tr class="memdesc:gaf123f494fccf3d1e9420928c32915189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element equal to value.  <br /></td></tr>
<tr class="separator:gaf123f494fccf3d1e9420928c32915189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3668f0480d1f8d6976de08b3658eb97e" id="r_ga3668f0480d1f8d6976de08b3658eb97e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:ga3668f0480d1f8d6976de08b3658eb97e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga3668f0480d1f8d6976de08b3658eb97e">find_end</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> <a class="el" href="structetl_1_1bitset.html">sFirst</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> <a class="el" href="structetl_1_1bitset.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a></td></tr>
<tr class="separator:ga3668f0480d1f8d6976de08b3658eb97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ba00834faefda2a3d9b112d053f889" id="r_ga99ba00834faefda2a3d9b112d053f889"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga99ba00834faefda2a3d9b112d053f889"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga99ba00834faefda2a3d9b112d053f889">find_end</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> <a class="el" href="structetl_1_1bitset.html">sFirst</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> <a class="el" href="structetl_1_1bitset.html">sLast</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a></td></tr>
<tr class="memdesc:ga99ba00834faefda2a3d9b112d053f889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of the sequence [sFirst, sLast) in the range <code>[first, last)</code>. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga99ba00834faefda2a3d9b112d053f889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74fd28c3677d3bebf66460a3e492f3c0" id="r_ga74fd28c3677d3bebf66460a3e492f3c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga74fd28c3677d3bebf66460a3e492f3c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga74fd28c3677d3bebf66460a3e492f3c0">find_first_of</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> <a class="el" href="structetl_1_1bitset.html">sFirst</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> <a class="el" href="structetl_1_1bitset.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">InputIt</a></td></tr>
<tr class="memdesc:ga74fd28c3677d3bebf66460a3e492f3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast).  <br /></td></tr>
<tr class="separator:ga74fd28c3677d3bebf66460a3e492f3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac49fa522ef832adfa9ebb8c4592ca60" id="r_gaac49fa522ef832adfa9ebb8c4592ca60"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gaac49fa522ef832adfa9ebb8c4592ca60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaac49fa522ef832adfa9ebb8c4592ca60">find_first_of</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> <a class="el" href="structetl_1_1bitset.html">sFirst</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> <a class="el" href="structetl_1_1bitset.html">sLast</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">InputIt</a></td></tr>
<tr class="memdesc:gaac49fa522ef832adfa9ebb8c4592ca60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for any of the elements in the range [sFirst, sLast). Elements are compared using the given binary predicate pred.  <br /></td></tr>
<tr class="separator:gaac49fa522ef832adfa9ebb8c4592ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214a2898fc2820379237f4cc89e3249f" id="r_ga214a2898fc2820379237f4cc89e3249f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga214a2898fc2820379237f4cc89e3249f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga214a2898fc2820379237f4cc89e3249f">find_if</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">InputIt</a></td></tr>
<tr class="memdesc:ga214a2898fc2820379237f4cc89e3249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate p returns true.  <br /></td></tr>
<tr class="separator:ga214a2898fc2820379237f4cc89e3249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd10eb98eb927ed2e7efb96bbbebac30" id="r_gabd10eb98eb927ed2e7efb96bbbebac30"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gabd10eb98eb927ed2e7efb96bbbebac30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gabd10eb98eb927ed2e7efb96bbbebac30">find_if_not</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">InputIt</a></td></tr>
<tr class="memdesc:gabd10eb98eb927ed2e7efb96bbbebac30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate q returns false.  <br /></td></tr>
<tr class="separator:gabd10eb98eb927ed2e7efb96bbbebac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e24662e346fc90c79dc7023e66ebd6d" id="r_ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga7e24662e346fc90c79dc7023e66ebd6d">flip_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip bit at position Pos.  <br /></td></tr>
<tr class="separator:ga7e24662e346fc90c79dc7023e66ebd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83522e02ec5bafd96be4cbdd71c207ae" id="r_ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga83522e02ec5bafd96be4cbdd71c207ae">flip_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>, UInt <a class="el" href="structetl_1_1bitset.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga83522e02ec5bafd96be4cbdd71c207ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14fe21109f4f9d8ce7a3364bb45e9eae" id="r_ga14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">UnaryFunc</a> &gt; </td></tr>
<tr class="memitem:ga14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga14fe21109f4f9d8ce7a3364bb45e9eae">for_each</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">UnaryFunc</a> f) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">UnaryFunc</a></td></tr>
<tr class="memdesc:ga14fe21109f4f9d8ce7a3364bb45e9eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, last)</code> in order.  <br /></td></tr>
<tr class="separator:ga14fe21109f4f9d8ce7a3364bb45e9eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef3395c26e44857cb21437ffbd285e7" id="r_ga5ef3395c26e44857cb21437ffbd285e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Size</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">UnaryFunc</a> &gt; </td></tr>
<tr class="memitem:ga5ef3395c26e44857cb21437ffbd285e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5ef3395c26e44857cb21437ffbd285e7">for_each_n</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">Size</a> <a class="el" href="structetl_1_1bitset.html">n</a>, <a class="el" href="structetl_1_1bitset.html">UnaryFunc</a> f) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">InputIt</a></td></tr>
<tr class="memdesc:ga5ef3395c26e44857cb21437ffbd285e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range <code>[first, first + n]</code> in order.  <br /></td></tr>
<tr class="separator:ga5ef3395c26e44857cb21437ffbd285e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142c844e65677a96dcb134681d85e8a2" id="r_a142c844e65677a96dcb134681d85e8a2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a142c844e65677a96dcb134681d85e8a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a142c844e65677a96dcb134681d85e8a2">format_to</a> (<a class="el" href="structetl_1_1bitset.html">OutputIt</a> out, <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1bitset.html">fmt</a>, <a class="el" href="structetl_1_1bitset.html">Args</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;... args) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:a142c844e65677a96dcb134681d85e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and write the result to the output iterator out.  <br /></td></tr>
<tr class="separator:a142c844e65677a96dcb134681d85e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2b8092a29056d823a289eb08a11484" id="r_afa2b8092a29056d823a289eb08a11484"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIter</a> , typename... Args&gt; </td></tr>
<tr class="memitem:afa2b8092a29056d823a289eb08a11484"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa2b8092a29056d823a289eb08a11484">format_to_n</a> (<a class="el" href="structetl_1_1bitset.html">OutputIter</a> out, <a class="el" href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">diff_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">OutputIter</a> &gt; <a class="el" href="structetl_1_1bitset.html">n</a>, <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1bitset.html">fmt</a>, <a class="el" href="structetl_1_1bitset.html">Args</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;... args) -&gt; <a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a>&lt; <a class="el" href="structetl_1_1bitset.html">OutputIter</a> &gt;</td></tr>
<tr class="memdesc:afa2b8092a29056d823a289eb08a11484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format args according to the format string fmt, and write the result to the output iterator out. At most n characters are written.  <br /></td></tr>
<tr class="separator:afa2b8092a29056d823a289eb08a11484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7e67893a6b3c341ea0624e30e1d89d" id="r_a6a7e67893a6b3c341ea0624e30e1d89d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6a7e67893a6b3c341ea0624e30e1d89d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a7e67893a6b3c341ea0624e30e1d89d">forward</a> (<a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt; T &gt; &amp;&amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="separator:a6a7e67893a6b3c341ea0624e30e1d89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea04c6a544a650bcf6a7f88ff623c80f" id="r_aea04c6a544a650bcf6a7f88ff623c80f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aea04c6a544a650bcf6a7f88ff623c80f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea04c6a544a650bcf6a7f88ff623c80f">forward</a> (<a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt; T &gt; &amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="memdesc:aea04c6a544a650bcf6a7f88ff623c80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards lvalues as either lvalues or as rvalues, depending on T. When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function.  <br /></td></tr>
<tr class="separator:aea04c6a544a650bcf6a7f88ff623c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73855f5edc16acf9ba653c540059bf5c" id="r_a73855f5edc16acf9ba653c540059bf5c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a73855f5edc16acf9ba653c540059bf5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73855f5edc16acf9ba653c540059bf5c">forward_as_tuple</a> (<a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;... args) noexcept -&gt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt; <a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;... &gt;</td></tr>
<tr class="memdesc:a73855f5edc16acf9ba653c540059bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members.  <br /></td></tr>
<tr class="separator:a73855f5edc16acf9ba653c540059bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881439150ce3ae249968cc8b15d6e31d" id="r_a881439150ce3ae249968cc8b15d6e31d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a881439150ce3ae249968cc8b15d6e31d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a881439150ce3ae249968cc8b15d6e31d">forward_like</a> (U &amp;&amp;<a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:a881439150ce3ae249968cc8b15d6e31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57744d86f1f45347bc48d426591e1ce1" id="r_a57744d86f1f45347bc48d426591e1ce1"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; <br />
requires (<a class="el" href="structetl_1_1bitset.html">not</a> same_as&lt;<a class="el" href="structetl_1_1bitset.html">Int</a>, <a class="el" href="structetl_1_1bitset.html">bool</a>&gt;)</td></tr>
<tr class="memitem:a57744d86f1f45347bc48d426591e1ce1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57744d86f1f45347bc48d426591e1ce1">from_chars</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *first, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *last, <a class="el" href="structetl_1_1bitset.html">Int</a> &amp;value, <a class="el" href="structetl_1_1bitset.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a></td></tr>
<tr class="memdesc:a57744d86f1f45347bc48d426591e1ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value.  <br /></td></tr>
<tr class="separator:a57744d86f1f45347bc48d426591e1ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cd5fdd90a750ceb082da63058a6816" id="r_aa8cd5fdd90a750ceb082da63058a6816"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:aa8cd5fdd90a750ceb082da63058a6816"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8cd5fdd90a750ceb082da63058a6816">front_inserter</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Container</a> &gt;</td></tr>
<tr class="memdesc:aa8cd5fdd90a750ceb082da63058a6816"><td class="mdescLeft">&#160;</td><td class="mdescRight">front_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:aa8cd5fdd90a750ceb082da63058a6816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b5eb982170f3879c1af31e1f245e8e" id="r_gab6b5eb982170f3879c1af31e1f245e8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:gab6b5eb982170f3879c1af31e1f245e8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gab6b5eb982170f3879c1af31e1f245e8e">full</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) noexcept(noexcept(c.full())) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.full())</td></tr>
<tr class="memdesc:gab6b5eb982170f3879c1af31e1f245e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is full.  <br /></td></tr>
<tr class="separator:gab6b5eb982170f3879c1af31e1f245e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d0a38b0d0530c7cdcea3add44e91d4" id="r_gab6d0a38b0d0530c7cdcea3add44e91d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:gab6d0a38b0d0530c7cdcea3add44e91d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gab6d0a38b0d0530c7cdcea3add44e91d4">full</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">N</a>]) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gab6d0a38b0d0530c7cdcea3add44e91d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcfb06e9497d99667ce90201fa5c056" id="r_abdcfb06e9497d99667ce90201fa5c056"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args&gt; </td></tr>
<tr class="memitem:abdcfb06e9497d99667ce90201fa5c056"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abdcfb06e9497d99667ce90201fa5c056">function_ref</a> (<a class="el" href="structetl_1_1bitset.html">R</a>(*)(Args...)) -&gt; function_ref&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...)&gt;</td></tr>
<tr class="separator:abdcfb06e9497d99667ce90201fa5c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga955751ac2a2b96303705764b4bb30db3" id="r_ga955751ac2a2b96303705764b4bb30db3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">M</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">N</a> &gt; </td></tr>
<tr class="memitem:ga955751ac2a2b96303705764b4bb30db3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga955751ac2a2b96303705764b4bb30db3">gcd</a> (<a class="el" href="structetl_1_1bitset.html">M</a> m, <a class="el" href="structetl_1_1bitset.html">N</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="#ac0f7a81113943dc723a4e4751c342144">etl::common_type_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">M</a>, <a class="el" href="structetl_1_1bitset.html">N</a> &gt;</td></tr>
<tr class="memdesc:ga955751ac2a2b96303705764b4bb30db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of the integers m and n.  <br /></td></tr>
<tr class="separator:ga955751ac2a2b96303705764b4bb30db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379d8ee0b21dfbdc9b0e5e4d7762eb43" id="r_ga379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Generator</a> &gt; </td></tr>
<tr class="memitem:ga379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga379d8ee0b21dfbdc9b0e5e4d7762eb43">generate</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Generator</a> g) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns each element in range <code>[first, last)</code> a value generated by the given function object g.  <br /></td></tr>
<tr class="separator:ga379d8ee0b21dfbdc9b0e5e4d7762eb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476438c577a79ab5e228c05ea53e8986" id="r_ga476438c577a79ab5e228c05ea53e8986"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Real</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Bits, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RNG</a> &gt; </td></tr>
<tr class="memitem:ga476438c577a79ab5e228c05ea53e8986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__random.html#ga476438c577a79ab5e228c05ea53e8986">generate_canonical</a> (<a class="el" href="structetl_1_1bitset.html">RNG</a> &amp;g) noexcept(noexcept(g())) -&gt; <a class="el" href="structetl_1_1bitset.html">Real</a></td></tr>
<tr class="memdesc:ga476438c577a79ab5e228c05ea53e8986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random floating point number in range [0,1).  <br /></td></tr>
<tr class="separator:ga476438c577a79ab5e228c05ea53e8986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12543b4f9ab02e90be68988a60f74dbe" id="r_ga12543b4f9ab02e90be68988a60f74dbe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">SizeT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Generator</a> &gt; </td></tr>
<tr class="memitem:ga12543b4f9ab02e90be68988a60f74dbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga12543b4f9ab02e90be68988a60f74dbe">generate_n</a> (<a class="el" href="structetl_1_1bitset.html">OutputIt</a> first, <a class="el" href="structetl_1_1bitset.html">SizeT</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="structetl_1_1bitset.html">Generator</a> g) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga12543b4f9ab02e90be68988a60f74dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns values, generated by given function object <code>g</code>, to the first count elements in the range beginning at <code>first</code>, if <code>count &gt; 0</code>. Does nothing otherwise.  <br /></td></tr>
<tr class="separator:ga12543b4f9ab02e90be68988a60f74dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2afb17c2e9b1ec115692dd31cdf6574" id="r_af2afb17c2e9b1ec115692dd31cdf6574"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:af2afb17c2e9b1ec115692dd31cdf6574"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af2afb17c2e9b1ec115692dd31cdf6574">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &amp;&amp;p) noexcept -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &gt; &amp;&amp;</td></tr>
<tr class="memdesc:af2afb17c2e9b1ec115692dd31cdf6574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:af2afb17c2e9b1ec115692dd31cdf6574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab277e7f8a028602ec26923ca3a4efe8e" id="r_ab277e7f8a028602ec26923ca3a4efe8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:ab277e7f8a028602ec26923ca3a4efe8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab277e7f8a028602ec26923ca3a4efe8e">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &amp;p) noexcept -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &gt; &amp;</td></tr>
<tr class="memdesc:ab277e7f8a028602ec26923ca3a4efe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:ab277e7f8a028602ec26923ca3a4efe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf3dcd4caaf2ac0322f3ee3dd4d5123" id="r_a8cf3dcd4caaf2ac0322f3ee3dd4d5123"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a8cf3dcd4caaf2ac0322f3ee3dd4d5123"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8cf3dcd4caaf2ac0322f3ee3dd4d5123">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;p) noexcept -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a8cf3dcd4caaf2ac0322f3ee3dd4d5123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:a8cf3dcd4caaf2ac0322f3ee3dd4d5123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2437363ad77d75596d13cf069467823c" id="r_a2437363ad77d75596d13cf069467823c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a2437363ad77d75596d13cf069467823c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2437363ad77d75596d13cf069467823c">get</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;p) noexcept -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="memdesc:a2437363ad77d75596d13cf069467823c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an element from the pair using tuple-like interface.  <br /></td></tr>
<tr class="separator:a2437363ad77d75596d13cf069467823c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bc2983c6b858933480a19a9f6ca6f6" id="r_ae2bc2983c6b858933480a19a9f6ca6f6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:ae2bc2983c6b858933480a19a9f6ca6f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2bc2983c6b858933480a19a9f6ca6f6">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1bitset.html">t</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:ae2bc2983c6b858933480a19a9f6ca6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8214f25116b3dd5ee4ecd4605b8e5cf8" id="r_a8214f25116b3dd5ee4ecd4605b8e5cf8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a8214f25116b3dd5ee4ecd4605b8e5cf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8214f25116b3dd5ee4ecd4605b8e5cf8">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1bitset.html">t</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> &amp;</td></tr>
<tr class="separator:a8214f25116b3dd5ee4ecd4605b8e5cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da5e04ad6238c60c904e4c9ac6bc5e9" id="r_a6da5e04ad6238c60c904e4c9ac6bc5e9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a6da5e04ad6238c60c904e4c9ac6bc5e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6da5e04ad6238c60c904e4c9ac6bc5e9">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1bitset.html">t</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td></tr>
<tr class="separator:a6da5e04ad6238c60c904e4c9ac6bc5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05f6f308ed4004eec8f0b4559371a0f" id="r_aa05f6f308ed4004eec8f0b4559371a0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:aa05f6f308ed4004eec8f0b4559371a0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa05f6f308ed4004eec8f0b4559371a0f">get</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">t</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="separator:aa05f6f308ed4004eec8f0b4559371a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade109c386a760b9572261c6afe7dbdf8" id="r_ade109c386a760b9572261c6afe7dbdf8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Types&gt; </td></tr>
<tr class="memitem:ade109c386a760b9572261c6afe7dbdf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade109c386a760b9572261c6afe7dbdf8">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; *<a class="el" href="structetl_1_1bitset.html">pv</a>) noexcept -&gt; add_pointer_t&lt; T &gt;</td></tr>
<tr class="separator:ade109c386a760b9572261c6afe7dbdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2d2fedb0567e3c7742e87fd799b82c" id="r_ade2d2fedb0567e3c7742e87fd799b82c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Types&gt; </td></tr>
<tr class="memitem:ade2d2fedb0567e3c7742e87fd799b82c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade2d2fedb0567e3c7742e87fd799b82c">get_if</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">pv</a>) noexcept -&gt; add_pointer_t&lt; T <a class="el" href="structetl_1_1bitset.html">const</a> &gt;</td></tr>
<tr class="separator:ade2d2fedb0567e3c7742e87fd799b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee8f3605b778d70c05a5697ffae6192" id="r_ga4ee8f3605b778d70c05a5697ffae6192"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:ga4ee8f3605b778d70c05a5697ffae6192"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4ee8f3605b778d70c05a5697ffae6192">gnome_sort</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga4ee8f3605b778d70c05a5697ffae6192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga4ee8f3605b778d70c05a5697ffae6192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe96d864c89d47ea3902b6fc8826d2b5" id="r_gafe96d864c89d47ea3902b6fc8826d2b5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gafe96d864c89d47ea3902b6fc8826d2b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gafe96d864c89d47ea3902b6fc8826d2b5">gnome_sort</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:gafe96d864c89d47ea3902b6fc8826d2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:gafe96d864c89d47ea3902b6fc8826d2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4732ae6a536891ce2d355378e0ac571c" id="r_ga4732ae6a536891ce2d355378e0ac571c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga4732ae6a536891ce2d355378e0ac571c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga4732ae6a536891ce2d355378e0ac571c">has_single_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga4732ae6a536891ce2d355378e0ac571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if x is an integral power of two.  <br /></td></tr>
<tr class="separator:ga4732ae6a536891ce2d355378e0ac571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27e213c027bfb11ed648fb543842995" id="r_ad27e213c027bfb11ed648fb543842995"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ad27e213c027bfb11ed648fb543842995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad27e213c027bfb11ed648fb543842995">ignore_unused</a> (<a class="el" href="structetl_1_1bitset.html">Types</a> &amp;&amp;...) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ad27e213c027bfb11ed648fb543842995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly ignore arguments or variables.  <br /></td></tr>
<tr class="separator:ad27e213c027bfb11ed648fb543842995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86319ce6c017b8e0cbaed828b6dad2f7" id="r_a86319ce6c017b8e0cbaed828b6dad2f7"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a86319ce6c017b8e0cbaed828b6dad2f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86319ce6c017b8e0cbaed828b6dad2f7">ilog2</a> (<a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a></td></tr>
<tr class="separator:a86319ce6c017b8e0cbaed828b6dad2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab3bbdd5f75b3b8343a6f44cf4845397" id="r_gaab3bbdd5f75b3b8343a6f44cf4845397"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaab3bbdd5f75b3b8343a6f44cf4845397"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gaab3bbdd5f75b3b8343a6f44cf4845397">imag</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) noexcept(noexcept(z.imag())) -&gt; T</td></tr>
<tr class="separator:gaab3bbdd5f75b3b8343a6f44cf4845397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d0ad216ba4bc6ac0ce104fa507be482" id="r_ga6d0ad216ba4bc6ac0ce104fa507be482"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:ga6d0ad216ba4bc6ac0ce104fa507be482"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga6d0ad216ba4bc6ac0ce104fa507be482">imag</a> (<a class="el" href="structetl_1_1bitset.html">Float</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Float</a></td></tr>
<tr class="separator:ga6d0ad216ba4bc6ac0ce104fa507be482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aee87424a681f33d80df9fdd70c16bc" id="r_ga0aee87424a681f33d80df9fdd70c16bc"><td class="memTemplParams" colspan="2">template&lt;integral Integer&gt; </td></tr>
<tr class="memitem:ga0aee87424a681f33d80df9fdd70c16bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga0aee87424a681f33d80df9fdd70c16bc">imag</a> (<a class="el" href="structetl_1_1bitset.html">Integer</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga0aee87424a681f33d80df9fdd70c16bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06254a010da20091fb04d67702c29da3" id="r_a06254a010da20091fb04d67702c29da3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires etl::detail::integer_and_not_char&lt;T&gt;</td></tr>
<tr class="memitem:a06254a010da20091fb04d67702c29da3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06254a010da20091fb04d67702c29da3">in_range</a> (T <a class="el" href="structetl_1_1bitset.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a06254a010da20091fb04d67702c29da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss.  <br /></td></tr>
<tr class="separator:a06254a010da20091fb04d67702c29da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d74dfc016d11d54f60ad30618fc276" id="r_gae0d74dfc016d11d54f60ad30618fc276"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:gae0d74dfc016d11d54f60ad30618fc276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gae0d74dfc016d11d54f60ad30618fc276">includes</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gae0d74dfc016d11d54f60ad30618fc276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0d5db89d1e54d2ccb479a559df46aa" id="r_ga5f0d5db89d1e54d2ccb479a559df46aa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga5f0d5db89d1e54d2ccb479a559df46aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5f0d5db89d1e54d2ccb479a559df46aa">includes</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga5f0d5db89d1e54d2ccb479a559df46aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range <code>[first2, last2)</code> is a subsequence of the sorted range <code>[first1, last1)</code>. Both ranges must be sorted.  <br /></td></tr>
<tr class="separator:ga5f0d5db89d1e54d2ccb479a559df46aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ad6461a0165e73290f0352e8fd4cd0" id="r_ga96ad6461a0165e73290f0352e8fd4cd0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga96ad6461a0165e73290f0352e8fd4cd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga96ad6461a0165e73290f0352e8fd4cd0">inner_product</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, T init) -&gt; T</td></tr>
<tr class="memdesc:ga96ad6461a0165e73290f0352e8fd4cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2.  <br /></td></tr>
<tr class="separator:ga96ad6461a0165e73290f0352e8fd4cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0ed0370d54cfcffdf5a5d84313c3bc" id="r_ga7c0ed0370d54cfcffdf5a5d84313c3bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryOperation1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryOperation2</a> &gt; </td></tr>
<tr class="memitem:ga7c0ed0370d54cfcffdf5a5d84313c3bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga7c0ed0370d54cfcffdf5a5d84313c3bc">inner_product</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, T init, <a class="el" href="structetl_1_1bitset.html">BinaryOperation1</a> <a class="el" href="structetl_1_1bitset.html">op1</a>, <a class="el" href="structetl_1_1bitset.html">BinaryOperation2</a> <a class="el" href="structetl_1_1bitset.html">op2</a>) -&gt; T</td></tr>
<tr class="separator:ga7c0ed0370d54cfcffdf5a5d84313c3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90ac00af714eca3a603115a96d226d1" id="r_gaf90ac00af714eca3a603115a96d226d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gaf90ac00af714eca3a603115a96d226d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaf90ac00af714eca3a603115a96d226d1">inplace_merge</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> <a class="el" href="group__iterator.html#gaeb088ae74a2ec53c8c206de329935df4">begin</a>, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> <a class="el" href="structetl_1_1bitset.html">mid</a>, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> <a class="el" href="group__iterator.html#gaa26698de685cc42e99c0c560d05ca93c">end</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:gaf90ac00af714eca3a603115a96d226d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last).  <br /></td></tr>
<tr class="separator:gaf90ac00af714eca3a603115a96d226d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485ce5c1c0690a9616ba899fe2db7a10" id="r_ga485ce5c1c0690a9616ba899fe2db7a10"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:ga485ce5c1c0690a9616ba899fe2db7a10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga485ce5c1c0690a9616ba899fe2db7a10">inplace_merge</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> <a class="el" href="structetl_1_1bitset.html">mid</a>, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:ga485ce5c1c0690a9616ba899fe2db7a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819f2e196782c8f996a7a6d85853564b" id="r_ga819f2e196782c8f996a7a6d85853564b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ga819f2e196782c8f996a7a6d85853564b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga819f2e196782c8f996a7a6d85853564b">insertion_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:ga819f2e196782c8f996a7a6d85853564b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1189f81daa0314d4422781edab8a4e83" id="r_ga1189f81daa0314d4422781edab8a4e83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga1189f81daa0314d4422781edab8a4e83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1189f81daa0314d4422781edab8a4e83">insertion_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga1189f81daa0314d4422781edab8a4e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga1189f81daa0314d4422781edab8a4e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdaffbfe13a56a7417bfdd32d335dd6" id="r_aabdaffbfe13a56a7417bfdd32d335dd6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> , typename... Args&gt; </td></tr>
<tr class="memitem:aabdaffbfe13a56a7417bfdd32d335dd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aabdaffbfe13a56a7417bfdd32d335dd6">invoke</a> (<a class="el" href="structetl_1_1bitset.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;... args) -&gt; invoke_result_t&lt; <a class="el" href="structetl_1_1bitset.html">F</a>, Args... &gt;</td></tr>
<tr class="separator:aabdaffbfe13a56a7417bfdd32d335dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8b1e57bc5b47496c1898878c7d6916" id="r_a4b8b1e57bc5b47496c1898878c7d6916"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> , typename... Args&gt; <br />
requires (<a class="el" href="#a79bb140a0b590bb8a6eadea52d880d17">etl::is_invocable_r_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">R</a>, <a class="el" href="structetl_1_1bitset.html">F</a>, Args...&gt;)</td></tr>
<tr class="memitem:a4b8b1e57bc5b47496c1898878c7d6916"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b8b1e57bc5b47496c1898878c7d6916">invoke_r</a> (<a class="el" href="structetl_1_1bitset.html">F</a> &amp;&amp;f, <a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;... args) -&gt; <a class="el" href="structetl_1_1bitset.html">R</a></td></tr>
<tr class="separator:a4b8b1e57bc5b47496c1898878c7d6916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ee38a471c3e4fe67b474e4bf11cec8" id="r_ga38ee38a471c3e4fe67b474e4bf11cec8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga38ee38a471c3e4fe67b474e4bf11cec8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga38ee38a471c3e4fe67b474e4bf11cec8">iota</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T value) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga38ee38a471c3e4fe67b474e4bf11cec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value.  <br /></td></tr>
<tr class="separator:ga38ee38a471c3e4fe67b474e4bf11cec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabc2a74c91be5a9c6b446824c7d2cee" id="r_afabc2a74c91be5a9c6b446824c7d2cee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">auto</a> Base&gt; </td></tr>
<tr class="memitem:afabc2a74c91be5a9c6b446824c7d2cee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afabc2a74c91be5a9c6b446824c7d2cee">ipow</a> (<a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">Base</a>) <a class="el" href="structetl_1_1bitset.html">exponent</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">Base</a>)</td></tr>
<tr class="separator:afabc2a74c91be5a9c6b446824c7d2cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af1eade8d7b506ab0a6732e681a803b" id="r_a0af1eade8d7b506ab0a6732e681a803b"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:a0af1eade8d7b506ab0a6732e681a803b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0af1eade8d7b506ab0a6732e681a803b">ipow</a> (<a class="el" href="structetl_1_1bitset.html">Int</a> base, <a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="structetl_1_1bitset.html">exponent</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a></td></tr>
<tr class="separator:a0af1eade8d7b506ab0a6732e681a803b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ea1c61ce77c9bf27e83df6a1fec64" id="r_a135ea1c61ce77c9bf27e83df6a1fec64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a135ea1c61ce77c9bf27e83df6a1fec64">is_constant_evaluated</a> () noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a135ea1c61ce77c9bf27e83df6a1fec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false.  <br /></td></tr>
<tr class="separator:a135ea1c61ce77c9bf27e83df6a1fec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c8a352def3b5c249692e3ed0da20ad" id="r_ga17c8a352def3b5c249692e3ed0da20ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debugging.html#ga17c8a352def3b5c249692e3ed0da20ad">is_debugger_present</a> () noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga17c8a352def3b5c249692e3ed0da20ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to determine if the program is being executed with debugger present.  <br /></td></tr>
<tr class="separator:ga17c8a352def3b5c249692e3ed0da20ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982037f958b7b332615a47e0458470a4" id="r_ga982037f958b7b332615a47e0458470a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compare.html#ga982037f958b7b332615a47e0458470a4">is_eq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1bitset.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga982037f958b7b332615a47e0458470a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf6fdfc0878be3154d7671edc95de7f" id="r_adcf6fdfc0878be3154d7671edc95de7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">consteval</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf6fdfc0878be3154d7671edc95de7f">is_freestanding</a> () noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:adcf6fdfc0878be3154d7671edc95de7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9aac3f063804059658718a8e9e19195" id="r_gaf9aac3f063804059658718a8e9e19195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compare.html#gaf9aac3f063804059658718a8e9e19195">is_gt</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1bitset.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gaf9aac3f063804059658718a8e9e19195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511c9b1ac1fc84868ea3530a2b2fc111" id="r_ga511c9b1ac1fc84868ea3530a2b2fc111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compare.html#ga511c9b1ac1fc84868ea3530a2b2fc111">is_gteq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1bitset.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga511c9b1ac1fc84868ea3530a2b2fc111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5914a0a90f9a279328bcadc57b7ce090" id="r_a5914a0a90f9a279328bcadc57b7ce090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">consteval</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5914a0a90f9a279328bcadc57b7ce090">is_hosted</a> () noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a5914a0a90f9a279328bcadc57b7ce090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266a85d1d883c6a4b7c74721dcfa9d3d" id="r_ga266a85d1d883c6a4b7c74721dcfa9d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compare.html#ga266a85d1d883c6a4b7c74721dcfa9d3d">is_lt</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1bitset.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga266a85d1d883c6a4b7c74721dcfa9d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5180426dd93c0ed7faa85c5b9aaeca8" id="r_gaf5180426dd93c0ed7faa85c5b9aaeca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compare.html#gaf5180426dd93c0ed7faa85c5b9aaeca8">is_lteq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1bitset.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gaf5180426dd93c0ed7faa85c5b9aaeca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af0c0f3f06fcc2acc7fb473b8060eab" id="r_ga2af0c0f3f06fcc2acc7fb473b8060eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compare.html#ga2af0c0f3f06fcc2acc7fb473b8060eab">is_neq</a> (<a class="el" href="structetl_1_1partial__ordering.html">partial_ordering</a> <a class="el" href="structetl_1_1bitset.html">cmp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga2af0c0f3f06fcc2acc7fb473b8060eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3a106198fbf6b07743f082cec761fa" id="r_ga7c3a106198fbf6b07743f082cec761fa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga7c3a106198fbf6b07743f082cec761fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7c3a106198fbf6b07743f082cec761fa">is_partitioned</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga7c3a106198fbf6b07743f082cec761fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements in the range <code>[first, last)</code> that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty.  <br /></td></tr>
<tr class="separator:ga7c3a106198fbf6b07743f082cec761fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ca70817d9b940ccd963245edb804e7" id="r_gab7ca70817d9b940ccd963245edb804e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:gab7ca70817d9b940ccd963245edb804e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gab7ca70817d9b940ccd963245edb804e7">is_permutation</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> last, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gab7ca70817d9b940ccd963245edb804e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there exists a permutation of the elements in the range <code>[first1, last1)</code> that makes that range equal to the range <code>[first2, last2)</code>, where <code>last2</code> denotes <code>first2 + (last1 - first1)</code> if it was not given.  <br /></td></tr>
<tr class="separator:gab7ca70817d9b940ccd963245edb804e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebb0727381b2818e6575c43ad064189" id="r_gacebb0727381b2818e6575c43ad064189"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:gacebb0727381b2818e6575c43ad064189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gacebb0727381b2818e6575c43ad064189">is_permutation</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gacebb0727381b2818e6575c43ad064189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25741a63c525afca9eaf8054b7122a9" id="r_gaa25741a63c525afca9eaf8054b7122a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:gaa25741a63c525afca9eaf8054b7122a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaa25741a63c525afca9eaf8054b7122a9">is_sorted</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gaa25741a63c525afca9eaf8054b7122a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range <code>[first, last)</code> are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:gaa25741a63c525afca9eaf8054b7122a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a1d40ec7a46d94456bc76abf70910c" id="r_gaf0a1d40ec7a46d94456bc76abf70910c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gaf0a1d40ec7a46d94456bc76abf70910c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaf0a1d40ec7a46d94456bc76abf70910c">is_sorted</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gaf0a1d40ec7a46d94456bc76abf70910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb2f98e7a5c930b843b813c8885ff0e" id="r_ga1eb2f98e7a5c930b843b813c8885ff0e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga1eb2f98e7a5c930b843b813c8885ff0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1eb2f98e7a5c930b843b813c8885ff0e">is_sorted_until</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga1eb2f98e7a5c930b843b813c8885ff0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range <code>[first, last)</code> and finds the largest range beginning at <code>first</code> in which the elements are sorted in non-descending order.  <br /></td></tr>
<tr class="separator:ga1eb2f98e7a5c930b843b813c8885ff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76ed3932bcae919d183136bb3dcf658" id="r_gaa76ed3932bcae919d183136bb3dcf658"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gaa76ed3932bcae919d183136bb3dcf658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaa76ed3932bcae919d183136bb3dcf658">is_sorted_until</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="separator:gaa76ed3932bcae919d183136bb3dcf658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f0c06539ace1da2bddf4e0812b84bb" id="r_ga59f0c06539ace1da2bddf4e0812b84bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga59f0c06539ace1da2bddf4e0812b84bb">isalnum</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga59f0c06539ace1da2bddf4e0812b84bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is an alphanumeric character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:ga59f0c06539ace1da2bddf4e0812b84bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3971a86a072f5ef420f9446c69f3e9b8" id="r_ga3971a86a072f5ef420f9446c69f3e9b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga3971a86a072f5ef420f9446c69f3e9b8">isalpha</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga3971a86a072f5ef420f9446c69f3e9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is an alphabetic character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:ga3971a86a072f5ef420f9446c69f3e9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga538306563b896d39ab29eb2c13bce86b" id="r_ga538306563b896d39ab29eb2c13bce86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga538306563b896d39ab29eb2c13bce86b">isblank</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga538306563b896d39ab29eb2c13bce86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (0x20) and horizontal tab (0x09) are classified as blank characters.  <br /></td></tr>
<tr class="separator:ga538306563b896d39ab29eb2c13bce86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368e8ddd21d388ae1504166640a1b80b" id="r_ga368e8ddd21d388ae1504166640a1b80b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga368e8ddd21d388ae1504166640a1b80b">iscntrl</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga368e8ddd21d388ae1504166640a1b80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a control character as classified by the currently installed C locale. In the default, "C" locale, the control characters are the characters with the codes 0x00-0x1F and 0x7F.  <br /></td></tr>
<tr class="separator:ga368e8ddd21d388ae1504166640a1b80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ada684f4a3c41f99153164e5465e49c" id="r_ga7ada684f4a3c41f99153164e5465e49c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga7ada684f4a3c41f99153164e5465e49c">isdigit</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga7ada684f4a3c41f99153164e5465e49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is one of the 10 decimal digits: 0123456789.  <br /></td></tr>
<tr class="separator:ga7ada684f4a3c41f99153164e5465e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a2f3a81c9fd5d4f1622ab810dd46f2c" id="r_ga9a2f3a81c9fd5d4f1622ab810dd46f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9a2f3a81c9fd5d4f1622ab810dd46f2c">isfinite</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga9a2f3a81c9fd5d4f1622ab810dd46f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee338b4a795e4fb1b7c0b78c9db74f1f" id="r_gaee338b4a795e4fb1b7c0b78c9db74f1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaee338b4a795e4fb1b7c0b78c9db74f1f">isfinite</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gaee338b4a795e4fb1b7c0b78c9db74f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN.  <br /></td></tr>
<tr class="separator:gaee338b4a795e4fb1b7c0b78c9db74f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7a4153c0b6a56949cfa7691169049b" id="r_a1f7a4153c0b6a56949cfa7691169049b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f7a4153c0b6a56949cfa7691169049b">isfinite</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a1f7a4153c0b6a56949cfa7691169049b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa39ec48dfbc1eb4db9280a9f861195" id="r_ga2aa39ec48dfbc1eb4db9280a9f861195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2aa39ec48dfbc1eb4db9280a9f861195">isfinite</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga2aa39ec48dfbc1eb4db9280a9f861195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce765b38ec7d09c9ef4e3424d24ce3b" id="r_ga3ce765b38ec7d09c9ef4e3424d24ce3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga3ce765b38ec7d09c9ef4e3424d24ce3b">isgraph</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga3ce765b38ec7d09c9ef4e3424d24ce3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is graphic (has a graphical representation) as classified by the default C locale.  <br /></td></tr>
<tr class="separator:ga3ce765b38ec7d09c9ef4e3424d24ce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d34fa46237c6eaba8d1ae5d60fc1db" id="r_ga38d34fa46237c6eaba8d1ae5d60fc1db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga38d34fa46237c6eaba8d1ae5d60fc1db">isinf</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga38d34fa46237c6eaba8d1ae5d60fc1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4929f99b9e3887a3b3e6d79a8bc8b90" id="r_gad4929f99b9e3887a3b3e6d79a8bc8b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad4929f99b9e3887a3b3e6d79a8bc8b90">isinf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gad4929f99b9e3887a3b3e6d79a8bc8b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a positive or negative infinity.  <br /></td></tr>
<tr class="separator:gad4929f99b9e3887a3b3e6d79a8bc8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b70d7be5ca34b77def3ff9950ef1cc" id="r_a25b70d7be5ca34b77def3ff9950ef1cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b70d7be5ca34b77def3ff9950ef1cc">isinf</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a25b70d7be5ca34b77def3ff9950ef1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1a8761a20e5e1776772fe35f2d955e" id="r_gace1a8761a20e5e1776772fe35f2d955e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:gace1a8761a20e5e1776772fe35f2d955e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gace1a8761a20e5e1776772fe35f2d955e">isinf</a> (<a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gace1a8761a20e5e1776772fe35f2d955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9066363a2f58c8ae28f552ced26dc75" id="r_gae9066363a2f58c8ae28f552ced26dc75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae9066363a2f58c8ae28f552ced26dc75">isinf</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gae9066363a2f58c8ae28f552ced26dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b19e10b64e3f368ecdf462fb07b15b" id="r_ga66b19e10b64e3f368ecdf462fb07b15b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga66b19e10b64e3f368ecdf462fb07b15b">islower</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga66b19e10b64e3f368ecdf462fb07b15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is classified as a lowercase character according to the default C locale.  <br /></td></tr>
<tr class="separator:ga66b19e10b64e3f368ecdf462fb07b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga018b25daf513092eb1a12dae74bd71e5" id="r_ga018b25daf513092eb1a12dae74bd71e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga018b25daf513092eb1a12dae74bd71e5">isnan</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga018b25daf513092eb1a12dae74bd71e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4931c1f16663033473fa99a430d07d9b" id="r_ga4931c1f16663033473fa99a430d07d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4931c1f16663033473fa99a430d07d9b">isnan</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga4931c1f16663033473fa99a430d07d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <br /></td></tr>
<tr class="separator:ga4931c1f16663033473fa99a430d07d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8986c9bc042cb46d1874b992a453180" id="r_ab8986c9bc042cb46d1874b992a453180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8986c9bc042cb46d1874b992a453180">isnan</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ab8986c9bc042cb46d1874b992a453180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ebce8e7c8c14a50e69039ecedf0316" id="r_gaa5ebce8e7c8c14a50e69039ecedf0316"><td class="memTemplParams" colspan="2">template&lt;integral Int&gt; </td></tr>
<tr class="memitem:gaa5ebce8e7c8c14a50e69039ecedf0316"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa5ebce8e7c8c14a50e69039ecedf0316">isnan</a> (<a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gaa5ebce8e7c8c14a50e69039ecedf0316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <br /></td></tr>
<tr class="separator:gaa5ebce8e7c8c14a50e69039ecedf0316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac42ed915a942af2b65228826aae92e77" id="r_gac42ed915a942af2b65228826aae92e77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac42ed915a942af2b65228826aae92e77">isnan</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:gac42ed915a942af2b65228826aae92e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf694dfa4152d5e19dfb263a24d0b3fd" id="r_aaf694dfa4152d5e19dfb263a24d0b3fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf694dfa4152d5e19dfb263a24d0b3fd">isnormal</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:aaf694dfa4152d5e19dfb263a24d0b3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa48a725052c02bf9e7e2b74019bcb27e" id="r_gaa48a725052c02bf9e7e2b74019bcb27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#gaa48a725052c02bf9e7e2b74019bcb27e">isprint</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gaa48a725052c02bf9e7e2b74019bcb27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if ch is a printable character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:gaa48a725052c02bf9e7e2b74019bcb27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b14f213f7af1217b2d2cdf65f180738" id="r_ga5b14f213f7af1217b2d2cdf65f180738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga5b14f213f7af1217b2d2cdf65f180738">ispunct</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga5b14f213f7af1217b2d2cdf65f180738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a punctuation character as classified by the current C locale.  <br /></td></tr>
<tr class="separator:ga5b14f213f7af1217b2d2cdf65f180738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d797fc03c5126b24a821bd1fc122b3a" id="r_ga9d797fc03c5126b24a821bd1fc122b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga9d797fc03c5126b24a821bd1fc122b3a">isspace</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga9d797fc03c5126b24a821bd1fc122b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is whitespace character as classified by the default C locale.  <br /></td></tr>
<tr class="separator:ga9d797fc03c5126b24a821bd1fc122b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060875a823b3d041865221eecc9b93de" id="r_ga060875a823b3d041865221eecc9b93de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#ga060875a823b3d041865221eecc9b93de">isupper</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga060875a823b3d041865221eecc9b93de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is classified as a uppercase character according to the default C locale.  <br /></td></tr>
<tr class="separator:ga060875a823b3d041865221eecc9b93de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd605e16e8fe82cfcbe722d1cc32531" id="r_gadcd605e16e8fe82cfcbe722d1cc32531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#gadcd605e16e8fe82cfcbe722d1cc32531">iswalnum</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gadcd605e16e8fe82cfcbe722d1cc32531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an alphanumeric character, i.e. either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphanumeric character specific to the current locale.  <br /></td></tr>
<tr class="separator:gadcd605e16e8fe82cfcbe722d1cc32531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e7f38abfa4626a87a678221210ff20" id="r_ga26e7f38abfa4626a87a678221210ff20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#ga26e7f38abfa4626a87a678221210ff20">iswalpha</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga26e7f38abfa4626a87a678221210ff20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz) or any alphabetic character specific to the current locale.  <br /></td></tr>
<tr class="separator:ga26e7f38abfa4626a87a678221210ff20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ddfc9129d96c9d732bd42aae4d2b7e" id="r_gaf6ddfc9129d96c9d732bd42aae4d2b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#gaf6ddfc9129d96c9d732bd42aae4d2b7e">iswblank</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gaf6ddfc9129d96c9d732bd42aae4d2b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (0x20) and horizontal tab (0x09) are blank characters.  <br /></td></tr>
<tr class="separator:gaf6ddfc9129d96c9d732bd42aae4d2b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcb4d7527b43f2bf80b6709558ce8751" id="r_gabcb4d7527b43f2bf80b6709558ce8751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#gabcb4d7527b43f2bf80b6709558ce8751">iswcntrl</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gabcb4d7527b43f2bf80b6709558ce8751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a control character, i.e. codes 0x00-0x1F and 0x7F and any control characters specific to the current locale.  <br /></td></tr>
<tr class="separator:gabcb4d7527b43f2bf80b6709558ce8751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd57dd6cbdd4676e575a985b16fc6c73" id="r_gacd57dd6cbdd4676e575a985b16fc6c73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#gacd57dd6cbdd4676e575a985b16fc6c73">iswdigit</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gacd57dd6cbdd4676e575a985b16fc6c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.  <br /></td></tr>
<tr class="separator:gacd57dd6cbdd4676e575a985b16fc6c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7497aa1630afdaae61880742d859160" id="r_gae7497aa1630afdaae61880742d859160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#gae7497aa1630afdaae61880742d859160">iswgraph</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gae7497aa1630afdaae61880742d859160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character has a graphical representation, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~) or any graphical character specific to the current C locale.  <br /></td></tr>
<tr class="separator:gae7497aa1630afdaae61880742d859160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebca8a0e95d8a7c4b7fbe0022762b5c" id="r_gacebca8a0e95d8a7c4b7fbe0022762b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#gacebca8a0e95d8a7c4b7fbe0022762b5c">iswlower</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gacebca8a0e95d8a7c4b7fbe0022762b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a lowercase letter, i.e. one of abcdefghijklmnopqrstuvwxyz or any lowercase letter specific to the current locale.  <br /></td></tr>
<tr class="separator:gacebca8a0e95d8a7c4b7fbe0022762b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c844b2e79830a5920aef8f6537b691d" id="r_ga9c844b2e79830a5920aef8f6537b691d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#ga9c844b2e79830a5920aef8f6537b691d">iswprint</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga9c844b2e79830a5920aef8f6537b691d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character can be printed, i.e. it is either a number (0123456789), an uppercase letter (ABCDEFGHIJKLMNOPQRSTUVWXYZ), a lowercase letter (abcdefghijklmnopqrstuvwxyz), a punctuation character(!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~), space or any printable character specific to the current C locale.  <br /></td></tr>
<tr class="separator:ga9c844b2e79830a5920aef8f6537b691d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeae65f95769adaef057cef1e2072cf2" id="r_gafeae65f95769adaef057cef1e2072cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#gafeae65f95769adaef057cef1e2072cf2">iswpunct</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gafeae65f95769adaef057cef1e2072cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a punctuation character, i.e. it is one of !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ or any punctuation character specific to the current locale.  <br /></td></tr>
<tr class="separator:gafeae65f95769adaef057cef1e2072cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bc2486b7f8fe2d819d038bde3e96dd" id="r_ga08bc2486b7f8fe2d819d038bde3e96dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#ga08bc2486b7f8fe2d819d038bde3e96dd">iswspace</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga08bc2486b7f8fe2d819d038bde3e96dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:  <br /></td></tr>
<tr class="separator:ga08bc2486b7f8fe2d819d038bde3e96dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597b876c6866c7f04154fcc066fd08ba" id="r_ga597b876c6866c7f04154fcc066fd08ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#ga597b876c6866c7f04154fcc066fd08ba">iswupper</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga597b876c6866c7f04154fcc066fd08ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character is an uppercase letter, i.e. one of ABCDEFGHIJKLMNOPQRSTUVWXYZ or any uppercase letter specific to the current locale.  <br /></td></tr>
<tr class="separator:ga597b876c6866c7f04154fcc066fd08ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d8adf51dcb6a599f5da613d2e32b5d" id="r_ga49d8adf51dcb6a599f5da613d2e32b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#ga49d8adf51dcb6a599f5da613d2e32b5d">iswxdigit</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga49d8adf51dcb6a599f5da613d2e32b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of 0123456789abcdefABCDEF.  <br /></td></tr>
<tr class="separator:ga49d8adf51dcb6a599f5da613d2e32b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab501c4cabaa10c4b866b9c957ff5e16b" id="r_gab501c4cabaa10c4b866b9c957ff5e16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#gab501c4cabaa10c4b866b9c957ff5e16b">isxdigit</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gab501c4cabaa10c4b866b9c957ff5e16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given character is a hexadecimal numeric character (0123456789abcdefABCDEF).  <br /></td></tr>
<tr class="separator:gab501c4cabaa10c4b866b9c957ff5e16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1249aee36691133f6b783a82290f8e" id="r_ga7a1249aee36691133f6b783a82290f8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:ga7a1249aee36691133f6b783a82290f8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7a1249aee36691133f6b783a82290f8e">iter_swap</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> a, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> b) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga7a1249aee36691133f6b783a82290f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of the elements the given iterators are pointing to.  <br /></td></tr>
<tr class="separator:ga7a1249aee36691133f6b783a82290f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bafeda54d634206adcb005c3ec87be3" id="r_a6bafeda54d634206adcb005c3ec87be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bafeda54d634206adcb005c3ec87be3">labs</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a6bafeda54d634206adcb005c3ec87be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a6bafeda54d634206adcb005c3ec87be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa915cd734d0a5efbd9ac5e5f059f6a9f" id="r_gaa915cd734d0a5efbd9ac5e5f059f6a9f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">M</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <br />
requires (<a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">M</a>&gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">M</a>, <a class="el" href="structetl_1_1bitset.html">bool</a>&gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">N</a>&gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">N</a>, <a class="el" href="structetl_1_1bitset.html">bool</a>&gt;)</td></tr>
<tr class="memitem:gaa915cd734d0a5efbd9ac5e5f059f6a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gaa915cd734d0a5efbd9ac5e5f059f6a9f">lcm</a> (<a class="el" href="structetl_1_1bitset.html">M</a> m, <a class="el" href="structetl_1_1bitset.html">N</a> <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="#ac0f7a81113943dc723a4e4751c342144">common_type_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">M</a>, <a class="el" href="structetl_1_1bitset.html">N</a> &gt;</td></tr>
<tr class="memdesc:gaa915cd734d0a5efbd9ac5e5f059f6a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common multiple of the integers m and n.  <br /></td></tr>
<tr class="separator:gaa915cd734d0a5efbd9ac5e5f059f6a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817f60653f2167239f303e63ec82d4d8" id="r_a817f60653f2167239f303e63ec82d4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a817f60653f2167239f303e63ec82d4d8">ldiv</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a></td></tr>
<tr class="memdesc:a817f60653f2167239f303e63ec82d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a817f60653f2167239f303e63ec82d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc29d72e030e4aed81ae36516bdd74b" id="r_ga7dc29d72e030e4aed81ae36516bdd74b"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:ga7dc29d72e030e4aed81ae36516bdd74b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7dc29d72e030e4aed81ae36516bdd74b">lerp</a> (<a class="el" href="structetl_1_1bitset.html">Float</a> a, <a class="el" href="structetl_1_1bitset.html">Float</a> b, <a class="el" href="structetl_1_1bitset.html">Float</a> <a class="el" href="structetl_1_1bitset.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Float</a></td></tr>
<tr class="memdesc:ga7dc29d72e030e4aed81ae36516bdd74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a+t(b−a), i.e. the linear interpolation between a and b for the parameter t (or extrapolation, when t is outside the range [0,1]).  <br /></td></tr>
<tr class="separator:ga7dc29d72e030e4aed81ae36516bdd74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbb8794e1a09c00341acc4070284bd3" id="r_ga6bbb8794e1a09c00341acc4070284bd3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:ga6bbb8794e1a09c00341acc4070284bd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga6bbb8794e1a09c00341acc4070284bd3">lexicographical_compare</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">f1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">l1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">f2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">l2</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga6bbb8794e1a09c00341acc4070284bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb90a196cbc728c59a4f2f16a9a9befd" id="r_gacb90a196cbc728c59a4f2f16a9a9befd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gacb90a196cbc728c59a4f2f16a9a9befd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gacb90a196cbc728c59a4f2f16a9a9befd">lexicographical_compare</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">f1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">l1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">f2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">l2</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gacb90a196cbc728c59a4f2f16a9a9befd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range <code>[f1, l1)</code> is lexicographically less than the second range <code>[f2, l2)</code>.  <br /></td></tr>
<tr class="separator:gacb90a196cbc728c59a4f2f16a9a9befd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574f3e25d6dacc63b25e035a984caab4" id="r_ga574f3e25d6dacc63b25e035a984caab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga574f3e25d6dacc63b25e035a984caab4">lgamma</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga574f3e25d6dacc63b25e035a984caab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga574f3e25d6dacc63b25e035a984caab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952ade8c6a107ccbc790414ad7e3a08b" id="r_ga952ade8c6a107ccbc790414ad7e3a08b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga952ade8c6a107ccbc790414ad7e3a08b">lgamma</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:ga952ade8c6a107ccbc790414ad7e3a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga952ade8c6a107ccbc790414ad7e3a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01350c85781f91749ef0c3a61f7f3174" id="r_ga01350c85781f91749ef0c3a61f7f3174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga01350c85781f91749ef0c3a61f7f3174">lgamma</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga01350c85781f91749ef0c3a61f7f3174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga01350c85781f91749ef0c3a61f7f3174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764e7260866a5c3c61a9a51b61844b37" id="r_ga764e7260866a5c3c61a9a51b61844b37"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga764e7260866a5c3c61a9a51b61844b37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga764e7260866a5c3c61a9a51b61844b37">lgamma</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga764e7260866a5c3c61a9a51b61844b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:ga764e7260866a5c3c61a9a51b61844b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab423384d8c3b8ae5e4d2b8803c0a9926" id="r_gab423384d8c3b8ae5e4d2b8803c0a9926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab423384d8c3b8ae5e4d2b8803c0a9926">lgammaf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:gab423384d8c3b8ae5e4d2b8803c0a9926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:gab423384d8c3b8ae5e4d2b8803c0a9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd20233a764728c1b58bdd991dd8798a" id="r_gadd20233a764728c1b58bdd991dd8798a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadd20233a764728c1b58bdd991dd8798a">lgammal</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:gadd20233a764728c1b58bdd991dd8798a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of arg.  <br /></td></tr>
<tr class="separator:gadd20233a764728c1b58bdd991dd8798a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d83917d527505e29d3a8d3afb413bc" id="r_a44d83917d527505e29d3a8d3afb413bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44d83917d527505e29d3a8d3afb413bc">llabs</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">n</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a44d83917d527505e29d3a8d3afb413bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.  <br /></td></tr>
<tr class="separator:a44d83917d527505e29d3a8d3afb413bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540df0e14af1fb716877eb210bd107b5" id="r_a540df0e14af1fb716877eb210bd107b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a540df0e14af1fb716877eb210bd107b5">lldiv</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> y) noexcept -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a></td></tr>
<tr class="memdesc:a540df0e14af1fb716877eb210bd107b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy.  <br /></td></tr>
<tr class="separator:a540df0e14af1fb716877eb210bd107b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga180c24891e630b3f18c0b4b9cb061029" id="r_ga180c24891e630b3f18c0b4b9cb061029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga180c24891e630b3f18c0b4b9cb061029">llrint</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga180c24891e630b3f18c0b4b9cb061029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga180c24891e630b3f18c0b4b9cb061029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e2f14842eae5461374d32134da63da" id="r_ga85e2f14842eae5461374d32134da63da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga85e2f14842eae5461374d32134da63da">llrint</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga85e2f14842eae5461374d32134da63da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga85e2f14842eae5461374d32134da63da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b59bd85c99252163730280e1121450" id="r_gae3b59bd85c99252163730280e1121450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae3b59bd85c99252163730280e1121450">llrint</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:gae3b59bd85c99252163730280e1121450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:gae3b59bd85c99252163730280e1121450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97392fcf514d03d3134a3baf48272937" id="r_ga97392fcf514d03d3134a3baf48272937"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga97392fcf514d03d3134a3baf48272937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga97392fcf514d03d3134a3baf48272937">llrint</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga97392fcf514d03d3134a3baf48272937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga97392fcf514d03d3134a3baf48272937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga116fe6cace461371abbfd41ccf54e291" id="r_ga116fe6cace461371abbfd41ccf54e291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga116fe6cace461371abbfd41ccf54e291">llrintf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga116fe6cace461371abbfd41ccf54e291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga116fe6cace461371abbfd41ccf54e291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d8b7c2252d2757e38b9896cf9be1ff" id="r_ga49d8b7c2252d2757e38b9896cf9be1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga49d8b7c2252d2757e38b9896cf9be1ff">llrintl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga49d8b7c2252d2757e38b9896cf9be1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga49d8b7c2252d2757e38b9896cf9be1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga028e3243afe345483aa28369337b416e" id="r_ga028e3243afe345483aa28369337b416e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga028e3243afe345483aa28369337b416e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga028e3243afe345483aa28369337b416e">log</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga028e3243afe345483aa28369337b416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade18a03ea75529b1b254300ce82929cf" id="r_gade18a03ea75529b1b254300ce82929cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gade18a03ea75529b1b254300ce82929cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gade18a03ea75529b1b254300ce82929cf">log10</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gade18a03ea75529b1b254300ce82929cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef2815c598ddf680df6562ff413fc89" id="r_gaeef2815c598ddf680df6562ff413fc89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaeef2815c598ddf680df6562ff413fc89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaeef2815c598ddf680df6562ff413fc89">lower_bound</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="separator:gaeef2815c598ddf680df6562ff413fc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eac84d4e60cc02ce593a33117a79ba3" id="r_ga7eac84d4e60cc02ce593a33117a79ba3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga7eac84d4e60cc02ce593a33117a79ba3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7eac84d4e60cc02ce593a33117a79ba3">lower_bound</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga7eac84d4e60cc02ce593a33117a79ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is not less than (i.e. greater or equal to) value, or last if no such element is found.  <br /></td></tr>
<tr class="separator:ga7eac84d4e60cc02ce593a33117a79ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541a33c411499961bd3e08733707140f" id="r_ga541a33c411499961bd3e08733707140f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga541a33c411499961bd3e08733707140f">lrint</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga541a33c411499961bd3e08733707140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga541a33c411499961bd3e08733707140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efdcfc19324e3e04f9368cece16244f" id="r_ga9efdcfc19324e3e04f9368cece16244f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9efdcfc19324e3e04f9368cece16244f">lrint</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga9efdcfc19324e3e04f9368cece16244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga9efdcfc19324e3e04f9368cece16244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f44d4156ec3e888fbcbdc58e2d1d9eb" id="r_ga5f44d4156ec3e888fbcbdc58e2d1d9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5f44d4156ec3e888fbcbdc58e2d1d9eb">lrint</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga5f44d4156ec3e888fbcbdc58e2d1d9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga5f44d4156ec3e888fbcbdc58e2d1d9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9466128546cf8b58e9221df02f82b56d" id="r_ga9466128546cf8b58e9221df02f82b56d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga9466128546cf8b58e9221df02f82b56d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9466128546cf8b58e9221df02f82b56d">lrint</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga9466128546cf8b58e9221df02f82b56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga9466128546cf8b58e9221df02f82b56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca941408e9c364428b2587af9bca033" id="r_ga4ca941408e9c364428b2587af9bca033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4ca941408e9c364428b2587af9bca033">lrintf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:ga4ca941408e9c364428b2587af9bca033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga4ca941408e9c364428b2587af9bca033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14c44304eebfdfc43c7bb881bfb7cf4" id="r_gaa14c44304eebfdfc43c7bb881bfb7cf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa14c44304eebfdfc43c7bb881bfb7cf4">lrintl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:gaa14c44304eebfdfc43c7bb881bfb7cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value, using the current rounding mode.  <br /></td></tr>
<tr class="separator:gaa14c44304eebfdfc43c7bb881bfb7cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc7cabf52200c976eb934c6de9399fb" id="r_a0bc7cabf52200c976eb934c6de9399fb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Context</a>  = etl::format_context, typename... Args&gt; </td></tr>
<tr class="memitem:a0bc7cabf52200c976eb934c6de9399fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bc7cabf52200c976eb934c6de9399fb">make_format_args</a> (<a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;... args) -&gt; detail::format_arg_store&lt; <a class="el" href="structetl_1_1bitset.html">Context</a>, Args... &gt;</td></tr>
<tr class="separator:a0bc7cabf52200c976eb934c6de9399fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae0d54a117c055337810c0829b22eaf" id="r_a1ae0d54a117c055337810c0829b22eaf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Tuple</a> &gt; </td></tr>
<tr class="memitem:a1ae0d54a117c055337810c0829b22eaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ae0d54a117c055337810c0829b22eaf">make_from_tuple</a> (<a class="el" href="structetl_1_1bitset.html">Tuple</a> &amp;&amp;<a class="el" href="structetl_1_1bitset.html">t</a>) -&gt; T</td></tr>
<tr class="separator:a1ae0d54a117c055337810c0829b22eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944300e491e850f5e82717c7a66b5463" id="r_a944300e491e850f5e82717c7a66b5463"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a944300e491e850f5e82717c7a66b5463"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a944300e491e850f5e82717c7a66b5463">make_pair</a> (<a class="el" href="structetl_1_1bitset.html">T1</a> &amp;&amp;<a class="el" href="structetl_1_1bitset.html">t</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &amp;&amp;<a class="el" href="structetl_1_1bitset.html">u</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a> &gt;, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &gt;</td></tr>
<tr class="memdesc:a944300e491e850f5e82717c7a66b5463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments.  <br /></td></tr>
<tr class="separator:a944300e491e850f5e82717c7a66b5463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0773cf088e3cccbce2905050fcdd0eb" id="r_af0773cf088e3cccbce2905050fcdd0eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; </td></tr>
<tr class="memitem:af0773cf088e3cccbce2905050fcdd0eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0773cf088e3cccbce2905050fcdd0eb">make_reverse_iterator</a> (<a class="el" href="structetl_1_1bitset.html">Iter</a> <a class="el" href="structetl_1_1bitset.html">i</a>) noexcept -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt;</td></tr>
<tr class="memdesc:af0773cf088e3cccbce2905050fcdd0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function template that constructs a <a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">etl::reverse_iterator</a> for the given iterator i (which must be a LegacyBidirectionalIterator) with the type deduced from the type of the argument.  <br /></td></tr>
<tr class="separator:af0773cf088e3cccbce2905050fcdd0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b36b4f297a155e09e83fcca0b06d279" id="r_a3b36b4f297a155e09e83fcca0b06d279"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3b36b4f297a155e09e83fcca0b06d279"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b36b4f297a155e09e83fcca0b06d279">make_tuple</a> (<a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3b36b4f297a155e09e83fcca0b06d279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tuple object, deducing the target type from the types of arguments.  <br /></td></tr>
<tr class="separator:a3b36b4f297a155e09e83fcca0b06d279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a9f575220aa9ab48e4d48b82093698" id="r_ae6a9f575220aa9ab48e4d48b82093698"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae6a9f575220aa9ab48e4d48b82093698"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6a9f575220aa9ab48e4d48b82093698">make_wformat_args</a> (<a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;... args) -&gt; detail::format_arg_store&lt; <a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a>, Args... &gt;</td></tr>
<tr class="separator:ae6a9f575220aa9ab48e4d48b82093698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3eca1793f7f38aeb756464984eb194" id="r_ga5f3eca1793f7f38aeb756464984eb194"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> &gt; </td></tr>
<tr class="memitem:ga5f3eca1793f7f38aeb756464984eb194"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5f3eca1793f7f38aeb756464984eb194">max</a> (<a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;a, <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="memdesc:ga5f3eca1793f7f38aeb756464984eb194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b.  <br /></td></tr>
<tr class="separator:ga5f3eca1793f7f38aeb756464984eb194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b79e7341165c49fa24ea2d66a761a5" id="r_gab9b79e7341165c49fa24ea2d66a761a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gab9b79e7341165c49fa24ea2d66a761a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gab9b79e7341165c49fa24ea2d66a761a5">max</a> (<a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;a, <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;b, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="memdesc:gab9b79e7341165c49fa24ea2d66a761a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b, using a compare function.  <br /></td></tr>
<tr class="separator:gab9b79e7341165c49fa24ea2d66a761a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4b38361c7330f3c5996fef40213eed" id="r_ga3b4b38361c7330f3c5996fef40213eed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga3b4b38361c7330f3c5996fef40213eed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga3b4b38361c7330f3c5996fef40213eed">max_element</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga3b4b38361c7330f3c5996fef40213eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <br /></td></tr>
<tr class="separator:ga3b4b38361c7330f3c5996fef40213eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac847a74164e6c1a692093c156b35eb30" id="r_gac847a74164e6c1a692093c156b35eb30"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gac847a74164e6c1a692093c156b35eb30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gac847a74164e6c1a692093c156b35eb30">max_element</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:gac847a74164e6c1a692093c156b35eb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <br /></td></tr>
<tr class="separator:gac847a74164e6c1a692093c156b35eb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe0d774229c098831602663bd591f28" id="r_a1fe0d774229c098831602663bd591f28"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CArray</a> &gt; <br />
requires (<a class="el" href="#a8b0e44222b6a1dc103286f3c5225ad93">is_array_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">CArray</a>&gt; &amp;&amp; <a class="el" href="#a3c66bceba9ac1596666a40596ddf9b62">rank_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">CArray</a>&gt; == 1)</td></tr>
<tr class="memitem:a1fe0d774229c098831602663bd591f28"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fe0d774229c098831602663bd591f28">mdspan</a> (<a class="el" href="structetl_1_1bitset.html">CArray</a> &amp;) -&gt; mdspan&lt; <a class="el" href="#a0ffde65d0200b12233a0dff1979cc210">remove_all_extents_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">CArray</a> &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, <a class="el" href="#a06332dc22e85765f2c195c703cc49068">extent_v</a>&lt; <a class="el" href="structetl_1_1bitset.html">CArray</a>, 0 &gt; &gt; &gt;</td></tr>
<tr class="separator:a1fe0d774229c098831602663bd591f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4c4186488804dd6af16be8ffb48af4" id="r_adc4c4186488804dd6af16be8ffb48af4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ElementType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">IndexType</a> , size_t... ExtentsPack&gt; </td></tr>
<tr class="memitem:adc4c4186488804dd6af16be8ffb48af4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc4c4186488804dd6af16be8ffb48af4">mdspan</a> (<a class="el" href="structetl_1_1bitset.html">ElementType</a> *, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1bitset.html">IndexType</a>, ExtentsPack... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1bitset.html">ElementType</a>, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1bitset.html">IndexType</a>, ExtentsPack... &gt; &gt;</td></tr>
<tr class="separator:adc4c4186488804dd6af16be8ffb48af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82de4f51577f9cfd914c0f916caf46fc" id="r_a82de4f51577f9cfd914c0f916caf46fc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ElementType</a> , typename... Integrals&gt; <br />
requires ((<a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">is_convertible_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">Integrals</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt; &amp;&amp; ...) &amp;&amp; sizeof...(<a class="el" href="structetl_1_1bitset.html">Integrals</a>) &gt; 0)</td></tr>
<tr class="memitem:a82de4f51577f9cfd914c0f916caf46fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82de4f51577f9cfd914c0f916caf46fc">mdspan</a> (<a class="el" href="structetl_1_1bitset.html">ElementType</a> *, Integrals...) -&gt; mdspan&lt; <a class="el" href="structetl_1_1bitset.html">ElementType</a>, <a class="el" href="#ac53bcc0a66170293af1f9319d4663d1a">dextents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, sizeof...(<a class="el" href="structetl_1_1bitset.html">Integrals</a>)&gt; &gt;</td></tr>
<tr class="separator:a82de4f51577f9cfd914c0f916caf46fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc583d3a74b54cf8a1b2f2de409a2b74" id="r_abc583d3a74b54cf8a1b2f2de409a2b74"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ElementType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">MappingType</a> &gt; </td></tr>
<tr class="memitem:abc583d3a74b54cf8a1b2f2de409a2b74"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc583d3a74b54cf8a1b2f2de409a2b74">mdspan</a> (<a class="el" href="structetl_1_1bitset.html">ElementType</a> *, <a class="el" href="structetl_1_1bitset.html">MappingType</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1bitset.html">ElementType</a>, <a class="el" href="structetl_1_1bitset.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1bitset.html">typename</a> MappingType::layout_type &gt;</td></tr>
<tr class="separator:abc583d3a74b54cf8a1b2f2de409a2b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa581bd5419c1b5ce63db2ceefe37b971" id="r_aa581bd5419c1b5ce63db2ceefe37b971"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Pointer</a> &gt; <br />
requires (<a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">is_pointer_v</a>&lt;<a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Pointer</a>&gt;&gt;)</td></tr>
<tr class="memitem:aa581bd5419c1b5ce63db2ceefe37b971"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa581bd5419c1b5ce63db2ceefe37b971">mdspan</a> (<a class="el" href="structetl_1_1bitset.html">Pointer</a> &amp;&amp;) -&gt; mdspan&lt; <a class="el" href="#a81cba9b583535ccfde0e7eb172bbec71">remove_pointer_t</a>&lt; <a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">Pointer</a> &gt; &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> &gt; &gt;</td></tr>
<tr class="separator:aa581bd5419c1b5ce63db2ceefe37b971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0eace36bd684274a175bbf90c48247" id="r_a0f0eace36bd684274a175bbf90c48247"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">MappingType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">AccessorType</a> &gt; </td></tr>
<tr class="memitem:a0f0eace36bd684274a175bbf90c48247"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f0eace36bd684274a175bbf90c48247">mdspan</a> (<a class="el" href="structetl_1_1bitset.html">typename</a> AccessorType::data_handle_type <a class="el" href="structetl_1_1bitset.html">const</a> &amp;, <a class="el" href="structetl_1_1bitset.html">MappingType</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;, <a class="el" href="structetl_1_1bitset.html">AccessorType</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;) -&gt; mdspan&lt; <a class="el" href="structetl_1_1bitset.html">typename</a> AccessorType::element_type, <a class="el" href="structetl_1_1bitset.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1bitset.html">typename</a> MappingType::layout_type, <a class="el" href="structetl_1_1bitset.html">AccessorType</a> &gt;</td></tr>
<tr class="separator:a0f0eace36bd684274a175bbf90c48247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6740ef7f61c971d75fd44a39eac300f5" id="r_ga6740ef7f61c971d75fd44a39eac300f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga6740ef7f61c971d75fd44a39eac300f5">memchr</a> (<a class="el" href="structetl_1_1bitset.html">void</a> *ptr, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a> *</td></tr>
<tr class="memdesc:ga6740ef7f61c971d75fd44a39eac300f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <br /></td></tr>
<tr class="separator:ga6740ef7f61c971d75fd44a39eac300f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7e9e584f1928136b069284b7c32f45" id="r_gafc7e9e584f1928136b069284b7c32f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gafc7e9e584f1928136b069284b7c32f45">memchr</a> (<a class="el" href="structetl_1_1bitset.html">void</a> <a class="el" href="structetl_1_1bitset.html">const</a> *ptr, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:gafc7e9e584f1928136b069284b7c32f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts ch to unsigned char and locates the first occurrence of that value in the initial count characters (each interpreted as unsigned char) of the object pointed to by ptr.  <br /></td></tr>
<tr class="separator:gafc7e9e584f1928136b069284b7c32f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ec3f6b7d154def9046012af9517965" id="r_ga08ec3f6b7d154def9046012af9517965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga08ec3f6b7d154def9046012af9517965">memcpy</a> (<a class="el" href="structetl_1_1bitset.html">void</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">void</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a> *</td></tr>
<tr class="memdesc:ga08ec3f6b7d154def9046012af9517965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="group__cstring.html#ga4e0d1af4b8d0546159c26456db74a309" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead.  <br /></td></tr>
<tr class="separator:ga08ec3f6b7d154def9046012af9517965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e0d1af4b8d0546159c26456db74a309" id="r_ga4e0d1af4b8d0546159c26456db74a309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga4e0d1af4b8d0546159c26456db74a309">memmove</a> (<a class="el" href="structetl_1_1bitset.html">void</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">void</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a> *</td></tr>
<tr class="memdesc:ga4e0d1af4b8d0546159c26456db74a309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap.  <br /></td></tr>
<tr class="separator:ga4e0d1af4b8d0546159c26456db74a309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987e078e2adade59dfd923d96f3ba4ce" id="r_ga987e078e2adade59dfd923d96f3ba4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga987e078e2adade59dfd923d96f3ba4ce">memset</a> (<a class="el" href="structetl_1_1bitset.html">void</a> *<a class="el" href="structetl_1_1bitset.html">s</a>, <a class="el" href="structetl_1_1bitset.html">int</a> c, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a> *</td></tr>
<tr class="memdesc:ga987e078e2adade59dfd923d96f3ba4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of c (converted to an unsigned char) into each of the ﬁrst n characters of the object pointed to by s.  <br /></td></tr>
<tr class="separator:ga987e078e2adade59dfd923d96f3ba4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de3be8fc3e9e834497d00be337e09ea" id="r_ga2de3be8fc3e9e834497d00be337e09ea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga2de3be8fc3e9e834497d00be337e09ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga2de3be8fc3e9e834497d00be337e09ea">merge</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:ga2de3be8fc3e9e834497d00be337e09ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390da486f87fc7f5e59fd16cb3015c25" id="r_ga390da486f87fc7f5e59fd16cb3015c25"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga390da486f87fc7f5e59fd16cb3015c25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga390da486f87fc7f5e59fd16cb3015c25">merge</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga390da486f87fc7f5e59fd16cb3015c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into one sorted range beginning at <code>destination</code>.  <br /></td></tr>
<tr class="separator:ga390da486f87fc7f5e59fd16cb3015c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6585cd4834d332ff438ca8af30a270cf" id="r_ga6585cd4834d332ff438ca8af30a270cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1floating__point.html">etl::floating_point</a> Float&gt; </td></tr>
<tr class="memitem:ga6585cd4834d332ff438ca8af30a270cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga6585cd4834d332ff438ca8af30a270cf">midpoint</a> (<a class="el" href="structetl_1_1bitset.html">Float</a> a, <a class="el" href="structetl_1_1bitset.html">Float</a> b) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Float</a></td></tr>
<tr class="separator:ga6585cd4834d332ff438ca8af30a270cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95add6b4d15835797abab298377b728a" id="r_ga95add6b4d15835797abab298377b728a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Int</a> &gt; <br />
requires (<a class="el" href="#a396e4b8c756441b942c1619de108e56a">etl::is_integral_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">Int</a>&gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">etl::is_same_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">Int</a>, <a class="el" href="structetl_1_1bitset.html">bool</a>&gt;)</td></tr>
<tr class="memitem:ga95add6b4d15835797abab298377b728a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga95add6b4d15835797abab298377b728a">midpoint</a> (<a class="el" href="structetl_1_1bitset.html">Int</a> a, <a class="el" href="structetl_1_1bitset.html">Int</a> b) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a></td></tr>
<tr class="memdesc:ga95add6b4d15835797abab298377b728a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns half the sum of a + b. If the sum is odd, the result is rounded towards a.  <br /></td></tr>
<tr class="separator:ga95add6b4d15835797abab298377b728a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ecea7106161c23a577360c57654c08" id="r_ga06ecea7106161c23a577360c57654c08"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Ptr</a> &gt; <br />
requires <a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">etl::is_pointer_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">Ptr</a>&gt;</td></tr>
<tr class="memitem:ga06ecea7106161c23a577360c57654c08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga06ecea7106161c23a577360c57654c08">midpoint</a> (<a class="el" href="structetl_1_1bitset.html">Ptr</a> a, <a class="el" href="structetl_1_1bitset.html">Ptr</a> b) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Ptr</a></td></tr>
<tr class="separator:ga06ecea7106161c23a577360c57654c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga810b4260b22a58b461be941fa6acb745" id="r_ga810b4260b22a58b461be941fa6acb745"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> &gt; </td></tr>
<tr class="memitem:ga810b4260b22a58b461be941fa6acb745"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga810b4260b22a58b461be941fa6acb745">min</a> (<a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;a, <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="memdesc:ga810b4260b22a58b461be941fa6acb745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b.  <br /></td></tr>
<tr class="separator:ga810b4260b22a58b461be941fa6acb745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c60a3adb053935acbf3c8a91a0a035" id="r_ga80c60a3adb053935acbf3c8a91a0a035"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga80c60a3adb053935acbf3c8a91a0a035"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga80c60a3adb053935acbf3c8a91a0a035">min</a> (<a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;a, <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;b, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="memdesc:ga80c60a3adb053935acbf3c8a91a0a035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b, using a compare function.  <br /></td></tr>
<tr class="separator:ga80c60a3adb053935acbf3c8a91a0a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5571b6aa07c8298071d5e43411200c" id="r_ga4b5571b6aa07c8298071d5e43411200c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga4b5571b6aa07c8298071d5e43411200c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4b5571b6aa07c8298071d5e43411200c">min_element</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga4b5571b6aa07c8298071d5e43411200c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using operator&lt;.  <br /></td></tr>
<tr class="separator:ga4b5571b6aa07c8298071d5e43411200c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb64c2aeca7185a3fdd03bff27f93f2" id="r_ga4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4fb64c2aeca7185a3fdd03bff27f93f2">min_element</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga4fb64c2aeca7185a3fdd03bff27f93f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range <code>[first, last)</code>. Elements are compared using the given binary comparison function comp.  <br /></td></tr>
<tr class="separator:ga4fb64c2aeca7185a3fdd03bff27f93f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe7517750d66b576d14d06fd58d74b1" id="r_ga8fe7517750d66b576d14d06fd58d74b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga8fe7517750d66b576d14d06fd58d74b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga8fe7517750d66b576d14d06fd58d74b1">minmax</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;a, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;b) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp; &gt;</td></tr>
<tr class="memdesc:ga8fe7517750d66b576d14d06fd58d74b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <br /></td></tr>
<tr class="separator:ga8fe7517750d66b576d14d06fd58d74b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf8c00a7d8e6e8c5eff71f1063fad52" id="r_ga2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga2cf8c00a7d8e6e8c5eff71f1063fad52">minmax</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;a, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;b, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp; &gt;</td></tr>
<tr class="memdesc:ga2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <br /></td></tr>
<tr class="separator:ga2cf8c00a7d8e6e8c5eff71f1063fad52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ee575bad4a7b0cecd1869f7ecdc942" id="r_ga26ee575bad4a7b0cecd1869f7ecdc942"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga26ee575bad4a7b0cecd1869f7ecdc942"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga26ee575bad4a7b0cecd1869f7ecdc942">minmax_element</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:ga26ee575bad4a7b0cecd1869f7ecdc942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga26ee575bad4a7b0cecd1869f7ecdc942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68fb6c83c244cd496ea25c4f5a9d01f" id="r_gaa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gaa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaa68fb6c83c244cd496ea25c4f5a9d01f">minmax_element</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt;</td></tr>
<tr class="memdesc:gaa68fb6c83c244cd496ea25c4f5a9d01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gaa68fb6c83c244cd496ea25c4f5a9d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc526e4d807581e208306a999a8a51" id="r_a05cc526e4d807581e208306a999a8a51"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a05cc526e4d807581e208306a999a8a51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05cc526e4d807581e208306a999a8a51">mismatch</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">InputIt1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:a05cc526e4d807581e208306a999a8a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371e9767b06eb932a467448a6e8e32fc" id="r_a371e9767b06eb932a467448a6e8e32fc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt; </td></tr>
<tr class="memitem:a371e9767b06eb932a467448a6e8e32fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a371e9767b06eb932a467448a6e8e32fc">mismatch</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">InputIt1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:a371e9767b06eb932a467448a6e8e32fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1833ff8cfefd00fbce92848e93af31e4" id="r_a1833ff8cfefd00fbce92848e93af31e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:a1833ff8cfefd00fbce92848e93af31e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1833ff8cfefd00fbce92848e93af31e4">mismatch</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">InputIt1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt;</td></tr>
<tr class="separator:a1833ff8cfefd00fbce92848e93af31e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272907f42acd772ea50acaa07ffb12aa" id="r_ga272907f42acd772ea50acaa07ffb12aa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga272907f42acd772ea50acaa07ffb12aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga272907f42acd772ea50acaa07ffb12aa">mismatch</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">InputIt1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt;</td></tr>
<tr class="memdesc:ga272907f42acd772ea50acaa07ffb12aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by <code>[first1, last1)</code> and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred.  <br /></td></tr>
<tr class="separator:ga272907f42acd772ea50acaa07ffb12aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9060e0931516472a88f4657d835684a9" id="r_ga9060e0931516472a88f4657d835684a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga9060e0931516472a88f4657d835684a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga9060e0931516472a88f4657d835684a9">move</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga9060e0931516472a88f4657d835684a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in the range <code>[first, last)</code>, to another range beginning at destination, starting from first and proceeding to <code>last - 1</code>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.  <br /></td></tr>
<tr class="separator:ga9060e0931516472a88f4657d835684a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb87647bd4c378500cd694ccc0e4608" id="r_adeb87647bd4c378500cd694ccc0e4608"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adeb87647bd4c378500cd694ccc0e4608"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adeb87647bd4c378500cd694ccc0e4608">move</a> (T &amp;&amp;<a class="el" href="structetl_1_1bitset.html">t</a>) noexcept -&gt; <a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">etl::remove_reference_t</a>&lt; T &gt; &amp;&amp;</td></tr>
<tr class="memdesc:adeb87647bd4c378500cd694ccc0e4608"><td class="mdescLeft">&#160;</td><td class="mdescRight">move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.  <br /></td></tr>
<tr class="separator:adeb87647bd4c378500cd694ccc0e4608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf551d4e71ff0eabb8f92409796fcf33d" id="r_gaf551d4e71ff0eabb8f92409796fcf33d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt2</a> &gt; </td></tr>
<tr class="memitem:gaf551d4e71ff0eabb8f92409796fcf33d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaf551d4e71ff0eabb8f92409796fcf33d">move_backward</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt1</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt1</a> last, <a class="el" href="structetl_1_1bitset.html">BidirIt2</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">BidirIt2</a></td></tr>
<tr class="memdesc:gaf551d4e71ff0eabb8f92409796fcf33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements from the range <code>[first, last)</code>, to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.  <br /></td></tr>
<tr class="separator:gaf551d4e71ff0eabb8f92409796fcf33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae197a91f87223433229090889ab96734" id="r_ae197a91f87223433229090889ab96734"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae197a91f87223433229090889ab96734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae197a91f87223433229090889ab96734">move_if_noexcept</a> (T &amp;<a class="el" href="structetl_1_1bitset.html">x</a>) noexcept -&gt; <a class="el" href="#a09d091a01d0f719c0e795ed347e18a6d">etl::conditional_t</a>&lt;!<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="#a03f5da2852be4424089f4235ef44dec2">etl::is_copy_constructible_v</a>&lt; T &gt;, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;, T &amp;&amp; &gt;</td></tr>
<tr class="memdesc:ae197a91f87223433229090889ab96734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally convert a value to an rvalue.  <br /></td></tr>
<tr class="separator:ae197a91f87223433229090889ab96734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e8085c3345374b117c1dc70edf9d9b" id="r_gab5e8085c3345374b117c1dc70edf9d9b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> &gt; </td></tr>
<tr class="memitem:gab5e8085c3345374b117c1dc70edf9d9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gab5e8085c3345374b117c1dc70edf9d9b">next</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> <a class="el" href="structetl_1_1bitset.html">it</a>, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1bitset.html">InputIt</a> &gt;::difference_type <a class="el" href="structetl_1_1bitset.html">n</a>=1) -&gt; <a class="el" href="structetl_1_1bitset.html">InputIt</a></td></tr>
<tr class="memdesc:gab5e8085c3345374b117c1dc70edf9d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth successor of iterator it.  <br /></td></tr>
<tr class="separator:gab5e8085c3345374b117c1dc70edf9d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga816a532bf04d7e7c0a846b930a571a1d" id="r_ga816a532bf04d7e7c0a846b930a571a1d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga816a532bf04d7e7c0a846b930a571a1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga816a532bf04d7e7c0a846b930a571a1d">none_of</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga816a532bf04d7e7c0a846b930a571a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for no elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga816a532bf04d7e7c0a846b930a571a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f970b8afc721e0d297f41f5b4e93b4f" id="r_ga5f970b8afc721e0d297f41f5b4e93b4f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga5f970b8afc721e0d297f41f5b4e93b4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga5f970b8afc721e0d297f41f5b4e93b4f">norm</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; T</td></tr>
<tr class="separator:ga5f970b8afc721e0d297f41f5b4e93b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad53365f58607769e78eb64bf2442fc3b" id="r_gad53365f58607769e78eb64bf2442fc3b"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:gad53365f58607769e78eb64bf2442fc3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gad53365f58607769e78eb64bf2442fc3b">norm</a> (<a class="el" href="structetl_1_1bitset.html">Float</a> f) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">Float</a> &gt;</td></tr>
<tr class="separator:gad53365f58607769e78eb64bf2442fc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8258458b8977e7d9a73c4bcc2f61bca6" id="r_ga8258458b8977e7d9a73c4bcc2f61bca6"><td class="memTemplParams" colspan="2">template&lt;integral Integer&gt; </td></tr>
<tr class="memitem:ga8258458b8977e7d9a73c4bcc2f61bca6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga8258458b8977e7d9a73c4bcc2f61bca6">norm</a> (<a class="el" href="structetl_1_1bitset.html">Integer</a> <a class="el" href="structetl_1_1bitset.html">i</a>) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">double</a> &gt;</td></tr>
<tr class="separator:ga8258458b8977e7d9a73c4bcc2f61bca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92780374b4fcf868ff0a7cb7dddaa385" id="r_a92780374b4fcf868ff0a7cb7dddaa385"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">auto</a> ConstFn&gt; </td></tr>
<tr class="memitem:a92780374b4fcf868ff0a7cb7dddaa385"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92780374b4fcf868ff0a7cb7dddaa385">not_fn</a> () noexcept -&gt; detail::stateless_not_fn&lt; <a class="el" href="structetl_1_1bitset.html">ConstFn</a> &gt;</td></tr>
<tr class="separator:a92780374b4fcf868ff0a7cb7dddaa385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea99b0f54121ebdd09e467ea46f3f865" id="r_aea99b0f54121ebdd09e467ea46f3f865"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> &gt; </td></tr>
<tr class="memitem:aea99b0f54121ebdd09e467ea46f3f865"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea99b0f54121ebdd09e467ea46f3f865">not_fn</a> (<a class="el" href="structetl_1_1bitset.html">F</a> &amp;&amp;f) -&gt; detail::not_fn_t&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">etl::decay_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">F</a> &gt; &gt;</td></tr>
<tr class="separator:aea99b0f54121ebdd09e467ea46f3f865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477060cd9d79c15a82456242a3005517" id="r_a477060cd9d79c15a82456242a3005517"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a477060cd9d79c15a82456242a3005517"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a477060cd9d79c15a82456242a3005517">nth_element</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> <a class="el" href="structetl_1_1bitset.html">nth</a>, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:a477060cd9d79c15a82456242a3005517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a975e8950c5e7cc4ff7f97638d34a53" id="r_ga8a975e8950c5e7cc4ff7f97638d34a53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga8a975e8950c5e7cc4ff7f97638d34a53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga8a975e8950c5e7cc4ff7f97638d34a53">nth_element</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> <a class="el" href="structetl_1_1bitset.html">nth</a>, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga8a975e8950c5e7cc4ff7f97638d34a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">nth_element is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that:  <br /></td></tr>
<tr class="separator:ga8a975e8950c5e7cc4ff7f97638d34a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e5b0ddb23a7821301be31ebd8198ea" id="r_a99e5b0ddb23a7821301be31ebd8198ea"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a99e5b0ddb23a7821301be31ebd8198ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99e5b0ddb23a7821301be31ebd8198ea">operator!=</a> (<a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a99e5b0ddb23a7821301be31ebd8198ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a99e5b0ddb23a7821301be31ebd8198ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c27b4cf9bc931994626a2ef5dccdd31" id="r_a0c27b4cf9bc931994626a2ef5dccdd31"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0c27b4cf9bc931994626a2ef5dccdd31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c27b4cf9bc931994626a2ef5dccdd31">operator!=</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a0c27b4cf9bc931994626a2ef5dccdd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ed7f0af0742e1a5ac4571b8a0cb1f8" id="r_a21ed7f0af0742e1a5ac4571b8a0cb1f8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a21ed7f0af0742e1a5ac4571b8a0cb1f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21ed7f0af0742e1a5ac4571b8a0cb1f8">operator!=</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a21ed7f0af0742e1a5ac4571b8a0cb1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49422796568a3674505ac60670c4010" id="r_ab49422796568a3674505ac60670c4010"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:ab49422796568a3674505ac60670c4010"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab49422796568a3674505ac60670c4010">operator!=</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ab49422796568a3674505ac60670c4010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ab49422796568a3674505ac60670c4010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f52b3227280e130c8b8d2a8c424c4c0" id="r_a8f52b3227280e130c8b8d2a8c424c4c0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a8f52b3227280e130c8b8d2a8c424c4c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f52b3227280e130c8b8d2a8c424c4c0">operator!=</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a8f52b3227280e130c8b8d2a8c424c4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a8f52b3227280e130c8b8d2a8c424c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42d5ab2b854a73191219d9dd7768be5" id="r_aa42d5ab2b854a73191219d9dd7768be5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:aa42d5ab2b854a73191219d9dd7768be5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa42d5ab2b854a73191219d9dd7768be5">operator!=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:aa42d5ab2b854a73191219d9dd7768be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:aa42d5ab2b854a73191219d9dd7768be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4874c4f433c6b61ab0bf85023f138b4c" id="r_a4874c4f433c6b61ab0bf85023f138b4c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a4874c4f433c6b61ab0bf85023f138b4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4874c4f433c6b61ab0bf85023f138b4c">operator!=</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;f, <a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a4874c4f433c6b61ab0bf85023f138b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:a4874c4f433c6b61ab0bf85023f138b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677b4c86284624fe83dc36333e3d4212" id="r_a677b4c86284624fe83dc36333e3d4212"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Rhs</a> , <a class="el" href="structetl_1_1bitset.html">Rhs</a> R, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Lhs</a> , <a class="el" href="structetl_1_1bitset.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:a677b4c86284624fe83dc36333e3d4212"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a677b4c86284624fe83dc36333e3d4212">operator!=</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Rhs</a>, <a class="el" href="structetl_1_1bitset.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Lhs</a>, <a class="el" href="structetl_1_1bitset.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">bool</a>, <a class="el" href="structetl_1_1bitset.html">L</a> !=<a class="el" href="structetl_1_1bitset.html">R</a> &gt;</td></tr>
<tr class="separator:a677b4c86284624fe83dc36333e3d4212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7d0d2c778d8ba04d8b73a77fec5d83" id="r_afd7d0d2c778d8ba04d8b73a77fec5d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd7d0d2c778d8ba04d8b73a77fec5d83">operator!=</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:afd7d0d2c778d8ba04d8b73a77fec5d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfdea32a40caa3a28fb120ded25d66e" id="r_afdfdea32a40caa3a28fb120ded25d66e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:afdfdea32a40caa3a28fb120ded25d66e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdfdea32a40caa3a28fb120ded25d66e">operator!=</a> (<a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;f) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:afdfdea32a40caa3a28fb120ded25d66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:afdfdea32a40caa3a28fb120ded25d66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b524b62bdc9f0a6c515bb44965cb68c" id="r_a3b524b62bdc9f0a6c515bb44965cb68c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </td></tr>
<tr class="memitem:a3b524b62bdc9f0a6c515bb44965cb68c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b524b62bdc9f0a6c515bb44965cb68c">operator!=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a3b524b62bdc9f0a6c515bb44965cb68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:a3b524b62bdc9f0a6c515bb44965cb68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473df8e3ace08ad49d812cd57fcc5f90" id="r_a473df8e3ace08ad49d812cd57fcc5f90"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a473df8e3ace08ad49d812cd57fcc5f90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a473df8e3ace08ad49d812cd57fcc5f90">operator!=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a473df8e3ace08ad49d812cd57fcc5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b2c8e96c56c4b8a13d0a122cf47b17" id="r_a87b2c8e96c56c4b8a13d0a122cf47b17"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a87b2c8e96c56c4b8a13d0a122cf47b17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a87b2c8e96c56c4b8a13d0a122cf47b17">operator!=</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a87b2c8e96c56c4b8a13d0a122cf47b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaba1a7c447283c046a48394e74172ea" id="r_aaaba1a7c447283c046a48394e74172ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#aaaba1a7c447283c046a48394e74172ea">operator&quot;&quot;_d</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> d) noexcept -&gt; <a class="el" href="structetl_1_1chrono_1_1day.html">etl::chrono::day</a></td></tr>
<tr class="memdesc:aaaba1a7c447283c046a48394e74172ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1day.html">etl::chrono::day</a> literal representing a day of the month in the calendar.  <br /></td></tr>
<tr class="separator:aaaba1a7c447283c046a48394e74172ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4577bf7867d4337d8dd08dc3fc31900" id="r_ae4577bf7867d4337d8dd08dc3fc31900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#ae4577bf7867d4337d8dd08dc3fc31900">operator&quot;&quot;_h</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> h) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a>, <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 3600, 1 &gt; &gt;</td></tr>
<tr class="memdesc:ae4577bf7867d4337d8dd08dc3fc31900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing hours. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#ae4c835a01e4830892ef9701461215a4e" title="Signed integer type of at least 23 bits.">etl::chrono::hours</a>.  <br /></td></tr>
<tr class="separator:ae4577bf7867d4337d8dd08dc3fc31900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4723809483e46957434578efbbf37c8" id="r_ab4723809483e46957434578efbbf37c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#ab4723809483e46957434578efbbf37c8">operator&quot;&quot;_h</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> h) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#ae4c835a01e4830892ef9701461215a4e">etl::chrono::hours</a></td></tr>
<tr class="memdesc:ab4723809483e46957434578efbbf37c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing hours. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#ae4c835a01e4830892ef9701461215a4e" title="Signed integer type of at least 23 bits.">etl::chrono::hours(hrs)</a>.  <br /></td></tr>
<tr class="separator:ab4723809483e46957434578efbbf37c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2266f4104a4fb536c9a02bcb8fa139d" id="r_ac2266f4104a4fb536c9a02bcb8fa139d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#ac2266f4104a4fb536c9a02bcb8fa139d">operator&quot;&quot;_i</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">double</a> &gt;</td></tr>
<tr class="separator:ac2266f4104a4fb536c9a02bcb8fa139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f553b242808150befd3366a0aee09fc" id="r_a2f553b242808150befd3366a0aee09fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a2f553b242808150befd3366a0aee09fc">operator&quot;&quot;_i</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">double</a> &gt;</td></tr>
<tr class="separator:a2f553b242808150befd3366a0aee09fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480d031789767adfbb12ca58dd47dec7" id="r_a480d031789767adfbb12ca58dd47dec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a480d031789767adfbb12ca58dd47dec7">operator&quot;&quot;_if</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">float</a> &gt;</td></tr>
<tr class="separator:a480d031789767adfbb12ca58dd47dec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa911f105ff040ac4aedea0f73e86dcf0" id="r_aa911f105ff040ac4aedea0f73e86dcf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#aa911f105ff040ac4aedea0f73e86dcf0">operator&quot;&quot;_if</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">float</a> &gt;</td></tr>
<tr class="separator:aa911f105ff040ac4aedea0f73e86dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853b7e0bec79c51fcf33f952a7415700" id="r_a853b7e0bec79c51fcf33f952a7415700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a853b7e0bec79c51fcf33f952a7415700">operator&quot;&quot;_il</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> &gt;</td></tr>
<tr class="separator:a853b7e0bec79c51fcf33f952a7415700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394f12cefe14e96cca9da3af660a66b7" id="r_a394f12cefe14e96cca9da3af660a66b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1complex__literals.html#a394f12cefe14e96cca9da3af660a66b7">operator&quot;&quot;_il</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> d) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> &gt;</td></tr>
<tr class="separator:a394f12cefe14e96cca9da3af660a66b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffa7b6293471e52a5217851a25ed47f" id="r_afffa7b6293471e52a5217851a25ed47f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#afffa7b6293471e52a5217851a25ed47f">operator&quot;&quot;_min</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a>, <a class="el" href="structetl_1_1ratio.html">etl::ratio</a>&lt; 60, 1 &gt; &gt;</td></tr>
<tr class="memdesc:afffa7b6293471e52a5217851a25ed47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing minutes. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a76434032b633191afff02bd6132b1fcf" title="Signed integer type of at least 29 bits.">etl::chrono::minutes</a>.  <br /></td></tr>
<tr class="separator:afffa7b6293471e52a5217851a25ed47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec4b5254ed6657b1f18b4d95cb6273b" id="r_a3ec4b5254ed6657b1f18b4d95cb6273b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a3ec4b5254ed6657b1f18b4d95cb6273b">operator&quot;&quot;_min</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a76434032b633191afff02bd6132b1fcf">etl::chrono::minutes</a></td></tr>
<tr class="memdesc:a3ec4b5254ed6657b1f18b4d95cb6273b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing minutes. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#a76434032b633191afff02bd6132b1fcf" title="Signed integer type of at least 29 bits.">etl::chrono::minutes(mins)</a>.  <br /></td></tr>
<tr class="separator:a3ec4b5254ed6657b1f18b4d95cb6273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c45fa1092960236ed3d893f8ababb0c" id="r_a8c45fa1092960236ed3d893f8ababb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a8c45fa1092960236ed3d893f8ababb0c">operator&quot;&quot;_ms</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a>, <a class="el" href="#ab10931e9eceef3f81bae9ea43bdd8e89">etl::milli</a> &gt;</td></tr>
<tr class="memdesc:a8c45fa1092960236ed3d893f8ababb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing milliseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a2d20076b8b8ba2dbc8cbcaee638b48f1" title="Signed integer type of at least 45 bits.">etl::chrono::milliseconds</a>.  <br /></td></tr>
<tr class="separator:a8c45fa1092960236ed3d893f8ababb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e7126dbdb381ba91fc2640ad3d4d80" id="r_a06e7126dbdb381ba91fc2640ad3d4d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a06e7126dbdb381ba91fc2640ad3d4d80">operator&quot;&quot;_ms</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a2d20076b8b8ba2dbc8cbcaee638b48f1">etl::chrono::milliseconds</a></td></tr>
<tr class="memdesc:a06e7126dbdb381ba91fc2640ad3d4d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing milliseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#a2d20076b8b8ba2dbc8cbcaee638b48f1" title="Signed integer type of at least 45 bits.">etl::chrono::milliseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a06e7126dbdb381ba91fc2640ad3d4d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b50f9e1b881a27f0114aabcbec55a3" id="r_a64b50f9e1b881a27f0114aabcbec55a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a64b50f9e1b881a27f0114aabcbec55a3">operator&quot;&quot;_ns</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a>, <a class="el" href="#a1718104bd02150cc3a553b7289ea2d2d">etl::nano</a> &gt;</td></tr>
<tr class="memdesc:a64b50f9e1b881a27f0114aabcbec55a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing nanoseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#aa2bdb8896e8a0a6a257483bf345f97ec" title="Signed integer type of at least 64 bits.">etl::chrono::nanoseconds</a>.  <br /></td></tr>
<tr class="separator:a64b50f9e1b881a27f0114aabcbec55a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbff174c4704c0334cf0614ef691012" id="r_a5bbff174c4704c0334cf0614ef691012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a5bbff174c4704c0334cf0614ef691012">operator&quot;&quot;_ns</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#aa2bdb8896e8a0a6a257483bf345f97ec">etl::chrono::nanoseconds</a></td></tr>
<tr class="memdesc:a5bbff174c4704c0334cf0614ef691012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing nanoseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#aa2bdb8896e8a0a6a257483bf345f97ec" title="Signed integer type of at least 64 bits.">etl::chrono::nanoseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a5bbff174c4704c0334cf0614ef691012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b537721ce0895c51b93d53d4542d746" id="r_a5b537721ce0895c51b93d53d4542d746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a5b537721ce0895c51b93d53d4542d746">operator&quot;&quot;_s</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> &gt;</td></tr>
<tr class="memdesc:a5b537721ce0895c51b93d53d4542d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing seconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#ad74086ee1024e4cf191fcc7e461a2835" title="Signed integer type of at least 35 bits.">etl::chrono::seconds</a>.  <br /></td></tr>
<tr class="separator:a5b537721ce0895c51b93d53d4542d746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf39bd85cf926b2a54efaa5bfffe433" id="r_accf39bd85cf926b2a54efaa5bfffe433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#accf39bd85cf926b2a54efaa5bfffe433">operator&quot;&quot;_s</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#ad74086ee1024e4cf191fcc7e461a2835">etl::chrono::seconds</a></td></tr>
<tr class="memdesc:accf39bd85cf926b2a54efaa5bfffe433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing seconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#ad74086ee1024e4cf191fcc7e461a2835" title="Signed integer type of at least 35 bits.">etl::chrono::seconds(mins)</a>.  <br /></td></tr>
<tr class="separator:accf39bd85cf926b2a54efaa5bfffe433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2624a1c2bc9ae10e7e77dddbc403bf22" id="r_a2624a1c2bc9ae10e7e77dddbc403bf22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1string__view__literals.html#a2624a1c2bc9ae10e7e77dddbc403bf22">operator&quot;&quot;_sv</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">len</a>) noexcept -&gt; <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td></tr>
<tr class="memdesc:a2624a1c2bc9ae10e7e77dddbc403bf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a string view of a character literal. Returns <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f" title="Typedefs for common character type.">etl::string_view</a>{str, len}.  <br /></td></tr>
<tr class="separator:a2624a1c2bc9ae10e7e77dddbc403bf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f2fde9a4fd051a6bc050a417a1b859" id="r_a41f2fde9a4fd051a6bc050a417a1b859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a41f2fde9a4fd051a6bc050a417a1b859">operator&quot;&quot;_us</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> m) -&gt; <a class="el" href="structetl_1_1chrono_1_1duration.html">etl::chrono::duration</a>&lt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a>, <a class="el" href="#af06b69df89587850ded6209b864e7569">etl::micro</a> &gt;</td></tr>
<tr class="memdesc:a41f2fde9a4fd051a6bc050a417a1b859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing microseconds. Floating-point literal, returns a floating-point duration equivalent to <a class="el" href="namespaceetl_1_1chrono.html#a080788fed03294e645b6718a9063b197" title="Signed integer type of at least 55 bits.">etl::chrono::microseconds</a>.  <br /></td></tr>
<tr class="separator:a41f2fde9a4fd051a6bc050a417a1b859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cefb6c59cd3f3c6fc3d7c87b547074c" id="r_a6cefb6c59cd3f3c6fc3d7c87b547074c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals_1_1chrono__literals.html#a6cefb6c59cd3f3c6fc3d7c87b547074c">operator&quot;&quot;_us</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> m) -&gt; <a class="el" href="namespaceetl_1_1chrono.html#a080788fed03294e645b6718a9063b197">etl::chrono::microseconds</a></td></tr>
<tr class="memdesc:a6cefb6c59cd3f3c6fc3d7c87b547074c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a <a class="el" href="structetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval.">etl::chrono::duration</a> literal representing microseconds. Integer literal, returns exactly <a class="el" href="namespaceetl_1_1chrono.html#a080788fed03294e645b6718a9063b197" title="Signed integer type of at least 55 bits.">etl::chrono::microseconds(mins)</a>.  <br /></td></tr>
<tr class="separator:a6cefb6c59cd3f3c6fc3d7c87b547074c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91ff1be82212d980d87b1b7eee50ae" id="r_a3e91ff1be82212d980d87b1b7eee50ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:a3e91ff1be82212d980d87b1b7eee50ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e91ff1be82212d980d87b1b7eee50ae">operator&amp;</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt;</td></tr>
<tr class="memdesc:a3e91ff1be82212d980d87b1b7eee50ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary AND between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:a3e91ff1be82212d980d87b1b7eee50ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86219208a90a3dde7323cc44e0df0ef4" id="r_a86219208a90a3dde7323cc44e0df0ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86219208a90a3dde7323cc44e0df0ef4">operator&amp;</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:a86219208a90a3dde7323cc44e0df0ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) &amp; static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:a86219208a90a3dde7323cc44e0df0ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb7a75a06b494847b855d850a44918" id="r_a99fb7a75a06b494847b855d850a44918"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a99fb7a75a06b494847b855d850a44918"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99fb7a75a06b494847b855d850a44918">operator&amp;</a> (T <a class="el" href="structetl_1_1bitset.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:a99fb7a75a06b494847b855d850a44918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d19ed615073fb38a2b13da90e273c7c" id="r_a7d19ed615073fb38a2b13da90e273c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d19ed615073fb38a2b13da90e273c7c">operator&amp;=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a7d19ed615073fb38a2b13da90e273c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs &amp; rhs;</code>  <br /></td></tr>
<tr class="separator:a7d19ed615073fb38a2b13da90e273c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcea5ac2499171347312a5f20051970" id="r_a2fcea5ac2499171347312a5f20051970"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a2fcea5ac2499171347312a5f20051970"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2fcea5ac2499171347312a5f20051970">operator&amp;=</a> (T &amp;<a class="el" href="structetl_1_1bitset.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="separator:a2fcea5ac2499171347312a5f20051970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade01d8f935d63f6d9cba9fbe323f8821" id="r_ade01d8f935d63f6d9cba9fbe323f8821"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ade01d8f935d63f6d9cba9fbe323f8821"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade01d8f935d63f6d9cba9fbe323f8821">operator*</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ade01d8f935d63f6d9cba9fbe323f8821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9749f0f6e219a2633cc87acdfe48904" id="r_af9749f0f6e219a2633cc87acdfe48904"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af9749f0f6e219a2633cc87acdfe48904"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9749f0f6e219a2633cc87acdfe48904">operator*</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:af9749f0f6e219a2633cc87acdfe48904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfad387b2163cd13b324a0f466cb12cd" id="r_acfad387b2163cd13b324a0f466cb12cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:acfad387b2163cd13b324a0f466cb12cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfad387b2163cd13b324a0f466cb12cd">operator*</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:acfad387b2163cd13b324a0f466cb12cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c02fa2b4e3d75149c7c267b0b86789e" id="r_a7c02fa2b4e3d75149c7c267b0b86789e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a7c02fa2b4e3d75149c7c267b0b86789e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c02fa2b4e3d75149c7c267b0b86789e">operator+</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a7c02fa2b4e3d75149c7c267b0b86789e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a7c02fa2b4e3d75149c7c267b0b86789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b2ef0a592d24d47bd878ebab0b1fcd" id="r_ae3b2ef0a592d24d47bd878ebab0b1fcd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ae3b2ef0a592d24d47bd878ebab0b1fcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3b2ef0a592d24d47bd878ebab0b1fcd">operator+</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:ae3b2ef0a592d24d47bd878ebab0b1fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:ae3b2ef0a592d24d47bd878ebab0b1fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965bb0b68cd6953bbc4bea8deb155b75" id="r_a965bb0b68cd6953bbc4bea8deb155b75"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a965bb0b68cd6953bbc4bea8deb155b75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a965bb0b68cd6953bbc4bea8deb155b75">operator+</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:a965bb0b68cd6953bbc4bea8deb155b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:a965bb0b68cd6953bbc4bea8deb155b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf2684bd57acf26e10d868de8ee378e" id="r_accf2684bd57acf26e10d868de8ee378e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:accf2684bd57acf26e10d868de8ee378e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#accf2684bd57acf26e10d868de8ee378e">operator+</a> (<a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:accf2684bd57acf26e10d868de8ee378e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:accf2684bd57acf26e10d868de8ee378e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfb1769b71b9cc8fa1deda92b613ca6" id="r_addfb1769b71b9cc8fa1deda92b613ca6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:addfb1769b71b9cc8fa1deda92b613ca6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#addfb1769b71b9cc8fa1deda92b613ca6">operator+</a> (<a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td></tr>
<tr class="memdesc:addfb1769b71b9cc8fa1deda92b613ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing characters from lhs followed by the characters from rhs.  <br /></td></tr>
<tr class="separator:addfb1769b71b9cc8fa1deda92b613ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71864baa5b16ae3823bed93daadd854e" id="r_a71864baa5b16ae3823bed93daadd854e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a71864baa5b16ae3823bed93daadd854e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71864baa5b16ae3823bed93daadd854e">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a71864baa5b16ae3823bed93daadd854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2343a7c24574c0a76def77f277d07e" id="r_afd2343a7c24574c0a76def77f277d07e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afd2343a7c24574c0a76def77f277d07e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd2343a7c24574c0a76def77f277d07e">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:afd2343a7c24574c0a76def77f277d07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1ea907ad0e2faef6a9dc5daae77f10" id="r_a8f1ea907ad0e2faef6a9dc5daae77f10"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8f1ea907ad0e2faef6a9dc5daae77f10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f1ea907ad0e2faef6a9dc5daae77f10">operator+</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;val) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a8f1ea907ad0e2faef6a9dc5daae77f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab218217c542cbcae689d277e927d360a" id="r_ab218217c542cbcae689d277e927d360a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Rhs</a> , <a class="el" href="structetl_1_1bitset.html">Rhs</a> R, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Lhs</a> , <a class="el" href="structetl_1_1bitset.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:ab218217c542cbcae689d277e927d360a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab218217c542cbcae689d277e927d360a">operator+</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Rhs</a>, <a class="el" href="structetl_1_1bitset.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Lhs</a>, <a class="el" href="structetl_1_1bitset.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">L</a>+<a class="el" href="structetl_1_1bitset.html">R</a>), <a class="el" href="structetl_1_1bitset.html">L</a>+<a class="el" href="structetl_1_1bitset.html">R</a> &gt;</td></tr>
<tr class="separator:ab218217c542cbcae689d277e927d360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278c443da9c85213dd35424e55083798" id="r_a278c443da9c85213dd35424e55083798"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a278c443da9c85213dd35424e55083798"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a278c443da9c85213dd35424e55083798">operator+</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a278c443da9c85213dd35424e55083798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6132e0e8e9af5871d3647489c0e9ab7f" id="r_a6132e0e8e9af5871d3647489c0e9ab7f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; </td></tr>
<tr class="memitem:a6132e0e8e9af5871d3647489c0e9ab7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6132e0e8e9af5871d3647489c0e9ab7f">operator+</a> (<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt;::difference_type <a class="el" href="structetl_1_1bitset.html">n</a>, <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">it</a>) noexcept(noexcept(it.base() - <a class="el" href="structetl_1_1bitset.html">n</a>)) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt;</td></tr>
<tr class="memdesc:a6132e0e8e9af5871d3647489c0e9ab7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator it incremented by n.  <br /></td></tr>
<tr class="separator:a6132e0e8e9af5871d3647489c0e9ab7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368b52e0bd3a7839fd60d3f5e39cbb0f" id="r_a368b52e0bd3a7839fd60d3f5e39cbb0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a368b52e0bd3a7839fd60d3f5e39cbb0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a368b52e0bd3a7839fd60d3f5e39cbb0f">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a368b52e0bd3a7839fd60d3f5e39cbb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af027a8b3ad1bb5ca5f5179ed2206ad66" id="r_af027a8b3ad1bb5ca5f5179ed2206ad66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af027a8b3ad1bb5ca5f5179ed2206ad66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af027a8b3ad1bb5ca5f5179ed2206ad66">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:af027a8b3ad1bb5ca5f5179ed2206ad66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8518792aba8f0c6bfdf3518364ab586c" id="r_a8518792aba8f0c6bfdf3518364ab586c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8518792aba8f0c6bfdf3518364ab586c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8518792aba8f0c6bfdf3518364ab586c">operator-</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;val) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a8518792aba8f0c6bfdf3518364ab586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d97b143943fdd5165246151965e6e1a" id="r_a2d97b143943fdd5165246151965e6e1a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iterator1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iterator2</a> &gt; </td></tr>
<tr class="memitem:a2d97b143943fdd5165246151965e6e1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d97b143943fdd5165246151965e6e1a">operator-</a> (<a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iterator1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iterator2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept(noexcept(rhs.base() - lhs.base())) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(rhs.base() - lhs.base())</td></tr>
<tr class="memdesc:a2d97b143943fdd5165246151965e6e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two iterator adaptors.  <br /></td></tr>
<tr class="separator:a2d97b143943fdd5165246151965e6e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa390de4495e3c0ec93c4491c5639143" id="r_aaa390de4495e3c0ec93c4491c5639143"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aaa390de4495e3c0ec93c4491c5639143"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa390de4495e3c0ec93c4491c5639143">operator-</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:aaa390de4495e3c0ec93c4491c5639143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b89ab01f9efe7650b6a97888f1e869" id="r_ac1b89ab01f9efe7650b6a97888f1e869"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac1b89ab01f9efe7650b6a97888f1e869"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1b89ab01f9efe7650b6a97888f1e869">operator/</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ac1b89ab01f9efe7650b6a97888f1e869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdc7ea9b09001e49518715162e70290" id="r_aafdc7ea9b09001e49518715162e70290"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aafdc7ea9b09001e49518715162e70290"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafdc7ea9b09001e49518715162e70290">operator/</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:aafdc7ea9b09001e49518715162e70290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9660b9b2b46b561d976ffbf7dbde8d69" id="r_a9660b9b2b46b561d976ffbf7dbde8d69"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a9660b9b2b46b561d976ffbf7dbde8d69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9660b9b2b46b561d976ffbf7dbde8d69">operator/</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:a9660b9b2b46b561d976ffbf7dbde8d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3293c8c6e37d2b24c05f95baa58aef" id="r_a2c3293c8c6e37d2b24c05f95baa58aef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a2c3293c8c6e37d2b24c05f95baa58aef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c3293c8c6e37d2b24c05f95baa58aef">operator&lt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a2c3293c8c6e37d2b24c05f95baa58aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af437446fcc1e53640c10980cfd99616e" id="r_af437446fcc1e53640c10980cfd99616e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </td></tr>
<tr class="memitem:af437446fcc1e53640c10980cfd99616e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af437446fcc1e53640c10980cfd99616e">operator&lt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:af437446fcc1e53640c10980cfd99616e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:af437446fcc1e53640c10980cfd99616e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571d0698767bc83dd12cd1d4d3dd9a9c" id="r_a571d0698767bc83dd12cd1d4d3dd9a9c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a571d0698767bc83dd12cd1d4d3dd9a9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a571d0698767bc83dd12cd1d4d3dd9a9c">operator&lt;</a> (<a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a571d0698767bc83dd12cd1d4d3dd9a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a571d0698767bc83dd12cd1d4d3dd9a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3409e7cab3e6c13e3d748566971e05e" id="r_ae3409e7cab3e6c13e3d748566971e05e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:ae3409e7cab3e6c13e3d748566971e05e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3409e7cab3e6c13e3d748566971e05e">operator&lt;</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ae3409e7cab3e6c13e3d748566971e05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435b7c6bb6e776d7d7b22bc36f3a364" id="r_a6435b7c6bb6e776d7d7b22bc36f3a364"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a6435b7c6bb6e776d7d7b22bc36f3a364"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6435b7c6bb6e776d7d7b22bc36f3a364">operator&lt;</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a6435b7c6bb6e776d7d7b22bc36f3a364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a6435b7c6bb6e776d7d7b22bc36f3a364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cd653fa75caba7b24defbc611c6f71" id="r_ab4cd653fa75caba7b24defbc611c6f71"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:ab4cd653fa75caba7b24defbc611c6f71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4cd653fa75caba7b24defbc611c6f71">operator&lt;</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:ab4cd653fa75caba7b24defbc611c6f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ab4cd653fa75caba7b24defbc611c6f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b87a87e119f906f153eb7a9dd4b27f" id="r_a86b87a87e119f906f153eb7a9dd4b27f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:a86b87a87e119f906f153eb7a9dd4b27f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86b87a87e119f906f153eb7a9dd4b27f">operator&lt;</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a86b87a87e119f906f153eb7a9dd4b27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:a86b87a87e119f906f153eb7a9dd4b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3d8b9402fd47ee81c43ca9621035b7" id="r_acc3d8b9402fd47ee81c43ca9621035b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc3d8b9402fd47ee81c43ca9621035b7">operator&lt;</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:acc3d8b9402fd47ee81c43ca9621035b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4f1579948c0050989b6bc4d56f0862" id="r_a1e4f1579948c0050989b6bc4d56f0862"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a1e4f1579948c0050989b6bc4d56f0862"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e4f1579948c0050989b6bc4d56f0862">operator&lt;</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a1e4f1579948c0050989b6bc4d56f0862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a1e4f1579948c0050989b6bc4d56f0862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49df96265d6364140d73a8656425763" id="r_ad49df96265d6364140d73a8656425763"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </td></tr>
<tr class="memitem:ad49df96265d6364140d73a8656425763"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad49df96265d6364140d73a8656425763">operator&lt;</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ad49df96265d6364140d73a8656425763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:ad49df96265d6364140d73a8656425763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab892f9c1b557a16dd61daa9664feafda" id="r_ab892f9c1b557a16dd61daa9664feafda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ab892f9c1b557a16dd61daa9664feafda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab892f9c1b557a16dd61daa9664feafda">operator&lt;</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ab892f9c1b557a16dd61daa9664feafda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors.  <br /></td></tr>
<tr class="separator:ab892f9c1b557a16dd61daa9664feafda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eb9271474c81cef432c9a2b4afbee6" id="r_a36eb9271474c81cef432c9a2b4afbee6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a36eb9271474c81cef432c9a2b4afbee6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36eb9271474c81cef432c9a2b4afbee6">operator&lt;&lt;</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> b, <a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="structetl_1_1bitset.html">shift</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:a36eb9271474c81cef432c9a2b4afbee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);</code>  <br /></td></tr>
<tr class="separator:a36eb9271474c81cef432c9a2b4afbee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cb2843a224e246ba96818c029d3cbc" id="r_af1cb2843a224e246ba96818c029d3cbc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:af1cb2843a224e246ba96818c029d3cbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1cb2843a224e246ba96818c029d3cbc">operator&lt;&lt;=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;b, <a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="structetl_1_1bitset.html">shift</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:af1cb2843a224e246ba96818c029d3cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return b = b &lt;&lt; shift;</code>  <br /></td></tr>
<tr class="separator:af1cb2843a224e246ba96818c029d3cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2e96c99f7d8223e682d299d15a63a1" id="r_a4f2e96c99f7d8223e682d299d15a63a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a4f2e96c99f7d8223e682d299d15a63a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f2e96c99f7d8223e682d299d15a63a1">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a4f2e96c99f7d8223e682d299d15a63a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6911622913c358aa6c9a69533740656e" id="r_a6911622913c358aa6c9a69533740656e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a6911622913c358aa6c9a69533740656e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6911622913c358aa6c9a69533740656e">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a6911622913c358aa6c9a69533740656e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a6911622913c358aa6c9a69533740656e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168c032d92366a1e3a01fd042f1bdd4b" id="r_a168c032d92366a1e3a01fd042f1bdd4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a168c032d92366a1e3a01fd042f1bdd4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a168c032d92366a1e3a01fd042f1bdd4b">operator&lt;=</a> (<a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a168c032d92366a1e3a01fd042f1bdd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a168c032d92366a1e3a01fd042f1bdd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2166e999595123c9283e1d8b743f4d37" id="r_a2166e999595123c9283e1d8b743f4d37"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a2166e999595123c9283e1d8b743f4d37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2166e999595123c9283e1d8b743f4d37">operator&lt;=</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a2166e999595123c9283e1d8b743f4d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c452fa081a792d415bada3098142f2c" id="r_a6c452fa081a792d415bada3098142f2c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a6c452fa081a792d415bada3098142f2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c452fa081a792d415bada3098142f2c">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a6c452fa081a792d415bada3098142f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a6c452fa081a792d415bada3098142f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dafd7cae83ec90b947ed85149a4b38" id="r_a40dafd7cae83ec90b947ed85149a4b38"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a40dafd7cae83ec90b947ed85149a4b38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40dafd7cae83ec90b947ed85149a4b38">operator&lt;=</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a40dafd7cae83ec90b947ed85149a4b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a40dafd7cae83ec90b947ed85149a4b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26706133b16070592575cd905122691" id="r_ab26706133b16070592575cd905122691"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:ab26706133b16070592575cd905122691"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab26706133b16070592575cd905122691">operator&lt;=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ab26706133b16070592575cd905122691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:ab26706133b16070592575cd905122691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8fec49a7e24b2cb1f6dc5b738b1daa" id="r_a4e8fec49a7e24b2cb1f6dc5b738b1daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e8fec49a7e24b2cb1f6dc5b738b1daa">operator&lt;=</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a4e8fec49a7e24b2cb1f6dc5b738b1daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a36c94057cb8199ed38d8d08fd67ef5" id="r_a5a36c94057cb8199ed38d8d08fd67ef5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a5a36c94057cb8199ed38d8d08fd67ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a36c94057cb8199ed38d8d08fd67ef5">operator&lt;=</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a5a36c94057cb8199ed38d8d08fd67ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a5a36c94057cb8199ed38d8d08fd67ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf24c3b1cefb36e0c44f1cfaf6bf3f61" id="r_acf24c3b1cefb36e0c44f1cfaf6bf3f61"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </td></tr>
<tr class="memitem:acf24c3b1cefb36e0c44f1cfaf6bf3f61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf24c3b1cefb36e0c44f1cfaf6bf3f61">operator&lt;=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:acf24c3b1cefb36e0c44f1cfaf6bf3f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:acf24c3b1cefb36e0c44f1cfaf6bf3f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894460b393d2ac20c8b8f033322ff230" id="r_a894460b393d2ac20c8b8f033322ff230"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a894460b393d2ac20c8b8f033322ff230"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a894460b393d2ac20c8b8f033322ff230">operator&lt;=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a894460b393d2ac20c8b8f033322ff230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2918fec19c7ddaff292731a3c702c2" id="r_aaf2918fec19c7ddaff292731a3c702c2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </td></tr>
<tr class="memitem:aaf2918fec19c7ddaff292731a3c702c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf2918fec19c7ddaff292731a3c702c2">operator==</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="group__type__traits.html#gaca42c1976d1b12998afcabf8f39e8c23">type_identity_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:aaf2918fec19c7ddaff292731a3c702c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:aaf2918fec19c7ddaff292731a3c702c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0713b9e434e4421d0130fc330118092d" id="r_a0713b9e434e4421d0130fc330118092d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a0713b9e434e4421d0130fc330118092d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0713b9e434e4421d0130fc330118092d">operator==</a> (<a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a0713b9e434e4421d0130fc330118092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a0713b9e434e4421d0130fc330118092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27742612e6861226707341546907da1e" id="r_a27742612e6861226707341546907da1e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a27742612e6861226707341546907da1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a27742612e6861226707341546907da1e">operator==</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a27742612e6861226707341546907da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746cebe9104d4847df63754ab19eeb7" id="r_af746cebe9104d4847df63754ab19eeb7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af746cebe9104d4847df63754ab19eeb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af746cebe9104d4847df63754ab19eeb7">operator==</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:af746cebe9104d4847df63754ab19eeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66a17a791126b7c9b34055551b46721" id="r_ab66a17a791126b7c9b34055551b46721"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ab66a17a791126b7c9b34055551b46721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab66a17a791126b7c9b34055551b46721">operator==</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ab66a17a791126b7c9b34055551b46721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ab66a17a791126b7c9b34055551b46721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f869738f3ebf43e3b752d084fe4abf" id="r_a00f869738f3ebf43e3b752d084fe4abf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a00f869738f3ebf43e3b752d084fe4abf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00f869738f3ebf43e3b752d084fe4abf">operator==</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a00f869738f3ebf43e3b752d084fe4abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a00f869738f3ebf43e3b752d084fe4abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9a7daa4f77fbf1aae7a1b941301cc" id="r_a9ac9a7daa4f77fbf1aae7a1b941301cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:a9ac9a7daa4f77fbf1aae7a1b941301cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ac9a7daa4f77fbf1aae7a1b941301cc">operator==</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a9ac9a7daa4f77fbf1aae7a1b941301cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:a9ac9a7daa4f77fbf1aae7a1b941301cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cae3523aef79cbee6d0ad095484749" id="r_a06cae3523aef79cbee6d0ad095484749"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a06cae3523aef79cbee6d0ad095484749"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06cae3523aef79cbee6d0ad095484749">operator==</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;f, <a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a06cae3523aef79cbee6d0ad095484749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:a06cae3523aef79cbee6d0ad095484749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d3cf9c4f58fa9982c28bfa20adb0cb" id="r_a49d3cf9c4f58fa9982c28bfa20adb0cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Rhs</a> , <a class="el" href="structetl_1_1bitset.html">Rhs</a> R, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Lhs</a> , <a class="el" href="structetl_1_1bitset.html">Lhs</a> L&gt; </td></tr>
<tr class="memitem:a49d3cf9c4f58fa9982c28bfa20adb0cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49d3cf9c4f58fa9982c28bfa20adb0cb">operator==</a> (<a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Rhs</a>, <a class="el" href="structetl_1_1bitset.html">R</a> &gt;, <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Lhs</a>, <a class="el" href="structetl_1_1bitset.html">L</a> &gt;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">bool</a>, <a class="el" href="structetl_1_1bitset.html">L</a>==<a class="el" href="structetl_1_1bitset.html">R</a> &gt;</td></tr>
<tr class="separator:a49d3cf9c4f58fa9982c28bfa20adb0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1ef9857ea2d2e84bd3c311d0ccc92f" id="r_aaf1ef9857ea2d2e84bd3c311d0ccc92f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf1ef9857ea2d2e84bd3c311d0ccc92f">operator==</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:aaf1ef9857ea2d2e84bd3c311d0ccc92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares language_standards.  <br /></td></tr>
<tr class="separator:aaf1ef9857ea2d2e84bd3c311d0ccc92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d46beb3d8ffc0ea6e9f5157d7f1b299" id="r_a1d46beb3d8ffc0ea6e9f5157d7f1b299"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:a1d46beb3d8ffc0ea6e9f5157d7f1b299"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d46beb3d8ffc0ea6e9f5157d7f1b299">operator==</a> (<a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;f) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a1d46beb3d8ffc0ea6e9f5157d7f1b299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal.  <br /></td></tr>
<tr class="separator:a1d46beb3d8ffc0ea6e9f5157d7f1b299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb99a045aef160b997eab5178610a6a" id="r_a4eb99a045aef160b997eab5178610a6a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a4eb99a045aef160b997eab5178610a6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4eb99a045aef160b997eab5178610a6a">operator==</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a4eb99a045aef160b997eab5178610a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second.  <br /></td></tr>
<tr class="separator:a4eb99a045aef160b997eab5178610a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae066ee7e8566233be5ae1d96840d0c27" id="r_ae066ee7e8566233be5ae1d96840d0c27"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </td></tr>
<tr class="memitem:ae066ee7e8566233be5ae1d96840d0c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae066ee7e8566233be5ae1d96840d0c27">operator==</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ae066ee7e8566233be5ae1d96840d0c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:ae066ee7e8566233be5ae1d96840d0c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287ee2e9239c563f862cb177ec7d5792" id="r_a287ee2e9239c563f862cb177ec7d5792"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a287ee2e9239c563f862cb177ec7d5792"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a287ee2e9239c563f862cb177ec7d5792">operator==</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a287ee2e9239c563f862cb177ec7d5792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors.  <br /></td></tr>
<tr class="separator:a287ee2e9239c563f862cb177ec7d5792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a46d2610263aec2af4e9c49c94519ae" id="r_a9a46d2610263aec2af4e9c49c94519ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , CharT... Chars&gt; </td></tr>
<tr class="memitem:a9a46d2610263aec2af4e9c49c94519ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a46d2610263aec2af4e9c49c94519ae">operator==</a> (<a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, Chars... &gt;, <a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, Chars... &gt;) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a9a46d2610263aec2af4e9c49c94519ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9202f4500faf2a0dfeb6d39233517e" id="r_a2d9202f4500faf2a0dfeb6d39233517e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , CharT... CharsL, CharT... CharsR&gt; </td></tr>
<tr class="memitem:a2d9202f4500faf2a0dfeb6d39233517e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d9202f4500faf2a0dfeb6d39233517e">operator==</a> (<a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, CharsL... &gt;, <a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, CharsR... &gt;) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a2d9202f4500faf2a0dfeb6d39233517e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bab80e6235274bcc58d29d59d310a0" id="r_a32bab80e6235274bcc58d29d59d310a0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a32bab80e6235274bcc58d29d59d310a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32bab80e6235274bcc58d29d59d310a0">operator==</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a32bab80e6235274bcc58d29d59d310a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbffd4a8b5d0838ecc6a3f36cad3e3c6" id="r_abbffd4a8b5d0838ecc6a3f36cad3e3c6"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Us&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1bitset.html">Ts</a>) == sizeof...(<a class="el" href="structetl_1_1bitset.html">Us</a>))</td></tr>
<tr class="memitem:abbffd4a8b5d0838ecc6a3f36cad3e3c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abbffd4a8b5d0838ecc6a3f36cad3e3c6">operator==</a> (<a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Us... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:abbffd4a8b5d0838ecc6a3f36cad3e3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e34f2ca4ffdc8cf580ee55405dbd50" id="r_a77e34f2ca4ffdc8cf580ee55405dbd50"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a77e34f2ca4ffdc8cf580ee55405dbd50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77e34f2ca4ffdc8cf580ee55405dbd50">operator&gt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a77e34f2ca4ffdc8cf580ee55405dbd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282dab84234297d94efc2b6326190a55" id="r_a282dab84234297d94efc2b6326190a55"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a282dab84234297d94efc2b6326190a55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a282dab84234297d94efc2b6326190a55">operator&gt;</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a282dab84234297d94efc2b6326190a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a282dab84234297d94efc2b6326190a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a02eaf1df39c8c9bf6616e9d9297c7" id="r_a19a02eaf1df39c8c9bf6616e9d9297c7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:a19a02eaf1df39c8c9bf6616e9d9297c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19a02eaf1df39c8c9bf6616e9d9297c7">operator&gt;</a> (<a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a19a02eaf1df39c8c9bf6616e9d9297c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a19a02eaf1df39c8c9bf6616e9d9297c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767725b8e1034844aa4c3245f940832f" id="r_a767725b8e1034844aa4c3245f940832f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:a767725b8e1034844aa4c3245f940832f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a767725b8e1034844aa4c3245f940832f">operator&gt;</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a767725b8e1034844aa4c3245f940832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad834ca81bce076e5e37bd38d124fbbda" id="r_ad834ca81bce076e5e37bd38d124fbbda"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </td></tr>
<tr class="memitem:ad834ca81bce076e5e37bd38d124fbbda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad834ca81bce076e5e37bd38d124fbbda">operator&gt;</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ad834ca81bce076e5e37bd38d124fbbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:ad834ca81bce076e5e37bd38d124fbbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874855bcecdef2ce1a2b18ee560f4875" id="r_a874855bcecdef2ce1a2b18ee560f4875"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a874855bcecdef2ce1a2b18ee560f4875"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a874855bcecdef2ce1a2b18ee560f4875">operator&gt;</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a874855bcecdef2ce1a2b18ee560f4875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a874855bcecdef2ce1a2b18ee560f4875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4156f3a7bdd78f42dba049d9cd2a7f" id="r_aca4156f3a7bdd78f42dba049d9cd2a7f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:aca4156f3a7bdd78f42dba049d9cd2a7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca4156f3a7bdd78f42dba049d9cd2a7f">operator&gt;</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:aca4156f3a7bdd78f42dba049d9cd2a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:aca4156f3a7bdd78f42dba049d9cd2a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f071a704146a7adbb1dc8186e6cd184" id="r_a5f071a704146a7adbb1dc8186e6cd184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f071a704146a7adbb1dc8186e6cd184">operator&gt;</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a5f071a704146a7adbb1dc8186e6cd184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba18e7582c10621006e4e0cbc7ad4e4a" id="r_aba18e7582c10621006e4e0cbc7ad4e4a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:aba18e7582c10621006e4e0cbc7ad4e4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba18e7582c10621006e4e0cbc7ad4e4a">operator&gt;</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:aba18e7582c10621006e4e0cbc7ad4e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:aba18e7582c10621006e4e0cbc7ad4e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ccbb17eca7af36ce1a29e8d176f165" id="r_a17ccbb17eca7af36ce1a29e8d176f165"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </td></tr>
<tr class="memitem:a17ccbb17eca7af36ce1a29e8d176f165"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17ccbb17eca7af36ce1a29e8d176f165">operator&gt;</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a17ccbb17eca7af36ce1a29e8d176f165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:a17ccbb17eca7af36ce1a29e8d176f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab897f8f3641b27de2e08d2d16563a2c2" id="r_ab897f8f3641b27de2e08d2d16563a2c2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ab897f8f3641b27de2e08d2d16563a2c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab897f8f3641b27de2e08d2d16563a2c2">operator&gt;</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ab897f8f3641b27de2e08d2d16563a2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7456ec6ff542660d9777cf19081a2cac" id="r_a7456ec6ff542660d9777cf19081a2cac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 2&gt; </td></tr>
<tr class="memitem:a7456ec6ff542660d9777cf19081a2cac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7456ec6ff542660d9777cf19081a2cac">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a7456ec6ff542660d9777cf19081a2cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06acbb7e9de53f5357b8a05ff2b81346" id="r_a06acbb7e9de53f5357b8a05ff2b81346"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </td></tr>
<tr class="memitem:a06acbb7e9de53f5357b8a05ff2b81346"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06acbb7e9de53f5357b8a05ff2b81346">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a06acbb7e9de53f5357b8a05ff2b81346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <br /></td></tr>
<tr class="separator:a06acbb7e9de53f5357b8a05ff2b81346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a024f13c49393549366cb074449cb" id="r_a926a024f13c49393549366cb074449cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a926a024f13c49393549366cb074449cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a926a024f13c49393549366cb074449cb">operator&gt;=</a> (<a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a926a024f13c49393549366cb074449cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a926a024f13c49393549366cb074449cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf977200588526eee94f7bfe90d02a9" id="r_abbf977200588526eee94f7bfe90d02a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 1&gt; </td></tr>
<tr class="memitem:abbf977200588526eee94f7bfe90d02a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abbf977200588526eee94f7bfe90d02a9">operator&gt;=</a> (<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt; <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:abbf977200588526eee94f7bfe90d02a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add94f74715c924f9a96904acdea72bc9" id="r_add94f74715c924f9a96904acdea72bc9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:add94f74715c924f9a96904acdea72bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add94f74715c924f9a96904acdea72bc9">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:add94f74715c924f9a96904acdea72bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:add94f74715c924f9a96904acdea72bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d74379e90ba804afd1c2f9739b7d9d7" id="r_a5d74379e90ba804afd1c2f9739b7d9d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </td></tr>
<tr class="memitem:a5d74379e90ba804afd1c2f9739b7d9d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d74379e90ba804afd1c2f9739b7d9d7">operator&gt;=</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept</td></tr>
<tr class="memdesc:a5d74379e90ba804afd1c2f9739b7d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of a string with another string or a null-terminated array of CharT.  <br /></td></tr>
<tr class="separator:a5d74379e90ba804afd1c2f9739b7d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adada3b76df2e6fc502cf397340f36c22" id="r_adada3b76df2e6fc502cf397340f36c22"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </td></tr>
<tr class="memitem:adada3b76df2e6fc502cf397340f36c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adada3b76df2e6fc502cf397340f36c22">operator&gt;=</a> (<a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:adada3b76df2e6fc502cf397340f36c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed.  <br /></td></tr>
<tr class="separator:adada3b76df2e6fc502cf397340f36c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a11fea942b05530889b9e1944f07147" id="r_a9a11fea942b05530889b9e1944f07147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a11fea942b05530889b9e1944f07147">operator&gt;=</a> (<a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a9a11fea942b05530889b9e1944f07147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f52394fdd7dcf3de62c6201ba727716" id="r_a8f52394fdd7dcf3de62c6201ba727716"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a8f52394fdd7dcf3de62c6201ba727716"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f52394fdd7dcf3de62c6201ba727716">operator&gt;=</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:a8f52394fdd7dcf3de62c6201ba727716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <br /></td></tr>
<tr class="separator:a8f52394fdd7dcf3de62c6201ba727716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7a5ebdf6dec990fea752e60d99fc2c" id="r_adb7a5ebdf6dec990fea752e60d99fc2c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </td></tr>
<tr class="memitem:adb7a5ebdf6dec990fea752e60d99fc2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb7a5ebdf6dec990fea752e60d99fc2c">operator&gt;=</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:adb7a5ebdf6dec990fea752e60d99fc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two sets.  <br /></td></tr>
<tr class="separator:adb7a5ebdf6dec990fea752e60d99fc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5beff690dcaa87cb11a10e760c1d0211" id="r_a5beff690dcaa87cb11a10e760c1d0211"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a5beff690dcaa87cb11a10e760c1d0211"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5beff690dcaa87cb11a10e760c1d0211">operator&gt;=</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a5beff690dcaa87cb11a10e760c1d0211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51eea63a0ce9f777a6682aaf90f48696" id="r_a51eea63a0ce9f777a6682aaf90f48696"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a51eea63a0ce9f777a6682aaf90f48696"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51eea63a0ce9f777a6682aaf90f48696">operator&gt;&gt;</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> b, <a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="structetl_1_1bitset.html">shift</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:a51eea63a0ce9f777a6682aaf90f48696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);</code>  <br /></td></tr>
<tr class="separator:a51eea63a0ce9f777a6682aaf90f48696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec81972434cf41e3465929f46a9d9e4" id="r_a5ec81972434cf41e3465929f46a9d9e4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a5ec81972434cf41e3465929f46a9d9e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ec81972434cf41e3465929f46a9d9e4">operator&gt;&gt;=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;b, <a class="el" href="structetl_1_1bitset.html">Int</a> <a class="el" href="structetl_1_1bitset.html">shift</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a5ec81972434cf41e3465929f46a9d9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return b = b &gt;&gt; shift;</code>  <br /></td></tr>
<tr class="separator:a5ec81972434cf41e3465929f46a9d9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a15b444153bb6f6f05086c199285cb" id="r_a40a15b444153bb6f6f05086c199285cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:a40a15b444153bb6f6f05086c199285cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40a15b444153bb6f6f05086c199285cb">operator^</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt;</td></tr>
<tr class="memdesc:a40a15b444153bb6f6f05086c199285cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary XOR between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:a40a15b444153bb6f6f05086c199285cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f70d9e6f3612368a7a87afd88db9a49" id="r_a0f70d9e6f3612368a7a87afd88db9a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f70d9e6f3612368a7a87afd88db9a49">operator^</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:a0f70d9e6f3612368a7a87afd88db9a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) ^ static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:a0f70d9e6f3612368a7a87afd88db9a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949f06ea9ccea69532ff49532f6cd7c7" id="r_a949f06ea9ccea69532ff49532f6cd7c7"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a949f06ea9ccea69532ff49532f6cd7c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a949f06ea9ccea69532ff49532f6cd7c7">operator^</a> (T <a class="el" href="structetl_1_1bitset.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:a949f06ea9ccea69532ff49532f6cd7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bdb2fbcbe02268c3ef208d91d5b702" id="r_a71bdb2fbcbe02268c3ef208d91d5b702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71bdb2fbcbe02268c3ef208d91d5b702">operator^=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a71bdb2fbcbe02268c3ef208d91d5b702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs ^ rhs;</code>  <br /></td></tr>
<tr class="separator:a71bdb2fbcbe02268c3ef208d91d5b702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa9d2eff6d0a0723cccce281bcf5619" id="r_acfa9d2eff6d0a0723cccce281bcf5619"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:acfa9d2eff6d0a0723cccce281bcf5619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfa9d2eff6d0a0723cccce281bcf5619">operator^=</a> (T &amp;<a class="el" href="structetl_1_1bitset.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="separator:acfa9d2eff6d0a0723cccce281bcf5619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6dd579fe662e47108bc466e6f4b94a" id="r_afb6dd579fe662e47108bc466e6f4b94a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </td></tr>
<tr class="memitem:afb6dd579fe662e47108bc466e6f4b94a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb6dd579fe662e47108bc466e6f4b94a">operator|</a> (<a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt;</td></tr>
<tr class="memdesc:afb6dd579fe662e47108bc466e6f4b94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary OR between two bitsets, lhs and rhs.  <br /></td></tr>
<tr class="separator:afb6dd579fe662e47108bc466e6f4b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae524596905624f411ac531dd57bdc7db" id="r_ae524596905624f411ac531dd57bdc7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae524596905624f411ac531dd57bdc7db">operator|</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:ae524596905624f411ac531dd57bdc7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) | static_cast&lt;unsigned int&gt;(rhs));</code>  <br /></td></tr>
<tr class="separator:ae524596905624f411ac531dd57bdc7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbe12aeee105b81dad6ee8d5bf70db5" id="r_a8dbe12aeee105b81dad6ee8d5bf70db5"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a8dbe12aeee105b81dad6ee8d5bf70db5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8dbe12aeee105b81dad6ee8d5bf70db5">operator|</a> (T <a class="el" href="structetl_1_1bitset.html">x</a>, T y) -&gt; T</td></tr>
<tr class="separator:a8dbe12aeee105b81dad6ee8d5bf70db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3816e8de39ecc8a024d86bd10a4f6f0" id="r_aa3816e8de39ecc8a024d86bd10a4f6f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3816e8de39ecc8a024d86bd10a4f6f0">operator|=</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> <a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:aa3816e8de39ecc8a024d86bd10a4f6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return lhs = lhs | rhs;</code>  <br /></td></tr>
<tr class="separator:aa3816e8de39ecc8a024d86bd10a4f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde4cd3357a82b4fb074755ab815223f" id="r_afde4cd3357a82b4fb074755ab815223f"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:afde4cd3357a82b4fb074755ab815223f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afde4cd3357a82b4fb074755ab815223f">operator|=</a> (T &amp;<a class="el" href="structetl_1_1bitset.html">x</a>, T y) noexcept -&gt; T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="separator:afde4cd3357a82b4fb074755ab815223f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea255f7742cda95d1dab63279b70687" id="r_aeea255f7742cda95d1dab63279b70687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeea255f7742cda95d1dab63279b70687">operator~</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> b) noexcept -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td></tr>
<tr class="memdesc:aeea255f7742cda95d1dab63279b70687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return byte(~static_cast&lt;unsigned int&gt;(b));</code>  <br /></td></tr>
<tr class="separator:aeea255f7742cda95d1dab63279b70687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2bdaacf0312586cd586bd854a7b35a" id="r_a8b2bdaacf0312586cd586bd854a7b35a"><td class="memTemplParams" colspan="2">template&lt;bitmask_type T&gt; </td></tr>
<tr class="memitem:a8b2bdaacf0312586cd586bd854a7b35a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b2bdaacf0312586cd586bd854a7b35a">operator~</a> (T <a class="el" href="structetl_1_1bitset.html">x</a>) -&gt; T</td></tr>
<tr class="separator:a8b2bdaacf0312586cd586bd854a7b35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabca2e2f91841c82fb5ef20995a618bb" id="r_aabca2e2f91841c82fb5ef20995a618bb"><td class="memTemplParams" colspan="2">template&lt;typename... Functor&gt; </td></tr>
<tr class="memitem:aabca2e2f91841c82fb5ef20995a618bb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aabca2e2f91841c82fb5ef20995a618bb">overload</a> (Functor...) -&gt; overload&lt; Functor... &gt;</td></tr>
<tr class="separator:aabca2e2f91841c82fb5ef20995a618bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1145f95a262f79865247b6744e474069" id="r_a1145f95a262f79865247b6744e474069"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a1145f95a262f79865247b6744e474069"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1145f95a262f79865247b6744e474069">pair</a> (<a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a>) -&gt; pair&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt;</td></tr>
<tr class="separator:a1145f95a262f79865247b6744e474069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3bdc4477493e7bc5c106a53a3a314" id="r_a88a3bdc4477493e7bc5c106a53a3a314"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:a88a3bdc4477493e7bc5c106a53a3a314"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88a3bdc4477493e7bc5c106a53a3a314">partial_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> <a class="el" href="structetl_1_1bitset.html">middle</a>, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:a88a3bdc4477493e7bc5c106a53a3a314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae05431e1f03b692ae88a58f8629a057" id="r_gaae05431e1f03b692ae88a58f8629a057"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gaae05431e1f03b692ae88a58f8629a057"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaae05431e1f03b692ae88a58f8629a057">partial_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> <a class="el" href="structetl_1_1bitset.html">middle</a>, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:gaae05431e1f03b692ae88a58f8629a057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges elements such that the range <code>[first, middle)</code> contains the sorted <code>middle - first</code> smallest elements in the range <code>[first, last)</code>. The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range <code>[middle, last)</code> is unspecified.  <br /></td></tr>
<tr class="separator:gaae05431e1f03b692ae88a58f8629a057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48622cf727966c91682f2a36c6cc3695" id="r_ga48622cf727966c91682f2a36c6cc3695"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga48622cf727966c91682f2a36c6cc3695"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga48622cf727966c91682f2a36c6cc3695">partial_sum</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:ga48622cf727966c91682f2a36c6cc3695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8650e67603d39eabc51d4f625fd33dd9" id="r_ga8650e67603d39eabc51d4f625fd33dd9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga8650e67603d39eabc51d4f625fd33dd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga8650e67603d39eabc51d4f625fd33dd9">partial_sum</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, <a class="el" href="structetl_1_1bitset.html">BinaryOperation</a> <a class="el" href="structetl_1_1bitset.html">op</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga8650e67603d39eabc51d4f625fd33dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses the given binary function op, both applying <a class="el" href="group__algorithm.html#ga9060e0931516472a88f4657d835684a9" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> to their operands on the left hand side.  <br /></td></tr>
<tr class="separator:ga8650e67603d39eabc51d4f625fd33dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58dc6d94b5e29f2351debc8dff607246" id="r_ga58dc6d94b5e29f2351debc8dff607246"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga58dc6d94b5e29f2351debc8dff607246"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga58dc6d94b5e29f2351debc8dff607246">partition</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga58dc6d94b5e29f2351debc8dff607246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved.  <br /></td></tr>
<tr class="separator:ga58dc6d94b5e29f2351debc8dff607246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac406ce808473104b511907657832cd92" id="r_gac406ce808473104b511907657832cd92"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gac406ce808473104b511907657832cd92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gac406ce808473104b511907657832cd92">partition_copy</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt1</a> <a class="el" href="structetl_1_1bitset.html">destinationTrue</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt2</a> <a class="el" href="structetl_1_1bitset.html">destinationFalse</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">OutputIt1</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt2</a> &gt;</td></tr>
<tr class="memdesc:gac406ce808473104b511907657832cd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false.  <br /></td></tr>
<tr class="separator:gac406ce808473104b511907657832cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59eeccfe79ec5ab27f96d577417ca35a" id="r_ga59eeccfe79ec5ab27f96d577417ca35a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga59eeccfe79ec5ab27f96d577417ca35a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga59eeccfe79ec5ab27f96d577417ca35a">partition_point</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga59eeccfe79ec5ab27f96d577417ca35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the partitioned (as if by partition) range [first, last) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p.  <br /></td></tr>
<tr class="separator:ga59eeccfe79ec5ab27f96d577417ca35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568678757973b6b2d4c68a97b8140469" id="r_ga568678757973b6b2d4c68a97b8140469"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga568678757973b6b2d4c68a97b8140469"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga568678757973b6b2d4c68a97b8140469">polar</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">r</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">theta</a>=T()) noexcept -&gt; <a class="el" href="structetl_1_1complex.html">etl::complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga568678757973b6b2d4c68a97b8140469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484a219aea6406f7398208397bb244eb" id="r_ga484a219aea6406f7398208397bb244eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga484a219aea6406f7398208397bb244eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga484a219aea6406f7398208397bb244eb">popcount</a> (UInt val) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:ga484a219aea6406f7398208397bb244eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 1 bits in the value of x.  <br /></td></tr>
<tr class="separator:ga484a219aea6406f7398208397bb244eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4988f2e075719ba3d210798d7a4c41" id="r_ga6f4988f2e075719ba3d210798d7a4c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6f4988f2e075719ba3d210798d7a4c41">pow</a> (<a class="el" href="structetl_1_1bitset.html">double</a> base, <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__cmath.html#gadcf2fa322adfe3a7e284b01811eaec85">exp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga6f4988f2e075719ba3d210798d7a4c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga6f4988f2e075719ba3d210798d7a4c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbf71111fe08fe36439f7f8ff386071" id="r_ga5bbf71111fe08fe36439f7f8ff386071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5bbf71111fe08fe36439f7f8ff386071">pow</a> (<a class="el" href="structetl_1_1bitset.html">double</a> base, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga5bbf71111fe08fe36439f7f8ff386071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga5bbf71111fe08fe36439f7f8ff386071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ccd55507890350381ab591f83ec80e" id="r_ga65ccd55507890350381ab591f83ec80e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga65ccd55507890350381ab591f83ec80e">pow</a> (<a class="el" href="structetl_1_1bitset.html">float</a> base, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__cmath.html#gadcf2fa322adfe3a7e284b01811eaec85">exp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:ga65ccd55507890350381ab591f83ec80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga65ccd55507890350381ab591f83ec80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32cff7420fed14a1ae8a7b15a2ee3ffe" id="r_ga32cff7420fed14a1ae8a7b15a2ee3ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga32cff7420fed14a1ae8a7b15a2ee3ffe">pow</a> (<a class="el" href="structetl_1_1bitset.html">float</a> base, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:ga32cff7420fed14a1ae8a7b15a2ee3ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga32cff7420fed14a1ae8a7b15a2ee3ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga186fa5b37164f5f923f9dcc5fad2b831" id="r_ga186fa5b37164f5f923f9dcc5fad2b831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga186fa5b37164f5f923f9dcc5fad2b831">pow</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> base, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">iexp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga186fa5b37164f5f923f9dcc5fad2b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga186fa5b37164f5f923f9dcc5fad2b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0e589686d56d5bdf6af9a6cdc8cce8" id="r_ga3e0e589686d56d5bdf6af9a6cdc8cce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3e0e589686d56d5bdf6af9a6cdc8cce8">pow</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> base, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__cmath.html#gadcf2fa322adfe3a7e284b01811eaec85">exp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga3e0e589686d56d5bdf6af9a6cdc8cce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga3e0e589686d56d5bdf6af9a6cdc8cce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad55d0cf247d8674fe1c6116b3328cc21" id="r_gad55d0cf247d8674fe1c6116b3328cc21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad55d0cf247d8674fe1c6116b3328cc21">powf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> base, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__cmath.html#gadcf2fa322adfe3a7e284b01811eaec85">exp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:gad55d0cf247d8674fe1c6116b3328cc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:gad55d0cf247d8674fe1c6116b3328cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2faf58ce4c1c2fd993748a69cecd13c5" id="r_ga2faf58ce4c1c2fd993748a69cecd13c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2faf58ce4c1c2fd993748a69cecd13c5">powl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> base, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__cmath.html#gadcf2fa322adfe3a7e284b01811eaec85">exp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga2faf58ce4c1c2fd993748a69cecd13c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of base raised to the power exp.  <br /></td></tr>
<tr class="separator:ga2faf58ce4c1c2fd993748a69cecd13c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9cd7356c493ca709070e97bf61ed63" id="r_ga6d9cd7356c493ca709070e97bf61ed63"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:ga6d9cd7356c493ca709070e97bf61ed63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga6d9cd7356c493ca709070e97bf61ed63">prev</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> <a class="el" href="structetl_1_1bitset.html">it</a>, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1bitset.html">BidirIt</a> &gt;::difference_type <a class="el" href="structetl_1_1bitset.html">n</a>=1) -&gt; <a class="el" href="structetl_1_1bitset.html">BidirIt</a></td></tr>
<tr class="memdesc:ga6d9cd7356c493ca709070e97bf61ed63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth predecessor of iterator it.  <br /></td></tr>
<tr class="separator:ga6d9cd7356c493ca709070e97bf61ed63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e19467104f59f0dafeaf2752b461a9e" id="r_a5e19467104f59f0dafeaf2752b461a9e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Exception</a> &gt; </td></tr>
<tr class="memitem:a5e19467104f59f0dafeaf2752b461a9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="attributes_8hpp.html#abb156b0e852ad82749ae42934d3b4dbf">TETL_NO_INLINE</a> <a class="el" href="attributes_8hpp.html#af0eb4be3e44a6a8a9235265e12ad89a7">TETL_COLD</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e19467104f59f0dafeaf2752b461a9e">raise</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">msg</a>, <a class="el" href="structetl_1_1source__location.html">etl::source_location</a> <a class="el" href="structetl_1_1bitset.html">const</a> <a class="el" href="structetl_1_1bitset.html">loc</a>=<a class="el" href="structetl_1_1source__location.html#a53acf372b311e213942517d71b4bf8b8">etl::source_location::current</a>()) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:a5e19467104f59f0dafeaf2752b461a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0e9ff3b7516f90525a93acb5fccc8e" id="r_gaef0e9ff3b7516f90525a93acb5fccc8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:gaef0e9ff3b7516f90525a93acb5fccc8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gaef0e9ff3b7516f90525a93acb5fccc8e">rbegin</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.rbegin())</td></tr>
<tr class="memdesc:gaef0e9ff3b7516f90525a93acb5fccc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-beginning of the given container.  <br /></td></tr>
<tr class="separator:gaef0e9ff3b7516f90525a93acb5fccc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9728314a1814cd3fd1c7beaa6a54271" id="r_gad9728314a1814cd3fd1c7beaa6a54271"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:gad9728314a1814cd3fd1c7beaa6a54271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gad9728314a1814cd3fd1c7beaa6a54271">rbegin</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.rbegin())</td></tr>
<tr class="separator:gad9728314a1814cd3fd1c7beaa6a54271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b35374c826579acfd588a9e6f8b390" id="r_gaa6b35374c826579acfd588a9e6f8b390"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:gaa6b35374c826579acfd588a9e6f8b390"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gaa6b35374c826579acfd588a9e6f8b390">rbegin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">N</a>]) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; T * &gt;</td></tr>
<tr class="separator:gaa6b35374c826579acfd588a9e6f8b390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a916ec279d38f265fea523e6dd6e432" id="r_ga6a916ec279d38f265fea523e6dd6e432"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga6a916ec279d38f265fea523e6dd6e432"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga6a916ec279d38f265fea523e6dd6e432">real</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) noexcept(noexcept(z.real())) -&gt; T</td></tr>
<tr class="separator:ga6a916ec279d38f265fea523e6dd6e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3a8aec7386866e71debfff16f93b46" id="r_ga9d3a8aec7386866e71debfff16f93b46"><td class="memTemplParams" colspan="2">template&lt;floating_point Float&gt; </td></tr>
<tr class="memitem:ga9d3a8aec7386866e71debfff16f93b46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga9d3a8aec7386866e71debfff16f93b46">real</a> (<a class="el" href="structetl_1_1bitset.html">Float</a> f) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Float</a></td></tr>
<tr class="separator:ga9d3a8aec7386866e71debfff16f93b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c5a0b82f39dfba4d253645f2fe7876f" id="r_ga2c5a0b82f39dfba4d253645f2fe7876f"><td class="memTemplParams" colspan="2">template&lt;integral Integer&gt; </td></tr>
<tr class="memitem:ga2c5a0b82f39dfba4d253645f2fe7876f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga2c5a0b82f39dfba4d253645f2fe7876f">real</a> (<a class="el" href="structetl_1_1bitset.html">Integer</a> <a class="el" href="structetl_1_1bitset.html">i</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga2c5a0b82f39dfba4d253645f2fe7876f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aab27726885209d183d580fba57f1bb" id="r_ga1aab27726885209d183d580fba57f1bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIter</a> &gt; </td></tr>
<tr class="memitem:ga1aab27726885209d183d580fba57f1bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga1aab27726885209d183d580fba57f1bb">reduce</a> (<a class="el" href="structetl_1_1bitset.html">InputIter</a> first, <a class="el" href="structetl_1_1bitset.html">InputIter</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="structetl_1_1bitset.html">InputIter</a> &gt;::value_type</td></tr>
<tr class="memdesc:ga1aab27726885209d183d580fba57f1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gabb8f915bbbbe802e8277bc6c7334bbd1" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:ga1aab27726885209d183d580fba57f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c4d18cd54181d2f678ecbf4ca6110c" id="r_ga10c4d18cd54181d2f678ecbf4ca6110c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIter</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga10c4d18cd54181d2f678ecbf4ca6110c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga10c4d18cd54181d2f678ecbf4ca6110c">reduce</a> (<a class="el" href="structetl_1_1bitset.html">InputIter</a> first, <a class="el" href="structetl_1_1bitset.html">InputIter</a> last, T init) -&gt; T</td></tr>
<tr class="memdesc:ga10c4d18cd54181d2f678ecbf4ca6110c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gabb8f915bbbbe802e8277bc6c7334bbd1" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:ga10c4d18cd54181d2f678ecbf4ca6110c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c4ece300169efb3528dd8de1633ca66" id="r_ga1c4ece300169efb3528dd8de1633ca66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIter</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryOp</a> &gt; </td></tr>
<tr class="memitem:ga1c4ece300169efb3528dd8de1633ca66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga1c4ece300169efb3528dd8de1633ca66">reduce</a> (<a class="el" href="structetl_1_1bitset.html">InputIter</a> first, <a class="el" href="structetl_1_1bitset.html">InputIter</a> last, T init, <a class="el" href="structetl_1_1bitset.html">BinaryOp</a> <a class="el" href="structetl_1_1bitset.html">op</a>) -&gt; T</td></tr>
<tr class="memdesc:ga1c4ece300169efb3528dd8de1633ca66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group__numeric.html#gabb8f915bbbbe802e8277bc6c7334bbd1" title="Computes the sum of the given value init and the elements in the range [first, last).">etl::accumulate</a>.  <br /></td></tr>
<tr class="separator:ga1c4ece300169efb3528dd8de1633ca66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea72996d2287ae1be393a1827dfa5bf" id="r_adea72996d2287ae1be393a1827dfa5bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adea72996d2287ae1be393a1827dfa5bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adea72996d2287ae1be393a1827dfa5bf">ref</a> (<a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="memdesc:adea72996d2287ae1be393a1827dfa5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result.  <br /></td></tr>
<tr class="separator:adea72996d2287ae1be393a1827dfa5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11516b369ddf80bc94d2f450200f5d11" id="r_a11516b369ddf80bc94d2f450200f5d11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a11516b369ddf80bc94d2f450200f5d11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11516b369ddf80bc94d2f450200f5d11">ref</a> (T &amp;<a class="el" href="structetl_1_1bitset.html">t</a>) noexcept -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a11516b369ddf80bc94d2f450200f5d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result.  <br /></td></tr>
<tr class="separator:a11516b369ddf80bc94d2f450200f5d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffcd97e84a642fa9f9f3297692d128e" id="r_a1ffcd97e84a642fa9f9f3297692d128e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1ffcd97e84a642fa9f9f3297692d128e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ffcd97e84a642fa9f9f3297692d128e">reference_wrapper</a> (T &amp;) -&gt; reference_wrapper&lt; T &gt;</td></tr>
<tr class="separator:a1ffcd97e84a642fa9f9f3297692d128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e922528ea738cb036a8c917caf0414f" id="r_ga5e922528ea738cb036a8c917caf0414f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5e922528ea738cb036a8c917caf0414f">remainder</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga5e922528ea738cb036a8c917caf0414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:ga5e922528ea738cb036a8c917caf0414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d0ba97813a6d3794162cdc11f39c75" id="r_gaf2d0ba97813a6d3794162cdc11f39c75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf2d0ba97813a6d3794162cdc11f39c75">remainder</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:gaf2d0ba97813a6d3794162cdc11f39c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:gaf2d0ba97813a6d3794162cdc11f39c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae696b6d50fefabd62921ce139258065e" id="r_gae696b6d50fefabd62921ce139258065e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae696b6d50fefabd62921ce139258065e">remainder</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:gae696b6d50fefabd62921ce139258065e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:gae696b6d50fefabd62921ce139258065e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d49f0cdedd4430d83b237bc96cba962" id="r_ga1d49f0cdedd4430d83b237bc96cba962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1d49f0cdedd4430d83b237bc96cba962">remainderf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:ga1d49f0cdedd4430d83b237bc96cba962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:ga1d49f0cdedd4430d83b237bc96cba962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bcb0b3d00f14721c9789ac0aed6e26" id="r_ga35bcb0b3d00f14721c9789ac0aed6e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga35bcb0b3d00f14721c9789ac0aed6e26">remainderl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga35bcb0b3d00f14721c9789ac0aed6e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the floating point division operation x/y.  <br /></td></tr>
<tr class="separator:ga35bcb0b3d00f14721c9789ac0aed6e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ecba2ecefe71607f67bec456ff072fd" id="r_ga1ecba2ecefe71607f67bec456ff072fd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga1ecba2ecefe71607f67bec456ff072fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1ecba2ecefe71607f67bec456ff072fd">remove</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga1ecba2ecefe71607f67bec456ff072fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <br /></td></tr>
<tr class="separator:ga1ecba2ecefe71607f67bec456ff072fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafdb5717541ddef9974357131dc1d248" id="r_gaafdb5717541ddef9974357131dc1d248"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gaafdb5717541ddef9974357131dc1d248"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaafdb5717541ddef9974357131dc1d248">remove_copy</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:gaafdb5717541ddef9974357131dc1d248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value.  <br /></td></tr>
<tr class="separator:gaafdb5717541ddef9974357131dc1d248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bdbbf4b495def4cb406f6af3ef25882" id="r_ga8bdbbf4b495def4cb406f6af3ef25882"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga8bdbbf4b495def4cb406f6af3ef25882"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga8bdbbf4b495def4cb406f6af3ef25882">remove_copy_if</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga8bdbbf4b495def4cb406f6af3ef25882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [first, last), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:ga8bdbbf4b495def4cb406f6af3ef25882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22cf73ac58ec2b4dd086be384cbbdd7d" id="r_ga22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga22cf73ac58ec2b4dd086be384cbbdd7d">remove_if</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga22cf73ac58ec2b4dd086be384cbbdd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range <code>[first, last)</code> and returns a past-the-end iterator for the new end of the range.  <br /></td></tr>
<tr class="separator:ga22cf73ac58ec2b4dd086be384cbbdd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55d22696b4d22653a103d0726157a18" id="r_gab55d22696b4d22653a103d0726157a18"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:gab55d22696b4d22653a103d0726157a18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gab55d22696b4d22653a103d0726157a18">rend</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.rend())</td></tr>
<tr class="memdesc:gab55d22696b4d22653a103d0726157a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the reverse-end of the given container.  <br /></td></tr>
<tr class="separator:gab55d22696b4d22653a103d0726157a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286af0157d3f2f88bdd154d26195e29a" id="r_ga286af0157d3f2f88bdd154d26195e29a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:ga286af0157d3f2f88bdd154d26195e29a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga286af0157d3f2f88bdd154d26195e29a">rend</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.rend())</td></tr>
<tr class="separator:ga286af0157d3f2f88bdd154d26195e29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d58f51b451013d9255c48b59cdabee" id="r_gac0d58f51b451013d9255c48b59cdabee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:gac0d58f51b451013d9255c48b59cdabee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gac0d58f51b451013d9255c48b59cdabee">rend</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">N</a>]) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; T * &gt;</td></tr>
<tr class="separator:gac0d58f51b451013d9255c48b59cdabee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e970687eb65ad36a17922ed1be6764a" id="r_ga7e970687eb65ad36a17922ed1be6764a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga7e970687eb65ad36a17922ed1be6764a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7e970687eb65ad36a17922ed1be6764a">replace</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">oldValue</a>, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">newValue</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga7e970687eb65ad36a17922ed1be6764a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements that are equal to old_value.  <br /></td></tr>
<tr class="separator:ga7e970687eb65ad36a17922ed1be6764a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13040e3fc5925b1bc966782f36635444" id="r_ga13040e3fc5925b1bc966782f36635444"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga13040e3fc5925b1bc966782f36635444"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga13040e3fc5925b1bc966782f36635444">replace_if</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">newValue</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga13040e3fc5925b1bc966782f36635444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [first, last). Replaces all elements for which predicate p returns true.  <br /></td></tr>
<tr class="separator:ga13040e3fc5925b1bc966782f36635444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475638bd9306d99c55d5543eb3979b8f" id="r_ga475638bd9306d99c55d5543eb3979b8f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga475638bd9306d99c55d5543eb3979b8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga475638bd9306d99c55d5543eb3979b8f">reset_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga475638bd9306d99c55d5543eb3979b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset bit at position Pos.  <br /></td></tr>
<tr class="separator:ga475638bd9306d99c55d5543eb3979b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d7eab610ba1068c0cd27c9cc00a45a" id="r_ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga76d7eab610ba1068c0cd27c9cc00a45a">reset_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>, UInt <a class="el" href="structetl_1_1bitset.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga76d7eab610ba1068c0cd27c9cc00a45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3169a8bd10088a7cf7d65b8aae66bc" id="r_gabf3169a8bd10088a7cf7d65b8aae66bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:gabf3169a8bd10088a7cf7d65b8aae66bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gabf3169a8bd10088a7cf7d65b8aae66bc">reverse</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:gabf3169a8bd10088a7cf7d65b8aae66bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gabf3169a8bd10088a7cf7d65b8aae66bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5067524643b55244e12cb5eed183ddae" id="r_ga5067524643b55244e12cb5eed183ddae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga5067524643b55244e12cb5eed183ddae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5067524643b55244e12cb5eed183ddae">reverse_copy</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga5067524643b55244e12cb5eed183ddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code> to another range beginning at d_first in such a way that the elements in the new range are in reverse order.  <br /></td></tr>
<tr class="separator:ga5067524643b55244e12cb5eed183ddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72dc5cf6f75e993b6f14aa70b8fbabb" id="r_gab72dc5cf6f75e993b6f14aa70b8fbabb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab72dc5cf6f75e993b6f14aa70b8fbabb">rint</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:gab72dc5cf6f75e993b6f14aa70b8fbabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:gab72dc5cf6f75e993b6f14aa70b8fbabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b82891bedb870579150afb24c75018" id="r_ga47b82891bedb870579150afb24c75018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga47b82891bedb870579150afb24c75018">rint</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:ga47b82891bedb870579150afb24c75018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga47b82891bedb870579150afb24c75018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cb9a1a27b90a9caf7b8f8ca19a377e" id="r_ga28cb9a1a27b90a9caf7b8f8ca19a377e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga28cb9a1a27b90a9caf7b8f8ca19a377e">rint</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga28cb9a1a27b90a9caf7b8f8ca19a377e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga28cb9a1a27b90a9caf7b8f8ca19a377e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3273c48edc44f821db7773c25c2abf5d" id="r_ga3273c48edc44f821db7773c25c2abf5d"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga3273c48edc44f821db7773c25c2abf5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3273c48edc44f821db7773c25c2abf5d">rint</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga3273c48edc44f821db7773c25c2abf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga3273c48edc44f821db7773c25c2abf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b16975e01d95a7658e320c27e80715" id="r_gab3b16975e01d95a7658e320c27e80715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab3b16975e01d95a7658e320c27e80715">rintf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:gab3b16975e01d95a7658e320c27e80715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:gab3b16975e01d95a7658e320c27e80715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04364ca7c76677ba6ca7448f9a3b00bc" id="r_ga04364ca7c76677ba6ca7448f9a3b00bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga04364ca7c76677ba6ca7448f9a3b00bc">rintl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga04364ca7c76677ba6ca7448f9a3b00bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the floating-point argument arg to an integer value (in floating-point format), using the current rounding mode.  <br /></td></tr>
<tr class="separator:ga04364ca7c76677ba6ca7448f9a3b00bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d4db23a06789c303ee8ec693d84129" id="r_ga99d4db23a06789c303ee8ec693d84129"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga99d4db23a06789c303ee8ec693d84129"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga99d4db23a06789c303ee8ec693d84129">rotate</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> <a class="el" href="structetl_1_1bitset.html">nFirst</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga99d4db23a06789c303ee8ec693d84129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on a range of elements.  <br /></td></tr>
<tr class="separator:ga99d4db23a06789c303ee8ec693d84129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3ea43eb370058e059c95c0738eb379" id="r_ga8e3ea43eb370058e059c95c0738eb379"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga8e3ea43eb370058e059c95c0738eb379"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga8e3ea43eb370058e059c95c0738eb379">rotate_copy</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> <a class="el" href="structetl_1_1bitset.html">nFirst</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga8e3ea43eb370058e059c95c0738eb379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range <code>[first, last)</code>, to another range beginning at destination in such a way, that the element <code>nFirst</code> becomes the first element of the new range and <code>nFirst - 1</code> becomes the last element.  <br /></td></tr>
<tr class="separator:ga8e3ea43eb370058e059c95c0738eb379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3111087bb441d3683d06cb5af2e68c3c" id="r_ga3111087bb441d3683d06cb5af2e68c3c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga3111087bb441d3683d06cb5af2e68c3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga3111087bb441d3683d06cb5af2e68c3c">rotl</a> (UInt <a class="el" href="structetl_1_1bitset.html">t</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">s</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga3111087bb441d3683d06cb5af2e68c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise left-rotating the value of x by s positions. This operation is also known as a left circular shift.  <br /></td></tr>
<tr class="separator:ga3111087bb441d3683d06cb5af2e68c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aeaa8cb213500ab9a8cf6ee98314d2a" id="r_ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga2aeaa8cb213500ab9a8cf6ee98314d2a">rotr</a> (UInt <a class="el" href="structetl_1_1bitset.html">t</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">s</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the result of bitwise right-rotating the value of x by s positions. This operation is also known as a right circular shift.  <br /></td></tr>
<tr class="separator:ga2aeaa8cb213500ab9a8cf6ee98314d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8ae9359da3a0a4cb0573e8cd219638" id="r_a0e8ae9359da3a0a4cb0573e8cd219638"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">FuncT</a> &gt; </td></tr>
<tr class="memitem:a0e8ae9359da3a0a4cb0573e8cd219638"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e8ae9359da3a0a4cb0573e8cd219638">scope_exit</a> (<a class="el" href="structetl_1_1bitset.html">FuncT</a>) -&gt; scope_exit&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">FuncT</a> &gt; &gt;</td></tr>
<tr class="separator:a0e8ae9359da3a0a4cb0573e8cd219638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef0ecd7ca83244453f2e3ca077cf4d4" id="r_gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaeef0ecd7ca83244453f2e3ca077cf4d4">set_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>Pos</code>  <br /></td></tr>
<tr class="separator:gaeef0ecd7ca83244453f2e3ca077cf4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa73517548e29dd7eff01b08cd2619a2" id="r_gafa73517548e29dd7eff01b08cd2619a2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gafa73517548e29dd7eff01b08cd2619a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gafa73517548e29dd7eff01b08cd2619a2">set_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>, <a class="el" href="structetl_1_1bitset.html">bool</a> value) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:gafa73517548e29dd7eff01b08cd2619a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>Pos</code> to <code>value</code>.  <br /></td></tr>
<tr class="separator:gafa73517548e29dd7eff01b08cd2619a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029b15dc4de2e5837b791049d6d16ed0" id="r_ga029b15dc4de2e5837b791049d6d16ed0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga029b15dc4de2e5837b791049d6d16ed0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga029b15dc4de2e5837b791049d6d16ed0">set_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>, UInt <a class="el" href="structetl_1_1bitset.html">pos</a>) noexcept -&gt; UInt</td></tr>
<tr class="memdesc:ga029b15dc4de2e5837b791049d6d16ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:ga029b15dc4de2e5837b791049d6d16ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12374769ae1db920c570b5b5b0cec13" id="r_gaa12374769ae1db920c570b5b5b0cec13"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gaa12374769ae1db920c570b5b5b0cec13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gaa12374769ae1db920c570b5b5b0cec13">set_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>, UInt <a class="el" href="structetl_1_1bitset.html">pos</a>, <a class="el" href="structetl_1_1bitset.html">bool</a> value) -&gt; UInt</td></tr>
<tr class="memdesc:gaa12374769ae1db920c570b5b5b0cec13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit at position <code>pos</code> to <code>value</code>.  <br /></td></tr>
<tr class="separator:gaa12374769ae1db920c570b5b5b0cec13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6d3457c4b1a845dce8219245bbc31c" id="r_ga2a6d3457c4b1a845dce8219245bbc31c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga2a6d3457c4b1a845dce8219245bbc31c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga2a6d3457c4b1a845dce8219245bbc31c">shift_left</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> <a class="el" href="structetl_1_1bitset.html">const</a> last, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt;::difference_type <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga2a6d3457c4b1a845dce8219245bbc31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <br /></td></tr>
<tr class="separator:ga2a6d3457c4b1a845dce8219245bbc31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465e2a36ddbbed9d12ad5403dccbb7b3" id="r_ga465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidiIt</a> &gt; </td></tr>
<tr class="memitem:ga465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga465e2a36ddbbed9d12ad5403dccbb7b3">shift_right</a> (<a class="el" href="structetl_1_1bitset.html">BidiIt</a> first, <a class="el" href="structetl_1_1bitset.html">BidiIt</a> last, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; <a class="el" href="structetl_1_1bitset.html">BidiIt</a> &gt;::difference_type <a class="el" href="structetl_1_1bitset.html">n</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">BidiIt</a></td></tr>
<tr class="memdesc:ga465e2a36ddbbed9d12ad5403dccbb7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the elements in the range [first, last) by n positions.  <br /></td></tr>
<tr class="separator:ga465e2a36ddbbed9d12ad5403dccbb7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab158f9b28e09533819c5781922c6cdfd" id="r_gab158f9b28e09533819c5781922c6cdfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab158f9b28e09533819c5781922c6cdfd">signbit</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gab158f9b28e09533819c5781922c6cdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:gab158f9b28e09533819c5781922c6cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7506d6f1c9f1562f76ddf3085ab653ad" id="r_ga7506d6f1c9f1562f76ddf3085ab653ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7506d6f1c9f1562f76ddf3085ab653ad">signbit</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga7506d6f1c9f1562f76ddf3085ab653ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:ga7506d6f1c9f1562f76ddf3085ab653ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4da52394b4be08dc83783c505ddc3a" id="r_a7f4da52394b4be08dc83783c505ddc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f4da52394b4be08dc83783c505ddc3a">signbit</a> (<a class="el" href="structetl_1_1half.html">half</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:a7f4da52394b4be08dc83783c505ddc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ca6b6c05a7686713a1efaeeb4ae60d" id="r_ga35ca6b6c05a7686713a1efaeeb4ae60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga35ca6b6c05a7686713a1efaeeb4ae60d">signbit</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga35ca6b6c05a7686713a1efaeeb4ae60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is negative.  <br /></td></tr>
<tr class="separator:ga35ca6b6c05a7686713a1efaeeb4ae60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a55d91192ee62e13043d349a5c422e" id="r_ga76a55d91192ee62e13043d349a5c422e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga76a55d91192ee62e13043d349a5c422e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga76a55d91192ee62e13043d349a5c422e">sin</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga76a55d91192ee62e13043d349a5c422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c91cffc26040b2a72d63bd17de8e9e9" id="r_ga1c91cffc26040b2a72d63bd17de8e9e9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga1c91cffc26040b2a72d63bd17de8e9e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga1c91cffc26040b2a72d63bd17de8e9e9">sinh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga1c91cffc26040b2a72d63bd17de8e9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd130d9da0b245419fceb59d99c8f26" id="r_ga1cd130d9da0b245419fceb59d99c8f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1cd130d9da0b245419fceb59d99c8f26">sinh</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga1cd130d9da0b245419fceb59d99c8f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga1cd130d9da0b245419fceb59d99c8f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06830c89453f38692a070341789c5ada" id="r_ga06830c89453f38692a070341789c5ada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga06830c89453f38692a070341789c5ada">sinh</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:ga06830c89453f38692a070341789c5ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga06830c89453f38692a070341789c5ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb541096f27e868926f6b4ac9c66648" id="r_ga8cb541096f27e868926f6b4ac9c66648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8cb541096f27e868926f6b4ac9c66648">sinh</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga8cb541096f27e868926f6b4ac9c66648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga8cb541096f27e868926f6b4ac9c66648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956f17ccc22563322921dfc13a006050" id="r_ga956f17ccc22563322921dfc13a006050"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga956f17ccc22563322921dfc13a006050"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga956f17ccc22563322921dfc13a006050">sinh</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga956f17ccc22563322921dfc13a006050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:ga956f17ccc22563322921dfc13a006050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc0c8e397bc6f72a71a493da9d0feb65" id="r_gafc0c8e397bc6f72a71a493da9d0feb65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gafc0c8e397bc6f72a71a493da9d0feb65">sinhf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:gafc0c8e397bc6f72a71a493da9d0feb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gafc0c8e397bc6f72a71a493da9d0feb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbfe20cf12f097d721ff918c18fe523a" id="r_gacbfe20cf12f097d721ff918c18fe523a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gacbfe20cf12f097d721ff918c18fe523a">sinhl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:gacbfe20cf12f097d721ff918c18fe523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hyperbolic sine of arg.  <br /></td></tr>
<tr class="separator:gacbfe20cf12f097d721ff918c18fe523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8701f2e299015f92e83f375a604ef61" id="r_gae8701f2e299015f92e83f375a604ef61"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:gae8701f2e299015f92e83f375a604ef61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#gae8701f2e299015f92e83f375a604ef61">size</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) noexcept(noexcept(c.size())) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.size())</td></tr>
<tr class="memdesc:gae8701f2e299015f92e83f375a604ef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the given container c or array array. Returns c.size(), converted to the return type if necessary.  <br /></td></tr>
<tr class="separator:gae8701f2e299015f92e83f375a604ef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256d0ca03ee6c9127ce2c4baefc0c50b" id="r_ga256d0ca03ee6c9127ce2c4baefc0c50b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> N&gt; </td></tr>
<tr class="memitem:ga256d0ca03ee6c9127ce2c4baefc0c50b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga256d0ca03ee6c9127ce2c4baefc0c50b">size</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> (&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">N</a>]) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a></td></tr>
<tr class="separator:ga256d0ca03ee6c9127ce2c4baefc0c50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f81df02edb24d409273f1a4f4ae1da7" id="r_a0f81df02edb24d409273f1a4f4ae1da7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:a0f81df02edb24d409273f1a4f4ae1da7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f81df02edb24d409273f1a4f4ae1da7">span</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1bitset.html">Element</a> &gt;</td></tr>
<tr class="separator:a0f81df02edb24d409273f1a4f4ae1da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929cb3ca520c09729a4166ed8244f76e" id="r_a929cb3ca520c09729a4166ed8244f76e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:a929cb3ca520c09729a4166ed8244f76e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a929cb3ca520c09729a4166ed8244f76e">span</a> (<a class="el" href="structetl_1_1bitset.html">Container</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1bitset.html">Element</a> &gt;</td></tr>
<tr class="separator:a929cb3ca520c09729a4166ed8244f76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971583484d70115eb585a522b3d27c94" id="r_a971583484d70115eb585a522b3d27c94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:a971583484d70115eb585a522b3d27c94"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a971583484d70115eb585a522b3d27c94">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Size</a> &gt; &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Size</a> &gt;</td></tr>
<tr class="separator:a971583484d70115eb585a522b3d27c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26de73efb9b95ad5ed7a2efee4db36d1" id="r_a26de73efb9b95ad5ed7a2efee4db36d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </td></tr>
<tr class="memitem:a26de73efb9b95ad5ed7a2efee4db36d1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26de73efb9b95ad5ed7a2efee4db36d1">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Size</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;) -&gt; span&lt; <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a>, <a class="el" href="structetl_1_1bitset.html">Size</a> &gt;</td></tr>
<tr class="separator:a26de73efb9b95ad5ed7a2efee4db36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeda768ae3894ba5ab71ab85c206b19d" id="r_adeda768ae3894ba5ab71ab85c206b19d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Extent&gt; </td></tr>
<tr class="memitem:adeda768ae3894ba5ab71ab85c206b19d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adeda768ae3894ba5ab71ab85c206b19d">span</a> (<a class="el" href="structetl_1_1bitset.html">Type</a>(&amp;)[<a class="el" href="structetl_1_1bitset.html">Extent</a>]) -&gt; span&lt; <a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Extent</a> &gt;</td></tr>
<tr class="separator:adeda768ae3894ba5ab71ab85c206b19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ace0191001caa6f64e0a19166a147ae" id="r_ga7ace0191001caa6f64e0a19166a147ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7ace0191001caa6f64e0a19166a147ae">sqrt</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga7ace0191001caa6f64e0a19166a147ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:ga7ace0191001caa6f64e0a19166a147ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee507c8cfe43c8b4db84786a500b0e2a" id="r_gaee507c8cfe43c8b4db84786a500b0e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaee507c8cfe43c8b4db84786a500b0e2a">sqrt</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:gaee507c8cfe43c8b4db84786a500b0e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:gaee507c8cfe43c8b4db84786a500b0e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31cc59fdcd0b0e6fe47e105bcfe3f6f9" id="r_ga31cc59fdcd0b0e6fe47e105bcfe3f6f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga31cc59fdcd0b0e6fe47e105bcfe3f6f9">sqrt</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga31cc59fdcd0b0e6fe47e105bcfe3f6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:ga31cc59fdcd0b0e6fe47e105bcfe3f6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70eeceedd0d7ba7d7ac10b7399b6d2c2" id="r_ga70eeceedd0d7ba7d7ac10b7399b6d2c2"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; </td></tr>
<tr class="memitem:ga70eeceedd0d7ba7d7ac10b7399b6d2c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga70eeceedd0d7ba7d7ac10b7399b6d2c2">sqrt</a> (T <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga70eeceedd0d7ba7d7ac10b7399b6d2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:ga70eeceedd0d7ba7d7ac10b7399b6d2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa15ac1ee624011bf5f4358d2e133ad17" id="r_gaa15ac1ee624011bf5f4358d2e133ad17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa15ac1ee624011bf5f4358d2e133ad17">sqrtf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:gaa15ac1ee624011bf5f4358d2e133ad17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:gaa15ac1ee624011bf5f4358d2e133ad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d1792d7684e697e99dbab7160e9c48" id="r_ga06d1792d7684e697e99dbab7160e9c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga06d1792d7684e697e99dbab7160e9c48">sqrtl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga06d1792d7684e697e99dbab7160e9c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of arg.  <br /></td></tr>
<tr class="separator:ga06d1792d7684e697e99dbab7160e9c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67945df65c1fbfa26461032e32b8bd70" id="r_ga67945df65c1fbfa26461032e32b8bd70"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; </td></tr>
<tr class="memitem:ga67945df65c1fbfa26461032e32b8bd70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga67945df65c1fbfa26461032e32b8bd70">ssize</a> (<a class="el" href="structetl_1_1bitset.html">C</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;c) -&gt; <a class="el" href="#ac0f7a81113943dc723a4e4751c342144">common_type_t</a>&lt; <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a>, <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(c.size())&gt; &gt;</td></tr>
<tr class="separator:ga67945df65c1fbfa26461032e32b8bd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga584fdd298577a7f3d9696eefe3ddac61" id="r_ga584fdd298577a7f3d9696eefe3ddac61"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a> N&gt; </td></tr>
<tr class="memitem:ga584fdd298577a7f3d9696eefe3ddac61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator.html#ga584fdd298577a7f3d9696eefe3ddac61">ssize</a> (T <a class="el" href="structetl_1_1bitset.html">const</a> (&amp;<a class="el" href="structetl_1_1array.html">array</a>)[<a class="el" href="structetl_1_1bitset.html">static_cast</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> &gt;(<a class="el" href="structetl_1_1bitset.html">N</a>)]) noexcept -&gt; <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a></td></tr>
<tr class="separator:ga584fdd298577a7f3d9696eefe3ddac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0402fada51d792d7500e9a8f196eb649" id="r_ga0402fada51d792d7500e9a8f196eb649"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga0402fada51d792d7500e9a8f196eb649"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga0402fada51d792d7500e9a8f196eb649">stable_partition</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> f, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> <a class="el" href="structetl_1_1bitset.html">l</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">BidirIt</a></td></tr>
<tr class="memdesc:ga0402fada51d792d7500e9a8f196eb649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range <code>[first, last)</code> in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved.  <br /></td></tr>
<tr class="separator:ga0402fada51d792d7500e9a8f196eb649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1582db8c501fc2a0866681ff10eeef" id="r_aaa1582db8c501fc2a0866681ff10eeef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </td></tr>
<tr class="memitem:aaa1582db8c501fc2a0866681ff10eeef"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa1582db8c501fc2a0866681ff10eeef">stack</a> (<a class="el" href="structetl_1_1bitset.html">Container</a>) -&gt; stack&lt; <a class="el" href="structetl_1_1bitset.html">typename</a> Container::value_type, <a class="el" href="structetl_1_1bitset.html">Container</a> &gt;</td></tr>
<tr class="separator:aaa1582db8c501fc2a0866681ff10eeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ef04cbec9181a661996527e875a00a" id="r_gae2ef04cbec9181a661996527e875a00a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:gae2ef04cbec9181a661996527e875a00a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#gae2ef04cbec9181a661996527e875a00a">stod</a> (<a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *<a class="el" href="structetl_1_1bitset.html">pos</a>=<a class="el" href="structetl_1_1bitset.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:gae2ef04cbec9181a661996527e875a00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:gae2ef04cbec9181a661996527e875a00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8374fa7ba20373e38b7faf50c7a2e9eb" id="r_ga8374fa7ba20373e38b7faf50c7a2e9eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ga8374fa7ba20373e38b7faf50c7a2e9eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#ga8374fa7ba20373e38b7faf50c7a2e9eb">stof</a> (<a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *<a class="el" href="structetl_1_1bitset.html">pos</a>=<a class="el" href="structetl_1_1bitset.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:ga8374fa7ba20373e38b7faf50c7a2e9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:ga8374fa7ba20373e38b7faf50c7a2e9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a292e75d88b4e3619e2654b8f6f8660" id="r_a1a292e75d88b4e3619e2654b8f6f8660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a292e75d88b4e3619e2654b8f6f8660">stoi</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1bitset.html">pos</a>=<a class="el" href="structetl_1_1bitset.html">nullptr</a>, <a class="el" href="structetl_1_1bitset.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:a1a292e75d88b4e3619e2654b8f6f8660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a1a292e75d88b4e3619e2654b8f6f8660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bfd356983e8d8a730538cd6b5f7cd" id="r_a634bfd356983e8d8a730538cd6b5f7cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a634bfd356983e8d8a730538cd6b5f7cd">stol</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1bitset.html">pos</a>=<a class="el" href="structetl_1_1bitset.html">nullptr</a>, <a class="el" href="structetl_1_1bitset.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a634bfd356983e8d8a730538cd6b5f7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a634bfd356983e8d8a730538cd6b5f7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f331cad44e7c284adb790b1daabb0cc" id="r_ga8f331cad44e7c284adb790b1daabb0cc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:ga8f331cad44e7c284adb790b1daabb0cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#ga8f331cad44e7c284adb790b1daabb0cc">stold</a> (<a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> *<a class="el" href="structetl_1_1bitset.html">pos</a>=<a class="el" href="structetl_1_1bitset.html">nullptr</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ga8f331cad44e7c284adb790b1daabb0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a string str.  <br /></td></tr>
<tr class="separator:ga8f331cad44e7c284adb790b1daabb0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b844e6e1102e2efe7b9f7ad9ef4fff6" id="r_a8b844e6e1102e2efe7b9f7ad9ef4fff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b844e6e1102e2efe7b9f7ad9ef4fff6">stoll</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1bitset.html">pos</a>=<a class="el" href="structetl_1_1bitset.html">nullptr</a>, <a class="el" href="structetl_1_1bitset.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a8b844e6e1102e2efe7b9f7ad9ef4fff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a8b844e6e1102e2efe7b9f7ad9ef4fff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c74f60fe53545b60e1c1404719b84e6" id="r_a0c74f60fe53545b60e1c1404719b84e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c74f60fe53545b60e1c1404719b84e6">stoul</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1bitset.html">pos</a>=<a class="el" href="structetl_1_1bitset.html">nullptr</a>, <a class="el" href="structetl_1_1bitset.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a0c74f60fe53545b60e1c1404719b84e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a0c74f60fe53545b60e1c1404719b84e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d870cb89861489715e34bf225feb213" id="r_a3d870cb89861489715e34bf225feb213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d870cb89861489715e34bf225feb213">stoull</a> (<a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a> <a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *<a class="el" href="structetl_1_1bitset.html">pos</a>=<a class="el" href="structetl_1_1bitset.html">nullptr</a>, <a class="el" href="structetl_1_1bitset.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a3d870cb89861489715e34bf225feb213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a signed integer value in the string str.  <br /></td></tr>
<tr class="separator:a3d870cb89861489715e34bf225feb213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5321996edb97a0bb3ce62286dd77d58e" id="r_ga5321996edb97a0bb3ce62286dd77d58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga5321996edb97a0bb3ce62286dd77d58e">strcat</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> *</td></tr>
<tr class="memdesc:ga5321996edb97a0bb3ce62286dd77d58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the character string pointed to by src to the end of the character string pointed to by dest. The character src[0] replaces the null terminator at the end of dest. The resulting byte string is null-terminated.  <br /></td></tr>
<tr class="separator:ga5321996edb97a0bb3ce62286dd77d58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab0d635f5b2d4f2b9cfceec2c41c373" id="r_ga1ab0d635f5b2d4f2b9cfceec2c41c373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga1ab0d635f5b2d4f2b9cfceec2c41c373">strchr</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> *</td></tr>
<tr class="memdesc:ga1ab0d635f5b2d4f2b9cfceec2c41c373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ga1ab0d635f5b2d4f2b9cfceec2c41c373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fca1e170d91ea2b0901d41ccb3f4ef6" id="r_ga6fca1e170d91ea2b0901d41ccb3f4ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga6fca1e170d91ea2b0901d41ccb3f4ef6">strchr</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:ga6fca1e170d91ea2b0901d41ccb3f4ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ga6fca1e170d91ea2b0901d41ccb3f4ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03c96c75f1fa5b4153f1dab9148fd34" id="r_gaa03c96c75f1fa5b4153f1dab9148fd34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gaa03c96c75f1fa5b4153f1dab9148fd34">strcmp</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gaa03c96c75f1fa5b4153f1dab9148fd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the C string lhs to the C string rhs.  <br /></td></tr>
<tr class="separator:gaa03c96c75f1fa5b4153f1dab9148fd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac458fbcee97fcd2a801b23b1a05587f8" id="r_gac458fbcee97fcd2a801b23b1a05587f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gac458fbcee97fcd2a801b23b1a05587f8">strcpy</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> *</td></tr>
<tr class="memdesc:gac458fbcee97fcd2a801b23b1a05587f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the character string pointed to by src, including the null terminator, to the character array whose first element is pointed to by dest.  <br /></td></tr>
<tr class="separator:gac458fbcee97fcd2a801b23b1a05587f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cb449a1f27e32af89154ce5d4b31dc" id="r_gaf0cb449a1f27e32af89154ce5d4b31dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gaf0cb449a1f27e32af89154ce5d4b31dc">strcspn</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:gaf0cb449a1f27e32af89154ce5d4b31dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the byte string pointed to by dest, that consists of only the characters not found in byte string pointed to by src.  <br /></td></tr>
<tr class="separator:gaf0cb449a1f27e32af89154ce5d4b31dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9406cef0552ac36f0ea11e670081897" id="r_aa9406cef0552ac36f0ea11e670081897"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OffsetType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ExtentType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">StrideType</a> &gt; </td></tr>
<tr class="memitem:aa9406cef0552ac36f0ea11e670081897"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9406cef0552ac36f0ea11e670081897">strided_slice</a> (<a class="el" href="structetl_1_1bitset.html">OffsetType</a>, <a class="el" href="structetl_1_1bitset.html">ExtentType</a>, <a class="el" href="structetl_1_1bitset.html">StrideType</a>) -&gt; strided_slice&lt; <a class="el" href="structetl_1_1bitset.html">OffsetType</a>, <a class="el" href="structetl_1_1bitset.html">ExtentType</a>, <a class="el" href="structetl_1_1bitset.html">StrideType</a> &gt;</td></tr>
<tr class="separator:aa9406cef0552ac36f0ea11e670081897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847c7fe27bc536cdf5109074b14e81d7" id="r_ga847c7fe27bc536cdf5109074b14e81d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga847c7fe27bc536cdf5109074b14e81d7">strlen</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>) -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:ga847c7fe27bc536cdf5109074b14e81d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the C string str.  <br /></td></tr>
<tr class="separator:ga847c7fe27bc536cdf5109074b14e81d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f875253fd9982757bdb90f84284322c" id="r_ga3f875253fd9982757bdb90f84284322c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga3f875253fd9982757bdb90f84284322c">strncat</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> *</td></tr>
<tr class="memdesc:ga3f875253fd9982757bdb90f84284322c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a byte string pointed to by src to a byte string pointed to by dest. At most count characters are copied. The resulting byte string is null-terminated.  <br /></td></tr>
<tr class="separator:ga3f875253fd9982757bdb90f84284322c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc17ca72f164ecad9eb0bdf5fec43928" id="r_gacc17ca72f164ecad9eb0bdf5fec43928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gacc17ca72f164ecad9eb0bdf5fec43928">strncmp</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gacc17ca72f164ecad9eb0bdf5fec43928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count characters of two possibly null-terminated arrays. The comparison is done lexicographically. Characters following the null character are not compared.  <br /></td></tr>
<tr class="separator:gacc17ca72f164ecad9eb0bdf5fec43928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d78828452384f88828ac39373bdb7f" id="r_ga50d78828452384f88828ac39373bdb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga50d78828452384f88828ac39373bdb7f">strncpy</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> *</td></tr>
<tr class="memdesc:ga50d78828452384f88828ac39373bdb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the byte string pointed to by src (including the terminating null character) to character array pointed to by dest.  <br /></td></tr>
<tr class="separator:ga50d78828452384f88828ac39373bdb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042c917008dbbbd4e10d144f2b8153bf" id="r_ga042c917008dbbbd4e10d144f2b8153bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga042c917008dbbbd4e10d144f2b8153bf">strpbrk</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> *</td></tr>
<tr class="memdesc:ga042c917008dbbbd4e10d144f2b8153bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <br /></td></tr>
<tr class="separator:ga042c917008dbbbd4e10d144f2b8153bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a1eddfb9d029d0710fd07afafcf1fb" id="r_ga41a1eddfb9d029d0710fd07afafcf1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga41a1eddfb9d029d0710fd07afafcf1fb">strpbrk</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:ga41a1eddfb9d029d0710fd07afafcf1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the null-terminated byte string pointed to by dest for any character from the null-terminated byte string pointed to by breakset, and returns a pointer to that character.  <br /></td></tr>
<tr class="separator:ga41a1eddfb9d029d0710fd07afafcf1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ac7ed52583c6766a16279f6b2a56e2" id="r_ga21ac7ed52583c6766a16279f6b2a56e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga21ac7ed52583c6766a16279f6b2a56e2">strrchr</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> *</td></tr>
<tr class="memdesc:ga21ac7ed52583c6766a16279f6b2a56e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ga21ac7ed52583c6766a16279f6b2a56e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d044d1f8e1c1b85fe30e4830ca04d7" id="r_gab1d044d1f8e1c1b85fe30e4830ca04d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gab1d044d1f8e1c1b85fe30e4830ca04d7">strrchr</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:gab1d044d1f8e1c1b85fe30e4830ca04d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the character static_cast&lt;char&gt;(ch) in the byte string pointed to by str.  <br /></td></tr>
<tr class="separator:gab1d044d1f8e1c1b85fe30e4830ca04d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f31dcdd10129882c6856b848a0ca8f" id="r_gae4f31dcdd10129882c6856b848a0ca8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gae4f31dcdd10129882c6856b848a0ca8f">strspn</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:gae4f31dcdd10129882c6856b848a0ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment (span) of the byte string pointed to by dest, that consists of only the characters found in byte string pointed to by src.  <br /></td></tr>
<tr class="separator:gae4f31dcdd10129882c6856b848a0ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1553928b9c7f3cb2b4232652f7a8883" id="r_gab1553928b9c7f3cb2b4232652f7a8883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#gab1553928b9c7f3cb2b4232652f7a8883">strstr</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">haystack</a>, <a class="el" href="structetl_1_1bitset.html">char</a> *<a class="el" href="structetl_1_1bitset.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> *</td></tr>
<tr class="memdesc:gab1553928b9c7f3cb2b4232652f7a8883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:gab1553928b9c7f3cb2b4232652f7a8883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af5da7af9b58ac38ff5d4da3ff5434b" id="r_ga3af5da7af9b58ac38ff5d4da3ff5434b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cstring.html#ga3af5da7af9b58ac38ff5d4da3ff5434b">strstr</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">haystack</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:ga3af5da7af9b58ac38ff5d4da3ff5434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the byte string needle in the byte string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:ga3af5da7af9b58ac38ff5d4da3ff5434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908461fb82d1921b7d9d47fefd69808f" id="r_a908461fb82d1921b7d9d47fefd69808f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a908461fb82d1921b7d9d47fefd69808f">strtod</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **last=<a class="el" href="structetl_1_1bitset.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:a908461fb82d1921b7d9d47fefd69808f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a908461fb82d1921b7d9d47fefd69808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ff85f301c7ae10d33eb06607976726" id="r_a17ff85f301c7ae10d33eb06607976726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17ff85f301c7ae10d33eb06607976726">strtof</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **last=<a class="el" href="structetl_1_1bitset.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="memdesc:a17ff85f301c7ae10d33eb06607976726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a17ff85f301c7ae10d33eb06607976726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70d2daad7d58df41e035dc7b7d6ee1" id="r_a1a70d2daad7d58df41e035dc7b7d6ee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a70d2daad7d58df41e035dc7b7d6ee1">strtol</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **last, <a class="el" href="structetl_1_1bitset.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a1a70d2daad7d58df41e035dc7b7d6ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a1a70d2daad7d58df41e035dc7b7d6ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30cff1b320a5ca627023644ccb321ef" id="r_ac30cff1b320a5ca627023644ccb321ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac30cff1b320a5ca627023644ccb321ef">strtold</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **last=<a class="el" href="structetl_1_1bitset.html">nullptr</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="memdesc:ac30cff1b320a5ca627023644ccb321ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets a floating point value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:ac30cff1b320a5ca627023644ccb321ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6baccbeb60e396a8222d877a5ef28f" id="r_afe6baccbeb60e396a8222d877a5ef28f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe6baccbeb60e396a8222d877a5ef28f">strtoll</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **last, <a class="el" href="structetl_1_1bitset.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:afe6baccbeb60e396a8222d877a5ef28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:afe6baccbeb60e396a8222d877a5ef28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d60e5943db8f44ee5c351c7744db66" id="r_a11d60e5943db8f44ee5c351c7744db66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d60e5943db8f44ee5c351c7744db66">strtoul</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **last, <a class="el" href="structetl_1_1bitset.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a11d60e5943db8f44ee5c351c7744db66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a11d60e5943db8f44ee5c351c7744db66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab96db1ba94415b0dce36ec1327f314" id="r_a4ab96db1ba94415b0dce36ec1327f314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ab96db1ba94415b0dce36ec1327f314">strtoull</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **last, <a class="el" href="structetl_1_1bitset.html">int</a> base) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td></tr>
<tr class="memdesc:a4ab96db1ba94415b0dce36ec1327f314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interprets an integer value in a byte string pointed to by str.  <br /></td></tr>
<tr class="separator:a4ab96db1ba94415b0dce36ec1327f314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af804eb418abea75441ce277a3d8ac9a4" id="r_af804eb418abea75441ce277a3d8ac9a4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">IndexT</a> , etl::size_t... Extents, typename... SliceSpecifiers&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1bitset.html">slices</a>) == <a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt;<a class="el" href="structetl_1_1bitset.html">IndexT</a>, Extents...&gt;::rank())</td></tr>
<tr class="memitem:af804eb418abea75441ce277a3d8ac9a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af804eb418abea75441ce277a3d8ac9a4">submdspan_extents</a> (<a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt; <a class="el" href="structetl_1_1bitset.html">IndexT</a>, Extents... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">ext</a>, SliceSpecifiers... <a class="el" href="structetl_1_1bitset.html">slices</a>)</td></tr>
<tr class="separator:af804eb418abea75441ce277a3d8ac9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977829c40c43a6c097536fc959a86292" id="r_a977829c40c43a6c097536fc959a86292"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a977829c40c43a6c097536fc959a86292"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a977829c40c43a6c097536fc959a86292">swap</a> (<a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1bitset.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:a977829c40c43a6c097536fc959a86292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1basic__inplace__string.html" title="basic_inplace_string class with fixed size capacity.">etl::basic_inplace_string</a>. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:a977829c40c43a6c097536fc959a86292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15165afbf59de637ccf27b635458ece" id="r_ac15165afbf59de637ccf27b635458ece"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </td></tr>
<tr class="memitem:ac15165afbf59de637ccf27b635458ece"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac15165afbf59de637ccf27b635458ece">swap</a> (<a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ac15165afbf59de637ccf27b635458ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:ac15165afbf59de637ccf27b635458ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74587901a0df261ba728e5fab73273de" id="r_a74587901a0df261ba728e5fab73273de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </td></tr>
<tr class="memitem:a74587901a0df261ba728e5fab73273de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74587901a0df261ba728e5fab73273de">swap</a> (<a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1bitset.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:a74587901a0df261ba728e5fab73273de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of x and y. Equivalent to x.swap(y).  <br /></td></tr>
<tr class="separator:a74587901a0df261ba728e5fab73273de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bec9d408f2060c687550beff2bc22a" id="r_a49bec9d408f2060c687550beff2bc22a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; <br />
requires (<a class="el" href="#a6a08681ad0c17b00662bfd185a081335">is_swappable_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">C</a>&gt;)</td></tr>
<tr class="memitem:a49bec9d408f2060c687550beff2bc22a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49bec9d408f2060c687550beff2bc22a">swap</a> (<a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">C</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">C</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1bitset.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:a49bec9d408f2060c687550beff2bc22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for stack. Swaps the contents of lhs and rhs. This overload only participates in overload resolution if is_swappable&lt;C&gt;::value is true.  <br /></td></tr>
<tr class="separator:a49bec9d408f2060c687550beff2bc22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10be93498b340088ebf6b854223c733f" id="r_a10be93498b340088ebf6b854223c733f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:a10be93498b340088ebf6b854223c733f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10be93498b340088ebf6b854223c733f">swap</a> (<a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept(noexcept(lhs.swap(<a class="el" href="structetl_1_1bitset.html">rhs</a>))) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:a10be93498b340088ebf6b854223c733f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs).  <br /></td></tr>
<tr class="separator:a10be93498b340088ebf6b854223c733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1059d0a7b563d13c9d599eea27ca489e" id="r_a1059d0a7b563d13c9d599eea27ca489e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a1059d0a7b563d13c9d599eea27ca489e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1059d0a7b563d13c9d599eea27ca489e">swap</a> (<a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; &amp;<a class="el" href="structetl_1_1bitset.html">rhs</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:a1059d0a7b563d13c9d599eea27ca489e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the swap algorithm for <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">static_vector</a>. Swaps the contents of lhs and rhs.  <br /></td></tr>
<tr class="separator:a1059d0a7b563d13c9d599eea27ca489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885a42e965c6251995730e67ba6d09eb" id="r_a885a42e965c6251995730e67ba6d09eb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a885a42e965c6251995730e67ba6d09eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a885a42e965c6251995730e67ba6d09eb">swap</a> (T &amp;a, T &amp;b) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:a885a42e965c6251995730e67ba6d09eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:a885a42e965c6251995730e67ba6d09eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f797628671cf0d4b35a9858fd9a0455" id="r_a9f797628671cf0d4b35a9858fd9a0455"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a9f797628671cf0d4b35a9858fd9a0455"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f797628671cf0d4b35a9858fd9a0455">swap</a> (T &amp;a, T &amp;b) noexcept(<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; &amp;&amp;<a class="el" href="#ad26f59ba1b8a873f9d8374f72a4002c4">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:a9f797628671cf0d4b35a9858fd9a0455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:a9f797628671cf0d4b35a9858fd9a0455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad539af8c81b36e27d721d3df81ffe277" id="r_ad539af8c81b36e27d721d3df81ffe277"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:ad539af8c81b36e27d721d3df81ffe277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad539af8c81b36e27d721d3df81ffe277">swap</a> (T &amp;a, T &amp;b) noexcept(<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="#ad26f59ba1b8a873f9d8374f72a4002c4">etl::is_nothrow_move_assignable_v</a>&lt; T &gt;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ad539af8c81b36e27d721d3df81ffe277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <br /></td></tr>
<tr class="separator:ad539af8c81b36e27d721d3df81ffe277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5273f679984445be5233596370b7a15" id="r_af5273f679984445be5233596370b7a15"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="structetl_1_1is__swappable.html">etl::is_swappable</a>&lt;T&gt;::value)</td></tr>
<tr class="memitem:af5273f679984445be5233596370b7a15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5273f679984445be5233596370b7a15">swap</a> (T(&amp;a)[<a class="el" href="structetl_1_1bitset.html">N</a>], T(&amp;b)[<a class="el" href="structetl_1_1bitset.html">N</a>]) noexcept(<a class="el" href="structetl_1_1is__nothrow__swappable.html">etl::is_nothrow_swappable</a>&lt; T &gt;::value) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:af5273f679984445be5233596370b7a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ff5eb0624cb9e7995b622dc0c7e7c4" id="r_a23ff5eb0624cb9e7995b622dc0c7e7c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="#a6a08681ad0c17b00662bfd185a081335">etl::is_swappable_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a23ff5eb0624cb9e7995b622dc0c7e7c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23ff5eb0624cb9e7995b622dc0c7e7c4">swap</a> (T(&amp;a)[<a class="el" href="structetl_1_1bitset.html">N</a>], T(&amp;b)[<a class="el" href="structetl_1_1bitset.html">N</a>]) noexcept(<a class="el" href="structetl_1_1is__nothrow__swappable.html">etl::is_nothrow_swappable</a>&lt; T &gt;::value) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:a23ff5eb0624cb9e7995b622dc0c7e7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8e235b7f1654c13232e768201e17f4a" id="r_gaa8e235b7f1654c13232e768201e17f4a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> &gt; </td></tr>
<tr class="memitem:gaa8e235b7f1654c13232e768201e17f4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaa8e235b7f1654c13232e768201e17f4a">swap_ranges</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt2</a></td></tr>
<tr class="memdesc:gaa8e235b7f1654c13232e768201e17f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges elements between range <code>[first1 ,last1)</code> and another range starting at <code>first2</code>.  <br /></td></tr>
<tr class="separator:gaa8e235b7f1654c13232e768201e17f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e0a48ba202c18300d1ceb29d562da4" id="r_ga41e0a48ba202c18300d1ceb29d562da4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga41e0a48ba202c18300d1ceb29d562da4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#ga41e0a48ba202c18300d1ceb29d562da4">tan</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:ga41e0a48ba202c18300d1ceb29d562da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4213f4318ec3d9fa063bc56c8a3170c" id="r_gac4213f4318ec3d9fa063bc56c8a3170c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gac4213f4318ec3d9fa063bc56c8a3170c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex.html#gac4213f4318ec3d9fa063bc56c8a3170c">tanh</a> (<a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">z</a>) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt;</td></tr>
<tr class="separator:gac4213f4318ec3d9fa063bc56c8a3170c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga726b254bcee55a0855832cfd3bafd000" id="r_ga726b254bcee55a0855832cfd3bafd000"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Pos, <a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:ga726b254bcee55a0855832cfd3bafd000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#ga726b254bcee55a0855832cfd3bafd000">test_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga726b254bcee55a0855832cfd3bafd000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test bit at position <code>Pos</code>  <br /></td></tr>
<tr class="separator:ga726b254bcee55a0855832cfd3bafd000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4773cf495c99535fcec3c02995c7427" id="r_gab4773cf495c99535fcec3c02995c7427"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1builtin__unsigned__integer.html">etl::builtin_unsigned_integer</a> UInt&gt; </td></tr>
<tr class="memitem:gab4773cf495c99535fcec3c02995c7427"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bit.html#gab4773cf495c99535fcec3c02995c7427">test_bit</a> (UInt <a class="el" href="structetl_1_1bitset.html">word</a>, UInt <a class="el" href="structetl_1_1bitset.html">pos</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gab4773cf495c99535fcec3c02995c7427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test bit at position <code>pos</code>.  <br /></td></tr>
<tr class="separator:gab4773cf495c99535fcec3c02995c7427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3408c1dae71c214e0b2b360f5fcba723" id="r_a3408c1dae71c214e0b2b360f5fcba723"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3408c1dae71c214e0b2b360f5fcba723"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3408c1dae71c214e0b2b360f5fcba723">test_implicit_default_constructible</a> (T)</td></tr>
<tr class="separator:a3408c1dae71c214e0b2b360f5fcba723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1ede89bcd679cdd58f45d98b785cd8" id="r_a0d1ede89bcd679cdd58f45d98b785cd8"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0d1ede89bcd679cdd58f45d98b785cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d1ede89bcd679cdd58f45d98b785cd8">tie</a> (<a class="el" href="structetl_1_1bitset.html">Args</a> &amp;... args) noexcept -&gt; <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; <a class="el" href="structetl_1_1bitset.html">Args</a> &amp;... &gt;</td></tr>
<tr class="separator:a0d1ede89bcd679cdd58f45d98b785cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa171f5d95623a8a1268dc9134a02f972" id="r_aa171f5d95623a8a1268dc9134a02f972"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Ptr</a> &gt; </td></tr>
<tr class="memitem:aa171f5d95623a8a1268dc9134a02f972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa171f5d95623a8a1268dc9134a02f972">to_address</a> (<a class="el" href="structetl_1_1bitset.html">Ptr</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;ptr) noexcept</td></tr>
<tr class="memdesc:aa171f5d95623a8a1268dc9134a02f972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by p without forming a reference to the object pointed to by p.  <br /></td></tr>
<tr class="separator:aa171f5d95623a8a1268dc9134a02f972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9487e53c09efc9a8837a2d074e441b99" id="r_a9487e53c09efc9a8837a2d074e441b99"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#abffc77cc5069dfe2c648737671e340d9">is_function_v</a>&lt;T&gt;)</td></tr>
<tr class="memitem:a9487e53c09efc9a8837a2d074e441b99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9487e53c09efc9a8837a2d074e441b99">to_address</a> (T *ptr) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a9487e53c09efc9a8837a2d074e441b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the address represented by p without forming a reference to the object pointed to by p.  <br /></td></tr>
<tr class="separator:a9487e53c09efc9a8837a2d074e441b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ada873a32749c139721424bd4a122d" id="r_a76ada873a32749c139721424bd4a122d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76ada873a32749c139721424bd4a122d">to_chars</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *, <a class="el" href="structetl_1_1bitset.html">char</a> *, <a class="el" href="structetl_1_1bitset.html">bool</a>, <a class="el" href="structetl_1_1bitset.html">int</a>=10) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>=<a class="el" href="structetl_1_1bitset.html">delete</a></td></tr>
<tr class="separator:a76ada873a32749c139721424bd4a122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d46a108541ea7e9e622ba37063518f9" id="r_a6d46a108541ea7e9e622ba37063518f9"><td class="memTemplParams" colspan="2">template&lt;integral T&gt; <br />
requires (<a class="el" href="structetl_1_1bitset.html">not</a> same_as&lt;T, <a class="el" href="structetl_1_1bitset.html">bool</a>&gt;)</td></tr>
<tr class="memitem:a6d46a108541ea7e9e622ba37063518f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d46a108541ea7e9e622ba37063518f9">to_chars</a> (<a class="el" href="structetl_1_1bitset.html">char</a> *first, <a class="el" href="structetl_1_1bitset.html">char</a> *last, T val, <a class="el" href="structetl_1_1bitset.html">int</a> base=10) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a></td></tr>
<tr class="memdesc:a6d46a108541ea7e9e622ba37063518f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range.  <br /></td></tr>
<tr class="separator:a6d46a108541ea7e9e622ba37063518f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a64d34e50bd46ac7c48f9c3b20ecfe" id="r_a02a64d34e50bd46ac7c48f9c3b20ecfe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </td></tr>
<tr class="memitem:a02a64d34e50bd46ac7c48f9c3b20ecfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02a64d34e50bd46ac7c48f9c3b20ecfe">to_integer</a> (<a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> b) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a></td></tr>
<tr class="memdesc:a02a64d34e50bd46ac7c48f9c3b20ecfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: <code>return Int(b);</code>  <br /></td></tr>
<tr class="separator:a02a64d34e50bd46ac7c48f9c3b20ecfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabe21e30e1c4a3fe9d4b236c80b7bb1" id="r_acabe21e30e1c4a3fe9d4b236c80b7bb1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:acabe21e30e1c4a3fe9d4b236c80b7bb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acabe21e30e1c4a3fe9d4b236c80b7bb1">to_string</a> (<a class="el" href="structetl_1_1bitset.html">int</a> value) noexcept -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:acabe21e30e1c4a3fe9d4b236c80b7bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>.  <br /></td></tr>
<tr class="separator:acabe21e30e1c4a3fe9d4b236c80b7bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4058bf13763031d698e2360236eb1766" id="r_a4058bf13763031d698e2360236eb1766"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a4058bf13763031d698e2360236eb1766"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4058bf13763031d698e2360236eb1766">to_string</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> value) noexcept -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a4058bf13763031d698e2360236eb1766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>.  <br /></td></tr>
<tr class="separator:a4058bf13763031d698e2360236eb1766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1cd63528320986c9785a5073bd9a5c" id="r_aab1cd63528320986c9785a5073bd9a5c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:aab1cd63528320986c9785a5073bd9a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab1cd63528320986c9785a5073bd9a5c">to_string</a> (<a class="el" href="structetl_1_1bitset.html">long</a> value) noexcept -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:aab1cd63528320986c9785a5073bd9a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>.  <br /></td></tr>
<tr class="separator:aab1cd63528320986c9785a5073bd9a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8117b4615a13419168ed037eaa6440d7" id="r_a8117b4615a13419168ed037eaa6440d7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a8117b4615a13419168ed037eaa6440d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8117b4615a13419168ed037eaa6440d7">to_string</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> value) noexcept -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a8117b4615a13419168ed037eaa6440d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>.  <br /></td></tr>
<tr class="separator:a8117b4615a13419168ed037eaa6440d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1309afc3747c07e3c2bee0669cf786" id="r_a6d1309afc3747c07e3c2bee0669cf786"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a6d1309afc3747c07e3c2bee0669cf786"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d1309afc3747c07e3c2bee0669cf786">to_string</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> value) noexcept -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a6d1309afc3747c07e3c2bee0669cf786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>.  <br /></td></tr>
<tr class="separator:a6d1309afc3747c07e3c2bee0669cf786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5658429f25f4671a0e8a59cee2221895" id="r_a5658429f25f4671a0e8a59cee2221895"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </td></tr>
<tr class="memitem:a5658429f25f4671a0e8a59cee2221895"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5658429f25f4671a0e8a59cee2221895">to_string</a> (<a class="el" href="structetl_1_1bitset.html">unsigned</a> value) noexcept -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt;</td></tr>
<tr class="memdesc:a5658429f25f4671a0e8a59cee2221895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>.  <br /></td></tr>
<tr class="separator:a5658429f25f4671a0e8a59cee2221895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4b8c890cb36df65940f4a0e4a65c11" id="r_abd4b8c890cb36df65940f4a0e4a65c11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Enum</a> &gt; </td></tr>
<tr class="memitem:abd4b8c890cb36df65940f4a0e4a65c11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd4b8c890cb36df65940f4a0e4a65c11">to_underlying</a> (<a class="el" href="structetl_1_1bitset.html">Enum</a> e) noexcept -&gt; <a class="el" href="group__type__traits.html#ga23e4463cad64a4fb5f8e4cf7acafec27">underlying_type_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">Enum</a> &gt;</td></tr>
<tr class="memdesc:abd4b8c890cb36df65940f4a0e4a65c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an enumeration to its underlying type.  <br /></td></tr>
<tr class="separator:abd4b8c890cb36df65940f4a0e4a65c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeee7b085cced6d915305f9ae1bee437" id="r_gadeee7b085cced6d915305f9ae1bee437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#gadeee7b085cced6d915305f9ae1bee437">tolower</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gadeee7b085cced6d915305f9ae1bee437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given character to lowercase according to the character conversion rules defined by the default C locale.  <br /></td></tr>
<tr class="separator:gadeee7b085cced6d915305f9ae1bee437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5656409846cdb311fcc37acd590d9a" id="r_gabf5656409846cdb311fcc37acd590d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cctype.html#gabf5656409846cdb311fcc37acd590d9a">toupper</a> (<a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:gabf5656409846cdb311fcc37acd590d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given character to uppercase according to the character conversion rules defined by the default C locale.  <br /></td></tr>
<tr class="separator:gabf5656409846cdb311fcc37acd590d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9acd9b1a67a38e589ba86c569aac0cb9" id="r_ga9acd9b1a67a38e589ba86c569aac0cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#ga9acd9b1a67a38e589ba86c569aac0cb9">towlower</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td></tr>
<tr class="memdesc:ga9acd9b1a67a38e589ba86c569aac0cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given wide character to lowercase, if possible.  <br /></td></tr>
<tr class="separator:ga9acd9b1a67a38e589ba86c569aac0cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefdb01e19c1c3b047ac3a7586586f2fd" id="r_gaefdb01e19c1c3b047ac3a7586586f2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cwctype.html#gaefdb01e19c1c3b047ac3a7586586f2fd">towupper</a> (<a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) noexcept -&gt; <a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a></td></tr>
<tr class="memdesc:gaefdb01e19c1c3b047ac3a7586586f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given wide character to uppercase, if possible.  <br /></td></tr>
<tr class="separator:gaefdb01e19c1c3b047ac3a7586586f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38fcd7a07285868feed538786ca5523" id="r_gab38fcd7a07285868feed538786ca5523"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryReductionOp</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">UnaryTransformOp</a> &gt; </td></tr>
<tr class="memitem:gab38fcd7a07285868feed538786ca5523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gab38fcd7a07285868feed538786ca5523">transform_reduce</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, T init, <a class="el" href="structetl_1_1bitset.html">BinaryReductionOp</a> <a class="el" href="group__numeric.html#ga1c4ece300169efb3528dd8de1633ca66">reduce</a>, <a class="el" href="structetl_1_1bitset.html">UnaryTransformOp</a> <a class="el" href="group__algorithm.html#ga0d479673068495c0b88dcd93a99dfb57">transform</a>) -&gt; T</td></tr>
<tr class="memdesc:gab38fcd7a07285868feed538786ca5523"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce">https://en.cppreference.com/w/cpp/algorithm/transform_reduce</a>  <br /></td></tr>
<tr class="separator:gab38fcd7a07285868feed538786ca5523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab107a1f3770c53e8bae0569b29c8eb52" id="r_gab107a1f3770c53e8bae0569b29c8eb52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:gab107a1f3770c53e8bae0569b29c8eb52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#gab107a1f3770c53e8bae0569b29c8eb52">transform_reduce</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, T init) -&gt; T</td></tr>
<tr class="memdesc:gab107a1f3770c53e8bae0569b29c8eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce">https://en.cppreference.com/w/cpp/algorithm/transform_reduce</a>  <br /></td></tr>
<tr class="separator:gab107a1f3770c53e8bae0569b29c8eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a7150bf27fdb35cbafba959838e4e6" id="r_ga43a7150bf27fdb35cbafba959838e4e6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryReductionOp</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryTransformOp</a> &gt; </td></tr>
<tr class="memitem:ga43a7150bf27fdb35cbafba959838e4e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numeric.html#ga43a7150bf27fdb35cbafba959838e4e6">transform_reduce</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, T init, <a class="el" href="structetl_1_1bitset.html">BinaryReductionOp</a> <a class="el" href="group__numeric.html#ga1c4ece300169efb3528dd8de1633ca66">reduce</a>, <a class="el" href="structetl_1_1bitset.html">BinaryTransformOp</a> <a class="el" href="group__algorithm.html#ga0d479673068495c0b88dcd93a99dfb57">transform</a>) -&gt; T</td></tr>
<tr class="memdesc:ga43a7150bf27fdb35cbafba959838e4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce">https://en.cppreference.com/w/cpp/algorithm/transform_reduce</a>  <br /></td></tr>
<tr class="separator:ga43a7150bf27fdb35cbafba959838e4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95e50e7b2dda0a7a7fd3b1b3a37dc9" id="r_a4c95e50e7b2dda0a7a7fd3b1b3a37dc9"><td class="memTemplParams" colspan="2">template&lt;etl::tuple_like... Tuples&gt; </td></tr>
<tr class="memitem:a4c95e50e7b2dda0a7a7fd3b1b3a37dc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c95e50e7b2dda0a7a7fd3b1b3a37dc9">tuple_cat</a> (<a class="el" href="structetl_1_1bitset.html">Tuples</a> &amp;&amp;... <a class="el" href="structetl_1_1bitset.html">ts</a>)</td></tr>
<tr class="separator:a4c95e50e7b2dda0a7a7fd3b1b3a37dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a93d951b4c9c54a4e94d4380874a4f" id="r_aa4a93d951b4c9c54a4e94d4380874a4f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:aa4a93d951b4c9c54a4e94d4380874a4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4a93d951b4c9c54a4e94d4380874a4f">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;<a class="el" href="structetl_1_1bitset.html">v</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> &amp;&amp;</td></tr>
<tr class="separator:aa4a93d951b4c9c54a4e94d4380874a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9def1cedb7034b01e6cffb68531adbd3" id="r_a9def1cedb7034b01e6cffb68531adbd3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a9def1cedb7034b01e6cffb68531adbd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9def1cedb7034b01e6cffb68531adbd3">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;<a class="el" href="structetl_1_1bitset.html">v</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> &amp;</td></tr>
<tr class="separator:a9def1cedb7034b01e6cffb68531adbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcf60de77d9b1ad3d568505f3916fe2" id="r_a5dcf60de77d9b1ad3d568505f3916fe2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:a5dcf60de77d9b1ad3d568505f3916fe2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5dcf60de77d9b1ad3d568505f3916fe2">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;<a class="el" href="structetl_1_1bitset.html">v</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td></tr>
<tr class="separator:a5dcf60de77d9b1ad3d568505f3916fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac615a5375ea02af1dee73be6ba9c605c" id="r_ac615a5375ea02af1dee73be6ba9c605c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </td></tr>
<tr class="memitem:ac615a5375ea02af1dee73be6ba9c605c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac615a5375ea02af1dee73be6ba9c605c">unchecked_get</a> (<a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">v</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="separator:ac615a5375ea02af1dee73be6ba9c605c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14cd5bdeb510c30773c0a14b86d5f8e" id="r_aa14cd5bdeb510c30773c0a14b86d5f8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">E</a> &gt; </td></tr>
<tr class="memitem:aa14cd5bdeb510c30773c0a14b86d5f8e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa14cd5bdeb510c30773c0a14b86d5f8e">unexpected</a> (<a class="el" href="structetl_1_1bitset.html">E</a>) -&gt; unexpected&lt; <a class="el" href="structetl_1_1bitset.html">E</a> &gt;</td></tr>
<tr class="separator:aa14cd5bdeb510c30773c0a14b86d5f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3106ad57aa7a55b245407cb2b9d552" id="r_a3c3106ad57aa7a55b245407cb2b9d552"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a> &gt; </td></tr>
<tr class="memitem:a3c3106ad57aa7a55b245407cb2b9d552"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c3106ad57aa7a55b245407cb2b9d552">uninitialized_copy</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a> <a class="el" href="structetl_1_1bitset.html">dest</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a></td></tr>
<tr class="separator:a3c3106ad57aa7a55b245407cb2b9d552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4820f5ffdced8fbb8775a604cbcbc7" id="r_abe4820f5ffdced8fbb8775a604cbcbc7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abe4820f5ffdced8fbb8775a604cbcbc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe4820f5ffdced8fbb8775a604cbcbc7">uninitialized_fill</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:abe4820f5ffdced8fbb8775a604cbcbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af092ebf515a399cf1685d91ba2dbb6f7" id="r_af092ebf515a399cf1685d91ba2dbb6f7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a> &gt; </td></tr>
<tr class="memitem:af092ebf515a399cf1685d91ba2dbb6f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af092ebf515a399cf1685d91ba2dbb6f7">uninitialized_move</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a> <a class="el" href="structetl_1_1bitset.html">dest</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a></td></tr>
<tr class="separator:af092ebf515a399cf1685d91ba2dbb6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb16b244632f4ab5f6fd117e5a75473e" id="r_abb16b244632f4ab5f6fd117e5a75473e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb16b244632f4ab5f6fd117e5a75473e">unreachable</a> () -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:abb16b244632f4ab5f6fd117e5a75473e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c2340a69881856d04c55c19bb5c291" id="r_a08c2340a69881856d04c55c19bb5c291"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:a08c2340a69881856d04c55c19bb5c291"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08c2340a69881856d04c55c19bb5c291">vformat_to</a> (<a class="el" href="structetl_1_1bitset.html">OutputIt</a> out, <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">string_view</a> <a class="el" href="structetl_1_1bitset.html">fmt</a>, <a class="el" href="#abd8c737296655b44480da4fb422add24">format_args</a> args) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:a08c2340a69881856d04c55c19bb5c291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b81f8645cb1474f15eb0afc8297a82" id="r_a95b81f8645cb1474f15eb0afc8297a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95b81f8645cb1474f15eb0afc8297a82">wcscat</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a95b81f8645cb1474f15eb0afc8297a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated.  <br /></td></tr>
<tr class="separator:a95b81f8645cb1474f15eb0afc8297a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48742a27f06adaa943c923168958fffd" id="r_a48742a27f06adaa943c923168958fffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48742a27f06adaa943c923168958fffd">wcschr</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a48742a27f06adaa943c923168958fffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a48742a27f06adaa943c923168958fffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8528d93a4e282441b93ef41355de51" id="r_afa8528d93a4e282441b93ef41355de51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8528d93a4e282441b93ef41355de51">wcschr</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:afa8528d93a4e282441b93ef41355de51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:afa8528d93a4e282441b93ef41355de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394989e435a3d8820b9887b0cb6f32d0" id="r_a394989e435a3d8820b9887b0cb6f32d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a394989e435a3d8820b9887b0cb6f32d0">wcscmp</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:a394989e435a3d8820b9887b0cb6f32d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two null-terminated wide strings lexicographically.  <br /></td></tr>
<tr class="separator:a394989e435a3d8820b9887b0cb6f32d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6e17a8ddf3c4fbe89a15f971083a96" id="r_a9c6e17a8ddf3c4fbe89a15f971083a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c6e17a8ddf3c4fbe89a15f971083a96">wcscpy</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a9c6e17a8ddf3c4fbe89a15f971083a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a9c6e17a8ddf3c4fbe89a15f971083a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32c98dda497088d03d293fe8e7898f3" id="r_aa32c98dda497088d03d293fe8e7898f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa32c98dda497088d03d293fe8e7898f3">wcscspn</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:aa32c98dda497088d03d293fe8e7898f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src.  <br /></td></tr>
<tr class="separator:aa32c98dda497088d03d293fe8e7898f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76640f48ef8b4a03e9b81fd5ca4209a" id="r_ae76640f48ef8b4a03e9b81fd5ca4209a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76640f48ef8b4a03e9b81fd5ca4209a">wcslen</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>) -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a></td></tr>
<tr class="memdesc:ae76640f48ef8b4a03e9b81fd5ca4209a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character.  <br /></td></tr>
<tr class="separator:ae76640f48ef8b4a03e9b81fd5ca4209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f1acddf72fe1e8ca96d2ba2ce4728a" id="r_af7f1acddf72fe1e8ca96d2ba2ce4728a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f1acddf72fe1e8ca96d2ba2ce4728a">wcsncat</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:af7f1acddf72fe1e8ca96d2ba2ce4728a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1).  <br /></td></tr>
<tr class="separator:af7f1acddf72fe1e8ca96d2ba2ce4728a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab6f756717b07001aa0cc5ed00d89dd" id="r_aeab6f756717b07001aa0cc5ed00d89dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeab6f756717b07001aa0cc5ed00d89dd">wcsncmp</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:aeab6f756717b07001aa0cc5ed00d89dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically.  <br /></td></tr>
<tr class="separator:aeab6f756717b07001aa0cc5ed00d89dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075bf5df5b479586668e8dfe6a56d0b7" id="r_a075bf5df5b479586668e8dfe6a56d0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a075bf5df5b479586668e8dfe6a56d0b7">wcsncpy</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a075bf5df5b479586668e8dfe6a56d0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a075bf5df5b479586668e8dfe6a56d0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcddbba9daed153f19e883e9aea6f8d" id="r_a1dcddbba9daed153f19e883e9aea6f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dcddbba9daed153f19e883e9aea6f8d">wcspbrk</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a1dcddbba9daed153f19e883e9aea6f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a1dcddbba9daed153f19e883e9aea6f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa424e61dbe13ba0fa30a5c09f2045ac" id="r_afa424e61dbe13ba0fa30a5c09f2045ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa424e61dbe13ba0fa30a5c09f2045ac">wcspbrk</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">breakset</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:afa424e61dbe13ba0fa30a5c09f2045ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str.  <br /></td></tr>
<tr class="separator:afa424e61dbe13ba0fa30a5c09f2045ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75f8bb32c928b359607a41c9f634e5" id="r_abb75f8bb32c928b359607a41c9f634e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb75f8bb32c928b359607a41c9f634e5">wcsrchr</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:abb75f8bb32c928b359607a41c9f634e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:abb75f8bb32c928b359607a41c9f634e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef301df65d76aedef7c3211e00900a2" id="r_a5ef301df65d76aedef7c3211e00900a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ef301df65d76aedef7c3211e00900a2">wcsrchr</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">str</a>, <a class="el" href="structetl_1_1bitset.html">int</a> <a class="el" href="structetl_1_1bitset.html">ch</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:a5ef301df65d76aedef7c3211e00900a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the last occurrence of the wide character ch in the wide string pointed to by str.  <br /></td></tr>
<tr class="separator:a5ef301df65d76aedef7c3211e00900a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3a2cd36229b80bef3fcc819e45291" id="r_a62a3a2cd36229b80bef3fcc819e45291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a3a2cd36229b80bef3fcc819e45291">wcsspn</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>) noexcept -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td></tr>
<tr class="memdesc:a62a3a2cd36229b80bef3fcc819e45291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src.  <br /></td></tr>
<tr class="separator:a62a3a2cd36229b80bef3fcc819e45291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d69c1152ef7e628b1691179fc6f530" id="r_a74d69c1152ef7e628b1691179fc6f530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74d69c1152ef7e628b1691179fc6f530">wcsstr</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">haystack</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a74d69c1152ef7e628b1691179fc6f530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:a74d69c1152ef7e628b1691179fc6f530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67cab31ecf7c17b7ea41fbc4c1d0bd5" id="r_ad67cab31ecf7c17b7ea41fbc4c1d0bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67cab31ecf7c17b7ea41fbc4c1d0bd5">wcsstr</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">haystack</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">needle</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:ad67cab31ecf7c17b7ea41fbc4c1d0bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared.  <br /></td></tr>
<tr class="separator:ad67cab31ecf7c17b7ea41fbc4c1d0bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175847a36c688adb123a34e9780ab25" id="r_a5175847a36c688adb123a34e9780ab25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5175847a36c688adb123a34e9780ab25">wmemchr</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *ptr, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a5175847a36c688adb123a34e9780ab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.  <br /></td></tr>
<tr class="separator:a5175847a36c688adb123a34e9780ab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65747ecf11dff5d8f3be4a0f7793ca69" id="r_a65747ecf11dff5d8f3be4a0f7793ca69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65747ecf11dff5d8f3be4a0f7793ca69">wmemchr</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *ptr, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td></tr>
<tr class="memdesc:a65747ecf11dff5d8f3be4a0f7793ca69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr.  <br /></td></tr>
<tr class="separator:a65747ecf11dff5d8f3be4a0f7793ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af171fdc02565644fe46f805df68af177" id="r_af171fdc02565644fe46f805df68af177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af171fdc02565644fe46f805df68af177">wmemcmp</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">lhs</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">rhs</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">int</a></td></tr>
<tr class="memdesc:af171fdc02565644fe46f805df68af177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically.  <br /></td></tr>
<tr class="separator:af171fdc02565644fe46f805df68af177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ebfa659c54260fe5e6e06ee48a906b" id="r_af2ebfa659c54260fe5e6e06ee48a906b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2ebfa659c54260fe5e6e06ee48a906b">wmemcpy</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:af2ebfa659c54260fe5e6e06ee48a906b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing.  <br /></td></tr>
<tr class="separator:af2ebfa659c54260fe5e6e06ee48a906b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72695f43a1b04ada99db35bf2396de5a" id="r_a72695f43a1b04ada99db35bf2396de5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72695f43a1b04ada99db35bf2396de5a">wmemmove</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="structetl_1_1bitset.html">src</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a72695f43a1b04ada99db35bf2396de5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a72695f43a1b04ada99db35bf2396de5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181b3459989bb776b4fde2be3f0ff339" id="r_a181b3459989bb776b4fde2be3f0ff339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a181b3459989bb776b4fde2be3f0ff339">wmemset</a> (<a class="el" href="structetl_1_1bitset.html">wchar_t</a> *<a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">ch</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td></tr>
<tr class="memdesc:a181b3459989bb776b4fde2be3f0ff339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest.  <br /></td></tr>
<tr class="separator:a181b3459989bb776b4fde2be3f0ff339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga6643f5ca84c6579040caeeb9079e0c3a" id="r_ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga6643f5ca84c6579040caeeb9079e0c3a">adjacent_find</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga6643f5ca84c6579040caeeb9079e0c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf6853a6729fd97ca2688e2ce192273" id="r_ga5bf6853a6729fd97ca2688e2ce192273"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:ga5bf6853a6729fd97ca2688e2ce192273"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5bf6853a6729fd97ca2688e2ce192273">adjacent_find</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga5bf6853a6729fd97ca2688e2ce192273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for two consecutive equal elements. Elements are compared using the given binary predicate p.  <br /></td></tr>
<tr class="separator:ga5bf6853a6729fd97ca2688e2ce192273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga068d12997d2db7789f5feeee67ba6632" id="r_ga068d12997d2db7789f5feeee67ba6632"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga068d12997d2db7789f5feeee67ba6632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga068d12997d2db7789f5feeee67ba6632">all_of</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:ga068d12997d2db7789f5feeee67ba6632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:ga068d12997d2db7789f5feeee67ba6632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaeab7423807619552d4187d28ced39b9a" id="r_gaeab7423807619552d4187d28ced39b9a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gaeab7423807619552d4187d28ced39b9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaeab7423807619552d4187d28ced39b9a">any_of</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> p) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="memdesc:gaeab7423807619552d4187d28ced39b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range <code>[first, last)</code>.  <br /></td></tr>
<tr class="separator:gaeab7423807619552d4187d28ced39b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga518c4f26f6b475c9ba5b742ca6202a05" id="r_ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga518c4f26f6b475c9ba5b742ca6202a05">binary_search</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga518c4f26f6b475c9ba5b742ca6202a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd7d82f1e1253083d060c08049cb64b" id="r_ga5bd7d82f1e1253083d060c08049cb64b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga5bd7d82f1e1253083d060c08049cb64b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5bd7d82f1e1253083d060c08049cb64b">binary_search</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td></tr>
<tr class="separator:ga5bd7d82f1e1253083d060c08049cb64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga11d3f8f2170e346ec527e33ba981a2ae" id="r_ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga11d3f8f2170e346ec527e33ba981a2ae">bubble_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga11d3f8f2170e346ec527e33ba981a2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aaad8ffc58779f75d6ce3d017dd3cb4" id="r_ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1aaad8ffc58779f75d6ce3d017dd3cb4">bubble_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order. The order of equal elements is guaranteed to be preserved.  <br /></td></tr>
<tr class="separator:ga1aaad8ffc58779f75d6ce3d017dd3cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga72ad3fc1cb6d967df6a52c8e61030f75" id="r_ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga72ad3fc1cb6d967df6a52c8e61030f75">clamp</a> (<a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">v</a>, <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lo</a>, <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">hi</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="memdesc:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <br /></td></tr>
<tr class="separator:ga72ad3fc1cb6d967df6a52c8e61030f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e0d6f4937eef794486e125996b6ce1" id="r_gac2e0d6f4937eef794486e125996b6ce1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> &gt; </td></tr>
<tr class="memitem:gac2e0d6f4937eef794486e125996b6ce1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gac2e0d6f4937eef794486e125996b6ce1">clamp</a> (<a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">v</a>, <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">lo</a>, <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">hi</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td></tr>
<tr class="memdesc:gac2e0d6f4937eef794486e125996b6ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <br /></td></tr>
<tr class="separator:gac2e0d6f4937eef794486e125996b6ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga0d076e41cf7830be44fc5fc1322d9f49" id="r_ga0d076e41cf7830be44fc5fc1322d9f49"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga0d076e41cf7830be44fc5fc1322d9f49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga0d076e41cf7830be44fc5fc1322d9f49">merge_sort</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga0d076e41cf7830be44fc5fc1322d9f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga0d076e41cf7830be44fc5fc1322d9f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e07086e339175ad2433a095b9205e87" id="r_ga9e07086e339175ad2433a095b9205e87"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BidirIt</a> &gt; </td></tr>
<tr class="memitem:ga9e07086e339175ad2433a095b9205e87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga9e07086e339175ad2433a095b9205e87">merge_sort</a> (<a class="el" href="structetl_1_1bitset.html">BidirIt</a> first, <a class="el" href="structetl_1_1bitset.html">BidirIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="memdesc:ga9e07086e339175ad2433a095b9205e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range <code>[first, last)</code> in non-descending order.  <br /></td></tr>
<tr class="separator:ga9e07086e339175ad2433a095b9205e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e" id="r_gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">FwdIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">FwdIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e">search</a> (<a class="el" href="structetl_1_1bitset.html">FwdIt1</a> first, <a class="el" href="structetl_1_1bitset.html">FwdIt1</a> last, <a class="el" href="structetl_1_1bitset.html">FwdIt2</a> <a class="el" href="structetl_1_1bitset.html">sFirst</a>, <a class="el" href="structetl_1_1bitset.html">FwdIt2</a> <a class="el" href="structetl_1_1bitset.html">sLast</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">FwdIt1</a></td></tr>
<tr class="separator:gaa6b2f5d7fd6a15ab6fc4d30c1a716a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd9a9ec8c617610bf30e92fbaa678cd" id="r_ga9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">FwdIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">FwdIt2</a> &gt; </td></tr>
<tr class="memitem:ga9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga9fd9a9ec8c617610bf30e92fbaa678cd">search</a> (<a class="el" href="structetl_1_1bitset.html">FwdIt1</a> first, <a class="el" href="structetl_1_1bitset.html">FwdIt1</a> last, <a class="el" href="structetl_1_1bitset.html">FwdIt2</a> <a class="el" href="structetl_1_1bitset.html">sFirst</a>, <a class="el" href="structetl_1_1bitset.html">FwdIt2</a> <a class="el" href="structetl_1_1bitset.html">sLast</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">FwdIt1</a></td></tr>
<tr class="separator:ga9fd9a9ec8c617610bf30e92fbaa678cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec0297d32d2f51e39c270a715b430d1" id="r_ga8ec0297d32d2f51e39c270a715b430d1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">FwdIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Searcher</a> &gt; </td></tr>
<tr class="memitem:ga8ec0297d32d2f51e39c270a715b430d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga8ec0297d32d2f51e39c270a715b430d1">search</a> (<a class="el" href="structetl_1_1bitset.html">FwdIt</a> first, <a class="el" href="structetl_1_1bitset.html">FwdIt</a> last, <a class="el" href="structetl_1_1bitset.html">Searcher</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;<a class="el" href="structetl_1_1bitset.html">searcher</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">FwdIt</a></td></tr>
<tr class="separator:ga8ec0297d32d2f51e39c270a715b430d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga07b828a0b5a5e92873f178d30c4bb9df" id="r_ga07b828a0b5a5e92873f178d30c4bb9df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Size</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ValueT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga07b828a0b5a5e92873f178d30c4bb9df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga07b828a0b5a5e92873f178d30c4bb9df">search_n</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Size</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="structetl_1_1bitset.html">ValueT</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga07b828a0b5a5e92873f178d30c4bb9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value.  <br /></td></tr>
<tr class="separator:ga07b828a0b5a5e92873f178d30c4bb9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52038b2431b48b42d039e54647d96493" id="r_ga52038b2431b48b42d039e54647d96493"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Size</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ValueT</a> &gt; </td></tr>
<tr class="memitem:ga52038b2431b48b42d039e54647d96493"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga52038b2431b48b42d039e54647d96493">search_n</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Size</a> <a class="el" href="group__algorithm.html#gacf27092e22460faafdb958cac56c6fec">count</a>, <a class="el" href="structetl_1_1bitset.html">ValueT</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="memdesc:ga52038b2431b48b42d039e54647d96493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range <code>[first, last)</code> for the first sequence of count identical elements, each equal to the given value.  <br /></td></tr>
<tr class="separator:ga52038b2431b48b42d039e54647d96493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gafe32b3c3b80a92b66e5d7f118439492e" id="r_gafe32b3c3b80a92b66e5d7f118439492e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gafe32b3c3b80a92b66e5d7f118439492e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gafe32b3c3b80a92b66e5d7f118439492e">set_difference</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:gafe32b3c3b80a92b66e5d7f118439492e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same.  <br /></td></tr>
<tr class="separator:gafe32b3c3b80a92b66e5d7f118439492e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf15d37410e2266762deefec2f9552e2" id="r_gabf15d37410e2266762deefec2f9552e2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:gabf15d37410e2266762deefec2f9552e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gabf15d37410e2266762deefec2f9552e2">set_difference</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:gabf15d37410e2266762deefec2f9552e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range <code>[first1, last1)</code> which are not found in the sorted range <code>[first2, last2)</code> to the range beginning at destination. Elements are compared using the given binary comparison function <code>comp</code> and the ranges must be sorted with respect to the same.  <br /></td></tr>
<tr class="separator:gabf15d37410e2266762deefec2f9552e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gacfa483f6d503afb56bafdb6c73eebdd8" id="r_gacfa483f6d503afb56bafdb6c73eebdd8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gacfa483f6d503afb56bafdb6c73eebdd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gacfa483f6d503afb56bafdb6c73eebdd8">set_intersection</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:gacfa483f6d503afb56bafdb6c73eebdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:gacfa483f6d503afb56bafdb6c73eebdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac046bcca7d511bae026125e54c1f20e7" id="r_gac046bcca7d511bae026125e54c1f20e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:gac046bcca7d511bae026125e54c1f20e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gac046bcca7d511bae026125e54c1f20e7">set_intersection</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">dest</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:gac046bcca7d511bae026125e54c1f20e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted range beginning at <code>dest</code> consisting of elements that are found in both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. If some element is found <code>m</code> times in <code>[first1, last1)</code> and n times in <code>[first2, last2)</code>, the first <code>min(m, n)</code> elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:gac046bcca7d511bae026125e54c1f20e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga4249908e93f7b1367d3605c52b20a842" id="r_ga4249908e93f7b1367d3605c52b20a842"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga4249908e93f7b1367d3605c52b20a842"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4249908e93f7b1367d3605c52b20a842">set_symmetric_difference</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:ga4249908e93f7b1367d3605c52b20a842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c80d1254a7659943993cacc3498dc38" id="r_ga5c80d1254a7659943993cacc3498dc38"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga5c80d1254a7659943993cacc3498dc38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga5c80d1254a7659943993cacc3498dc38">set_symmetric_difference</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">dest</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:ga5c80d1254a7659943993cacc3498dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gacfd656aa427e48301b6fd14503854ff7" id="r_gacfd656aa427e48301b6fd14503854ff7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gacfd656aa427e48301b6fd14503854ff7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gacfd656aa427e48301b6fd14503854ff7">set_union</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:gacfd656aa427e48301b6fd14503854ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:gacfd656aa427e48301b6fd14503854ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4135eaec81217633145f410048de3cbe" id="r_ga4135eaec81217633145f410048de3cbe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga4135eaec81217633145f410048de3cbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4135eaec81217633145f410048de3cbe">set_union</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">last2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="memdesc:ga4135eaec81217633145f410048de3cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a sorted union beginning at destination consisting of the set of elements present in one or both sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The resulting range cannot overlap with either of the input ranges.  <br /></td></tr>
<tr class="separator:ga4135eaec81217633145f410048de3cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad5ef221b98a814660142c728ce9bac78" id="r_gad5ef221b98a814660142c728ce9bac78"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gad5ef221b98a814660142c728ce9bac78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gad5ef221b98a814660142c728ce9bac78">sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:gad5ef221b98a814660142c728ce9bac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9823f4c1911f50c9f7ac3b4a8be9f294" id="r_ga9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:ga9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga9823f4c1911f50c9f7ac3b4a8be9f294">sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:ga9823f4c1911f50c9f7ac3b4a8be9f294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga555004d15f48a5bb9b71103bcc3e1555" id="r_ga555004d15f48a5bb9b71103bcc3e1555"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:ga555004d15f48a5bb9b71103bcc3e1555"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga555004d15f48a5bb9b71103bcc3e1555">stable_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:ga555004d15f48a5bb9b71103bcc3e1555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57756439702cf72053e29b5c7294d85" id="r_gab57756439702cf72053e29b5c7294d85"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </td></tr>
<tr class="memitem:gab57756439702cf72053e29b5c7294d85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gab57756439702cf72053e29b5c7294d85">stable_sort</a> (<a class="el" href="structetl_1_1bitset.html">RandomIt</a> first, <a class="el" href="structetl_1_1bitset.html">RandomIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a></td></tr>
<tr class="separator:gab57756439702cf72053e29b5c7294d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga0d479673068495c0b88dcd93a99dfb57" id="r_ga0d479673068495c0b88dcd93a99dfb57"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">UnaryOp</a> &gt; </td></tr>
<tr class="memitem:ga0d479673068495c0b88dcd93a99dfb57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga0d479673068495c0b88dcd93a99dfb57">transform</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">UnaryOp</a> <a class="el" href="structetl_1_1bitset.html">op</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:ga0d479673068495c0b88dcd93a99dfb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f1eb9069005465b67c5d79eaae8bb9" id="r_gaa4f1eb9069005465b67c5d79eaae8bb9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">BinaryOp</a> &gt; </td></tr>
<tr class="memitem:gaa4f1eb9069005465b67c5d79eaae8bb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaa4f1eb9069005465b67c5d79eaae8bb9">transform</a> (<a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">first1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt1</a> <a class="el" href="structetl_1_1bitset.html">last1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a> <a class="el" href="structetl_1_1bitset.html">first2</a>, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">dest</a>, <a class="el" href="structetl_1_1bitset.html">BinaryOp</a> <a class="el" href="structetl_1_1bitset.html">op</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:gaa4f1eb9069005465b67c5d79eaae8bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga99f27339834dd24fea714a4b4ef5b383" id="r_ga99f27339834dd24fea714a4b4ef5b383"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga99f27339834dd24fea714a4b4ef5b383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga99f27339834dd24fea714a4b4ef5b383">unique</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="separator:ga99f27339834dd24fea714a4b4ef5b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf368b8bc471211756f0fd32f9d2c8968" id="r_gaf368b8bc471211756f0fd32f9d2c8968"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </td></tr>
<tr class="memitem:gaf368b8bc471211756f0fd32f9d2c8968"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaf368b8bc471211756f0fd32f9d2c8968">unique</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="separator:gaf368b8bc471211756f0fd32f9d2c8968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga6aefae29604dcd0147171f39aa1380be" id="r_ga6aefae29604dcd0147171f39aa1380be"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </td></tr>
<tr class="memitem:ga6aefae29604dcd0147171f39aa1380be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga6aefae29604dcd0147171f39aa1380be">unique_copy</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>, <a class="el" href="structetl_1_1bitset.html">Predicate</a> <a class="el" href="structetl_1_1bitset.html">pred</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:ga6aefae29604dcd0147171f39aa1380be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18330134b5b5074b665d9e91c994f5e2" id="r_ga18330134b5b5074b665d9e91c994f5e2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </td></tr>
<tr class="memitem:ga18330134b5b5074b665d9e91c994f5e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga18330134b5b5074b665d9e91c994f5e2">unique_copy</a> (<a class="el" href="structetl_1_1bitset.html">InputIt</a> first, <a class="el" href="structetl_1_1bitset.html">InputIt</a> last, <a class="el" href="structetl_1_1bitset.html">OutputIt</a> <a class="el" href="structetl_1_1bitset.html">destination</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a></td></tr>
<tr class="separator:ga18330134b5b5074b665d9e91c994f5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad3130ebfc35a09b9488d205269fdac86" id="r_gad3130ebfc35a09b9488d205269fdac86"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </td></tr>
<tr class="memitem:gad3130ebfc35a09b9488d205269fdac86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gad3130ebfc35a09b9488d205269fdac86">upper_bound</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value, <a class="el" href="structetl_1_1bitset.html">Compare</a> <a class="el" href="structetl_1_1bitset.html">comp</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="separator:gad3130ebfc35a09b9488d205269fdac86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25261717b25b3523e4fdb8d6420183d2" id="r_ga25261717b25b3523e4fdb8d6420183d2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ga25261717b25b3523e4fdb8d6420183d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga25261717b25b3523e4fdb8d6420183d2">upper_bound</a> (<a class="el" href="structetl_1_1bitset.html">ForwardIt</a> first, <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> last, T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;value) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td></tr>
<tr class="separator:ga25261717b25b3523e4fdb8d6420183d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga11a1ed136986f9f62b428fc9cff05a58" id="r_ga11a1ed136986f9f62b428fc9cff05a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga11a1ed136986f9f62b428fc9cff05a58">acos</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga11a1ed136986f9f62b428fc9cff05a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0e24810c31b2b4d6c03c4c797ee6b2" id="r_gaab0e24810c31b2b4d6c03c4c797ee6b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaab0e24810c31b2b4d6c03c4c797ee6b2">acosf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaab0e24810c31b2b4d6c03c4c797ee6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e0fd9460a48322d76bc75bf03963e8" id="r_ga38e0fd9460a48322d76bc75bf03963e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga38e0fd9460a48322d76bc75bf03963e8">acos</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga38e0fd9460a48322d76bc75bf03963e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69543b8c9d2a9c0be5a844d0ee4a2b28" id="r_ga69543b8c9d2a9c0be5a844d0ee4a2b28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga69543b8c9d2a9c0be5a844d0ee4a2b28">acos</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga69543b8c9d2a9c0be5a844d0ee4a2b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2279ca8b4d3e2c28ec4e4a299bf0c3a" id="r_gad2279ca8b4d3e2c28ec4e4a299bf0c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad2279ca8b4d3e2c28ec4e4a299bf0c3a">acosl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gad2279ca8b4d3e2c28ec4e4a299bf0c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2344086af420d0b44a311f1df76a9ccc" id="r_ga2344086af420d0b44a311f1df76a9ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2344086af420d0b44a311f1df76a9ccc">acos</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga2344086af420d0b44a311f1df76a9ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaa94aadcd386f23a070e188aa0e717455" id="r_gaa94aadcd386f23a070e188aa0e717455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa94aadcd386f23a070e188aa0e717455">acosh</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaa94aadcd386f23a070e188aa0e717455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf50a85a3985477a435e269682f2f887a" id="r_gaf50a85a3985477a435e269682f2f887a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf50a85a3985477a435e269682f2f887a">acoshf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaf50a85a3985477a435e269682f2f887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277e2f5e73eee56e174cd743b427093e" id="r_ga277e2f5e73eee56e174cd743b427093e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga277e2f5e73eee56e174cd743b427093e">acosh</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga277e2f5e73eee56e174cd743b427093e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c27c5ea58d63cf8f388201d96bec2af" id="r_ga0c27c5ea58d63cf8f388201d96bec2af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0c27c5ea58d63cf8f388201d96bec2af">acosh</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga0c27c5ea58d63cf8f388201d96bec2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429c4dfa96d36adcdac87db72304bbee" id="r_ga429c4dfa96d36adcdac87db72304bbee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga429c4dfa96d36adcdac87db72304bbee">acoshl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga429c4dfa96d36adcdac87db72304bbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d99b043e092dc645ccc249c60a61ed9" id="r_ga6d99b043e092dc645ccc249c60a61ed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6d99b043e092dc645ccc249c60a61ed9">acosh</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga6d99b043e092dc645ccc249c60a61ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga50604fe33f743a5a96db3d5894b899ea" id="r_ga50604fe33f743a5a96db3d5894b899ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga50604fe33f743a5a96db3d5894b899ea">asin</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga50604fe33f743a5a96db3d5894b899ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b76a26aa932ec109e5386f77168196" id="r_ga51b76a26aa932ec109e5386f77168196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga51b76a26aa932ec109e5386f77168196">asinf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga51b76a26aa932ec109e5386f77168196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01b199b8cbad2b6a6a6a62fdf677c69" id="r_gad01b199b8cbad2b6a6a6a62fdf677c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad01b199b8cbad2b6a6a6a62fdf677c69">asin</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gad01b199b8cbad2b6a6a6a62fdf677c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e900fb29e26b00afd5ddffc99f7b537" id="r_ga6e900fb29e26b00afd5ddffc99f7b537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6e900fb29e26b00afd5ddffc99f7b537">asin</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga6e900fb29e26b00afd5ddffc99f7b537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cba14d8fe2e4ab545185b18a751e4c5" id="r_ga8cba14d8fe2e4ab545185b18a751e4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8cba14d8fe2e4ab545185b18a751e4c5">asinl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga8cba14d8fe2e4ab545185b18a751e4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92df73766eefd0dcb2435c0601f1019e" id="r_ga92df73766eefd0dcb2435c0601f1019e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga92df73766eefd0dcb2435c0601f1019e">asin</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga92df73766eefd0dcb2435c0601f1019e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gac7859c18dbfae564f92d556e14fa7b6a" id="r_gac7859c18dbfae564f92d556e14fa7b6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac7859c18dbfae564f92d556e14fa7b6a">asinh</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gac7859c18dbfae564f92d556e14fa7b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476f7ceb4dce8dfbda05dcde42d9103d" id="r_ga476f7ceb4dce8dfbda05dcde42d9103d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga476f7ceb4dce8dfbda05dcde42d9103d">asinhf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga476f7ceb4dce8dfbda05dcde42d9103d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8505fcb3b44df45b2ad775124c5d099e" id="r_ga8505fcb3b44df45b2ad775124c5d099e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8505fcb3b44df45b2ad775124c5d099e">asinh</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga8505fcb3b44df45b2ad775124c5d099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga304b637bf14e2ea87a61dc632ea06d02" id="r_ga304b637bf14e2ea87a61dc632ea06d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga304b637bf14e2ea87a61dc632ea06d02">asinh</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga304b637bf14e2ea87a61dc632ea06d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fdc11c6a149dde153853117d7395182" id="r_ga4fdc11c6a149dde153853117d7395182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4fdc11c6a149dde153853117d7395182">asinhl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga4fdc11c6a149dde153853117d7395182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81619e2452282d602c17329e7691d64" id="r_gad81619e2452282d602c17329e7691d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad81619e2452282d602c17329e7691d64">asinh</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gad81619e2452282d602c17329e7691d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga050d30d9993cbfef460a649443ea4e14" id="r_ga050d30d9993cbfef460a649443ea4e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga050d30d9993cbfef460a649443ea4e14">atan</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga050d30d9993cbfef460a649443ea4e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc77c1f521b383cb7c8e3caea2ccd145" id="r_gadc77c1f521b383cb7c8e3caea2ccd145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadc77c1f521b383cb7c8e3caea2ccd145">atanf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gadc77c1f521b383cb7c8e3caea2ccd145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f38e6f2553eab83a47f6a250630516" id="r_gac7f38e6f2553eab83a47f6a250630516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac7f38e6f2553eab83a47f6a250630516">atan</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gac7f38e6f2553eab83a47f6a250630516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7618da1cd9d1a0e9f80aa0e46738c503" id="r_ga7618da1cd9d1a0e9f80aa0e46738c503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7618da1cd9d1a0e9f80aa0e46738c503">atan</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga7618da1cd9d1a0e9f80aa0e46738c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da6aa9cdb87c1dd54a93329b7a39b94" id="r_ga0da6aa9cdb87c1dd54a93329b7a39b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0da6aa9cdb87c1dd54a93329b7a39b94">atanl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga0da6aa9cdb87c1dd54a93329b7a39b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade68021b3a0ed38780444a3793a13409" id="r_gade68021b3a0ed38780444a3793a13409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gade68021b3a0ed38780444a3793a13409">atan</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gade68021b3a0ed38780444a3793a13409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaa3aa7a4e78ae3ce2384102d19c7012f0" id="r_gaa3aa7a4e78ae3ce2384102d19c7012f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa3aa7a4e78ae3ce2384102d19c7012f0">atan2</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaa3aa7a4e78ae3ce2384102d19c7012f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af6a240c95112abd3800979b58338b8" id="r_ga7af6a240c95112abd3800979b58338b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7af6a240c95112abd3800979b58338b8">atan2f</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga7af6a240c95112abd3800979b58338b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1793f80eaf46012c729372559f20a36" id="r_gac1793f80eaf46012c729372559f20a36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac1793f80eaf46012c729372559f20a36">atan2</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gac1793f80eaf46012c729372559f20a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913dc1d0214b7452ae06ae2744b10b52" id="r_ga913dc1d0214b7452ae06ae2744b10b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga913dc1d0214b7452ae06ae2744b10b52">atan2</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga913dc1d0214b7452ae06ae2744b10b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fecd8eed70865ec7a4bbaf336a108f" id="r_ga93fecd8eed70865ec7a4bbaf336a108f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga93fecd8eed70865ec7a4bbaf336a108f">atan2l</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga93fecd8eed70865ec7a4bbaf336a108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga0085c94b22dfe824cd8181da9714026a" id="r_ga0085c94b22dfe824cd8181da9714026a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0085c94b22dfe824cd8181da9714026a">atanh</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga0085c94b22dfe824cd8181da9714026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae158c810a6fc7cd5ba3a30ad242fa665" id="r_gae158c810a6fc7cd5ba3a30ad242fa665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae158c810a6fc7cd5ba3a30ad242fa665">atanhf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gae158c810a6fc7cd5ba3a30ad242fa665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc6272738fda91f94464a0ff78196f2" id="r_ga3cc6272738fda91f94464a0ff78196f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3cc6272738fda91f94464a0ff78196f2">atanh</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga3cc6272738fda91f94464a0ff78196f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44fbe54fbbf219b24c4e2a9f1bc38cc6" id="r_ga44fbe54fbbf219b24c4e2a9f1bc38cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga44fbe54fbbf219b24c4e2a9f1bc38cc6">atanh</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga44fbe54fbbf219b24c4e2a9f1bc38cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd5afff1dc0cd8c7e74a471a250cff5" id="r_ga5dd5afff1dc0cd8c7e74a471a250cff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5dd5afff1dc0cd8c7e74a471a250cff5">atanhl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga5dd5afff1dc0cd8c7e74a471a250cff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb1822f040a28c13544da79418e2489" id="r_ga9fb1822f040a28c13544da79418e2489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9fb1822f040a28c13544da79418e2489">atanh</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga9fb1822f040a28c13544da79418e2489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad7312ab60735f030c31d877e771df25b" id="r_gad7312ab60735f030c31d877e771df25b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad7312ab60735f030c31d877e771df25b">beta</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gad7312ab60735f030c31d877e771df25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ea0a5ab3eb1572d57df749fa2a1b29" id="r_ga43ea0a5ab3eb1572d57df749fa2a1b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga43ea0a5ab3eb1572d57df749fa2a1b29">betaf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga43ea0a5ab3eb1572d57df749fa2a1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6feea40ab25c49385c9da90776c9181" id="r_gad6feea40ab25c49385c9da90776c9181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad6feea40ab25c49385c9da90776c9181">betal</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gad6feea40ab25c49385c9da90776c9181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga519930d517ee057032189d734e9fc5ed" id="r_ga519930d517ee057032189d734e9fc5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga519930d517ee057032189d734e9fc5ed">ceil</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga519930d517ee057032189d734e9fc5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddaf0fe8a1ffd02877c6e0f6746e554" id="r_ga1ddaf0fe8a1ffd02877c6e0f6746e554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1ddaf0fe8a1ffd02877c6e0f6746e554">ceilf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga1ddaf0fe8a1ffd02877c6e0f6746e554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca876419c954b74e77fde43b651c1a45" id="r_gaca876419c954b74e77fde43b651c1a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaca876419c954b74e77fde43b651c1a45">ceil</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaca876419c954b74e77fde43b651c1a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cef9baa2395afd4785ff2e97806a21" id="r_ga38cef9baa2395afd4785ff2e97806a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga38cef9baa2395afd4785ff2e97806a21">ceil</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga38cef9baa2395afd4785ff2e97806a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7264f931bcdd9b7b9c418397d8a7ce0" id="r_gaa7264f931bcdd9b7b9c418397d8a7ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa7264f931bcdd9b7b9c418397d8a7ce0">ceill</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaa7264f931bcdd9b7b9c418397d8a7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5001ccc4dfab2325b96fab0131a6765" id="r_gaf5001ccc4dfab2325b96fab0131a6765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf5001ccc4dfab2325b96fab0131a6765">ceil</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaf5001ccc4dfab2325b96fab0131a6765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga3311ce930de7a4c480eb2d18975fd413" id="r_ga3311ce930de7a4c480eb2d18975fd413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3311ce930de7a4c480eb2d18975fd413">copysign</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">mag</a>, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga3311ce930de7a4c480eb2d18975fd413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3b7765a523593f95aab5ee4a830a0a" id="r_ga5c3b7765a523593f95aab5ee4a830a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5c3b7765a523593f95aab5ee4a830a0a">copysignf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">mag</a>, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga5c3b7765a523593f95aab5ee4a830a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff1096301fd095ed4ce11c7d7da07e9" id="r_gadff1096301fd095ed4ce11c7d7da07e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadff1096301fd095ed4ce11c7d7da07e9">copysign</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">mag</a>, <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gadff1096301fd095ed4ce11c7d7da07e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d191ad6ae48528f4b203b2ffc149db" id="r_ga07d191ad6ae48528f4b203b2ffc149db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga07d191ad6ae48528f4b203b2ffc149db">copysign</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">mag</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga07d191ad6ae48528f4b203b2ffc149db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a49b2265ca69e52783f386e10898bd6" id="r_ga6a49b2265ca69e52783f386e10898bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6a49b2265ca69e52783f386e10898bd6">copysignl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">mag</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">sgn</a>) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga6a49b2265ca69e52783f386e10898bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga1b56c844b2ce61b2d76a4d2c77396ce9" id="r_ga1b56c844b2ce61b2d76a4d2c77396ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1b56c844b2ce61b2d76a4d2c77396ce9">cos</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga1b56c844b2ce61b2d76a4d2c77396ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b64d241e55170c1c5ff3c81b7f049d8" id="r_ga6b64d241e55170c1c5ff3c81b7f049d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6b64d241e55170c1c5ff3c81b7f049d8">cosf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga6b64d241e55170c1c5ff3c81b7f049d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d37321a2b5d670a7f7e1d350e4a5d9" id="r_gaa6d37321a2b5d670a7f7e1d350e4a5d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa6d37321a2b5d670a7f7e1d350e4a5d9">cos</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaa6d37321a2b5d670a7f7e1d350e4a5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9bea6fec2b71789aa1efe4390cd8ca9" id="r_gad9bea6fec2b71789aa1efe4390cd8ca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad9bea6fec2b71789aa1efe4390cd8ca9">cos</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gad9bea6fec2b71789aa1efe4390cd8ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b52639423f23e3404d217ee510d9d5a" id="r_ga6b52639423f23e3404d217ee510d9d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6b52639423f23e3404d217ee510d9d5a">cosl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga6b52639423f23e3404d217ee510d9d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ce888291eb0c2d123d759960d0ee9e" id="r_ga94ce888291eb0c2d123d759960d0ee9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga94ce888291eb0c2d123d759960d0ee9e">cos</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga94ce888291eb0c2d123d759960d0ee9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaf0be4fdb5e458f645d1c425d2ae1651a" id="r_gaf0be4fdb5e458f645d1c425d2ae1651a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf0be4fdb5e458f645d1c425d2ae1651a">cosh</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaf0be4fdb5e458f645d1c425d2ae1651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07412925075eb7fdaff262a202c6d8b" id="r_gab07412925075eb7fdaff262a202c6d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab07412925075eb7fdaff262a202c6d8b">coshf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gab07412925075eb7fdaff262a202c6d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4f26d3503097887c1a08ebd5cb99ec" id="r_gabb4f26d3503097887c1a08ebd5cb99ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gabb4f26d3503097887c1a08ebd5cb99ec">cosh</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gabb4f26d3503097887c1a08ebd5cb99ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff130df1c63fe44e621b49cb14b8aee0" id="r_gaff130df1c63fe44e621b49cb14b8aee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaff130df1c63fe44e621b49cb14b8aee0">cosh</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaff130df1c63fe44e621b49cb14b8aee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4c7883e2812a93178162463f1eca34" id="r_ga3f4c7883e2812a93178162463f1eca34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3f4c7883e2812a93178162463f1eca34">coshl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga3f4c7883e2812a93178162463f1eca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ed710216672a83a5278976f0a08c89" id="r_ga53ed710216672a83a5278976f0a08c89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga53ed710216672a83a5278976f0a08c89">cosh</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga53ed710216672a83a5278976f0a08c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga1181784239ab4a4d91bbb09c6e136260" id="r_ga1181784239ab4a4d91bbb09c6e136260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1181784239ab4a4d91bbb09c6e136260">erf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga1181784239ab4a4d91bbb09c6e136260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc5a060cd5e28fdeabcf1393a23f64e" id="r_ga4dc5a060cd5e28fdeabcf1393a23f64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4dc5a060cd5e28fdeabcf1393a23f64e">erff</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga4dc5a060cd5e28fdeabcf1393a23f64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13bbf02499fb50c7f713c884e7519cd6" id="r_ga13bbf02499fb50c7f713c884e7519cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga13bbf02499fb50c7f713c884e7519cd6">erf</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga13bbf02499fb50c7f713c884e7519cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fcb9ae441725436b6e468541847f746" id="r_ga8fcb9ae441725436b6e468541847f746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8fcb9ae441725436b6e468541847f746">erf</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga8fcb9ae441725436b6e468541847f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cec8755ca64d6ee2774b2d1286f6e72" id="r_ga9cec8755ca64d6ee2774b2d1286f6e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9cec8755ca64d6ee2774b2d1286f6e72">erfl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga9cec8755ca64d6ee2774b2d1286f6e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b79eab7c06481251cf7bc3d0123cff" id="r_gaf2b79eab7c06481251cf7bc3d0123cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf2b79eab7c06481251cf7bc3d0123cff">erf</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaf2b79eab7c06481251cf7bc3d0123cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gadcf2fa322adfe3a7e284b01811eaec85" id="r_gadcf2fa322adfe3a7e284b01811eaec85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadcf2fa322adfe3a7e284b01811eaec85">exp</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gadcf2fa322adfe3a7e284b01811eaec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0968afe0e7ec491a982e2f849100400d" id="r_ga0968afe0e7ec491a982e2f849100400d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0968afe0e7ec491a982e2f849100400d">expf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga0968afe0e7ec491a982e2f849100400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744fd84929a0ba83626367fb0814fcc4" id="r_ga744fd84929a0ba83626367fb0814fcc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga744fd84929a0ba83626367fb0814fcc4">exp</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga744fd84929a0ba83626367fb0814fcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fc39900b41ce0c27c840f4864eb7e7" id="r_ga93fc39900b41ce0c27c840f4864eb7e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga93fc39900b41ce0c27c840f4864eb7e7">exp</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga93fc39900b41ce0c27c840f4864eb7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab87b218f1fc55b6fc30ccc076b6576a1" id="r_gab87b218f1fc55b6fc30ccc076b6576a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab87b218f1fc55b6fc30ccc076b6576a1">expl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gab87b218f1fc55b6fc30ccc076b6576a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4de36755d387716338b5639cf6202fb" id="r_gaf4de36755d387716338b5639cf6202fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf4de36755d387716338b5639cf6202fb">exp</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaf4de36755d387716338b5639cf6202fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gae40d830738a425fdaa77de5126137c9d" id="r_gae40d830738a425fdaa77de5126137c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae40d830738a425fdaa77de5126137c9d">fdim</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gae40d830738a425fdaa77de5126137c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab067c004a5ee6f46a9a6f7f86654154a" id="r_gab067c004a5ee6f46a9a6f7f86654154a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab067c004a5ee6f46a9a6f7f86654154a">fdimf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gab067c004a5ee6f46a9a6f7f86654154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1509070d05f6a7884ef06d44175925" id="r_ga1f1509070d05f6a7884ef06d44175925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1f1509070d05f6a7884ef06d44175925">fdim</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga1f1509070d05f6a7884ef06d44175925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107975b19f18d51fe1b0fea4fa21fd6b" id="r_ga107975b19f18d51fe1b0fea4fa21fd6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga107975b19f18d51fe1b0fea4fa21fd6b">fdim</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga107975b19f18d51fe1b0fea4fa21fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acecfd8db84e93791424bbc3d94714f" id="r_ga0acecfd8db84e93791424bbc3d94714f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0acecfd8db84e93791424bbc3d94714f">fdiml</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga0acecfd8db84e93791424bbc3d94714f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gabf9a1a2e9572dfe0caa6a574405369fe" id="r_gabf9a1a2e9572dfe0caa6a574405369fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gabf9a1a2e9572dfe0caa6a574405369fe">floor</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gabf9a1a2e9572dfe0caa6a574405369fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b269b4a8f158ef8fd4ebe3e6117fad8" id="r_ga2b269b4a8f158ef8fd4ebe3e6117fad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2b269b4a8f158ef8fd4ebe3e6117fad8">floorf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga2b269b4a8f158ef8fd4ebe3e6117fad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798ddc91a8ff660e3e5ae767103b2573" id="r_ga798ddc91a8ff660e3e5ae767103b2573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga798ddc91a8ff660e3e5ae767103b2573">floor</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga798ddc91a8ff660e3e5ae767103b2573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa478a6f2a9aabe0513ff380f64c8378" id="r_gaaa478a6f2a9aabe0513ff380f64c8378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaaa478a6f2a9aabe0513ff380f64c8378">floor</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaaa478a6f2a9aabe0513ff380f64c8378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94649517d90ede186b90638c7db492a7" id="r_ga94649517d90ede186b90638c7db492a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga94649517d90ede186b90638c7db492a7">floorl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga94649517d90ede186b90638c7db492a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d326f6fa30d2205b8ecfbb2e5b8a46" id="r_ga33d326f6fa30d2205b8ecfbb2e5b8a46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga33d326f6fa30d2205b8ecfbb2e5b8a46">floor</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga33d326f6fa30d2205b8ecfbb2e5b8a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga00bcdbb66121fef621b27d7f70316c9f" id="r_ga00bcdbb66121fef621b27d7f70316c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga00bcdbb66121fef621b27d7f70316c9f">fma</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga00bcdbb66121fef621b27d7f70316c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4663bcfb836899ed9faadca926cec52" id="r_gaf4663bcfb836899ed9faadca926cec52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf4663bcfb836899ed9faadca926cec52">fmaf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaf4663bcfb836899ed9faadca926cec52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5894e1f0898f72ee4d749bf3ebe481a" id="r_gac5894e1f0898f72ee4d749bf3ebe481a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac5894e1f0898f72ee4d749bf3ebe481a">fma</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y, <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gac5894e1f0898f72ee4d749bf3ebe481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9885e89bbef07cbda18deeb6baf7c5ba" id="r_ga9885e89bbef07cbda18deeb6baf7c5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9885e89bbef07cbda18deeb6baf7c5ba">fma</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga9885e89bbef07cbda18deeb6baf7c5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8054035883ddf10f76dddbe361976fe4" id="r_ga8054035883ddf10f76dddbe361976fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8054035883ddf10f76dddbe361976fe4">fmal</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga8054035883ddf10f76dddbe361976fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gadaa70d3059866e4b8121b7f68c8b3e98" id="r_gadaa70d3059866e4b8121b7f68c8b3e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadaa70d3059866e4b8121b7f68c8b3e98">fmax</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gadaa70d3059866e4b8121b7f68c8b3e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga283c8ca45d511fdf2bc444db6a13db6a" id="r_ga283c8ca45d511fdf2bc444db6a13db6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga283c8ca45d511fdf2bc444db6a13db6a">fmaxf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga283c8ca45d511fdf2bc444db6a13db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252d9ab2a9a452ca065f701fe2f0d5ab" id="r_ga252d9ab2a9a452ca065f701fe2f0d5ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga252d9ab2a9a452ca065f701fe2f0d5ab">fmax</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga252d9ab2a9a452ca065f701fe2f0d5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d1e573a47f6e45c034fa642143ffbf" id="r_ga53d1e573a47f6e45c034fa642143ffbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga53d1e573a47f6e45c034fa642143ffbf">fmax</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga53d1e573a47f6e45c034fa642143ffbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad3c69362f2624101b5f4c0f05ca4e3" id="r_gafad3c69362f2624101b5f4c0f05ca4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gafad3c69362f2624101b5f4c0f05ca4e3">fmaxl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gafad3c69362f2624101b5f4c0f05ca4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga69af224f0f1dcf75045a329546454539" id="r_ga69af224f0f1dcf75045a329546454539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga69af224f0f1dcf75045a329546454539">fmin</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga69af224f0f1dcf75045a329546454539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48d9860badaa088ca72788b9e1ee61e" id="r_gaf48d9860badaa088ca72788b9e1ee61e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf48d9860badaa088ca72788b9e1ee61e">fminf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaf48d9860badaa088ca72788b9e1ee61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8697722ec82db1de9d7411cbcb77989f" id="r_ga8697722ec82db1de9d7411cbcb77989f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8697722ec82db1de9d7411cbcb77989f">fmin</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga8697722ec82db1de9d7411cbcb77989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e5cd4b9b2fc1428c493acc46e9158e" id="r_ga95e5cd4b9b2fc1428c493acc46e9158e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga95e5cd4b9b2fc1428c493acc46e9158e">fmin</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga95e5cd4b9b2fc1428c493acc46e9158e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669fd2896aa32adef5d728a8413473fe" id="r_ga669fd2896aa32adef5d728a8413473fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga669fd2896aa32adef5d728a8413473fe">fminl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga669fd2896aa32adef5d728a8413473fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad31ccb95fa5e87e37eb042aef95f0dac" id="r_gad31ccb95fa5e87e37eb042aef95f0dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad31ccb95fa5e87e37eb042aef95f0dac">fmod</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gad31ccb95fa5e87e37eb042aef95f0dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703cda91c0dcce6bd41bebefcaef7cfa" id="r_ga703cda91c0dcce6bd41bebefcaef7cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga703cda91c0dcce6bd41bebefcaef7cfa">fmodf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga703cda91c0dcce6bd41bebefcaef7cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga502311c1812ecf633ad9b23c19042cf3" id="r_ga502311c1812ecf633ad9b23c19042cf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga502311c1812ecf633ad9b23c19042cf3">fmod</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga502311c1812ecf633ad9b23c19042cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9b4897566472c93109ce45ede4fe23" id="r_ga2c9b4897566472c93109ce45ede4fe23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga2c9b4897566472c93109ce45ede4fe23">fmod</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga2c9b4897566472c93109ce45ede4fe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37522e6021832ad590458f01fb85b302" id="r_ga37522e6021832ad590458f01fb85b302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga37522e6021832ad590458f01fb85b302">fmodl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga37522e6021832ad590458f01fb85b302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaef65d68eb2809fdf28f84ba4cb9ddcb0" id="r_gaef65d68eb2809fdf28f84ba4cb9ddcb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaef65d68eb2809fdf28f84ba4cb9ddcb0">hypot</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaef65d68eb2809fdf28f84ba4cb9ddcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ce9b544965e9e10ab119bcf528e9a7" id="r_ga95ce9b544965e9e10ab119bcf528e9a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga95ce9b544965e9e10ab119bcf528e9a7">hypotf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga95ce9b544965e9e10ab119bcf528e9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae25a1160334f62555b8f1147c07d855" id="r_gaae25a1160334f62555b8f1147c07d855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaae25a1160334f62555b8f1147c07d855">hypot</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaae25a1160334f62555b8f1147c07d855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96f76d5fad7b673c350d83944f6d8043" id="r_ga96f76d5fad7b673c350d83944f6d8043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga96f76d5fad7b673c350d83944f6d8043">hypot</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga96f76d5fad7b673c350d83944f6d8043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae219bdaec04a35376a4121abbdd6e403" id="r_gae219bdaec04a35376a4121abbdd6e403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae219bdaec04a35376a4121abbdd6e403">hypotl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gae219bdaec04a35376a4121abbdd6e403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebac6f56dad6bbb43d32fd02b797082a" id="r_gaebac6f56dad6bbb43d32fd02b797082a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaebac6f56dad6bbb43d32fd02b797082a">hypot</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">float</a> y, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaebac6f56dad6bbb43d32fd02b797082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb8298ed1711c3c88583c7021de8d09" id="r_ga4fb8298ed1711c3c88583c7021de8d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4fb8298ed1711c3c88583c7021de8d09">hypot</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">double</a> y, <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga4fb8298ed1711c3c88583c7021de8d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46b41382252069a234a49a3f86f60f67" id="r_ga46b41382252069a234a49a3f86f60f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga46b41382252069a234a49a3f86f60f67">hypot</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">x</a>, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> y, <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">z</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga46b41382252069a234a49a3f86f60f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga5a75b64172bc4772ae32459754e63768" id="r_ga5a75b64172bc4772ae32459754e63768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5a75b64172bc4772ae32459754e63768">log</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga5a75b64172bc4772ae32459754e63768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14541b9824cd6820be94879878d29173" id="r_ga14541b9824cd6820be94879878d29173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga14541b9824cd6820be94879878d29173">logf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga14541b9824cd6820be94879878d29173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661e29b318888c5dab142306385daa27" id="r_ga661e29b318888c5dab142306385daa27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga661e29b318888c5dab142306385daa27">log</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga661e29b318888c5dab142306385daa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758b1f8836537fd120e6a43ec143657e" id="r_ga758b1f8836537fd120e6a43ec143657e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga758b1f8836537fd120e6a43ec143657e">log</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga758b1f8836537fd120e6a43ec143657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef3d6de6a38a1374a9f3e48a11873f2" id="r_gaeef3d6de6a38a1374a9f3e48a11873f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaeef3d6de6a38a1374a9f3e48a11873f2">logl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaeef3d6de6a38a1374a9f3e48a11873f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fa1d8a913892ecec7577e302bc74a4" id="r_ga94fa1d8a913892ecec7577e302bc74a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga94fa1d8a913892ecec7577e302bc74a4">log</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga94fa1d8a913892ecec7577e302bc74a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga7e121a21d96d862846a8dd6a7d146fa8" id="r_ga7e121a21d96d862846a8dd6a7d146fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7e121a21d96d862846a8dd6a7d146fa8">log10</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga7e121a21d96d862846a8dd6a7d146fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b17bede4f9e5906deb56ec4f845c41" id="r_ga60b17bede4f9e5906deb56ec4f845c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga60b17bede4f9e5906deb56ec4f845c41">log10f</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga60b17bede4f9e5906deb56ec4f845c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad84527d44be6141bc0351fbf847e51" id="r_ga4ad84527d44be6141bc0351fbf847e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4ad84527d44be6141bc0351fbf847e51">log10</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga4ad84527d44be6141bc0351fbf847e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa865ca3dcb2351e2a3fb02c7b8171b9b" id="r_gaa865ca3dcb2351e2a3fb02c7b8171b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa865ca3dcb2351e2a3fb02c7b8171b9b">log10</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaa865ca3dcb2351e2a3fb02c7b8171b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7186dd4004ef53b28e2872d0e5f30ac6" id="r_ga7186dd4004ef53b28e2872d0e5f30ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga7186dd4004ef53b28e2872d0e5f30ac6">log10l</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga7186dd4004ef53b28e2872d0e5f30ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645f04d6246441c35ec0729cb0903fda" id="r_ga645f04d6246441c35ec0729cb0903fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga645f04d6246441c35ec0729cb0903fda">log10</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga645f04d6246441c35ec0729cb0903fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gae0dc2a04f24b015efbc1d749d8af4c0e" id="r_gae0dc2a04f24b015efbc1d749d8af4c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae0dc2a04f24b015efbc1d749d8af4c0e">log1p</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gae0dc2a04f24b015efbc1d749d8af4c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ceec6b47194b6218670a6a38324516b" id="r_ga0ceec6b47194b6218670a6a38324516b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga0ceec6b47194b6218670a6a38324516b">log1pf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga0ceec6b47194b6218670a6a38324516b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12f8274c143cf8a3143eb4d918ae3b2" id="r_gad12f8274c143cf8a3143eb4d918ae3b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad12f8274c143cf8a3143eb4d918ae3b2">log1p</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gad12f8274c143cf8a3143eb4d918ae3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07475d41b22316960815b3d50f148156" id="r_ga07475d41b22316960815b3d50f148156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga07475d41b22316960815b3d50f148156">log1p</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga07475d41b22316960815b3d50f148156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac82247b08fd64f14d6120ddb97dd44f7" id="r_gac82247b08fd64f14d6120ddb97dd44f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac82247b08fd64f14d6120ddb97dd44f7">log1pl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">v</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gac82247b08fd64f14d6120ddb97dd44f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3560d35ebed3783d3c13e31a1c58b9c1" id="r_ga3560d35ebed3783d3c13e31a1c58b9c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3560d35ebed3783d3c13e31a1c58b9c1">log1p</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga3560d35ebed3783d3c13e31a1c58b9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga9191968342c66327e279e2007d5bb7ce" id="r_ga9191968342c66327e279e2007d5bb7ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9191968342c66327e279e2007d5bb7ce">log2</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga9191968342c66327e279e2007d5bb7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9a81ee78be6ea9810f1144c3554c84" id="r_gaae9a81ee78be6ea9810f1144c3554c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaae9a81ee78be6ea9810f1144c3554c84">log2f</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaae9a81ee78be6ea9810f1144c3554c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df7f7d0d1fefde1fdb3cbde13b5fed0" id="r_ga5df7f7d0d1fefde1fdb3cbde13b5fed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga5df7f7d0d1fefde1fdb3cbde13b5fed0">log2</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga5df7f7d0d1fefde1fdb3cbde13b5fed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc012d679f6f798b5770a4b2d65f443c" id="r_gafc012d679f6f798b5770a4b2d65f443c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gafc012d679f6f798b5770a4b2d65f443c">log2</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gafc012d679f6f798b5770a4b2d65f443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23030fe110f0a79e9a390de4c93f99a3" id="r_ga23030fe110f0a79e9a390de4c93f99a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga23030fe110f0a79e9a390de4c93f99a3">log2l</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga23030fe110f0a79e9a390de4c93f99a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373d95b511f9ddc4d991f652eeac139f" id="r_ga373d95b511f9ddc4d991f652eeac139f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga373d95b511f9ddc4d991f652eeac139f">log2</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga373d95b511f9ddc4d991f652eeac139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga92b23f23746d65434dd57cbf03dde471" id="r_ga92b23f23746d65434dd57cbf03dde471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga92b23f23746d65434dd57cbf03dde471">nanf</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga92b23f23746d65434dd57cbf03dde471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b0eae0f0faa4e81c4fdbb7ecb99f64" id="r_ga08b0eae0f0faa4e81c4fdbb7ecb99f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga08b0eae0f0faa4e81c4fdbb7ecb99f64">nan</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga08b0eae0f0faa4e81c4fdbb7ecb99f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ef6ce5627884455b58fbf76bd8c8ea" id="r_gab2ef6ce5627884455b58fbf76bd8c8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab2ef6ce5627884455b58fbf76bd8c8ea">nanl</a> (<a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *<a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gab2ef6ce5627884455b58fbf76bd8c8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaaa3ff973e51c840722b01eca0e1af274" id="r_gaaa3ff973e51c840722b01eca0e1af274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaaa3ff973e51c840722b01eca0e1af274">nextafter</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">from</a>, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaaa3ff973e51c840722b01eca0e1af274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dcbc27b4908c97a6afd89f89b9cd525" id="r_ga3dcbc27b4908c97a6afd89f89b9cd525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3dcbc27b4908c97a6afd89f89b9cd525">nextafterf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">from</a>, <a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="structetl_1_1bitset.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga3dcbc27b4908c97a6afd89f89b9cd525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3520d2487f82a9efbef4e6df25e28905" id="r_ga3520d2487f82a9efbef4e6df25e28905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3520d2487f82a9efbef4e6df25e28905">nextafter</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">from</a>, <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="structetl_1_1bitset.html">to</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga3520d2487f82a9efbef4e6df25e28905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga8ece6b0eeb98b1650638dbbbb09cda23" id="r_ga8ece6b0eeb98b1650638dbbbb09cda23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8ece6b0eeb98b1650638dbbbb09cda23">round</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga8ece6b0eeb98b1650638dbbbb09cda23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f67bbe153f9daa0cbd56587131bfd3" id="r_ga25f67bbe153f9daa0cbd56587131bfd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga25f67bbe153f9daa0cbd56587131bfd3">roundf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga25f67bbe153f9daa0cbd56587131bfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20c80803dd9917b164ebef227db3ed1" id="r_gad20c80803dd9917b164ebef227db3ed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad20c80803dd9917b164ebef227db3ed1">round</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gad20c80803dd9917b164ebef227db3ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cc8394cdaabbc0790662af74f6574a3" id="r_ga3cc8394cdaabbc0790662af74f6574a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga3cc8394cdaabbc0790662af74f6574a3">round</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga3cc8394cdaabbc0790662af74f6574a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94747d1de39c6586935e11628963eee" id="r_gae94747d1de39c6586935e11628963eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gae94747d1de39c6586935e11628963eee">roundl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gae94747d1de39c6586935e11628963eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga594cdef05f79d80bbcb2c5f4b599b52e" id="r_ga594cdef05f79d80bbcb2c5f4b599b52e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga594cdef05f79d80bbcb2c5f4b599b52e">round</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga594cdef05f79d80bbcb2c5f4b599b52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad2d50adae837fe590bbf6d0158025ca0" id="r_gad2d50adae837fe590bbf6d0158025ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gad2d50adae837fe590bbf6d0158025ca0">sin</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gad2d50adae837fe590bbf6d0158025ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f8660c3d6563b03fa7980d0424f4b4" id="r_gab5f8660c3d6563b03fa7980d0424f4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab5f8660c3d6563b03fa7980d0424f4b4">sinf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gab5f8660c3d6563b03fa7980d0424f4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadad72b5449e49d82c0d083ac282382fc" id="r_gadad72b5449e49d82c0d083ac282382fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gadad72b5449e49d82c0d083ac282382fc">sin</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gadad72b5449e49d82c0d083ac282382fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c75026dce8dce819a6f9a0337ed6f13" id="r_ga1c75026dce8dce819a6f9a0337ed6f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga1c75026dce8dce819a6f9a0337ed6f13">sin</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga1c75026dce8dce819a6f9a0337ed6f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36289ec7bc0676bc8e1d150d3414462d" id="r_ga36289ec7bc0676bc8e1d150d3414462d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga36289ec7bc0676bc8e1d150d3414462d">sinl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga36289ec7bc0676bc8e1d150d3414462d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b88786d3b8b81deb6649914819a5d3" id="r_gac6b88786d3b8b81deb6649914819a5d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac6b88786d3b8b81deb6649914819a5d3">sin</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gac6b88786d3b8b81deb6649914819a5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga9e419bd6dfddb5077876e81fe4c9478e" id="r_ga9e419bd6dfddb5077876e81fe4c9478e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga9e419bd6dfddb5077876e81fe4c9478e">tan</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga9e419bd6dfddb5077876e81fe4c9478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95d5f88be021c2e5604f3c73a346c178" id="r_ga95d5f88be021c2e5604f3c73a346c178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga95d5f88be021c2e5604f3c73a346c178">tanf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga95d5f88be021c2e5604f3c73a346c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22851c99b004fa4b43659e41aa5b4a8" id="r_gab22851c99b004fa4b43659e41aa5b4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab22851c99b004fa4b43659e41aa5b4a8">tan</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gab22851c99b004fa4b43659e41aa5b4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a5e0584fe383ae26dc342fd870bb1b" id="r_gaa3a5e0584fe383ae26dc342fd870bb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa3a5e0584fe383ae26dc342fd870bb1b">tan</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaa3a5e0584fe383ae26dc342fd870bb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7981b2761ed309a12d574ea7b42543" id="r_gaae7981b2761ed309a12d574ea7b42543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaae7981b2761ed309a12d574ea7b42543">tanl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaae7981b2761ed309a12d574ea7b42543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8ba12a28d74da2cbb46cc2576cdf80" id="r_gaba8ba12a28d74da2cbb46cc2576cdf80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaba8ba12a28d74da2cbb46cc2576cdf80">tan</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaba8ba12a28d74da2cbb46cc2576cdf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga4bf343cf1730a0ed0b40fa6c929b0dab" id="r_ga4bf343cf1730a0ed0b40fa6c929b0dab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4bf343cf1730a0ed0b40fa6c929b0dab">tanh</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga4bf343cf1730a0ed0b40fa6c929b0dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d46e807418d26c2a7759cbfab02b72a" id="r_ga6d46e807418d26c2a7759cbfab02b72a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6d46e807418d26c2a7759cbfab02b72a">tanhf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga6d46e807418d26c2a7759cbfab02b72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga790f3ebf241e522dbb8f9ddb5ecf8301" id="r_ga790f3ebf241e522dbb8f9ddb5ecf8301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga790f3ebf241e522dbb8f9ddb5ecf8301">tanh</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga790f3ebf241e522dbb8f9ddb5ecf8301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32d2e0422188b651005ac234beb54d2" id="r_gab32d2e0422188b651005ac234beb54d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gab32d2e0422188b651005ac234beb54d2">tanh</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gab32d2e0422188b651005ac234beb54d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae21f7a8c9356084f0ae2632962da532" id="r_gaae21f7a8c9356084f0ae2632962da532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaae21f7a8c9356084f0ae2632962da532">tanhl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaae21f7a8c9356084f0ae2632962da532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95228f8d5f8e118e5c16c52ecb7067ed" id="r_ga95228f8d5f8e118e5c16c52ecb7067ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga95228f8d5f8e118e5c16c52ecb7067ed">tanh</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga95228f8d5f8e118e5c16c52ecb7067ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga075d32d3b4294027e82274f2d892df7c" id="r_ga075d32d3b4294027e82274f2d892df7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga075d32d3b4294027e82274f2d892df7c">tgamma</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga075d32d3b4294027e82274f2d892df7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67cc458d480c315807346ae741e909d9" id="r_ga67cc458d480c315807346ae741e909d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga67cc458d480c315807346ae741e909d9">tgammaf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga67cc458d480c315807346ae741e909d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c78080019a4d11ff8f688d6aaf59dd" id="r_ga82c78080019a4d11ff8f688d6aaf59dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga82c78080019a4d11ff8f688d6aaf59dd">tgamma</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga82c78080019a4d11ff8f688d6aaf59dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b4a8a777f41c9b6b469ad70d25c031" id="r_ga43b4a8a777f41c9b6b469ad70d25c031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga43b4a8a777f41c9b6b469ad70d25c031">tgamma</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga43b4a8a777f41c9b6b469ad70d25c031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeedb170320e69f563ba810bcbee6b2e0" id="r_gaeedb170320e69f563ba810bcbee6b2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaeedb170320e69f563ba810bcbee6b2e0">tgammal</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaeedb170320e69f563ba810bcbee6b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac714e6fcdf9173fac583364fea80e8de" id="r_gac714e6fcdf9173fac583364fea80e8de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gac714e6fcdf9173fac583364fea80e8de">tgamma</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gac714e6fcdf9173fac583364fea80e8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga6e537c9ad8ab972ba8d71f3b19b45d52" id="r_ga6e537c9ad8ab972ba8d71f3b19b45d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga6e537c9ad8ab972ba8d71f3b19b45d52">trunc</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:ga6e537c9ad8ab972ba8d71f3b19b45d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a5c20de653a2cb02c7a45828b64daf" id="r_gaa5a5c20de653a2cb02c7a45828b64daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaa5a5c20de653a2cb02c7a45828b64daf">truncf</a> (<a class="el" href="structetl_1_1bitset.html">float</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">float</a></td></tr>
<tr class="separator:gaa5a5c20de653a2cb02c7a45828b64daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4305af59a0861ebd6f9c8e4d30309281" id="r_ga4305af59a0861ebd6f9c8e4d30309281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga4305af59a0861ebd6f9c8e4d30309281">trunc</a> (<a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga4305af59a0861ebd6f9c8e4d30309281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29b9ba02b260d27b8a8c440a167afa6" id="r_gaf29b9ba02b260d27b8a8c440a167afa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf29b9ba02b260d27b8a8c440a167afa6">trunc</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaf29b9ba02b260d27b8a8c440a167afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30781fa4c32627e7c6be2ab566a0b67" id="r_gaf30781fa4c32627e7c6be2ab566a0b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#gaf30781fa4c32627e7c6be2ab566a0b67">truncl</a> (<a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:gaf30781fa4c32627e7c6be2ab566a0b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a9e45e6d873463fe70b02b8812e6eb4" id="r_ga8a9e45e6d873463fe70b02b8812e6eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cmath.html#ga8a9e45e6d873463fe70b02b8812e6eb4">trunc</a> (integral <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="group__complex.html#ga0c18e9f715e3983b7a71347ce6e0e2c1">arg</a>) noexcept -&gt; <a class="el" href="structetl_1_1bitset.html">double</a></td></tr>
<tr class="separator:ga8a9e45e6d873463fe70b02b8812e6eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae7fde4c1b709be147fc5d8f4efc0c605" id="r_ae7fde4c1b709be147fc5d8f4efc0c605"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae7fde4c1b709be147fc5d8f4efc0c605"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7fde4c1b709be147fc5d8f4efc0c605">alignment_of_v</a> = <a class="el" href="structetl_1_1alignment__of.html">alignment_of</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ae7fde4c1b709be147fc5d8f4efc0c605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1903f5208bf0e496f112e85dd1915de8" id="r_a1903f5208bf0e496f112e85dd1915de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1903f5208bf0e496f112e85dd1915de8">allocator_arg</a> {}</td></tr>
<tr class="memdesc:a1903f5208bf0e496f112e85dd1915de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator_arg is a constant of type <a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects.  <br /></td></tr>
<tr class="separator:a1903f5208bf0e496f112e85dd1915de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b52772010dec87f8867320a8b03dfc" id="r_a92b52772010dec87f8867320a8b03dfc"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a92b52772010dec87f8867320a8b03dfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92b52772010dec87f8867320a8b03dfc">always_false</a> = <a class="el" href="structetl_1_1bitset.html">false</a></td></tr>
<tr class="separator:a92b52772010dec87f8867320a8b03dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb794742f9815f88d6c2291181dc2501" id="r_abb794742f9815f88d6c2291181dc2501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb794742f9815f88d6c2291181dc2501">binary</a> = <a class="el" href="structetl_1_1binary__t.html">binary_t</a>{}</td></tr>
<tr class="separator:abb794742f9815f88d6c2291181dc2501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88c83d30ae1d2a54dd8438da2038aab" id="r_ae88c83d30ae1d2a54dd8438da2038aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="attributes_8hpp.html#a6cf990edeb7f9f6f1b5928471cef5e56">TETL_MAY_ALIAS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">byte</a></td></tr>
<tr class="memdesc:ae88c83d30ae1d2a54dd8438da2038aab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a> is a distinct type that implements the concept of byte as specified in the C++ language definition.  <br /></td></tr>
<tr class="separator:ae88c83d30ae1d2a54dd8438da2038aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5672914b2f1f9c1c4c50ded53a8db2e3" id="r_a5672914b2f1f9c1c4c50ded53a8db2e3"><td class="memTemplParams" colspan="2">template&lt;typename... B&gt; </td></tr>
<tr class="memitem:a5672914b2f1f9c1c4c50ded53a8db2e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5672914b2f1f9c1c4c50ded53a8db2e3">conjunction_v</a> = <a class="el" href="structetl_1_1conjunction.html">conjunction</a>&lt;B...&gt;::value</td></tr>
<tr class="separator:a5672914b2f1f9c1c4c50ded53a8db2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9683edd538ff0cc668fb5a823604223" id="r_ac9683edd538ff0cc668fb5a823604223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9683edd538ff0cc668fb5a823604223">current_implementation</a> = <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1">implementation::freestanding</a></td></tr>
<tr class="separator:ac9683edd538ff0cc668fb5a823604223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a32ab1ee4dc1bf7a3e86e713a4d6cbf" id="r_a6a32ab1ee4dc1bf7a3e86e713a4d6cbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a32ab1ee4dc1bf7a3e86e713a4d6cbf">current_standard</a> = <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff">language_standard::cpp_26</a></td></tr>
<tr class="memdesc:a6a32ab1ee4dc1bf7a3e86e713a4d6cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently configured C++ standard.  <br /></td></tr>
<tr class="separator:a6a32ab1ee4dc1bf7a3e86e713a4d6cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49e3304c1cd20a376c9bd1758dd13bd" id="r_ac49e3304c1cd20a376c9bd1758dd13bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac49e3304c1cd20a376c9bd1758dd13bd">destroying_delete</a> = <a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a>{}</td></tr>
<tr class="memdesc:ac49e3304c1cd20a376c9bd1758dd13bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to identify the destroying delete form of operator delete.  <br /></td></tr>
<tr class="separator:ac49e3304c1cd20a376c9bd1758dd13bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3abcd15bf9ea4a0629b7e03498e1e1" id="r_abb3abcd15bf9ea4a0629b7e03498e1e1"><td class="memTemplParams" colspan="2">template&lt;typename... B&gt; </td></tr>
<tr class="memitem:abb3abcd15bf9ea4a0629b7e03498e1e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb3abcd15bf9ea4a0629b7e03498e1e1">disjunction_v</a> = <a class="el" href="structetl_1_1disjunction.html">disjunction</a>&lt;B...&gt;::value</td></tr>
<tr class="separator:abb3abcd15bf9ea4a0629b7e03498e1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e7be40fea564f0c1fe3d11229ef0f8" id="r_ga22e7be40fea564f0c1fe3d11229ef0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__span.html#ga22e7be40fea564f0c1fe3d11229ef0f8">dynamic_extent</a> = <a class="el" href="structetl_1_1numeric__limits.html">numeric_limits</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&gt;<a class="el" href="group__algorithm.html#ga5f3eca1793f7f38aeb756464984eb194">::max</a>()</td></tr>
<tr class="memdesc:ga22e7be40fea564f0c1fe3d11229ef0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__span.html#ga22e7be40fea564f0c1fe3d11229ef0f8" title="etl::dynamic_extent is a constant of type etl::size_t that is used to differentiate etl::span of stat...">etl::dynamic_extent</a> is a constant of type <a class="el" href="#aee50235c04ef643cb7502785393220fe" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> that is used to differentiate <a class="el" href="structetl_1_1span.html" title="A non-owning view over a contiguous sequence of objects.">etl::span</a> of static and dynamic extent.  <br /></td></tr>
<tr class="separator:ga22e7be40fea564f0c1fe3d11229ef0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06332dc22e85765f2c195c703cc49068" id="r_a06332dc22e85765f2c195c703cc49068"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">unsigned</a> N = 0&gt; </td></tr>
<tr class="memitem:a06332dc22e85765f2c195c703cc49068"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06332dc22e85765f2c195c703cc49068">extent_v</a> = <a class="el" href="structetl_1_1bitset.html">static_cast</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt;(<a class="el" href="structetl_1_1extent.html">extent</a>&lt;T, <a class="el" href="structetl_1_1bitset.html">N</a>&gt;::value)</td></tr>
<tr class="separator:a06332dc22e85765f2c195c703cc49068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968338cd15fb1036406d2b3c8cb5b591" id="r_a968338cd15fb1036406d2b3c8cb5b591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a968338cd15fb1036406d2b3c8cb5b591">hardware_constructive_interference_size</a> = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td></tr>
<tr class="memdesc:a968338cd15fb1036406d2b3c8cb5b591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum offset between two objects to avoid false sharing. Guaranteed to be at least alignof(max_align_t).  <br /></td></tr>
<tr class="separator:a968338cd15fb1036406d2b3c8cb5b591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9464e19a95c1baba9554e5ae2c2af6" id="r_acf9464e19a95c1baba9554e5ae2c2af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9464e19a95c1baba9554e5ae2c2af6">hardware_destructive_interference_size</a> = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td></tr>
<tr class="memdesc:acf9464e19a95c1baba9554e5ae2c2af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least alignof(max_align_t).  <br /></td></tr>
<tr class="separator:acf9464e19a95c1baba9554e5ae2c2af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a77036b20d94554de76a0879573e1" id="r_a4c5a77036b20d94554de76a0879573e1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4c5a77036b20d94554de76a0879573e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c5a77036b20d94554de76a0879573e1">has_unique_object_representations_v</a> = <a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4c5a77036b20d94554de76a0879573e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5895291aecd11c1e854ea1cdaac5d7c9" id="r_a5895291aecd11c1e854ea1cdaac5d7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">struct</a> etl::ignore&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5895291aecd11c1e854ea1cdaac5d7c9">ignore</a></td></tr>
<tr class="separator:a5895291aecd11c1e854ea1cdaac5d7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d83619b037b662e5e0443f9d22fe3a" id="r_a36d83619b037b662e5e0443f9d22fe3a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I&gt; </td></tr>
<tr class="memitem:a36d83619b037b662e5e0443f9d22fe3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a36d83619b037b662e5e0443f9d22fe3a">index_v</a> = <a class="el" href="#a0fc29a848c78949599ea12f9b9827fd3">index_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>&gt;{}</td></tr>
<tr class="separator:a36d83619b037b662e5e0443f9d22fe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10afef86eafa806bb7142657cfa37f79" id="r_a10afef86eafa806bb7142657cfa37f79"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a10afef86eafa806bb7142657cfa37f79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10afef86eafa806bb7142657cfa37f79">is_abstract_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_abstract</a>(T)</td></tr>
<tr class="separator:a10afef86eafa806bb7142657cfa37f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e64aa57f60e45754ac20ba126bbe3" id="r_adb0e64aa57f60e45754ac20ba126bbe3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adb0e64aa57f60e45754ac20ba126bbe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb0e64aa57f60e45754ac20ba126bbe3">is_aggregate_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_aggregate</a>(<a class="el" href="#a57d58de8ee9130049557265efc11802c">remove_cv_t</a>&lt;T&gt;)</td></tr>
<tr class="separator:adb0e64aa57f60e45754ac20ba126bbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2224be65b8fb8794372d049a1d37d9" id="r_abf2224be65b8fb8794372d049a1d37d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abf2224be65b8fb8794372d049a1d37d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf2224be65b8fb8794372d049a1d37d9">is_arithmetic_v</a> = <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt;T&gt; <a class="el" href="structetl_1_1bitset.html">or</a> <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a>&lt;T&gt;</td></tr>
<tr class="separator:abf2224be65b8fb8794372d049a1d37d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0e44222b6a1dc103286f3c5225ad93" id="r_a8b0e44222b6a1dc103286f3c5225ad93"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8b0e44222b6a1dc103286f3c5225ad93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b0e44222b6a1dc103286f3c5225ad93">is_array_v</a> = <a class="el" href="structetl_1_1is__array.html">is_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8b0e44222b6a1dc103286f3c5225ad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762a8e8750c01c04403086076b7bab1e" id="r_a762a8e8750c01c04403086076b7bab1e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a762a8e8750c01c04403086076b7bab1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a762a8e8750c01c04403086076b7bab1e">is_assignable_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_assignable</a>(T, U)</td></tr>
<tr class="separator:a762a8e8750c01c04403086076b7bab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096bf5b121d9f427c8027f2949e8198e" id="r_a096bf5b121d9f427c8027f2949e8198e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Base</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Derived</a> &gt; </td></tr>
<tr class="memitem:a096bf5b121d9f427c8027f2949e8198e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a096bf5b121d9f427c8027f2949e8198e">is_base_of_v</a> = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;<a class="el" href="structetl_1_1bitset.html">Base</a>, <a class="el" href="structetl_1_1bitset.html">Derived</a>&gt;::value</td></tr>
<tr class="separator:a096bf5b121d9f427c8027f2949e8198e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cb779fe6050798f469e14a06f4412e" id="r_ad6cb779fe6050798f469e14a06f4412e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad6cb779fe6050798f469e14a06f4412e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6cb779fe6050798f469e14a06f4412e">is_bitmask_type_v</a> = <a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad6cb779fe6050798f469e14a06f4412e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a699f9a94f5d0c71c5e85e84f7baeb4" id="r_a7a699f9a94f5d0c71c5e85e84f7baeb4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7a699f9a94f5d0c71c5e85e84f7baeb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a699f9a94f5d0c71c5e85e84f7baeb4">is_bounded_array_v</a> = <a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a7a699f9a94f5d0c71c5e85e84f7baeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca38abc104326427a46bccfd27cbfe28" id="r_aca38abc104326427a46bccfd27cbfe28"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aca38abc104326427a46bccfd27cbfe28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca38abc104326427a46bccfd27cbfe28">is_class_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_class</a>(T)</td></tr>
<tr class="separator:aca38abc104326427a46bccfd27cbfe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2d62ca306fe828c5b72d7ebd4bf357" id="r_aad2d62ca306fe828c5b72d7ebd4bf357"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aad2d62ca306fe828c5b72d7ebd4bf357"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad2d62ca306fe828c5b72d7ebd4bf357">is_compound_v</a> = <a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#aec01da22051322819e36fdfa6c5514a5">is_fundamental_v</a>&lt;T&gt;</td></tr>
<tr class="separator:aad2d62ca306fe828c5b72d7ebd4bf357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf567b7866a96e4005d64743e0859b0" id="r_a0bf567b7866a96e4005d64743e0859b0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0bf567b7866a96e4005d64743e0859b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bf567b7866a96e4005d64743e0859b0">is_const_v</a> = <a class="el" href="structetl_1_1is__const.html">is_const</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0bf567b7866a96e4005d64743e0859b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123009e89543c37bab698abc5f4221a0" id="r_a123009e89543c37bab698abc5f4221a0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a123009e89543c37bab698abc5f4221a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a123009e89543c37bab698abc5f4221a0">is_constructible_v</a> = <a class="el" href="#aef5e3d94685880c2a0635ecd8f07b27f">is_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a123009e89543c37bab698abc5f4221a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5e75c4b12aa7982c5a97a14510ab35" id="r_adf5e75c4b12aa7982c5a97a14510ab35"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">From</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">To</a> &gt; </td></tr>
<tr class="memitem:adf5e75c4b12aa7982c5a97a14510ab35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">is_convertible_v</a> = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;<a class="el" href="structetl_1_1bitset.html">From</a>, <a class="el" href="structetl_1_1bitset.html">To</a>&gt;::value</td></tr>
<tr class="separator:adf5e75c4b12aa7982c5a97a14510ab35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8a0fd8e07b2a2b0d62816c2958722a" id="r_afe8a0fd8e07b2a2b0d62816c2958722a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afe8a0fd8e07b2a2b0d62816c2958722a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe8a0fd8e07b2a2b0d62816c2958722a">is_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afe8a0fd8e07b2a2b0d62816c2958722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f5da2852be4424089f4235ef44dec2" id="r_a03f5da2852be4424089f4235ef44dec2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a03f5da2852be4424089f4235ef44dec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03f5da2852be4424089f4235ef44dec2">is_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a03f5da2852be4424089f4235ef44dec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1a93c5d7a09590573ceccfb239a590" id="r_a5d1a93c5d7a09590573ceccfb239a590"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5d1a93c5d7a09590573ceccfb239a590"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d1a93c5d7a09590573ceccfb239a590">is_default_constructible_v</a> = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5d1a93c5d7a09590573ceccfb239a590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b3cd3fa2118be96d3b81105df490f8" id="r_ad9b3cd3fa2118be96d3b81105df490f8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad9b3cd3fa2118be96d3b81105df490f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9b3cd3fa2118be96d3b81105df490f8">is_destructible_v</a> = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad9b3cd3fa2118be96d3b81105df490f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd4405b77f18a1a21a5b886c3e335d" id="r_a91bd4405b77f18a1a21a5b886c3e335d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a91bd4405b77f18a1a21a5b886c3e335d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91bd4405b77f18a1a21a5b886c3e335d">is_empty_v</a> = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a91bd4405b77f18a1a21a5b886c3e335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b43ce4d692cabf9e9e569bc813f910e" id="r_a4b43ce4d692cabf9e9e569bc813f910e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4b43ce4d692cabf9e9e569bc813f910e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b43ce4d692cabf9e9e569bc813f910e">is_enum_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_enum</a>(T)</td></tr>
<tr class="separator:a4b43ce4d692cabf9e9e569bc813f910e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c97574ef59ab15ea9cff1856487d66" id="r_a98c97574ef59ab15ea9cff1856487d66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a98c97574ef59ab15ea9cff1856487d66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a98c97574ef59ab15ea9cff1856487d66">is_final_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_final</a>(T)</td></tr>
<tr class="separator:a98c97574ef59ab15ea9cff1856487d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a70da46bf8635132fd3757deb2fff94" id="r_a8a70da46bf8635132fd3757deb2fff94"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8a70da46bf8635132fd3757deb2fff94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a> = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8a70da46bf8635132fd3757deb2fff94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc77cc5069dfe2c648737671e340d9" id="r_abffc77cc5069dfe2c648737671e340d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abffc77cc5069dfe2c648737671e340d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abffc77cc5069dfe2c648737671e340d9">is_function_v</a> = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:abffc77cc5069dfe2c648737671e340d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a function type. Types like <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false.  <br /></td></tr>
<tr class="separator:abffc77cc5069dfe2c648737671e340d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec01da22051322819e36fdfa6c5514a5" id="r_aec01da22051322819e36fdfa6c5514a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aec01da22051322819e36fdfa6c5514a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec01da22051322819e36fdfa6c5514a5">is_fundamental_v</a> = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aec01da22051322819e36fdfa6c5514a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8014fcd9664b5608f77c514246ceafa8" id="r_a8014fcd9664b5608f77c514246ceafa8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8014fcd9664b5608f77c514246ceafa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8014fcd9664b5608f77c514246ceafa8">is_implicit_default_constructible_v</a> = <a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8014fcd9664b5608f77c514246ceafa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396e4b8c756441b942c1619de108e56a" id="r_a396e4b8c756441b942c1619de108e56a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a396e4b8c756441b942c1619de108e56a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a></td></tr>
<tr class="separator:a396e4b8c756441b942c1619de108e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bb140a0b590bb8a6eadea52d880d17" id="r_a79bb140a0b590bb8a6eadea52d880d17"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Fn</a> , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a79bb140a0b590bb8a6eadea52d880d17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79bb140a0b590bb8a6eadea52d880d17">is_invocable_r_v</a> = <a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a>&lt;<a class="el" href="structetl_1_1bitset.html">R</a>, <a class="el" href="structetl_1_1bitset.html">Fn</a>, ArgTypes...&gt;::value</td></tr>
<tr class="separator:a79bb140a0b590bb8a6eadea52d880d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65073ba479a098a622312ecaaa89fa64" id="r_a65073ba479a098a622312ecaaa89fa64"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Fn</a> , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a65073ba479a098a622312ecaaa89fa64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65073ba479a098a622312ecaaa89fa64">is_invocable_v</a> = <a class="el" href="structetl_1_1is__invocable.html">is_invocable</a>&lt;<a class="el" href="structetl_1_1bitset.html">Fn</a>, ArgTypes...&gt;::value</td></tr>
<tr class="separator:a65073ba479a098a622312ecaaa89fa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3172a26a55cf95dbe3c85e6611ebc0" id="r_a0a3172a26a55cf95dbe3c85e6611ebc0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0a3172a26a55cf95dbe3c85e6611ebc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a3172a26a55cf95dbe3c85e6611ebc0">is_lvalue_reference_v</a> = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0a3172a26a55cf95dbe3c85e6611ebc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241c086fc3e628de919419dd7772e345" id="r_a241c086fc3e628de919419dd7772e345"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a241c086fc3e628de919419dd7772e345"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a241c086fc3e628de919419dd7772e345">is_member_function_pointer_v</a> = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a241c086fc3e628de919419dd7772e345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868fe6017d6496b38fe1f2a58a879f14" id="r_a868fe6017d6496b38fe1f2a58a879f14"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a868fe6017d6496b38fe1f2a58a879f14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a868fe6017d6496b38fe1f2a58a879f14">is_member_object_pointer_v</a> = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a868fe6017d6496b38fe1f2a58a879f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f351ba579310d9228dc77b84bdf10b6" id="r_a8f351ba579310d9228dc77b84bdf10b6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8f351ba579310d9228dc77b84bdf10b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f351ba579310d9228dc77b84bdf10b6">is_member_pointer_v</a> = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8f351ba579310d9228dc77b84bdf10b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf52ca54b0d508bfc6b9bbe916faf18" id="r_afbf52ca54b0d508bfc6b9bbe916faf18"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:afbf52ca54b0d508bfc6b9bbe916faf18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">is_move_assignable_v</a> = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afbf52ca54b0d508bfc6b9bbe916faf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5181d927278f40a6a97e90944d673c0a" id="r_a5181d927278f40a6a97e90944d673c0a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5181d927278f40a6a97e90944d673c0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5181d927278f40a6a97e90944d673c0a">is_move_constructible_v</a> = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5181d927278f40a6a97e90944d673c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c249b3afd84019ec11170a1e06d267" id="r_ac0c249b3afd84019ec11170a1e06d267"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ac0c249b3afd84019ec11170a1e06d267"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0c249b3afd84019ec11170a1e06d267">is_nothrow_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:ac0c249b3afd84019ec11170a1e06d267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00c953e4e3f962b130f431bc25d6101" id="r_ac00c953e4e3f962b130f431bc25d6101"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:ac00c953e4e3f962b130f431bc25d6101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac00c953e4e3f962b130f431bc25d6101">is_nothrow_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:ac00c953e4e3f962b130f431bc25d6101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70f6258c3e925eeb2d27b652374660d" id="r_af70f6258c3e925eeb2d27b652374660d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">From</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">To</a> &gt; </td></tr>
<tr class="memitem:af70f6258c3e925eeb2d27b652374660d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af70f6258c3e925eeb2d27b652374660d">is_nothrow_convertible_v</a> = <a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a>&lt;<a class="el" href="structetl_1_1bitset.html">From</a>, <a class="el" href="structetl_1_1bitset.html">To</a>&gt;::value</td></tr>
<tr class="separator:af70f6258c3e925eeb2d27b652374660d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3322351bf5068346b84b6b19717f525c" id="r_a3322351bf5068346b84b6b19717f525c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a3322351bf5068346b84b6b19717f525c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3322351bf5068346b84b6b19717f525c">is_nothrow_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3322351bf5068346b84b6b19717f525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a08255d43824dc23e14e09d4f9a3d22" id="r_a1a08255d43824dc23e14e09d4f9a3d22"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a1a08255d43824dc23e14e09d4f9a3d22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a08255d43824dc23e14e09d4f9a3d22">is_nothrow_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a1a08255d43824dc23e14e09d4f9a3d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d84124b3f5c4c4fab97253443d07a56" id="r_a2d84124b3f5c4c4fab97253443d07a56"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a2d84124b3f5c4c4fab97253443d07a56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d84124b3f5c4c4fab97253443d07a56">is_nothrow_default_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a2d84124b3f5c4c4fab97253443d07a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6b378d80292ae38acd1f467e10dd49" id="r_adf6b378d80292ae38acd1f467e10dd49"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:adf6b378d80292ae38acd1f467e10dd49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf6b378d80292ae38acd1f467e10dd49">is_nothrow_destructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:adf6b378d80292ae38acd1f467e10dd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26f59ba1b8a873f9d8374f72a4002c4" id="r_ad26f59ba1b8a873f9d8374f72a4002c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ad26f59ba1b8a873f9d8374f72a4002c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad26f59ba1b8a873f9d8374f72a4002c4">is_nothrow_move_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad26f59ba1b8a873f9d8374f72a4002c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e3584e54b63fd9e6a35fffd41080bd" id="r_a34e3584e54b63fd9e6a35fffd41080bd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a34e3584e54b63fd9e6a35fffd41080bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">is_nothrow_move_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a34e3584e54b63fd9e6a35fffd41080bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740a9b650d7a3063e9414c3c50ffdb5" id="r_af740a9b650d7a3063e9414c3c50ffdb5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af740a9b650d7a3063e9414c3c50ffdb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af740a9b650d7a3063e9414c3c50ffdb5">is_nothrow_swappable_v</a> = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af740a9b650d7a3063e9414c3c50ffdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284cbaff17633b620e43bf4c4a5b9c66" id="r_a284cbaff17633b620e43bf4c4a5b9c66"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a284cbaff17633b620e43bf4c4a5b9c66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a284cbaff17633b620e43bf4c4a5b9c66">is_null_pointer_v</a> = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a284cbaff17633b620e43bf4c4a5b9c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0edf4d9cccfbffc3b8744b2c7bcfe9" id="r_a6e0edf4d9cccfbffc3b8744b2c7bcfe9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6e0edf4d9cccfbffc3b8744b2c7bcfe9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a> = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6e0edf4d9cccfbffc3b8744b2c7bcfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e287e878604ddef97548a69df3bb24" id="r_af6e287e878604ddef97548a69df3bb24"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af6e287e878604ddef97548a69df3bb24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6e287e878604ddef97548a69df3bb24">is_placeholder_v</a> = <a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af6e287e878604ddef97548a69df3bb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d8a43ca3d5d473f1651ef5114c2628" id="r_a60d8a43ca3d5d473f1651ef5114c2628"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a60d8a43ca3d5d473f1651ef5114c2628"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">is_pointer_v</a> = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a60d8a43ca3d5d473f1651ef5114c2628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a143b8d7f44dff4fa25a08864799234" id="r_a7a143b8d7f44dff4fa25a08864799234"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a7a143b8d7f44dff4fa25a08864799234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a143b8d7f44dff4fa25a08864799234">is_polymorphic_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_polymorphic</a>(T)</td></tr>
<tr class="separator:a7a143b8d7f44dff4fa25a08864799234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8301cd1745fa1701a4f9d6045f15a2e0" id="r_a8301cd1745fa1701a4f9d6045f15a2e0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8301cd1745fa1701a4f9d6045f15a2e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8301cd1745fa1701a4f9d6045f15a2e0">is_reference_v</a> = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8301cd1745fa1701a4f9d6045f15a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e51e4e96e7f9909244d577e730f80cf" id="r_a0e51e4e96e7f9909244d577e730f80cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a0e51e4e96e7f9909244d577e730f80cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e51e4e96e7f9909244d577e730f80cf">is_reference_wrapper_v</a> = <a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0e51e4e96e7f9909244d577e730f80cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76f1e4408116211d60d33934f2241ec" id="r_ae76f1e4408116211d60d33934f2241ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae76f1e4408116211d60d33934f2241ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae76f1e4408116211d60d33934f2241ec">is_rvalue_reference_v</a> = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ae76f1e4408116211d60d33934f2241ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c6bde5fd020a928e6d7b5fe8db7bb0" id="r_aa6c6bde5fd020a928e6d7b5fe8db7bb0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </td></tr>
<tr class="memitem:aa6c6bde5fd020a928e6d7b5fe8db7bb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a> = <a class="el" href="structetl_1_1bitset.html">false</a></td></tr>
<tr class="separator:aa6c6bde5fd020a928e6d7b5fe8db7bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4cca5d1a81afdeb0354d88b58554a1" id="r_abd4cca5d1a81afdeb0354d88b58554a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abd4cca5d1a81afdeb0354d88b58554a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd4cca5d1a81afdeb0354d88b58554a1">is_same_v&lt; T, T &gt;</a> = <a class="el" href="structetl_1_1bitset.html">true</a></td></tr>
<tr class="separator:abd4cca5d1a81afdeb0354d88b58554a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030808462771bbdd627d73c92a98565f" id="r_a030808462771bbdd627d73c92a98565f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a030808462771bbdd627d73c92a98565f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a030808462771bbdd627d73c92a98565f">is_scalar_v</a> = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a030808462771bbdd627d73c92a98565f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78db0060aa04a75ce5b8a07e7ece59de" id="r_a78db0060aa04a75ce5b8a07e7ece59de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a78db0060aa04a75ce5b8a07e7ece59de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78db0060aa04a75ce5b8a07e7ece59de">is_scoped_enum_v</a> = <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a78db0060aa04a75ce5b8a07e7ece59de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an scoped enumeration type. Provides the member constant value which is equal to true, if T is an scoped enumeration type. Otherwise, value is equal to false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a> or is_scoped_enum_v is undefined.  <br /></td></tr>
<tr class="separator:a78db0060aa04a75ce5b8a07e7ece59de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c78609bb9e06b42e0a4c0c4409b0a1" id="r_a05c78609bb9e06b42e0a4c0c4409b0a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a05c78609bb9e06b42e0a4c0c4409b0a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05c78609bb9e06b42e0a4c0c4409b0a1">is_signed_v</a> = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a05c78609bb9e06b42e0a4c0c4409b0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28194dad7a848538b478ff8c18abafed" id="r_a28194dad7a848538b478ff8c18abafed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">template</a>&lt; typename... &gt; <a class="el" href="structetl_1_1bitset.html">typename</a> Template, <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Tag</a>  = void&gt; </td></tr>
<tr class="memitem:a28194dad7a848538b478ff8c18abafed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28194dad7a848538b478ff8c18abafed">is_specialized_v</a> = <a class="el" href="structetl_1_1is__specialized.html">is_specialized</a>&lt;<a class="el" href="structetl_1_1bitset.html">Template</a>, T, <a class="el" href="structetl_1_1bitset.html">Tag</a>&gt;::value</td></tr>
<tr class="separator:a28194dad7a848538b478ff8c18abafed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87eee4459ff69343253626fdfad870b1" id="r_a87eee4459ff69343253626fdfad870b1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a87eee4459ff69343253626fdfad870b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a87eee4459ff69343253626fdfad870b1">is_standard_layout_v</a> = <a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a87eee4459ff69343253626fdfad870b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a08681ad0c17b00662bfd185a081335" id="r_a6a08681ad0c17b00662bfd185a081335"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a6a08681ad0c17b00662bfd185a081335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a08681ad0c17b00662bfd185a081335">is_swappable_v</a> = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6a08681ad0c17b00662bfd185a081335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c3e504b08a7a017cf1fafdf4435eff" id="r_ac1c3e504b08a7a017cf1fafdf4435eff"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </td></tr>
<tr class="memitem:ac1c3e504b08a7a017cf1fafdf4435eff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1c3e504b08a7a017cf1fafdf4435eff">is_swappable_with_v</a> = <a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:ac1c3e504b08a7a017cf1fafdf4435eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328d1a7de791585957bddf38501d3965" id="r_a328d1a7de791585957bddf38501d3965"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a328d1a7de791585957bddf38501d3965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a328d1a7de791585957bddf38501d3965">is_trivial_v</a> = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a328d1a7de791585957bddf38501d3965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5575d88dd9e2ccdec94f3e0221bd93" id="r_a3e5575d88dd9e2ccdec94f3e0221bd93"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </td></tr>
<tr class="memitem:a3e5575d88dd9e2ccdec94f3e0221bd93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e5575d88dd9e2ccdec94f3e0221bd93">is_trivially_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:a3e5575d88dd9e2ccdec94f3e0221bd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396c0b78998702552df9f3f40bc88982" id="r_a396c0b78998702552df9f3f40bc88982"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args&gt; </td></tr>
<tr class="memitem:a396c0b78998702552df9f3f40bc88982"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a396c0b78998702552df9f3f40bc88982">is_trivially_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a396c0b78998702552df9f3f40bc88982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b0a04cc2a51f7a14f9c7a02c44aecc" id="r_a57b0a04cc2a51f7a14f9c7a02c44aecc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a57b0a04cc2a51f7a14f9c7a02c44aecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57b0a04cc2a51f7a14f9c7a02c44aecc">is_trivially_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a57b0a04cc2a51f7a14f9c7a02c44aecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa380d2993e2d74ca6ec925404947169c" id="r_aa380d2993e2d74ca6ec925404947169c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa380d2993e2d74ca6ec925404947169c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa380d2993e2d74ca6ec925404947169c">is_trivially_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa380d2993e2d74ca6ec925404947169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94b442e8b9fb5a0de351b1b84d6f703" id="r_af94b442e8b9fb5a0de351b1b84d6f703"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af94b442e8b9fb5a0de351b1b84d6f703"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af94b442e8b9fb5a0de351b1b84d6f703">is_trivially_copyable_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_trivially_copyable</a>(T)</td></tr>
<tr class="separator:af94b442e8b9fb5a0de351b1b84d6f703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf6d7f246062eff8288873db7382e49" id="r_aadf6d7f246062eff8288873db7382e49"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aadf6d7f246062eff8288873db7382e49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aadf6d7f246062eff8288873db7382e49">is_trivially_default_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aadf6d7f246062eff8288873db7382e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c5a91c590beb77cbc056cb9327956f" id="r_a63c5a91c590beb77cbc056cb9327956f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a63c5a91c590beb77cbc056cb9327956f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63c5a91c590beb77cbc056cb9327956f">is_trivially_destructible_v</a> = <a class="el" href="structetl_1_1bitset.html">__has_trivial_destructor</a>(T)</td></tr>
<tr class="separator:a63c5a91c590beb77cbc056cb9327956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57849835554ed7e24b739e5ad635cc5d" id="r_a57849835554ed7e24b739e5ad635cc5d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a57849835554ed7e24b739e5ad635cc5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57849835554ed7e24b739e5ad635cc5d">is_trivially_move_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a57849835554ed7e24b739e5ad635cc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d1caff81b5bd6a9266da221ee4a2f5" id="r_aa7d1caff81b5bd6a9266da221ee4a2f5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aa7d1caff81b5bd6a9266da221ee4a2f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7d1caff81b5bd6a9266da221ee4a2f5">is_trivially_move_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa7d1caff81b5bd6a9266da221ee4a2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad99d6adeb2c1d8530bf9204f34aab4" id="r_a5ad99d6adeb2c1d8530bf9204f34aab4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a5ad99d6adeb2c1d8530bf9204f34aab4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ad99d6adeb2c1d8530bf9204f34aab4">is_tuple_like</a> = <a class="el" href="structetl_1_1bitset.html">false</a></td></tr>
<tr class="separator:a5ad99d6adeb2c1d8530bf9204f34aab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687f368c330615460df7f61947e88279" id="r_a687f368c330615460df7f61947e88279"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a687f368c330615460df7f61947e88279"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a687f368c330615460df7f61947e88279">is_unbounded_array_v</a> = <a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a687f368c330615460df7f61947e88279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d7414e06afd624ccd66acee3873b11" id="r_a39d7414e06afd624ccd66acee3873b11"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a39d7414e06afd624ccd66acee3873b11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39d7414e06afd624ccd66acee3873b11">is_union_v</a> = <a class="el" href="structetl_1_1bitset.html">__is_union</a>(T)</td></tr>
<tr class="separator:a39d7414e06afd624ccd66acee3873b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22b0b8d8faeebf7b2eb8d80ccdb03ba" id="r_ac22b0b8d8faeebf7b2eb8d80ccdb03ba"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac22b0b8d8faeebf7b2eb8d80ccdb03ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac22b0b8d8faeebf7b2eb8d80ccdb03ba">is_unsigned_v</a> = <a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac22b0b8d8faeebf7b2eb8d80ccdb03ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4414ccc8655262f0522dc640003d64b7" id="r_a4414ccc8655262f0522dc640003d64b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4414ccc8655262f0522dc640003d64b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4414ccc8655262f0522dc640003d64b7">is_void_v</a> = <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">void</a>, <a class="el" href="#a57d58de8ee9130049557265efc11802c">remove_cv_t</a>&lt;T&gt;&gt;</td></tr>
<tr class="separator:a4414ccc8655262f0522dc640003d64b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fd8976091aa72c12d7a7e5ee986400" id="r_af3fd8976091aa72c12d7a7e5ee986400"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:af3fd8976091aa72c12d7a7e5ee986400"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3fd8976091aa72c12d7a7e5ee986400">is_volatile_v</a> = <a class="el" href="structetl_1_1is__volatile.html">is_volatile</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af3fd8976091aa72c12d7a7e5ee986400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bef7b75bd1375e11a158bc94cbc4fa3" id="r_a3bef7b75bd1375e11a158bc94cbc4fa3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">B</a> &gt; </td></tr>
<tr class="memitem:a3bef7b75bd1375e11a158bc94cbc4fa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bef7b75bd1375e11a158bc94cbc4fa3">negation_v</a> = <a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="structetl_1_1bitset.html">static_cast</a>&lt;<a class="el" href="structetl_1_1bitset.html">bool</a>&gt;(B::value)</td></tr>
<tr class="separator:a3bef7b75bd1375e11a158bc94cbc4fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb090c3e2bd7b58f70ddb151d426d84c" id="r_afb090c3e2bd7b58f70ddb151d426d84c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">auto</a> V&gt; </td></tr>
<tr class="memitem:afb090c3e2bd7b58f70ddb151d426d84c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb090c3e2bd7b58f70ddb151d426d84c">nontype</a> = <a class="el" href="structetl_1_1nontype__t.html">etl::nontype_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">V</a>&gt;{}</td></tr>
<tr class="separator:afb090c3e2bd7b58f70ddb151d426d84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9706e5f8dbc47772797c3f13cfd73517" id="r_a9706e5f8dbc47772797c3f13cfd73517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9706e5f8dbc47772797c3f13cfd73517">nothrow</a> = <a class="el" href="structetl_1_1nothrow__t.html">etl::nothrow_t</a>{}</td></tr>
<tr class="memdesc:a9706e5f8dbc47772797c3f13cfd73517"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a9706e5f8dbc47772797c3f13cfd73517" title="etl::nothrow is a constant of type etl::nothrow_t used to disambiguate the overloads of throwing and ...">etl::nothrow</a> is a constant of type <a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> used to disambiguate the overloads of throwing and non-throwing allocation functions.  <br /></td></tr>
<tr class="separator:a9706e5f8dbc47772797c3f13cfd73517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773a2a7547427bfc26b4ff3b8c2cebe3" id="r_a773a2a7547427bfc26b4ff3b8c2cebe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a773a2a7547427bfc26b4ff3b8c2cebe3">piecewise_construct</a> = <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>{}</td></tr>
<tr class="memdesc:a773a2a7547427bfc26b4ff3b8c2cebe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant <a class="el" href="#a773a2a7547427bfc26b4ff3b8c2cebe3" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>.  <br /></td></tr>
<tr class="separator:a773a2a7547427bfc26b4ff3b8c2cebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66bceba9ac1596666a40596ddf9b62" id="r_a3c66bceba9ac1596666a40596ddf9b62"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> &gt; </td></tr>
<tr class="memitem:a3c66bceba9ac1596666a40596ddf9b62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c66bceba9ac1596666a40596ddf9b62">rank_v</a> = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;<a class="el" href="structetl_1_1bitset.html">Type</a>&gt;::value</td></tr>
<tr class="separator:a3c66bceba9ac1596666a40596ddf9b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad13c7dc384ea307cfe91df7962930245" id="r_gad13c7dc384ea307cfe91df7962930245"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R2</a> &gt; </td></tr>
<tr class="memitem:gad13c7dc384ea307cfe91df7962930245"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#gad13c7dc384ea307cfe91df7962930245">ratio_greater_v</a> = <a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a>&lt;<a class="el" href="structetl_1_1bitset.html">R1</a>, <a class="el" href="structetl_1_1bitset.html">R2</a>&gt;::value</td></tr>
<tr class="separator:gad13c7dc384ea307cfe91df7962930245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99eac87936526440c95e617b0e50ce24" id="r_ga99eac87936526440c95e617b0e50ce24"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga99eac87936526440c95e617b0e50ce24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga99eac87936526440c95e617b0e50ce24">ratio_less_equal_v</a> = <a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a>&lt;<a class="el" href="structetl_1_1bitset.html">R1</a>, <a class="el" href="structetl_1_1bitset.html">R2</a>&gt;::value</td></tr>
<tr class="separator:ga99eac87936526440c95e617b0e50ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5454788945776aa1ad4dffd76424c4" id="r_ga3a5454788945776aa1ad4dffd76424c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga3a5454788945776aa1ad4dffd76424c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga3a5454788945776aa1ad4dffd76424c4">ratio_less_v</a> = <a class="el" href="structetl_1_1ratio__less.html">ratio_less</a>&lt;<a class="el" href="structetl_1_1bitset.html">R1</a>, <a class="el" href="structetl_1_1bitset.html">R2</a>&gt;::value</td></tr>
<tr class="separator:ga3a5454788945776aa1ad4dffd76424c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b36293d12b31aee914984591aa28e3" id="r_ga87b36293d12b31aee914984591aa28e3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R2</a> &gt; </td></tr>
<tr class="memitem:ga87b36293d12b31aee914984591aa28e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ratio.html#ga87b36293d12b31aee914984591aa28e3">ratio_not_equal_v</a> = <a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a>&lt;<a class="el" href="structetl_1_1bitset.html">R1</a>, <a class="el" href="structetl_1_1bitset.html">R2</a>&gt;::value</td></tr>
<tr class="separator:ga87b36293d12b31aee914984591aa28e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba873a97be10ad8146b06a01a9694b9c" id="r_aba873a97be10ad8146b06a01a9694b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba873a97be10ad8146b06a01a9694b9c">sorted_unique</a> = <a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a>{}</td></tr>
<tr class="separator:aba873a97be10ad8146b06a01a9694b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bccb49e0b1f811bb51be4f782a5b6c6" id="r_a4bccb49e0b1f811bb51be4f782a5b6c6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a4bccb49e0b1f811bb51be4f782a5b6c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4bccb49e0b1f811bb51be4f782a5b6c6">tuple_size_v</a> = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4bccb49e0b1f811bb51be4f782a5b6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb779f5e8046c7d141522c238bc2764" id="r_a2eb779f5e8046c7d141522c238bc2764"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Alloc</a> &gt; </td></tr>
<tr class="memitem:a2eb779f5e8046c7d141522c238bc2764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2eb779f5e8046c7d141522c238bc2764">uses_allocator_v</a> = <a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a>&lt;<a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Alloc</a>&gt;::value</td></tr>
<tr class="memdesc:a2eb779f5e8046c7d141522c238bc2764"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false.  <br /></td></tr>
<tr class="separator:a2eb779f5e8046c7d141522c238bc2764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048867192f342c93436216b7b1ed601b" id="r_a048867192f342c93436216b7b1ed601b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a048867192f342c93436216b7b1ed601b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a048867192f342c93436216b7b1ed601b">variant_size_v</a> = <a class="el" href="structetl_1_1variant__size.html">variant_size</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a048867192f342c93436216b7b1ed601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae1bfcd9586bbb9936d7eb2d2ea32bc8e" name="ae1bfcd9586bbb9936d7eb2d2ea32bc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bfcd9586bbb9936d7eb2d2ea32bc8e">&#9670;&#160;</a></span>aligned_storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Len, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Align = alignof(detail::aligned_storage_impl&lt;Len&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ae1bfcd9586bbb9936d7eb2d2ea32bc8e">aligned_storage_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a>&lt;<a class="el" href="structetl_1_1bitset.html">Len</a>, <a class="el" href="structetl_1_1bitset.html">Align</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf5f392ace63d0a89352f050a2104edc" name="aaf5f392ace63d0a89352f050a2104edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5f392ace63d0a89352f050a2104edc">&#9670;&#160;</a></span>aligned_union_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Len, typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aaf5f392ace63d0a89352f050a2104edc">aligned_union_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1aligned__union.html">aligned_union</a>&lt;<a class="el" href="structetl_1_1bitset.html">Len</a>, Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac437d8206f0e17da3a896c5f4d17f95a" name="ac437d8206f0e17da3a896c5f4d17f95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac437d8206f0e17da3a896c5f4d17f95a">&#9670;&#160;</a></span>atto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ac437d8206f0e17da3a896c5f4d17f95a">atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5c90336c94cb0db8abdd10603a3c7cc" name="ac5c90336c94cb0db8abdd10603a3c7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c90336c94cb0db8abdd10603a3c7cc">&#9670;&#160;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">bool</a> B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">bool</a>, <a class="el" href="structetl_1_1bitset.html">B</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a037ed5d2bc56f378210678d84bcc854b" name="a037ed5d2bc56f378210678d84bcc854b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037ed5d2bc56f378210678d84bcc854b">&#9670;&#160;</a></span>centi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a037ed5d2bc56f378210678d84bcc854b">centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78cb041233ab00ef4358f99afedca8d0" name="a78cb041233ab00ef4358f99afedca8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cb041233ab00ef4358f99afedca8d0">&#9670;&#160;</a></span>clock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a78cb041233ab00ef4358f99afedca8d0">clock_t</a> = <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe1164daef675b01dddc89c2b7c28d80" name="afe1164daef675b01dddc89c2b7c28d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1164daef675b01dddc89c2b7c28d80">&#9670;&#160;</a></span>common_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#afe1164daef675b01dddc89c2b7c28d80">common_reference_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1common__reference.html">common_reference</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0f7a81113943dc723a4e4751c342144" name="ac0f7a81113943dc723a4e4751c342144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f7a81113943dc723a4e4751c342144">&#9670;&#160;</a></span>common_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ac0f7a81113943dc723a4e4751c342144">common_type_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1common__type.html">common_type</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09d091a01d0f719c0e795ed347e18a6d" name="a09d091a01d0f719c0e795ed347e18a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d091a01d0f719c0e795ed347e18a6d">&#9670;&#160;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">bool</a> B, <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a09d091a01d0f719c0e795ed347e18a6d">conditional_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1conditional.html">conditional</a>&lt;<a class="el" href="structetl_1_1bitset.html">B</a>, T, <a class="el" href="structetl_1_1bitset.html">F</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb47ecbe72de3b6984811c6a1c8c6d5b" name="aeb47ecbe72de3b6984811c6a1c8c6d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb47ecbe72de3b6984811c6a1c8c6d5b">&#9670;&#160;</a></span>deca</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aeb47ecbe72de3b6984811c6a1c8c6d5b">deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24f3c9ab2c53f9192c2899fc8efb263d" name="a24f3c9ab2c53f9192c2899fc8efb263d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f3c9ab2c53f9192c2899fc8efb263d">&#9670;&#160;</a></span>decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e1c874769f867849c115ae2d1867a02" name="a5e1c874769f867849c115ae2d1867a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1c874769f867849c115ae2d1867a02">&#9670;&#160;</a></span>deci</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a5e1c874769f867849c115ae2d1867a02">deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac53bcc0a66170293af1f9319d4663d1a" name="ac53bcc0a66170293af1f9319d4663d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53bcc0a66170293af1f9319d4663d1a">&#9670;&#160;</a></span>dextents</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">IndexType</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ac53bcc0a66170293af1f9319d4663d1a">dextents</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> detail::dextents_impl&lt;<a class="el" href="structetl_1_1bitset.html">IndexType</a>, <a class="el" href="#a3c526d8179a55ec15611d7627272e067">etl::make_index_sequence</a>&lt;<a class="el" href="structetl_1_1bitset.html">Rank</a>&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05dfe0d6b5c463f72f72a6bf14e21b0f" name="a05dfe0d6b5c463f72f72a6bf14e21b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">&#9670;&#160;</a></span>diff_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">diff_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;<a class="el" href="#a13534b69c91b07e4add5cea854cfedd8">etl::remove_cvref_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Iter</a>&gt;&gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e9cb7fadbcfaa2afb5b94058b8e34c" name="a93e9cb7fadbcfaa2afb5b94058b8e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">&#9670;&#160;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">bool</a> B, <a class="el" href="structetl_1_1bitset.html">typename</a> T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a93e9cb7fadbcfaa2afb5b94058b8e34c">enable_if_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structetl_1_1bitset.html">B</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabe49b8885eb17fdade12acd5f37acad" name="aabe49b8885eb17fdade12acd5f37acad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe49b8885eb17fdade12acd5f37acad">&#9670;&#160;</a></span>exa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aabe49b8885eb17fdade12acd5f37acad">exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad15d3ff5d80b8c8c22e9ce862353ba55" name="ad15d3ff5d80b8c8c22e9ce862353ba55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15d3ff5d80b8c8c22e9ce862353ba55">&#9670;&#160;</a></span>false_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ad15d3ff5d80b8c8c22e9ce862353ba55">false_type</a> = <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">false</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a626e7a2087ed63adf28928bc61505210" name="a626e7a2087ed63adf28928bc61505210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626e7a2087ed63adf28928bc61505210">&#9670;&#160;</a></span>femto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a626e7a2087ed63adf28928bc61505210">femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd8c737296655b44480da4fb422add24" name="abd8c737296655b44480da4fb422add24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8c737296655b44480da4fb422add24">&#9670;&#160;</a></span>format_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#abd8c737296655b44480da4fb422add24">format_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">format_context</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afadb6bf7ddccdb7fc0a95da5b0b911ef" name="afadb6bf7ddccdb7fc0a95da5b0b911ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">&#9670;&#160;</a></span>format_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#afadb6bf7ddccdb7fc0a95da5b0b911ef">format_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1bitset.html">char</a>&gt;&gt;, <a class="el" href="structetl_1_1bitset.html">char</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to formatting state consisting of the formatting arguments and the output iterator. </p>
<p>The first template argument is an output iterator that appends to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>, such as etl::back_insert_iterator&lt;etl::inplace_string&gt;. Implementations are encouraged to use an iterator to type-erased buffer type that supports appending to any contiguous and resizable container.</p>
<p>The behavior is undefined if OutputIt does not model output_iterator&lt;const CharT&amp;&gt;.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/basic_format_context">https://en.cppreference.com/w/cpp/utility/format/basic_format_context</a> </p>

</div>
</div>
<a id="a7f31f076b2eb408741895533f9222baa" name="a7f31f076b2eb408741895533f9222baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f31f076b2eb408741895533f9222baa">&#9670;&#160;</a></span>format_parse_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a7f31f076b2eb408741895533f9222baa">format_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56a828fb91283babdb0eef8e0d9010cb" name="a56a828fb91283babdb0eef8e0d9010cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a828fb91283babdb0eef8e0d9010cb">&#9670;&#160;</a></span>format_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a56a828fb91283babdb0eef8e0d9010cb">format_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>, <a class="el" href="group__type__traits.html#gaca42c1976d1b12998afcabf8f39e8c23">type_identity_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Args</a>&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0782f438fdf0a5e815bb88d8116543a" name="aa0782f438fdf0a5e815bb88d8116543a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0782f438fdf0a5e815bb88d8116543a">&#9670;&#160;</a></span>giga</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aa0782f438fdf0a5e815bb88d8116543a">giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee06e415331cdede5a5e81a37ae91014" name="aee06e415331cdede5a5e81a37ae91014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee06e415331cdede5a5e81a37ae91014">&#9670;&#160;</a></span>hecto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aee06e415331cdede5a5e81a37ae91014">hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fc29a848c78949599ea12f9b9827fd3" name="a0fc29a848c78949599ea12f9b9827fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc29a848c78949599ea12f9b9827fd3">&#9670;&#160;</a></span>index_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a0fc29a848c78949599ea12f9b9827fd3">index_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, <a class="el" href="structetl_1_1bitset.html">I</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c41ad6b9af06544b52833e235bb14dd" name="a6c41ad6b9af06544b52833e235bb14dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c41ad6b9af06544b52833e235bb14dd">&#9670;&#160;</a></span>index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t... Ints&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a6c41ad6b9af06544b52833e235bb14dd">index_sequence</a> = <a class="el" href="structetl_1_1integer__sequence.html">etl::integer_sequence</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, Ints...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26496b89801597f0e24f146bc25bb3ca" name="a26496b89801597f0e24f146bc25bb3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26496b89801597f0e24f146bc25bb3ca">&#9670;&#160;</a></span>index_sequence_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a26496b89801597f0e24f146bc25bb3ca">index_sequence_for</a> = <a class="el" href="#a3c526d8179a55ec15611d7627272e067">etl::make_index_sequence</a>&lt;sizeof...(T)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8a7ab76e5b59bba68d1362a0cbff96c" name="ad8a7ab76e5b59bba68d1362a0cbff96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a7ab76e5b59bba68d1362a0cbff96c">&#9670;&#160;</a></span>inplace_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">inplace_string</a> = <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="structetl_1_1basic__inplace__string.html" title="basic_inplace_string class with fixed size capacity.">basic_inplace_string</a> using 'char'. </p>

</div>
</div>
<a id="a9e4d364842c4ff48aed1de99ba3cf122" name="a9e4d364842c4ff48aed1de99ba3cf122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4d364842c4ff48aed1de99ba3cf122">&#9670;&#160;</a></span>inplace_wstring</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a9e4d364842c4ff48aed1de99ba3cf122">inplace_wstring</a> = <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">wchar_t</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a <a class="el" href="structetl_1_1basic__inplace__string.html" title="basic_inplace_string class with fixed size capacity.">basic_inplace_string</a> using 'wchar_t'. </p>

</div>
</div>
<a id="a962db76b841f05bb03ac61766d75d791" name="a962db76b841f05bb03ac61766d75d791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962db76b841f05bb03ac61766d75d791">&#9670;&#160;</a></span>int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a962db76b841f05bb03ac61766d75d791">int16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 16 bits. </p>

</div>
</div>
<a id="a07e2791ab5c84359b03776662eb994b6" name="a07e2791ab5c84359b03776662eb994b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e2791ab5c84359b03776662eb994b6">&#9670;&#160;</a></span>int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a07e2791ab5c84359b03776662eb994b6">int32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 32 bits. </p>

</div>
</div>
<a id="a3bed93ea1d934540fd05d361a6fc7c5e" name="a3bed93ea1d934540fd05d361a6fc7c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bed93ea1d934540fd05d361a6fc7c5e">&#9670;&#160;</a></span>int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a3bed93ea1d934540fd05d361a6fc7c5e">int64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 64 bits. </p>

</div>
</div>
<a id="a52ed057e79c7de5d1451928e10dcf46d" name="a52ed057e79c7de5d1451928e10dcf46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ed057e79c7de5d1451928e10dcf46d">&#9670;&#160;</a></span>int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a52ed057e79c7de5d1451928e10dcf46d">int8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of exactly 8 bits. </p>

</div>
</div>
<a id="a4b4c952a1c7a141ed7115060bf4c22b0" name="a4b4c952a1c7a141ed7115060bf4c22b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4c952a1c7a141ed7115060bf4c22b0">&#9670;&#160;</a></span>int_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a4b4c952a1c7a141ed7115060bf4c22b0">int_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="a32de47c4408fa865e1b8b99eb992d458" name="a32de47c4408fa865e1b8b99eb992d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32de47c4408fa865e1b8b99eb992d458">&#9670;&#160;</a></span>int_fast32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a32de47c4408fa865e1b8b99eb992d458">int_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="abff54514318ff648eb363a442f171c06" name="abff54514318ff648eb363a442f171c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff54514318ff648eb363a442f171c06">&#9670;&#160;</a></span>int_fast64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#abff54514318ff648eb363a442f171c06">int_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="a711e8ca666d23e897fd1d9f8411c6ca8" name="a711e8ca666d23e897fd1d9f8411c6ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711e8ca666d23e897fd1d9f8411c6ca8">&#9670;&#160;</a></span>int_fast8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a711e8ca666d23e897fd1d9f8411c6ca8">int_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a5cb2df1d7cc3d4d2c87221169156614f" name="a5cb2df1d7cc3d4d2c87221169156614f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb2df1d7cc3d4d2c87221169156614f">&#9670;&#160;</a></span>int_least16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a5cb2df1d7cc3d4d2c87221169156614f">int_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a4fc1b2767cb37289325d88157a39efd2">TETL_BUILTIN_INT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="ae2ce02c549a43d9c5f85a2b39b7c8c4b" name="ae2ce02c549a43d9c5f85a2b39b7c8c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ce02c549a43d9c5f85a2b39b7c8c4b">&#9670;&#160;</a></span>int_least32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ae2ce02c549a43d9c5f85a2b39b7c8c4b">int_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaefac9639ae2cd9e22ed5aba072005e4">TETL_BUILTIN_INT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a85a53a2f96f40b0aeddf74828d71712e" name="a85a53a2f96f40b0aeddf74828d71712e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a53a2f96f40b0aeddf74828d71712e">&#9670;&#160;</a></span>int_least64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a85a53a2f96f40b0aeddf74828d71712e">int_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a3ef24db1b7dec9f2cde7c12efbc5171b">TETL_BUILTIN_INT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="aff47f46aff9c632e1283854fda8dc0e1" name="aff47f46aff9c632e1283854fda8dc0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff47f46aff9c632e1283854fda8dc0e1">&#9670;&#160;</a></span>int_least8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aff47f46aff9c632e1283854fda8dc0e1">int_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#aa2c636f7af9182ce039f2e7a97752b7d">TETL_BUILTIN_INT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a64887361e0411caef7d81a411f3a6868" name="a64887361e0411caef7d81a411f3a6868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64887361e0411caef7d81a411f3a6868">&#9670;&#160;</a></span>intmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a64887361e0411caef7d81a411f3a6868">intmax_t</a> = <a class="el" href="builtin__types_8hpp.html#ad8678dda9c4b939fee5244864c53ada1">TETL_BUILTIN_INTMAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum-width signed integer type. </p>

</div>
</div>
<a id="a3fd46e49593ca8eb7a2a60667662abf4" name="a3fd46e49593ca8eb7a2a60667662abf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd46e49593ca8eb7a2a60667662abf4">&#9670;&#160;</a></span>intptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a3fd46e49593ca8eb7a2a60667662abf4">intptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a021098c463419df8b156d80c9153387e">TETL_BUILTIN_INTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type capable of holding a pointer. </p>

</div>
</div>
<a id="aef5e3d94685880c2a0635ecd8f07b27f" name="aef5e3d94685880c2a0635ecd8f07b27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5e3d94685880c2a0635ecd8f07b27f">&#9670;&#160;</a></span>is_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aef5e3d94685880c2a0635ecd8f07b27f">is_constructible</a> = detail::is_constructible_helper&lt;<a class="el" href="group__type__traits.html#gab8ddf9531fc4ac7ce28574db20c8f20e">void_t</a>&lt;&gt;, T, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad39c2555dd1910c170ae137cc8cdceb7" name="ad39c2555dd1910c170ae137cc8cdceb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39c2555dd1910c170ae137cc8cdceb7">&#9670;&#160;</a></span>iter_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::detail::dereferenceable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ad39c2555dd1910c170ae137cc8cdceb7">iter_reference_t</a> = <a class="el" href="structetl_1_1bitset.html">decltype</a>(*<a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a>&lt;T&amp;&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0bec1ad7f12ec0170c07608d82af228" name="ac0bec1ad7f12ec0170c07608d82af228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bec1ad7f12ec0170c07608d82af228">&#9670;&#160;</a></span>iter_rvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::detail::dereferenceable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ac0bec1ad7f12ec0170c07608d82af228">iter_rvalue_reference_t</a> = <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="group__iterator.html#ga78d082ea4928d84830a8184d72aedca6">etl::ranges::iter_move</a>(<a class="el" href="#a22b47f7719fd7b8373b49b15d5f701fb">etl::declval</a>&lt;T&amp;&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe275d17dd765cd278253e72900c895f" name="afe275d17dd765cd278253e72900c895f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe275d17dd765cd278253e72900c895f">&#9670;&#160;</a></span>iter_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#afe275d17dd765cd278253e72900c895f">iter_value_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> detail::iter_value&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a118ab5d9112082a698afa3512c99a46e" name="a118ab5d9112082a698afa3512c99a46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118ab5d9112082a698afa3512c99a46e">&#9670;&#160;</a></span>kilo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a118ab5d9112082a698afa3512c99a46e">kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c526d8179a55ec15611d7627272e067" name="a3c526d8179a55ec15611d7627272e067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c526d8179a55ec15611d7627272e067">&#9670;&#160;</a></span>make_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a3c526d8179a55ec15611d7627272e067">make_index_sequence</a> = <a class="el" href="#a4c97ecfe358afc1b3c226c0d7036da95">etl::make_integer_sequence</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="structetl_1_1bitset.html">Size</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c97ecfe358afc1b3c226c0d7036da95" name="a4c97ecfe358afc1b3c226c0d7036da95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c97ecfe358afc1b3c226c0d7036da95">&#9670;&#160;</a></span>make_integer_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , T Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a4c97ecfe358afc1b3c226c0d7036da95">make_integer_sequence</a> = <a class="el" href="builtin__functions_8hpp.html#a303c6144751de3e45c44990112e8b1cb">TETL_BUILTIN_INT_SEQ</a>(T, <a class="el" href="structetl_1_1bitset.html">Size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafd5f69b53391404e954cf610afa6c54" name="aafd5f69b53391404e954cf610afa6c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd5f69b53391404e954cf610afa6c54">&#9670;&#160;</a></span>make_signed_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabeda2fce2dea6fa29533488400dd386" name="aabeda2fce2dea6fa29533488400dd386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabeda2fce2dea6fa29533488400dd386">&#9670;&#160;</a></span>make_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aabeda2fce2dea6fa29533488400dd386">make_unsigned_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b7fbb2fd3099cd6e2bb5a712becf41c" name="a8b7fbb2fd3099cd6e2bb5a712becf41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7fbb2fd3099cd6e2bb5a712becf41c">&#9670;&#160;</a></span>mega</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a8b7fbb2fd3099cd6e2bb5a712becf41c">mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af06b69df89587850ded6209b864e7569" name="af06b69df89587850ded6209b864e7569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b69df89587850ded6209b864e7569">&#9670;&#160;</a></span>micro</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#af06b69df89587850ded6209b864e7569">micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab10931e9eceef3f81bae9ea43bdd8e89" name="ab10931e9eceef3f81bae9ea43bdd8e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10931e9eceef3f81bae9ea43bdd8e89">&#9670;&#160;</a></span>milli</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ab10931e9eceef3f81bae9ea43bdd8e89">milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1718104bd02150cc3a553b7289ea2d2d" name="a1718104bd02150cc3a553b7289ea2d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1718104bd02150cc3a553b7289ea2d2d">&#9670;&#160;</a></span>nano</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a1718104bd02150cc3a553b7289ea2d2d">nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2f26afef63b527bf205bb01455a515b" name="aa2f26afef63b527bf205bb01455a515b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f26afef63b527bf205bb01455a515b">&#9670;&#160;</a></span>new_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aa2f26afef63b527bf205bb01455a515b">new_handler</a> = <a class="el" href="structetl_1_1bitset.html">void</a> (*)()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aa2f26afef63b527bf205bb01455a515b" title="etl::new_handler is the function pointer type (pointer to function that takes no arguments and return...">etl::new_handler</a> is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions etl::set_new_handler and etl::get_new_handler </p>

</div>
</div>
<a id="afb2c9350d32e78a0e4c960b9859ccb40" name="afb2c9350d32e78a0e4c960b9859ccb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2c9350d32e78a0e4c960b9859ccb40">&#9670;&#160;</a></span>nullptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a> = <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">nullptr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40" title="etl::nullptr_t is the type of the null pointer literal, nullptr. It is a distinct type that is not it...">etl::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/nullptr_t">https://en.cppreference.com/w/cpp/types/nullptr_t</a> </p>

</div>
</div>
<a id="a8e47bd1a852d56651ef8b41a86a86fa8" name="a8e47bd1a852d56651ef8b41a86a86fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e47bd1a852d56651ef8b41a86a86fa8">&#9670;&#160;</a></span>peta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a8e47bd1a852d56651ef8b41a86a86fa8">peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1999fbf9a32aa8544e0ffa747d47518d" name="a1999fbf9a32aa8544e0ffa747d47518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1999fbf9a32aa8544e0ffa747d47518d">&#9670;&#160;</a></span>pico</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a1999fbf9a32aa8544e0ffa747d47518d">pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac63559b08846022abfeabda8583ed87" name="aac63559b08846022abfeabda8583ed87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac63559b08846022abfeabda8583ed87">&#9670;&#160;</a></span>ptrdiff_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aac63559b08846022abfeabda8583ed87">ptrdiff_t</a> = <a class="el" href="builtin__types_8hpp.html#a19bfe4995271e67306bab6dc974ed002">TETL_BUILTIN_PTRDIFF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aac63559b08846022abfeabda8583ed87" title="etl::ptrdiff_t is the signed integer type of the result of subtracting two pointers.">etl::ptrdiff_t</a> is the signed integer type of the result of subtracting two pointers. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/ptrdiff_t">https://en.cppreference.com/w/cpp/types/ptrdiff_t</a> </p>

</div>
</div>
<a id="a0ffde65d0200b12233a0dff1979cc210" name="a0ffde65d0200b12233a0dff1979cc210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffde65d0200b12233a0dff1979cc210">&#9670;&#160;</a></span>remove_all_extents_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a0ffde65d0200b12233a0dff1979cc210">remove_all_extents_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75ab6c9a804ec997a6e8cb9c5b36c3e4" name="a75ab6c9a804ec997a6e8cb9c5b36c3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ab6c9a804ec997a6e8cb9c5b36c3e4">&#9670;&#160;</a></span>remove_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a75ab6c9a804ec997a6e8cb9c5b36c3e4">remove_const_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__const.html">remove_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57d58de8ee9130049557265efc11802c" name="a57d58de8ee9130049557265efc11802c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d58de8ee9130049557265efc11802c">&#9670;&#160;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a57d58de8ee9130049557265efc11802c">remove_cv_t</a> = <a class="el" href="#a75ab6c9a804ec997a6e8cb9c5b36c3e4">remove_const_t</a>&lt;<a class="el" href="group__type__traits.html#ga52b035d7a0227468261ee211d61d7abf">remove_volatile_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13534b69c91b07e4add5cea854cfedd8" name="a13534b69c91b07e4add5cea854cfedd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13534b69c91b07e4add5cea854cfedd8">&#9670;&#160;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a13534b69c91b07e4add5cea854cfedd8">remove_cvref_t</a> = <a class="el" href="#a57d58de8ee9130049557265efc11802c">remove_cv_t</a>&lt;<a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff3a021106d8984e6a7283adfcae4117" name="aff3a021106d8984e6a7283adfcae4117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3a021106d8984e6a7283adfcae4117">&#9670;&#160;</a></span>remove_extent_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aff3a021106d8984e6a7283adfcae4117">remove_extent_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__extent.html">remove_extent</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81cba9b583535ccfde0e7eb172bbec71" name="a81cba9b583535ccfde0e7eb172bbec71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cba9b583535ccfde0e7eb172bbec71">&#9670;&#160;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a81cba9b583535ccfde0e7eb172bbec71">remove_pointer_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee50235c04ef643cb7502785393220fe" name="aee50235c04ef643cb7502785393220fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee50235c04ef643cb7502785393220fe">&#9670;&#160;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> = <a class="el" href="builtin__types_8hpp.html#ab236bea848bc390350ba3fc38ae07819">TETL_BUILTIN_SIZET</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aee50235c04ef643cb7502785393220fe" title="etl::size_t is the unsigned integer type of the result of the sizeof operator.">etl::size_t</a> is the unsigned integer type of the result of the sizeof operator. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/size_t">https://en.cppreference.com/w/cpp/types/size_t</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="numeric_8cpp-example.html#a0">numeric.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a66b66173615e2c5f0568adb2cae8739f" name="a66b66173615e2c5f0568adb2cae8739f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b66173615e2c5f0568adb2cae8739f">&#9670;&#160;</a></span>streamoff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a66b66173615e2c5f0568adb2cae8739f">streamoff</a> = <a class="el" href="structetl_1_1bitset.html">long</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcecc45ff4539025dd0eb1cea84021f9" name="afcecc45ff4539025dd0eb1cea84021f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcecc45ff4539025dd0eb1cea84021f9">&#9670;&#160;</a></span>streamsize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#afcecc45ff4539025dd0eb1cea84021f9">streamsize</a> = <a class="el" href="#aafd5f69b53391404e954cf610afa6c54">make_signed_t</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f7f02db9e66eaec8dccdca2f4e98a2f" name="a6f7f02db9e66eaec8dccdca2f4e98a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">&#9670;&#160;</a></span>string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">string_view</a> = <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt;<a class="el" href="structetl_1_1bitset.html">char</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedefs for common character type. </p>

</div>
</div>
<a id="abb0850018459aaecf06435ee5eb9f0d8" name="abb0850018459aaecf06435ee5eb9f0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0850018459aaecf06435ee5eb9f0d8">&#9670;&#160;</a></span>tera</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#abb0850018459aaecf06435ee5eb9f0d8">tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62da72e20fc89d790a5f88420496d0d7" name="a62da72e20fc89d790a5f88420496d0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62da72e20fc89d790a5f88420496d0d7">&#9670;&#160;</a></span>time_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a62da72e20fc89d790a5f88420496d0d7">time_t</a> = <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic type capable of representing times. </p>
<p>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to POSIX time. </p>

</div>
</div>
<a id="aa4e9c28fa52ab73ef48e5cbed20c66fd" name="aa4e9c28fa52ab73ef48e5cbed20c66fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e9c28fa52ab73ef48e5cbed20c66fd">&#9670;&#160;</a></span>true_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aa4e9c28fa52ab73ef48e5cbed20c66fd">true_type</a> = <a class="el" href="#ac5c90336c94cb0db8abdd10603a3c7cc">bool_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">true</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae88df1a5f5c335cb6cf4909b47882e53" name="ae88df1a5f5c335cb6cf4909b47882e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88df1a5f5c335cb6cf4909b47882e53">&#9670;&#160;</a></span>tuple_element_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1tuple__element.html">tuple_element</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46518a317507676ba5887e53ca4bf5bd" name="a46518a317507676ba5887e53ca4bf5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46518a317507676ba5887e53ca4bf5bd">&#9670;&#160;</a></span>uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a46518a317507676ba5887e53ca4bf5bd">uint16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 16 bits. </p>

</div>
</div>
<a id="ac524e3389ea120063f493b23ce5ba2a6" name="ac524e3389ea120063f493b23ce5ba2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac524e3389ea120063f493b23ce5ba2a6">&#9670;&#160;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ac524e3389ea120063f493b23ce5ba2a6">uint32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 32 bits. </p>

</div>
</div>
<a id="a5bbbc3f006120acc1de719e7d8ee6f40" name="a5bbbc3f006120acc1de719e7d8ee6f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbbc3f006120acc1de719e7d8ee6f40">&#9670;&#160;</a></span>uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a5bbbc3f006120acc1de719e7d8ee6f40">uint64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 64 bits. </p>

</div>
</div>
<a id="a71924434159564bc3aa4bd2930947053" name="a71924434159564bc3aa4bd2930947053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71924434159564bc3aa4bd2930947053">&#9670;&#160;</a></span>uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a71924434159564bc3aa4bd2930947053">uint8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type with width of exactly 8 bits. </p>

</div>
</div>
<a id="a516df22f1e6a839bc251cc699c90ab56" name="a516df22f1e6a839bc251cc699c90ab56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516df22f1e6a839bc251cc699c90ab56">&#9670;&#160;</a></span>uint_fast16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a516df22f1e6a839bc251cc699c90ab56">uint_fast16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="a39ae5542021173d59890b67e0f5dcd20" name="a39ae5542021173d59890b67e0f5dcd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ae5542021173d59890b67e0f5dcd20">&#9670;&#160;</a></span>uint_fast32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a39ae5542021173d59890b67e0f5dcd20">uint_fast32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="a49b174a549a84b470b20998da935f674" name="a49b174a549a84b470b20998da935f674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b174a549a84b470b20998da935f674">&#9670;&#160;</a></span>uint_fast64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a49b174a549a84b470b20998da935f674">uint_fast64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="aba8e71ca66f676d88d4bfc4023421cd9" name="aba8e71ca66f676d88d4bfc4023421cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8e71ca66f676d88d4bfc4023421cd9">&#9670;&#160;</a></span>uint_fast8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#aba8e71ca66f676d88d4bfc4023421cd9">uint_fast8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="acce3c5bd0ff2f44caabd1b4d707887fc" name="acce3c5bd0ff2f44caabd1b4d707887fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce3c5bd0ff2f44caabd1b4d707887fc">&#9670;&#160;</a></span>uint_least16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#acce3c5bd0ff2f44caabd1b4d707887fc">uint_least16_t</a> = <a class="el" href="builtin__types_8hpp.html#a0b66a88b9b5d20df56f0529e9fc8a217">TETL_BUILTIN_UINT16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 16 bits. </p>

</div>
</div>
<a id="ad35f8b747d163b033b7d4bf5b18b2f61" name="ad35f8b747d163b033b7d4bf5b18b2f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35f8b747d163b033b7d4bf5b18b2f61">&#9670;&#160;</a></span>uint_least32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ad35f8b747d163b033b7d4bf5b18b2f61">uint_least32_t</a> = <a class="el" href="builtin__types_8hpp.html#aaa3169b52838e0e96b8434caadc6a171">TETL_BUILTIN_UINT32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 32 bits. </p>

</div>
</div>
<a id="ace30aa068da2786e3178c001a9dcb45f" name="ace30aa068da2786e3178c001a9dcb45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace30aa068da2786e3178c001a9dcb45f">&#9670;&#160;</a></span>uint_least64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ace30aa068da2786e3178c001a9dcb45f">uint_least64_t</a> = <a class="el" href="builtin__types_8hpp.html#a01369298be0f5364165b8ee080e943c3">TETL_BUILTIN_UINT64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 64 bits. </p>

</div>
</div>
<a id="a3e9da1f87db9cd7b9d1f76ade9b44c94" name="a3e9da1f87db9cd7b9d1f76ade9b44c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9da1f87db9cd7b9d1f76ade9b44c94">&#9670;&#160;</a></span>uint_least8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a3e9da1f87db9cd7b9d1f76ade9b44c94">uint_least8_t</a> = <a class="el" href="builtin__types_8hpp.html#a4136e36e4cfceb2e237c73c2611333e4">TETL_BUILTIN_UINT8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer type with width of at least 8 bits. </p>

</div>
</div>
<a id="a05138bec421765330b01b925aae5d89f" name="a05138bec421765330b01b925aae5d89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05138bec421765330b01b925aae5d89f">&#9670;&#160;</a></span>uintmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a05138bec421765330b01b925aae5d89f">uintmax_t</a> = <a class="el" href="builtin__types_8hpp.html#a64175350ea04c19125422816cd6184e1">TETL_BUILTIN_UINTMAX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum-width unsigned integer type. </p>

</div>
</div>
<a id="a1d944a371245d51e3b9ea011f7b97f43" name="a1d944a371245d51e3b9ea011f7b97f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d944a371245d51e3b9ea011f7b97f43">&#9670;&#160;</a></span>uintptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a1d944a371245d51e3b9ea011f7b97f43">uintptr_t</a> = <a class="el" href="builtin__types_8hpp.html#a3b013e093af0767d757a3606463295d9">TETL_BUILTIN_UINTPTR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type capable of holding a pointer. </p>

</div>
</div>
<a id="ab50d469d33ed56a0ce32f87d03ac5f10" name="ab50d469d33ed56a0ce32f87d03ac5f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50d469d33ed56a0ce32f87d03ac5f10">&#9670;&#160;</a></span>unwrap_ref_decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#ab50d469d33ed56a0ce32f87d03ac5f10">unwrap_ref_decay_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1unwrap__ref__decay.html">unwrap_ref_decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b611e97373f7c9c739f58a942f9de05" name="a7b611e97373f7c9c739f58a942f9de05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b611e97373f7c9c739f58a942f9de05">&#9670;&#160;</a></span>variant_alternative_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a7b611e97373f7c9c739f58a942f9de05">variant_alternative_t</a> = <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afff8faaf423d40e312921ee1506eaf5b" name="afff8faaf423d40e312921ee1506eaf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff8faaf423d40e312921ee1506eaf5b">&#9670;&#160;</a></span>wformat_args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#afff8faaf423d40e312921ee1506eaf5b">wformat_args</a> = <a class="el" href="structetl_1_1basic__format__args.html">basic_format_args</a>&lt;<a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03b255764cde83db44d0e61eebc55d36" name="a03b255764cde83db44d0e61eebc55d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b255764cde83db44d0e61eebc55d36">&#9670;&#160;</a></span>wformat_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a> = <a class="el" href="structetl_1_1basic__format__context.html">basic_format_context</a>&lt;<a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;detail::fmt_buffer&lt;<a class="el" href="structetl_1_1bitset.html">wchar_t</a>&gt;&gt;, <a class="el" href="structetl_1_1bitset.html">wchar_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a60587ace165efab2fc40bddf69c89c" name="a9a60587ace165efab2fc40bddf69c89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a60587ace165efab2fc40bddf69c89c">&#9670;&#160;</a></span>wformat_parse_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a9a60587ace165efab2fc40bddf69c89c">wformat_parse_context</a> = <a class="el" href="structetl_1_1basic__format__parse__context.html">basic_format_parse_context</a>&lt;<a class="el" href="structetl_1_1bitset.html">wchar_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69c1b057042c87184f2220c79696ef73" name="a69c1b057042c87184f2220c79696ef73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c1b057042c87184f2220c79696ef73">&#9670;&#160;</a></span>wformat_string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#a69c1b057042c87184f2220c79696ef73">wformat_string</a> = <a class="el" href="structetl_1_1basic__format__string.html">basic_format_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">wchar_t</a>, <a class="el" href="group__type__traits.html#gaca42c1976d1b12998afcabf8f39e8c23">type_identity_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Args</a>&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb4e6bc2deecad0fb678bfe7c838df5e" name="afb4e6bc2deecad0fb678bfe7c838df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4e6bc2deecad0fb678bfe7c838df5e">&#9670;&#160;</a></span>wint_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">using</a> <a class="el" href="#afb4e6bc2deecad0fb678bfe7c838df5e">wint_t</a> = <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">int</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8c9590e0d8ba5b7b8a2d709113c3e7bb" name="a8c9590e0d8ba5b7b8a2d709113c3e7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9590e0d8ba5b7b8a2d709113c3e7bb">&#9670;&#160;</a></span>align_val_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="structetl_1_1bitset.html">struct</a> <a class="el" href="#a8c9590e0d8ba5b7b8a2d709113c3e7bb">align_val_t</a> : <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Both new-expression and delete-expression, when used with objects whose alignment requirement is greater than the default, pass that alignment requirement as an argument of type align_val_t to the selected allocation/deallocation function. </p>

</div>
</div>
<a id="abc55212e09044ea8a258cd3a53d90dde" name="abc55212e09044ea8a258cd3a53d90dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc55212e09044ea8a258cd3a53d90dde">&#9670;&#160;</a></span>chars_format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="structetl_1_1bitset.html">struct</a> <a class="el" href="#abc55212e09044ea8a258cd3a53d90dde">chars_format</a> : <a class="el" href="#a71924434159564bc3aa4bd2930947053">etl::uint8_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A BitmaskType used to specify floating-point formatting for to_chars and from_chars. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc55212e09044ea8a258cd3a53d90ddea55a95650a66b53ecbb960b53d985b964" name="abc55212e09044ea8a258cd3a53d90ddea55a95650a66b53ecbb960b53d985b964"></a>scientific&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abc55212e09044ea8a258cd3a53d90ddeacec315e3d0975e5cc2811d5d8725f149" name="abc55212e09044ea8a258cd3a53d90ddeacec315e3d0975e5cc2811d5d8725f149"></a>fixed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abc55212e09044ea8a258cd3a53d90ddeab8d1b43eae73587ba56baef574709ecb" name="abc55212e09044ea8a258cd3a53d90ddeab8d1b43eae73587ba56baef574709ecb"></a>hex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abc55212e09044ea8a258cd3a53d90ddea958153f1b8b96ec4c4eb2147429105d9" name="abc55212e09044ea8a258cd3a53d90ddea958153f1b8b96ec4c4eb2147429105d9"></a>general&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa31f743d6273b64f3e8a3121813ea243" name="aa31f743d6273b64f3e8a3121813ea243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31f743d6273b64f3e8a3121813ea243">&#9670;&#160;</a></span>errc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="structetl_1_1bitset.html">struct</a> <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243">errc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scoped enumeration <a class="el" href="#aa31f743d6273b64f3e8a3121813ea243" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a8ab69162f060cc46b805b3265ad1cdf1" name="aa31f743d6273b64f3e8a3121813ea243a8ab69162f060cc46b805b3265ad1cdf1"></a>address_family_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a8e2bc80599069d337b43dff6edfb6891" name="aa31f743d6273b64f3e8a3121813ea243a8e2bc80599069d337b43dff6edfb6891"></a>address_in_use&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a20abf2ffbf6e82e36405843f269d6438" name="aa31f743d6273b64f3e8a3121813ea243a20abf2ffbf6e82e36405843f269d6438"></a>address_not_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ab5580b198f691ab2df12f5e2ab974373" name="aa31f743d6273b64f3e8a3121813ea243ab5580b198f691ab2df12f5e2ab974373"></a>already_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a1b245b26b5ea3428c050d7f1503d7715" name="aa31f743d6273b64f3e8a3121813ea243a1b245b26b5ea3428c050d7f1503d7715"></a>argument_list_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a4b82222a0895b538d0597092b3ceab3e" name="aa31f743d6273b64f3e8a3121813ea243a4b82222a0895b538d0597092b3ceab3e"></a>argument_out_of_domain&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aaf169f73a82794128aa491c4b4f1c071" name="aa31f743d6273b64f3e8a3121813ea243aaf169f73a82794128aa491c4b4f1c071"></a>bad_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a9941c5c8c58ff058b870e94e96ac38e1" name="aa31f743d6273b64f3e8a3121813ea243a9941c5c8c58ff058b870e94e96ac38e1"></a>bad_file_descriptor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ac7944ab5d2e25bf75b267d070b506d1c" name="aa31f743d6273b64f3e8a3121813ea243ac7944ab5d2e25bf75b267d070b506d1c"></a>bad_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a2f0338eed54503152be1d31c93c9c2f1" name="aa31f743d6273b64f3e8a3121813ea243a2f0338eed54503152be1d31c93c9c2f1"></a>broken_pipe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a2f8f27a7eef1ad585c7ab6f25a6c2c79" name="aa31f743d6273b64f3e8a3121813ea243a2f8f27a7eef1ad585c7ab6f25a6c2c79"></a>connection_aborted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a81cf222a9b1530171fdfd66c3f734989" name="aa31f743d6273b64f3e8a3121813ea243a81cf222a9b1530171fdfd66c3f734989"></a>connection_already_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a53793ee58fc24168a0d6549c3cb2df8e" name="aa31f743d6273b64f3e8a3121813ea243a53793ee58fc24168a0d6549c3cb2df8e"></a>connection_refused&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243abf39bfc8665384194e343c08ab344405" name="aa31f743d6273b64f3e8a3121813ea243abf39bfc8665384194e343c08ab344405"></a>connection_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6177070a517d51a4382ab0d7c88e5b58" name="aa31f743d6273b64f3e8a3121813ea243a6177070a517d51a4382ab0d7c88e5b58"></a>cross_device_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a326032e01f2a5e14c7f730f4d03d753a" name="aa31f743d6273b64f3e8a3121813ea243a326032e01f2a5e14c7f730f4d03d753a"></a>destination_address_required&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ab3ab5338a00f49c4451851cc5442f370" name="aa31f743d6273b64f3e8a3121813ea243ab3ab5338a00f49c4451851cc5442f370"></a>device_or_resource_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6a336135d33e62f49edc55f29354e12e" name="aa31f743d6273b64f3e8a3121813ea243a6a336135d33e62f49edc55f29354e12e"></a>directory_not_empty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a4dfaf9c996cf045f32d17edc9754fc95" name="aa31f743d6273b64f3e8a3121813ea243a4dfaf9c996cf045f32d17edc9754fc95"></a>executable_format_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a41edf636e3c7b59f797348fc58472258" name="aa31f743d6273b64f3e8a3121813ea243a41edf636e3c7b59f797348fc58472258"></a>file_exists&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aa1e14bfb89b41ddf654b1772c8fd2e74" name="aa31f743d6273b64f3e8a3121813ea243aa1e14bfb89b41ddf654b1772c8fd2e74"></a>file_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6e56e6ed055b9771b8192a4f229fee27" name="aa31f743d6273b64f3e8a3121813ea243a6e56e6ed055b9771b8192a4f229fee27"></a>filename_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aa33c516bbdfb179cef733c8daeb97bed" name="aa31f743d6273b64f3e8a3121813ea243aa33c516bbdfb179cef733c8daeb97bed"></a>function_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243afe2377fbd16d7f335474e1df7d6376bf" name="aa31f743d6273b64f3e8a3121813ea243afe2377fbd16d7f335474e1df7d6376bf"></a>host_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a054e5b4ff59331386872de744d661719" name="aa31f743d6273b64f3e8a3121813ea243a054e5b4ff59331386872de744d661719"></a>identifier_removed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a53a9e57a679708b2d8ff0ccd8ec96b18" name="aa31f743d6273b64f3e8a3121813ea243a53a9e57a679708b2d8ff0ccd8ec96b18"></a>illegal_byte_sequence&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a45fe7da1767194b580aeba752d7b44ae" name="aa31f743d6273b64f3e8a3121813ea243a45fe7da1767194b580aeba752d7b44ae"></a>inappropriate_io_control_operation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243afadb76763385627e57ec386c9b6038f0" name="aa31f743d6273b64f3e8a3121813ea243afadb76763385627e57ec386c9b6038f0"></a>interrupted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ae55d43eabeefe5a8271b4a3c898bd18f" name="aa31f743d6273b64f3e8a3121813ea243ae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243abd86a2c65caf6a270b916234ab321ce3" name="aa31f743d6273b64f3e8a3121813ea243abd86a2c65caf6a270b916234ab321ce3"></a>invalid_seek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243acccc32f2a5f7dc7b87d2f85daea66789" name="aa31f743d6273b64f3e8a3121813ea243acccc32f2a5f7dc7b87d2f85daea66789"></a>io_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243af3c51d7ea75a76f26c0a2bdc00c4e006" name="aa31f743d6273b64f3e8a3121813ea243af3c51d7ea75a76f26c0a2bdc00c4e006"></a>is_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ade5f4bc2f8a4690176e22e83196b9fd3" name="aa31f743d6273b64f3e8a3121813ea243ade5f4bc2f8a4690176e22e83196b9fd3"></a>message_size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a93b16d34b1689f66f0cfed60e99c0009" name="aa31f743d6273b64f3e8a3121813ea243a93b16d34b1689f66f0cfed60e99c0009"></a>network_down&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a0e1d200ae35ede416bf85f84093ce37a" name="aa31f743d6273b64f3e8a3121813ea243a0e1d200ae35ede416bf85f84093ce37a"></a>network_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a608a68344b4eb1fe0690861a83828816" name="aa31f743d6273b64f3e8a3121813ea243a608a68344b4eb1fe0690861a83828816"></a>network_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a618ead44397b73cf0baa08b460b66c39" name="aa31f743d6273b64f3e8a3121813ea243a618ead44397b73cf0baa08b460b66c39"></a>no_buffer_space&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ad08d4c854a6810cebd2a8ab61876f919" name="aa31f743d6273b64f3e8a3121813ea243ad08d4c854a6810cebd2a8ab61876f919"></a>no_child_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243add431dfaf61ea842693dca8be1ebcaf7" name="aa31f743d6273b64f3e8a3121813ea243add431dfaf61ea842693dca8be1ebcaf7"></a>no_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a58688487c3e24313637a76bd29881e64" name="aa31f743d6273b64f3e8a3121813ea243a58688487c3e24313637a76bd29881e64"></a>no_lock_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aeec0f03ad92584c78835c10ab79d7f42" name="aa31f743d6273b64f3e8a3121813ea243aeec0f03ad92584c78835c10ab79d7f42"></a>no_message_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243acec935db07cfc57caafa37e98eafb213" name="aa31f743d6273b64f3e8a3121813ea243acec935db07cfc57caafa37e98eafb213"></a>no_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243abed8a9032d9366c28582a0ad59a31525" name="aa31f743d6273b64f3e8a3121813ea243abed8a9032d9366c28582a0ad59a31525"></a>no_protocol_option&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a1a5334dd8d1ca56e33887bd44630641b" name="aa31f743d6273b64f3e8a3121813ea243a1a5334dd8d1ca56e33887bd44630641b"></a>no_space_on_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ad8b1d94a0ac09c6d55b2ed68f0836142" name="aa31f743d6273b64f3e8a3121813ea243ad8b1d94a0ac09c6d55b2ed68f0836142"></a>no_stream_resources&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a5c83a012eac17bbf458df5804801e373" name="aa31f743d6273b64f3e8a3121813ea243a5c83a012eac17bbf458df5804801e373"></a>no_such_device_or_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243af42b2e58729e2783b683c8610977fc22" name="aa31f743d6273b64f3e8a3121813ea243af42b2e58729e2783b683c8610977fc22"></a>no_such_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a2e70fc89b08f26fa3fc77694c91e8f7a" name="aa31f743d6273b64f3e8a3121813ea243a2e70fc89b08f26fa3fc77694c91e8f7a"></a>no_such_file_or_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ad91a9b8a734f2bef4b778f89806cbab7" name="aa31f743d6273b64f3e8a3121813ea243ad91a9b8a734f2bef4b778f89806cbab7"></a>no_such_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a21e867ca95e1dfecff4701863547dcec" name="aa31f743d6273b64f3e8a3121813ea243a21e867ca95e1dfecff4701863547dcec"></a>not_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a22ac64bb14c46bcbc338a21950b6e722" name="aa31f743d6273b64f3e8a3121813ea243a22ac64bb14c46bcbc338a21950b6e722"></a>not_a_socket&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6e752b7a04543e5052b2d0dd05eca0fa" name="aa31f743d6273b64f3e8a3121813ea243a6e752b7a04543e5052b2d0dd05eca0fa"></a>not_a_stream&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a69c2dbb5917ca550a862e9c1c839bca1" name="aa31f743d6273b64f3e8a3121813ea243a69c2dbb5917ca550a862e9c1c839bca1"></a>not_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aafdb5594dc3e484fc1bfd7c564d550c1" name="aa31f743d6273b64f3e8a3121813ea243aafdb5594dc3e484fc1bfd7c564d550c1"></a>not_enough_memory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aa55e82356e9721946aa9ba954733c6f0" name="aa31f743d6273b64f3e8a3121813ea243aa55e82356e9721946aa9ba954733c6f0"></a>not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243afd3d0bdcc9eb9e68534b7d055c5fe586" name="aa31f743d6273b64f3e8a3121813ea243afd3d0bdcc9eb9e68534b7d055c5fe586"></a>operation_canceled&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a4c7eb50b6d86ac8a130ebebc18dbe263" name="aa31f743d6273b64f3e8a3121813ea243a4c7eb50b6d86ac8a130ebebc18dbe263"></a>operation_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a8344b3d509942f035d5e303022f9b986" name="aa31f743d6273b64f3e8a3121813ea243a8344b3d509942f035d5e303022f9b986"></a>operation_not_permitted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a69bf074bf052ee4c9047b62fe7c24569" name="aa31f743d6273b64f3e8a3121813ea243a69bf074bf052ee4c9047b62fe7c24569"></a>operation_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a738abdaead9cd7b2e2ea19a34764b385" name="aa31f743d6273b64f3e8a3121813ea243a738abdaead9cd7b2e2ea19a34764b385"></a>operation_would_block&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a2abac2fa6722c56b2ea17ac6c4097f68" name="aa31f743d6273b64f3e8a3121813ea243a2abac2fa6722c56b2ea17ac6c4097f68"></a>owner_dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ae8ee838822072f02738dbd7d97ea03fc" name="aa31f743d6273b64f3e8a3121813ea243ae8ee838822072f02738dbd7d97ea03fc"></a>permission_denied&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a9665c745d0a9132d8da6ed55e89a0564" name="aa31f743d6273b64f3e8a3121813ea243a9665c745d0a9132d8da6ed55e89a0564"></a>protocol_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aa2635acef8b9a3e1c40923829722d472" name="aa31f743d6273b64f3e8a3121813ea243aa2635acef8b9a3e1c40923829722d472"></a>protocol_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a06108efce8ef1cd8aa4cc440f8b4317f" name="aa31f743d6273b64f3e8a3121813ea243a06108efce8ef1cd8aa4cc440f8b4317f"></a>read_only_file_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aed65f7649c6f0e365673d65a9d8119d8" name="aa31f743d6273b64f3e8a3121813ea243aed65f7649c6f0e365673d65a9d8119d8"></a>resource_deadlock_would_occur&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ae46a97ea2906921c8c626890bde832cf" name="aa31f743d6273b64f3e8a3121813ea243ae46a97ea2906921c8c626890bde832cf"></a>resource_unavailable_try_again&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a8e0fafb181567cc468e1ee81983d739d" name="aa31f743d6273b64f3e8a3121813ea243a8e0fafb181567cc468e1ee81983d739d"></a>result_out_of_range&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a6805059549401365b824b54573a6f46e" name="aa31f743d6273b64f3e8a3121813ea243a6805059549401365b824b54573a6f46e"></a>state_not_recoverable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ac1a620a30954dc9402a811453c2c3e3f" name="aa31f743d6273b64f3e8a3121813ea243ac1a620a30954dc9402a811453c2c3e3f"></a>stream_timeout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243ad2f80f12d22bb099fcf1062db660b567" name="aa31f743d6273b64f3e8a3121813ea243ad2f80f12d22bb099fcf1062db660b567"></a>text_file_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a56c27b1ab1a5a5a0eae853cabb4dc0c1" name="aa31f743d6273b64f3e8a3121813ea243a56c27b1ab1a5a5a0eae853cabb4dc0c1"></a>timed_out&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a3130d1d4e000cdc1e7c47013e313c10e" name="aa31f743d6273b64f3e8a3121813ea243a3130d1d4e000cdc1e7c47013e313c10e"></a>too_many_files_open_in_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243aed2c33c8fe874cfeba6f4a7747c62d05" name="aa31f743d6273b64f3e8a3121813ea243aed2c33c8fe874cfeba6f4a7747c62d05"></a>too_many_files_open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243abfe22fc9b27a8ff13186aba60b6bc5c8" name="aa31f743d6273b64f3e8a3121813ea243abfe22fc9b27a8ff13186aba60b6bc5c8"></a>too_many_links&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a33c78baca1480479c88aa4d50cb68206" name="aa31f743d6273b64f3e8a3121813ea243a33c78baca1480479c88aa4d50cb68206"></a>too_many_symbolic_link_levels&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a143653b075bff946193644ba6d97fa5d" name="aa31f743d6273b64f3e8a3121813ea243a143653b075bff946193644ba6d97fa5d"></a>value_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa31f743d6273b64f3e8a3121813ea243a81cac28a38438710de9856af4a8bcd0b" name="aa31f743d6273b64f3e8a3121813ea243a81cac28a38438710de9856af4a8bcd0b"></a>wrong_protocol_type&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a592fe78d9bf66455d12aa075f36313b6" name="a592fe78d9bf66455d12aa075f36313b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592fe78d9bf66455d12aa075f36313b6">&#9670;&#160;</a></span>float_denorm_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="#a592fe78d9bf66455d12aa075f36313b6">float_denorm_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a592fe78d9bf66455d12aa075f36313b6ae6e5a92659b76e353da685746ec7a715" name="a592fe78d9bf66455d12aa075f36313b6ae6e5a92659b76e353da685746ec7a715"></a>denorm_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a592fe78d9bf66455d12aa075f36313b6ae1126f121e8e78fad4c2ea93b9154f70" name="a592fe78d9bf66455d12aa075f36313b6ae1126f121e8e78fad4c2ea93b9154f70"></a>denorm_absent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a592fe78d9bf66455d12aa075f36313b6ace9911a51bfc23dca58b86c67b0adfac" name="a592fe78d9bf66455d12aa075f36313b6ace9911a51bfc23dca58b86c67b0adfac"></a>denorm_present&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3bdaf6c7e8a65859bf550443989c5a66" name="a3bdaf6c7e8a65859bf550443989c5a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdaf6c7e8a65859bf550443989c5a66">&#9670;&#160;</a></span>float_round_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="#a3bdaf6c7e8a65859bf550443989c5a66">float_round_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66aef8e73dd0b0f1899790b6ba2bb47be7d" name="a3bdaf6c7e8a65859bf550443989c5a66aef8e73dd0b0f1899790b6ba2bb47be7d"></a>round_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66a2378935a2849c4d049d5e5a01324e827" name="a3bdaf6c7e8a65859bf550443989c5a66a2378935a2849c4d049d5e5a01324e827"></a>round_toward_zero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66aae97e229f8502c244371d7f7e3105afc" name="a3bdaf6c7e8a65859bf550443989c5a66aae97e229f8502c244371d7f7e3105afc"></a>round_to_nearest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66a33f65225750a8f3edc0b6601fa7bcd52" name="a3bdaf6c7e8a65859bf550443989c5a66a33f65225750a8f3edc0b6601fa7bcd52"></a>round_toward_infinity&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3bdaf6c7e8a65859bf550443989c5a66ad9c511acb4735515f2402087641e9725" name="a3bdaf6c7e8a65859bf550443989c5a66ad9c511acb4735515f2402087641e9725"></a>round_toward_neg_infinity&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a6a5c92ae723acdba8ce0f48be8530154" name="a6a5c92ae723acdba8ce0f48be8530154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5c92ae723acdba8ce0f48be8530154">&#9670;&#160;</a></span>implementation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="structetl_1_1bitset.html">struct</a> <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154">implementation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1" name="a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1"></a>freestanding&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6a5c92ae723acdba8ce0f48be8530154a734d3030ff72ad8d9678efa82b1db7d2" name="a6a5c92ae723acdba8ce0f48be8530154a734d3030ff72ad8d9678efa82b1db7d2"></a>hosted&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a72411d869deb28d3d6a0f7d0d77dd1de" name="a72411d869deb28d3d6a0f7d0d77dd1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72411d869deb28d3d6a0f7d0d77dd1de">&#9670;&#160;</a></span>language_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="structetl_1_1bitset.html">struct</a> <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a> : <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">char</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for the currently selected C++ standard version. Unlike the official macro <code>__cplusplus</code>, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a72411d869deb28d3d6a0f7d0d77dd1dea6289bbfa378818f7066ccad5847da5a2" name="a72411d869deb28d3d6a0f7d0d77dd1dea6289bbfa378818f7066ccad5847da5a2"></a>cpp_17&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a72411d869deb28d3d6a0f7d0d77dd1dea4c7aabdc3eb0d845c62edfb822b0fe5a" name="a72411d869deb28d3d6a0f7d0d77dd1dea4c7aabdc3eb0d845c62edfb822b0fe5a"></a>cpp_20&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a72411d869deb28d3d6a0f7d0d77dd1deaf7d98f68372c9de30cc2d571b75b19d7" name="a72411d869deb28d3d6a0f7d0d77dd1deaf7d98f68372c9de30cc2d571b75b19d7"></a>cpp_23&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff" name="a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff"></a>cpp_26&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5d44cf8dff1d93939ca2e9adeec696a7" name="a5d44cf8dff1d93939ca2e9adeec696a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d44cf8dff1d93939ca2e9adeec696a7">&#9670;&#160;</a></span>abs() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee6fd8ce3d926357e36de32769335251" name="aee6fd8ce3d926357e36de32769335251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6fd8ce3d926357e36de32769335251">&#9670;&#160;</a></span>abs() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e2bd83e2ec37c5b1298fae188a15607" name="a5e2bd83e2ec37c5b1298fae188a15607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2bd83e2ec37c5b1298fae188a15607">&#9670;&#160;</a></span>abs() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">int</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a71ed298b66e9f2fdd041b0fa9c5df301" name="a71ed298b66e9f2fdd041b0fa9c5df301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ed298b66e9f2fdd041b0fa9c5df301">&#9670;&#160;</a></span>abs() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a342a8a68c9a0f5c3ff1b3d5857553906" name="a342a8a68c9a0f5c3ff1b3d5857553906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342a8a68c9a0f5c3ff1b3d5857553906">&#9670;&#160;</a></span>abs() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e1eb0ffb77caba7f8242da4a5d7470" name="a51e1eb0ffb77caba7f8242da4a5d7470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e1eb0ffb77caba7f8242da4a5d7470">&#9670;&#160;</a></span>abs() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21ae02f44cb9f415d79d030c8ceb8c16" name="a21ae02f44cb9f415d79d030c8ceb8c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ae02f44cb9f415d79d030c8ceb8c16">&#9670;&#160;</a></span>addressof() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;. </p>

</div>
</div>
<a id="a2b8d9c987fb1214a1989a00c3ac4d175" name="a2b8d9c987fb1214a1989a00c3ac4d175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8d9c987fb1214a1989a00c3ac4d175">&#9670;&#160;</a></span>addressof() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">is_object_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;. </p>

</div>
</div>
<a id="a951855af4ae6cd241993c4f6bde82de5" name="a951855af4ae6cd241993c4f6bde82de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951855af4ae6cd241993c4f6bde82de5">&#9670;&#160;</a></span>addressof() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> addressof </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a410a978255250c24ca74fad8f26910d9" name="a410a978255250c24ca74fad8f26910d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410a978255250c24ca74fad8f26910d9">&#9670;&#160;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">void</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>space</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned. </p>
<p>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns nullptr.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if alignment is not a power of two. </dd></dl>

</div>
</div>
<a id="a0f7d8fa4cd29bfaa5efc2ced210dd105" name="a0f7d8fa4cd29bfaa5efc2ced210dd105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7d8fa4cd29bfaa5efc2ced210dd105">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Tuple</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Tuple</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">auto</a>)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a087e608dcade676ed1707b2780820b4b" name="a087e608dcade676ed1707b2780820b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087e608dcade676ed1707b2780820b4b">&#9670;&#160;</a></span>as_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> as_const </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; add_const_t&lt;T&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms lvalue reference to const type of t. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a4">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a73fcc8395221077570ae4d49d16fdfb5" name="a73fcc8395221077570ae4d49d16fdfb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fcc8395221077570ae4d49d16fdfb5">&#9670;&#160;</a></span>as_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> as_const </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1bitset.html">void</a>=<a class="el" href="structetl_1_1bitset.html">delete</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcdd4cbf8740ceb15439f10eee6080ee" name="afcdd4cbf8740ceb15439f10eee6080ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdd4cbf8740ceb15439f10eee6080ee">&#9670;&#160;</a></span>assert_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Assertion</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> assert_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Assertion</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">void</a> 
</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="cassert_8cpp-example.html#a0">cassert.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae867798dd2ddddb86806aa99a0ae9101" name="ae867798dd2ddddb86806aa99a0ae9101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae867798dd2ddddb86806aa99a0ae9101">&#9670;&#160;</a></span>assume_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N, <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> assume_aligned </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Informs the implementation that the object ptr points to is aligned to at least N. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of assume_aligned. </p>
<p>The program is ill-formed if N is not a power of 2. The behavior is undefined if ptr does not point to an object of type T (ignoring cv-qualification at every level), or if the object's alignment is not at least N.</p>
<p><a href="https://en.cppreference.com/w/cpp/memory/assume_aligned">https://en.cppreference.com/w/cpp/memory/assume_aligned</a> </p>

</div>
</div>
<a id="a27bf898417a69084f2e08aa12510db7d" name="a27bf898417a69084f2e08aa12510db7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bf898417a69084f2e08aa12510db7d">&#9670;&#160;</a></span>atof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> atof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>

</div>
</div>
<a id="ae6b33a1df966c3e01d825b336211e3ef" name="ae6b33a1df966c3e01d825b336211e3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b33a1df966c3e01d825b336211e3ef">&#9670;&#160;</a></span>atoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> atoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="a699027607c1a0d56baf456931b915e76" name="a699027607c1a0d56baf456931b915e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699027607c1a0d56baf456931b915e76">&#9670;&#160;</a></span>atol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> atol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="aa7f1052e901c72fde401b3019f9437b1" name="aa7f1052e901c72fde401b3019f9437b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f1052e901c72fde401b3019f9437b1">&#9670;&#160;</a></span>atoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> atoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. </p>

</div>
</div>
<a id="ae80a7746c87d52a34bfff83262802d0d" name="ae80a7746c87d52a34bfff83262802d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80a7746c87d52a34bfff83262802d0d">&#9670;&#160;</a></span>back_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> back_inserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;<a class="el" href="structetl_1_1bitset.html">Container</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>back_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">back_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="aa615187d5a248ab9e6493944c709279e" name="aa615187d5a248ab9e6493944c709279e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa615187d5a248ab9e6493944c709279e">&#9670;&#160;</a></span>bind_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Func</a> , typename... BoundArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> bind_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Func</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">BoundArgs</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>boundArgs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function template bind_front generates a forwarding call wrapper for f. Calling this wrapper is equivalent to invoking f with its first sizeof...(Args) parameters bound to args. In other words, bind_front(f,
bound_args...)(call_args...) is equivalent to invoke(f, bound_args..., call_args....). </p>
<p>Copied implementation from paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0356r5.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0356r5.html</a> </p>

</div>
</div>
<a id="affc67214aa9016de19ce8c56cacf050f" name="affc67214aa9016de19ce8c56cacf050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc67214aa9016de19ce8c56cacf050f">&#9670;&#160;</a></span>cmp_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> cmp_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a5">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad7f8a2ce45cfed83d620b12d6271272f" name="ad7f8a2ce45cfed83d620b12d6271272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f8a2ce45cfed83d620b12d6271272f">&#9670;&#160;</a></span>cmp_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> cmp_greater </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a6fdcd304a94bdadbaa2c7d6fb267e05b" name="a6fdcd304a94bdadbaa2c7d6fb267e05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdcd304a94bdadbaa2c7d6fb267e05b">&#9670;&#160;</a></span>cmp_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> cmp_greater_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="af465587d2f32a80939be1fad202d81a8" name="af465587d2f32a80939be1fad202d81a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af465587d2f32a80939be1fad202d81a8">&#9670;&#160;</a></span>cmp_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> cmp_less </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type).</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="ae910ff92e0c20546b3798e7acf0f62a4" name="ae910ff92e0c20546b3798e7acf0f62a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae910ff92e0c20546b3798e7acf0f62a4">&#9670;&#160;</a></span>cmp_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> cmp_less_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>

</div>
</div>
<a id="a693945b83d4561846bbf0b5944d0296e" name="a693945b83d4561846bbf0b5944d0296e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693945b83d4561846bbf0b5944d0296e">&#9670;&#160;</a></span>cmp_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; <br />
requires etl::detail::comparable_integers&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> cmp_not_equal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). <a href="https://en.cppreference.com/w/cpp/utility/intcmp">https://en.cppreference.com/w/cpp/utility/intcmp</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a6">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7f5ec2df5d7caffa501049e08c135fc1" name="a7f5ec2df5d7caffa501049e08c135fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5ec2df5d7caffa501049e08c135fc1">&#9670;&#160;</a></span>construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args, <a class="el" href="structetl_1_1bitset.html">typename</a>  = decltype(::new(etl::declval&lt;void*&gt;()) T(etl::declval&lt;Args&gt;()...))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> construct_at </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a T object initialized with arguments args... at given address p. </p>

</div>
</div>
<a id="a3dede0554b7d9e1163a2be7f26702258" name="a3dede0554b7d9e1163a2be7f26702258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dede0554b7d9e1163a2be7f26702258">&#9670;&#160;</a></span>cref() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> cref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T <a class="el" href="structetl_1_1bitset.html">const</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5ad6e6c525e1d3fb61aa60cab9f9dc3" name="af5ad6e6c525e1d3fb61aa60cab9f9dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ad6e6c525e1d3fb61aa60cab9f9dc3">&#9670;&#160;</a></span>cref() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">void</a> cref </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09ebab5fc63c081909c10f9255347efb" name="a09ebab5fc63c081909c10f9255347efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ebab5fc63c081909c10f9255347efb">&#9670;&#160;</a></span>cref() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> cref </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T <a class="el" href="structetl_1_1bitset.html">const</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. module Utility. </p>

</div>
</div>
<a id="a22b47f7719fd7b8373b49b15d5f701fb" name="a22b47f7719fd7b8373b49b15d5f701fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b47f7719fd7b8373b49b15d5f701fb">&#9670;&#160;</a></span>declval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> declval </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  add_rvalue_reference_t&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad349bf22ae9342501dceb73d04bfcb7e" name="ad349bf22ae9342501dceb73d04bfcb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad349bf22ae9342501dceb73d04bfcb7e">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the objects in the range [first, last). </p>

</div>
</div>
<a id="ae14a8af642cc7dc92cca033c1eff9fad" name="ae14a8af642cc7dc92cca033c1eff9fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14a8af642cc7dc92cca033c1eff9fad">&#9670;&#160;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling destroy(begin(*p), end(*p)). </p>

</div>
</div>
<a id="a6d9f1ed59c6342c3bcd7f4ed746a0dda" name="a6d9f1ed59c6342c3bcd7f4ed746a0dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9f1ed59c6342c3bcd7f4ed746a0dda">&#9670;&#160;</a></span>destroy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Size</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> destroy_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Size</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">ForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the n objects in the range starting at first. </p>

</div>
</div>
<a id="a2a2d6bdea1596be40cc1f1965d14d3a7" name="a2a2d6bdea1596be40cc1f1965d14d3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2d6bdea1596be40cc1f1965d14d3a7">&#9670;&#160;</a></span>div() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1div__t.html">div_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a6482fb76727697ae2e8c3d2da7de28d7" name="a6482fb76727697ae2e8c3d2da7de28d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6482fb76727697ae2e8c3d2da7de28d7">&#9670;&#160;</a></span>div() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="afe969af8a9f77fea0bb9e0d7a82c5b3f" name="afe969af8a9f77fea0bb9e0d7a82c5b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe969af8a9f77fea0bb9e0d7a82c5b3f">&#9670;&#160;</a></span>div() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="ad0457bf90404832209a27ed391d14e9f" name="ad0457bf90404832209a27ed391d14e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0457bf90404832209a27ed391d14e9f">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that compare equal to value from the container. </p>

</div>
</div>
<a id="ab2e72fc74a7231310049a5cb0790c765" name="ab2e72fc74a7231310049a5cb0790c765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e72fc74a7231310049a5cb0790c765">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt;T, <a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5826b2aecc2787206e14b1db8db393f" name="ad5826b2aecc2787206e14b1db8db393f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5826b2aecc2787206e14b1db8db393f">&#9670;&#160;</a></span>erase_if() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate pred from the container. </p>

</div>
</div>
<a id="ad89568833148c25f186a180cef490087" name="ad89568833148c25f186a180cef490087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89568833148c25f186a180cef490087">&#9670;&#160;</a></span>erase_if() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Pred</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1flat__set.html">etl::flat_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Container</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Pred</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1flat__set.html">etl::flat_set</a>&lt;<a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Container</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ae66b21dd10f996a2782e6e8b604593" name="a9ae66b21dd10f996a2782e6e8b604593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae66b21dd10f996a2782e6e8b604593">&#9670;&#160;</a></span>erase_if() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt;T, <a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;::size_type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements that satisfy the predicate pred from the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of erased elements.</dd></dl>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/erase2">https://en.cppreference.com/w/cpp/container/vector/erase2</a> </p>

</div>
</div>
<a id="a7c1576e57ae3b113a38b8a9793bb4074" name="a7c1576e57ae3b113a38b8a9793bb4074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1576e57ae3b113a38b8a9793bb4074">&#9670;&#160;</a></span>exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> exchange </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>newValue</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the value of obj with new_value and returns the old value of obj. </p>
<dl class="section return"><dt>Returns</dt><dd>The old value of obj. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a2">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8161915e533ff99801f4017d6737d978" name="a8161915e533ff99801f4017d6737d978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8161915e533ff99801f4017d6737d978">&#9670;&#160;</a></span>extents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Integrals&gt; <br />
requires (<a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">etl::is_convertible_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">Integrals</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>&gt; <a class="el" href="structetl_1_1bitset.html">and</a> ...)</div>
      <table class="memname">
        <tr>
          <td class="memname">extents </td>
          <td>(</td>
          <td class="paramtype">Integrals...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  extents&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>((<a class="el" href="structetl_1_1bitset.html">Integrals</a>(), <a class="el" href="group__span.html#ga22e7be40fea564f0c1fe3d11229ef0f8">etl::dynamic_extent</a>))... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc2dd0f4e4c727042a49eb7a07534b4d" name="abc2dd0f4e4c727042a49eb7a07534b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2dd0f4e4c727042a49eb7a07534b4d">&#9670;&#160;</a></span>fabs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad1cf30946e4d50ba41f9328a82e2e62" name="aad1cf30946e4d50ba41f9328a82e2e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1cf30946e4d50ba41f9328a82e2e62">&#9670;&#160;</a></span>fabs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3fbc2879eaeb897fcaf8de7bd117125" name="af3fbc2879eaeb897fcaf8de7bd117125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fbc2879eaeb897fcaf8de7bd117125">&#9670;&#160;</a></span>fabs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> fabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9183bd4ec44e90e6830581cf15f8d165" name="a9183bd4ec44e90e6830581cf15f8d165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9183bd4ec44e90e6830581cf15f8d165">&#9670;&#160;</a></span>fabsf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> fabsf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">float</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">float</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01976f0c02d8a34fad11dff21277f288" name="a01976f0c02d8a34fad11dff21277f288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01976f0c02d8a34fad11dff21277f288">&#9670;&#160;</a></span>fabsl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> fabsl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a142c844e65677a96dcb134681d85e8a2" name="a142c844e65677a96dcb134681d85e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142c844e65677a96dcb134681d85e8a2">&#9670;&#160;</a></span>format_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> format_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format args according to the format string fmt, and write the result to the output iterator out. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/format_to">https://en.cppreference.com/w/cpp/utility/format/format_to</a> </p>

</div>
</div>
<a id="afa2b8092a29056d823a289eb08a11484" name="afa2b8092a29056d823a289eb08a11484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2b8092a29056d823a289eb08a11484">&#9670;&#160;</a></span>format_to_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIter</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> format_to_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">OutputIter</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a05dfe0d6b5c463f72f72a6bf14e21b0f">diff_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">OutputIter</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1format__to__n__result.html">format_to_n_result</a>&lt;<a class="el" href="structetl_1_1bitset.html">OutputIter</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format args according to the format string fmt, and write the result to the output iterator out. At most n characters are written. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/format/format_to_n">https://en.cppreference.com/w/cpp/utility/format/format_to_n</a> </p>

</div>
</div>
<a id="a6a7e67893a6b3c341ea0624e30e1d89d" name="a6a7e67893a6b3c341ea0624e30e1d89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7e67893a6b3c341ea0624e30e1d89d">&#9670;&#160;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea04c6a544a650bcf6a7f88ff623c80f" name="aea04c6a544a650bcf6a7f88ff623c80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea04c6a544a650bcf6a7f88ff623c80f">&#9670;&#160;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards lvalues as either lvalues or as rvalues, depending on T. When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/forward">https://en.cppreference.com/w/cpp/utility/forward</a> </p>

</div>
</div>
<a id="a73855f5edc16acf9ba653c540059bf5c" name="a73855f5edc16acf9ba653c540059bf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73855f5edc16acf9ba653c540059bf5c">&#9670;&#160;</a></span>forward_as_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> forward_as_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt;<a class="el" href="structetl_1_1bitset.html">Args</a>&amp;&amp;...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a tuple of references to the arguments in args suitable for forwarding as an argument to a function. The tuple has rvalue reference data members when rvalues are used as arguments, and otherwise has lvalue reference data members. </p>

</div>
</div>
<a id="a881439150ce3ae249968cc8b15d6e31d" name="a881439150ce3ae249968cc8b15d6e31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881439150ce3ae249968cc8b15d6e31d">&#9670;&#160;</a></span>forward_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> forward_like </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57744d86f1f45347bc48d426591e1ce1" name="a57744d86f1f45347bc48d426591e1ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57744d86f1f45347bc48d426591e1ce1">&#9670;&#160;</a></span>from_chars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; <br />
requires (<a class="el" href="structetl_1_1bitset.html">not</a> same_as&lt;<a class="el" href="structetl_1_1bitset.html">Int</a>, <a class="el" href="structetl_1_1bitset.html">bool</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> from_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1from__chars__result.html">from_chars_result</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyzes the character sequence [first,last) for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of value, value is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in value. </p>

</div>
</div>
<a id="aa8cd5fdd90a750ceb082da63058a6816" name="aa8cd5fdd90a750ceb082da63058a6816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cd5fdd90a750ceb082da63058a6816">&#9670;&#160;</a></span>front_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> front_inserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1front__insert__iterator.html">front_insert_iterator</a>&lt;<a class="el" href="structetl_1_1bitset.html">Container</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>front_inserter is a convenience function template that constructs a <a class="el" href="structetl_1_1front__insert__iterator.html" title="front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it w...">front_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="abdcfb06e9497d99667ce90201fa5c056" name="abdcfb06e9497d99667ce90201fa5c056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcfb06e9497d99667ce90201fa5c056">&#9670;&#160;</a></span>function_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">R</a>(*</td>          <td class="paramname"><span class="paramname"><em>&#160;</em></span>)(Args...)</td><td>)</td>
          <td> -&gt;  function_ref&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2afb17c2e9b1ec115692dd31cdf6574" name="af2afb17c2e9b1ec115692dd31cdf6574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2afb17c2e9b1ec115692dd31cdf6574">&#9670;&#160;</a></span>get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a>&gt;&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="ab277e7f8a028602ec26923ca3a4efe8e" name="ab277e7f8a028602ec26923ca3a4efe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab277e7f8a028602ec26923ca3a4efe8e">&#9670;&#160;</a></span>get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a>&gt;&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="a8cf3dcd4caaf2ac0322f3ee3dd4d5123" name="a8cf3dcd4caaf2ac0322f3ee3dd4d5123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf3dcd4caaf2ac0322f3ee3dd4d5123">&#9670;&#160;</a></span>get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a>&gt;&gt; <a class="el" href="structetl_1_1bitset.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="a2437363ad77d75596d13cf069467823c" name="a2437363ad77d75596d13cf069467823c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2437363ad77d75596d13cf069467823c">&#9670;&#160;</a></span>get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88df1a5f5c335cb6cf4909b47882e53">tuple_element_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>, <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a>&gt;&gt; <a class="el" href="structetl_1_1bitset.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an element from the pair using tuple-like interface. </p>
<p>The index-based overloads (1-4) fail to compile if the index I is neither 0 nor 1. See Alisdar Meredith talk "Recreational C++" 35:00 to 46:00. <a href="https://youtu.be/ovxNM865WaU">https://youtu.be/ovxNM865WaU</a> </p>

</div>
</div>
<a id="ae2bc2983c6b858933480a19a9f6ca6f6" name="ae2bc2983c6b858933480a19a9f6ca6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bc2983c6b858933480a19a9f6ca6f6">&#9670;&#160;</a></span>get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8214f25116b3dd5ee4ecd4605b8e5cf8" name="a8214f25116b3dd5ee4ecd4605b8e5cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214f25116b3dd5ee4ecd4605b8e5cf8">&#9670;&#160;</a></span>get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6da5e04ad6238c60c904e4c9ac6bc5e9" name="a6da5e04ad6238c60c904e4c9ac6bc5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da5e04ad6238c60c904e4c9ac6bc5e9">&#9670;&#160;</a></span>get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">const</a>&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa05f6f308ed4004eec8f0b4559371a0f" name="aa05f6f308ed4004eec8f0b4559371a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05f6f308ed4004eec8f0b4559371a0f">&#9670;&#160;</a></span>get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade109c386a760b9572261c6afe7dbdf8" name="ade109c386a760b9572261c6afe7dbdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade109c386a760b9572261c6afe7dbdf8">&#9670;&#160;</a></span>get_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt;  add_pointer_t&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade2d2fedb0567e3c7742e87fd799b82c" name="ade2d2fedb0567e3c7742e87fd799b82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2d2fedb0567e3c7742e87fd799b82c">&#9670;&#160;</a></span>get_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Types... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>pv</em></span></td><td>)</td>
          <td> -&gt;  add_pointer_t&lt; T <a class="el" href="structetl_1_1bitset.html">const</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad27e213c027bfb11ed648fb543842995" name="ad27e213c027bfb11ed648fb543842995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27e213c027bfb11ed648fb543842995">&#9670;&#160;</a></span>ignore_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> ignore_unused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Types</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly ignore arguments or variables. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_struct" href="structetl_1_1bitset.html">main</a>(<span class="keywordtype">int</span> <a class="code hl_struct" href="structetl_1_1bitset.html">argc</a>, <span class="keywordtype">char</span>** <a class="code hl_struct" href="structetl_1_1bitset.html">argv</a>) -&gt; <span class="keywordtype">int</span></div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="#ad27e213c027bfb11ed648fb543842995">etl::ignore_unused</a>(<a class="code hl_struct" href="structetl_1_1bitset.html">argc</a>, <a class="code hl_struct" href="structetl_1_1bitset.html">argv</a>);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceetl_html_ad27e213c027bfb11ed648fb543842995"><div class="ttname"><a href="#ad27e213c027bfb11ed648fb543842995">etl::ignore_unused</a></div><div class="ttdeci">constexpr auto ignore_unused(Types &amp;&amp;...) -&gt; void</div><div class="ttdoc">Explicitly ignore arguments or variables.</div><div class="ttdef"><b>Definition</b> ignore_unused.hpp:17</div></div>
<div class="ttc" id="astructetl_1_1bitset_html"><div class="ttname"><a href="structetl_1_1bitset.html">etl::bitset</a></div><div class="ttdoc">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by s...</div><div class="ttdef"><b>Definition</b> bitset.hpp:24</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a86319ce6c017b8e0cbaed828b6dad2f7" name="a86319ce6c017b8e0cbaed828b6dad2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86319ce6c017b8e0cbaed828b6dad2f7">&#9670;&#160;</a></span>ilog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> ilog2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06254a010da20091fb04d67702c29da3" name="a06254a010da20091fb04d67702c29da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06254a010da20091fb04d67702c29da3">&#9670;&#160;</a></span>in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires etl::detail::integer_and_not_char&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> in_range </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss. </p>
<p>It is a compile-time error if either T or R is not a signed or unsigned integer type (including standard integer type and extended integer type). This function cannot be used with <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>, char, char8_t, char16_t, char32_t, wchar_t and bool.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/in_range">https://en.cppreference.com/w/cpp/utility/in_range</a> </p>

</div>
</div>
<a id="aabdaffbfe13a56a7417bfdd32d335dd6" name="aabdaffbfe13a56a7417bfdd32d335dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdaffbfe13a56a7417bfdd32d335dd6">&#9670;&#160;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; invoke_result_t&lt;<a class="el" href="structetl_1_1bitset.html">F</a>, Args...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo</a></b></dt><dd>Add noexcept(is_nothrow_invocable_v&lt;F, Args...&gt;) </dd></dl>

</div>
</div>
<a id="a4b8b1e57bc5b47496c1898878c7d6916" name="a4b8b1e57bc5b47496c1898878c7d6916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8b1e57bc5b47496c1898878c7d6916">&#9670;&#160;</a></span>invoke_r()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> , typename... Args&gt; <br />
requires (<a class="el" href="#a79bb140a0b590bb8a6eadea52d880d17">etl::is_invocable_r_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">R</a>, <a class="el" href="structetl_1_1bitset.html">F</a>, Args...&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> invoke_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">R</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo</a></b></dt><dd>Add noexcept(is_nothrow_invocable_r_v&lt;R, F, Args...&gt;) </dd></dl>

</div>
</div>
<a id="afabc2a74c91be5a9c6b446824c7d2cee" name="afabc2a74c91be5a9c6b446824c7d2cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabc2a74c91be5a9c6b446824c7d2cee">&#9670;&#160;</a></span>ipow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">auto</a> Base&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> ipow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">Base</a>)</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">Base</a>)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0af1eade8d7b506ab0a6732e681a803b" name="a0af1eade8d7b506ab0a6732e681a803b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af1eade8d7b506ab0a6732e681a803b">&#9670;&#160;</a></span>ipow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> ipow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a135ea1c61ce77c9bf27e83df6a1fec64" name="a135ea1c61ce77c9bf27e83df6a1fec64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135ea1c61ce77c9bf27e83df6a1fec64">&#9670;&#160;</a></span>is_constant_evaluated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_constant_evaluated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_constant_evaluated">https://en.cppreference.com/w/cpp/types/is_constant_evaluated</a> </p>

</div>
</div>
<a id="adcf6fdfc0878be3154d7671edc95de7f" name="adcf6fdfc0878be3154d7671edc95de7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf6fdfc0878be3154d7671edc95de7f">&#9670;&#160;</a></span>is_freestanding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_freestanding </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">consteval</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5914a0a90f9a279328bcadc57b7ce090" name="a5914a0a90f9a279328bcadc57b7ce090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5914a0a90f9a279328bcadc57b7ce090">&#9670;&#160;</a></span>is_hosted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_hosted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">consteval</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f7a4153c0b6a56949cfa7691169049b" name="a1f7a4153c0b6a56949cfa7691169049b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7a4153c0b6a56949cfa7691169049b">&#9670;&#160;</a></span>isfinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> isfinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a25b70d7be5ca34b77def3ff9950ef1cc" name="a25b70d7be5ca34b77def3ff9950ef1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b70d7be5ca34b77def3ff9950ef1cc">&#9670;&#160;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> isinf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8986c9bc042cb46d1874b992a453180" name="ab8986c9bc042cb46d1874b992a453180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8986c9bc042cb46d1874b992a453180">&#9670;&#160;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> isnan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf694dfa4152d5e19dfb263a24d0b3fd" name="aaf694dfa4152d5e19dfb263a24d0b3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf694dfa4152d5e19dfb263a24d0b3fd">&#9670;&#160;</a></span>isnormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> isnormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bafeda54d634206adcb005c3ec87be3" name="a6bafeda54d634206adcb005c3ec87be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bafeda54d634206adcb005c3ec87be3">&#9670;&#160;</a></span>labs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> labs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a817f60653f2167239f303e63ec82d4d8" name="a817f60653f2167239f303e63ec82d4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817f60653f2167239f303e63ec82d4d8">&#9670;&#160;</a></span>ldiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> ldiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1ldiv__t.html">ldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a44d83917d527505e29d3a8d3afb413bc" name="a44d83917d527505e29d3a8d3afb413bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d83917d527505e29d3a8d3afb413bc">&#9670;&#160;</a></span>llabs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> llabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type. If abs is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed. </p>

</div>
</div>
<a id="a540df0e14af1fb716877eb210bd107b5" name="a540df0e14af1fb716877eb210bd107b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540df0e14af1fb716877eb210bd107b5">&#9670;&#160;</a></span>lldiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> lldiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1lldiv__t.html">lldiv_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes both the quotient and the remainder of the division of the numerator x by the denominator y. The quotient is the result of the expression x/y. The remainder is the result of the expression xy. </p>

</div>
</div>
<a id="a0bc7cabf52200c976eb934c6de9399fb" name="a0bc7cabf52200c976eb934c6de9399fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc7cabf52200c976eb934c6de9399fb">&#9670;&#160;</a></span>make_format_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Context</a>  = etl::format_context, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> make_format_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; detail::format_arg_store&lt;<a class="el" href="structetl_1_1bitset.html">Context</a>, Args...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ae0d54a117c055337810c0829b22eaf" name="a1ae0d54a117c055337810c0829b22eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae0d54a117c055337810c0829b22eaf">&#9670;&#160;</a></span>make_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Tuple</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> make_from_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Tuple</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a944300e491e850f5e82717c7a66b5463" name="a944300e491e850f5e82717c7a66b5463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944300e491e850f5e82717c7a66b5463">&#9670;&#160;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> make_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">T1</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">T2</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">T1</a>&gt;, <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">T2</a>&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments. </p>
<p>The deduced types V1 and V2 are <a class="el" href="structetl_1_1decay.html#acb0ece98c8acefaf9568a99493769e96">etl::decay&lt;T1&gt;::type</a> and <a class="el" href="structetl_1_1decay.html#acb0ece98c8acefaf9568a99493769e96">etl::decay&lt;T2&gt;::type</a> (the usual type transformations applied to arguments of functions passed by value).</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/pair/make_pair">https://en.cppreference.com/w/cpp/utility/pair/make_pair</a> </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a8">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af0773cf088e3cccbce2905050fcdd0eb" name="af0773cf088e3cccbce2905050fcdd0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0773cf088e3cccbce2905050fcdd0eb">&#9670;&#160;</a></span>make_reverse_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> make_reverse_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Iter</a></td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt;<a class="el" href="structetl_1_1bitset.html">Iter</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function template that constructs a <a class="el" href="structetl_1_1reverse__iterator.html" title="reverse_iterator is an iterator adaptor that reverses the direction of a given iterator....">etl::reverse_iterator</a> for the given iterator i (which must be a LegacyBidirectionalIterator) with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="a3b36b4f297a155e09e83fcca0b06d279" name="a3b36b4f297a155e09e83fcca0b06d279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b36b4f297a155e09e83fcca0b06d279">&#9670;&#160;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> make_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tuple object, deducing the target type from the types of arguments. </p>

</div>
</div>
<a id="ae6a9f575220aa9ab48e4d48b82093698" name="ae6a9f575220aa9ab48e4d48b82093698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a9f575220aa9ab48e4d48b82093698">&#9670;&#160;</a></span>make_wformat_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> make_wformat_args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; detail::format_arg_store&lt;<a class="el" href="#a03b255764cde83db44d0e61eebc55d36">wformat_context</a>, Args...&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fe0d774229c098831602663bd591f28" name="a1fe0d774229c098831602663bd591f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe0d774229c098831602663bd591f28">&#9670;&#160;</a></span>mdspan() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CArray</a> &gt; <br />
requires (<a class="el" href="#a8b0e44222b6a1dc103286f3c5225ad93">is_array_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">CArray</a>&gt; &amp;&amp; <a class="el" href="#a3c66bceba9ac1596666a40596ddf9b62">rank_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">CArray</a>&gt; == 1)</div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  mdspan&lt; <a class="el" href="#a0ffde65d0200b12233a0dff1979cc210">remove_all_extents_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">CArray</a> &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, <a class="el" href="#a06332dc22e85765f2c195c703cc49068">extent_v</a>&lt; <a class="el" href="structetl_1_1bitset.html">CArray</a>, 0 &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc4c4186488804dd6af16be8ffb48af4" name="adc4c4186488804dd6af16be8ffb48af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4c4186488804dd6af16be8ffb48af4">&#9670;&#160;</a></span>mdspan() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ElementType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">IndexType</a> , size_t... ExtentsPack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1bitset.html">IndexType</a>, ExtentsPack... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1bitset.html">ElementType</a>, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="structetl_1_1bitset.html">IndexType</a>, ExtentsPack... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82de4f51577f9cfd914c0f916caf46fc" name="a82de4f51577f9cfd914c0f916caf46fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82de4f51577f9cfd914c0f916caf46fc">&#9670;&#160;</a></span>mdspan() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ElementType</a> , typename... Integrals&gt; <br />
requires ((<a class="el" href="#adf5e75c4b12aa7982c5a97a14510ab35">is_convertible_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">Integrals</a>, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt; &amp;&amp; ...) &amp;&amp; sizeof...(<a class="el" href="structetl_1_1bitset.html">Integrals</a>) &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integrals...</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1bitset.html">ElementType</a>, <a class="el" href="#ac53bcc0a66170293af1f9319d4663d1a">dextents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>, sizeof...(<a class="el" href="structetl_1_1bitset.html">Integrals</a>)&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc583d3a74b54cf8a1b2f2de409a2b74" name="abc583d3a74b54cf8a1b2f2de409a2b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc583d3a74b54cf8a1b2f2de409a2b74">&#9670;&#160;</a></span>mdspan() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ElementType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">MappingType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ElementType</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">MappingType</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1bitset.html">ElementType</a>, <a class="el" href="structetl_1_1bitset.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1bitset.html">typename</a> MappingType::layout_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa581bd5419c1b5ce63db2ceefe37b971" name="aa581bd5419c1b5ce63db2ceefe37b971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa581bd5419c1b5ce63db2ceefe37b971">&#9670;&#160;</a></span>mdspan() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Pointer</a> &gt; <br />
requires (<a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">is_pointer_v</a>&lt;<a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Pointer</a>&gt;&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Pointer</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  mdspan&lt; <a class="el" href="#a81cba9b583535ccfde0e7eb172bbec71">remove_pointer_t</a>&lt; <a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">remove_reference_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">Pointer</a> &gt; &gt;, <a class="el" href="structetl_1_1extents.html">extents</a>&lt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f0eace36bd684274a175bbf90c48247" name="a0f0eace36bd684274a175bbf90c48247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0eace36bd684274a175bbf90c48247">&#9670;&#160;</a></span>mdspan() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">MappingType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">AccessorType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mdspan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">typename</a> AccessorType::data_handle_type <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">MappingType</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">AccessorType</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  mdspan&lt; <a class="el" href="structetl_1_1bitset.html">typename</a> AccessorType::element_type, <a class="el" href="structetl_1_1bitset.html">typename</a> MappingType::extents_type, <a class="el" href="structetl_1_1bitset.html">typename</a> MappingType::layout_type, <a class="el" href="structetl_1_1bitset.html">AccessorType</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05cc526e4d807581e208306a999a8a51" name="a05cc526e4d807581e208306a999a8a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cc526e4d807581e208306a999a8a51">&#9670;&#160;</a></span>mismatch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1bitset.html">InputIt1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a371e9767b06eb932a467448a6e8e32fc" name="a371e9767b06eb932a467448a6e8e32fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371e9767b06eb932a467448a6e8e32fc">&#9670;&#160;</a></span>mismatch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1bitset.html">InputIt1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1833ff8cfefd00fbce92848e93af31e4" name="a1833ff8cfefd00fbce92848e93af31e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1833ff8cfefd00fbce92848e93af31e4">&#9670;&#160;</a></span>mismatch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt2</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Predicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> mismatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>first1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt1</a></td>          <td class="paramname"><span class="paramname"><em>last1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>first2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt2</a></td>          <td class="paramname"><span class="paramname"><em>last2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Predicate</a></td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1pair.html">pair</a>&lt;<a class="el" href="structetl_1_1bitset.html">InputIt1</a>, <a class="el" href="structetl_1_1bitset.html">InputIt2</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adeb87647bd4c378500cd694ccc0e4608" name="adeb87647bd4c378500cd694ccc0e4608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb87647bd4c378500cd694ccc0e4608">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="group__type__traits.html#ga5993e4587ccd2777e95893329360358a">etl::remove_reference_t</a>&lt;T&gt;&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type. </p>
<dl class="section return"><dt>Returns</dt><dd><code>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t)</code> </dd></dl>

</div>
</div>
<a id="ae197a91f87223433229090889ab96734" name="ae197a91f87223433229090889ab96734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae197a91f87223433229090889ab96734">&#9670;&#160;</a></span>move_if_noexcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> move_if_noexcept </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#a09d091a01d0f719c0e795ed347e18a6d">etl::conditional_t</a>&lt;!<a class="el" href="#a34e3584e54b63fd9e6a35fffd41080bd">etl::is_nothrow_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="#a03f5da2852be4424089f4235ef44dec2">etl::is_copy_constructible_v</a>&lt;T&gt;, T <a class="el" href="structetl_1_1bitset.html">const</a>&amp;, T&amp;&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally convert a value to an rvalue. </p>
<p>Same as <a class="el" href="group__algorithm.html#ga9060e0931516472a88f4657d835684a9" title="Moves the elements in the range [first, last), to another range beginning at destination,...">etl::move</a> unless the type's move constructor could throw and the type is copyable, in which case an lvalue-reference is returned instead. </p>

</div>
</div>
<a id="a92780374b4fcf868ff0a7cb7dddaa385" name="a92780374b4fcf868ff0a7cb7dddaa385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92780374b4fcf868ff0a7cb7dddaa385">&#9670;&#160;</a></span>not_fn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">auto</a> ConstFn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> not_fn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; detail::stateless_not_fn&lt;<a class="el" href="structetl_1_1bitset.html">ConstFn</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea99b0f54121ebdd09e467ea46f3f865" name="aea99b0f54121ebdd09e467ea46f3f865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea99b0f54121ebdd09e467ea46f3f865">&#9670;&#160;</a></span>not_fn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> not_fn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">F</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td> -&gt; detail::not_fn_t&lt;<a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">etl::decay_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">F</a>&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a477060cd9d79c15a82456242a3005517" name="a477060cd9d79c15a82456242a3005517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477060cd9d79c15a82456242a3005517">&#9670;&#160;</a></span>nth_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> nth_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>nth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99e5b0ddb23a7821301be31ebd8198ea" name="a99e5b0ddb23a7821301be31ebd8198ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e5b0ddb23a7821301be31ebd8198ea">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a0c27b4cf9bc931994626a2ef5dccdd31" name="a0c27b4cf9bc931994626a2ef5dccdd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c27b4cf9bc931994626a2ef5dccdd31">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21ed7f0af0742e1a5ac4571b8a0cb1f8" name="a21ed7f0af0742e1a5ac4571b8a0cb1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ed7f0af0742e1a5ac4571b8a0cb1f8">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab49422796568a3674505ac60670c4010" name="ab49422796568a3674505ac60670c4010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49422796568a3674505ac60670c4010">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a8f52b3227280e130c8b8d2a8c424c4c0" name="a8f52b3227280e130c8b8d2a8c424c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f52b3227280e130c8b8d2a8c424c4c0">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="aa42d5ab2b854a73191219d9dd7768be5" name="aa42d5ab2b854a73191219d9dd7768be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42d5ab2b854a73191219d9dd7768be5">&#9670;&#160;</a></span>operator!=() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a4874c4f433c6b61ab0bf85023f138b4c" name="a4874c4f433c6b61ab0bf85023f138b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4874c4f433c6b61ab0bf85023f138b4c">&#9670;&#160;</a></span>operator!=() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a677b4c86284624fe83dc36333e3d4212" name="a677b4c86284624fe83dc36333e3d4212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677b4c86284624fe83dc36333e3d4212">&#9670;&#160;</a></span>operator!=() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Rhs</a> , <a class="el" href="structetl_1_1bitset.html">Rhs</a> R, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Lhs</a> , <a class="el" href="structetl_1_1bitset.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Rhs</a>, <a class="el" href="structetl_1_1bitset.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Lhs</a>, <a class="el" href="structetl_1_1bitset.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">bool</a>, <a class="el" href="structetl_1_1bitset.html">L</a> != <a class="el" href="structetl_1_1bitset.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd7d0d2c778d8ba04d8b73a77fec5d83" name="afd7d0d2c778d8ba04d8b73a77fec5d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7d0d2c778d8ba04d8b73a77fec5d83">&#9670;&#160;</a></span>operator!=() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdfdea32a40caa3a28fb120ded25d66e" name="afdfdea32a40caa3a28fb120ded25d66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfdea32a40caa3a28fb120ded25d66e">&#9670;&#160;</a></span>operator!=() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a3b524b62bdc9f0a6c515bb44965cb68c" name="a3b524b62bdc9f0a6c515bb44965cb68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b524b62bdc9f0a6c515bb44965cb68c">&#9670;&#160;</a></span>operator!=() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="a473df8e3ace08ad49d812cd57fcc5f90" name="a473df8e3ace08ad49d812cd57fcc5f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473df8e3ace08ad49d812cd57fcc5f90">&#9670;&#160;</a></span>operator!=() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87b2c8e96c56c4b8a13d0a122cf47b17" name="a87b2c8e96c56c4b8a13d0a122cf47b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b2c8e96c56c4b8a13d0a122cf47b17">&#9670;&#160;</a></span>operator!=() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e91ff1be82212d980d87b1b7eee50ae" name="a3e91ff1be82212d980d87b1b7eee50ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e91ff1be82212d980d87b1b7eee50ae">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1bitset.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary AND between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="a86219208a90a3dde7323cc44e0df0ef4" name="a86219208a90a3dde7323cc44e0df0ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86219208a90a3dde7323cc44e0df0ef4">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) &amp; static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a99fb7a75a06b494847b855d850a44918" name="a99fb7a75a06b494847b855d850a44918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb7a75a06b494847b855d850a44918">&#9670;&#160;</a></span>operator&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&amp; </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d19ed615073fb38a2b13da90e273c7c" name="a7d19ed615073fb38a2b13da90e273c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d19ed615073fb38a2b13da90e273c7c">&#9670;&#160;</a></span>operator&amp;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs &amp; rhs;</code> </p>

</div>
</div>
<a id="a2fcea5ac2499171347312a5f20051970" name="a2fcea5ac2499171347312a5f20051970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcea5ac2499171347312a5f20051970">&#9670;&#160;</a></span>operator&amp;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&amp;= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1bitset.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade01d8f935d63f6d9cba9fbe323f8821" name="ade01d8f935d63f6d9cba9fbe323f8821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade01d8f935d63f6d9cba9fbe323f8821">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9749f0f6e219a2633cc87acdfe48904" name="af9749f0f6e219a2633cc87acdfe48904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9749f0f6e219a2633cc87acdfe48904">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfad387b2163cd13b324a0f466cb12cd" name="acfad387b2163cd13b324a0f466cb12cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfad387b2163cd13b324a0f466cb12cd">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>* </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c02fa2b4e3d75149c7c267b0b86789e" name="a7c02fa2b4e3d75149c7c267b0b86789e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c02fa2b4e3d75149c7c267b0b86789e">&#9670;&#160;</a></span>operator+() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="ae3b2ef0a592d24d47bd878ebab0b1fcd" name="ae3b2ef0a592d24d47bd878ebab0b1fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b2ef0a592d24d47bd878ebab0b1fcd">&#9670;&#160;</a></span>operator+() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a965bb0b68cd6953bbc4bea8deb155b75" name="a965bb0b68cd6953bbc4bea8deb155b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965bb0b68cd6953bbc4bea8deb155b75">&#9670;&#160;</a></span>operator+() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="accf2684bd57acf26e10d868de8ee378e" name="accf2684bd57acf26e10d868de8ee378e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf2684bd57acf26e10d868de8ee378e">&#9670;&#160;</a></span>operator+() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="addfb1769b71b9cc8fa1deda92b613ca6" name="addfb1769b71b9cc8fa1deda92b613ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfb1769b71b9cc8fa1deda92b613ca6">&#9670;&#160;</a></span>operator+() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1basic__inplace__string.html">basic_inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string containing characters from lhs followed by the characters from rhs. </p>

</div>
</div>
<a id="a71864baa5b16ae3823bed93daadd854e" name="a71864baa5b16ae3823bed93daadd854e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71864baa5b16ae3823bed93daadd854e">&#9670;&#160;</a></span>operator+() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd2343a7c24574c0a76def77f277d07e" name="afd2343a7c24574c0a76def77f277d07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2343a7c24574c0a76def77f277d07e">&#9670;&#160;</a></span>operator+() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f1ea907ad0e2faef6a9dc5daae77f10" name="a8f1ea907ad0e2faef6a9dc5daae77f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1ea907ad0e2faef6a9dc5daae77f10">&#9670;&#160;</a></span>operator+() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab218217c542cbcae689d277e927d360a" name="ab218217c542cbcae689d277e927d360a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab218217c542cbcae689d277e927d360a">&#9670;&#160;</a></span>operator+() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Rhs</a> , <a class="el" href="structetl_1_1bitset.html">Rhs</a> R, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Lhs</a> , <a class="el" href="structetl_1_1bitset.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Rhs</a>, <a class="el" href="structetl_1_1bitset.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Lhs</a>, <a class="el" href="structetl_1_1bitset.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">decltype</a>(<a class="el" href="structetl_1_1bitset.html">L</a> + <a class="el" href="structetl_1_1bitset.html">R</a>), <a class="el" href="structetl_1_1bitset.html">L</a> + <a class="el" href="structetl_1_1bitset.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a278c443da9c85213dd35424e55083798" name="a278c443da9c85213dd35424e55083798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278c443da9c85213dd35424e55083798">&#9670;&#160;</a></span>operator+() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6132e0e8e9af5871d3647489c0e9ab7f" name="a6132e0e8e9af5871d3647489c0e9ab7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6132e0e8e9af5871d3647489c0e9ab7f">&#9670;&#160;</a></span>operator+() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt;::difference_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt;<a class="el" href="structetl_1_1bitset.html">Iter</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator it incremented by n. </p>

</div>
</div>
<a id="a368b52e0bd3a7839fd60d3f5e39cbb0f" name="a368b52e0bd3a7839fd60d3f5e39cbb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368b52e0bd3a7839fd60d3f5e39cbb0f">&#9670;&#160;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af027a8b3ad1bb5ca5f5179ed2206ad66" name="af027a8b3ad1bb5ca5f5179ed2206ad66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af027a8b3ad1bb5ca5f5179ed2206ad66">&#9670;&#160;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8518792aba8f0c6bfdf3518364ab586c" name="a8518792aba8f0c6bfdf3518364ab586c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8518792aba8f0c6bfdf3518364ab586c">&#9670;&#160;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d97b143943fdd5165246151965e6e1a" name="a2d97b143943fdd5165246151965e6e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d97b143943fdd5165246151965e6e1a">&#9670;&#160;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iterator1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iterator2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iterator1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iterator2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">decltype</a>(rhs.base() - lhs.base())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between two iterator adaptors. </p>

</div>
</div>
<a id="aaa390de4495e3c0ec93c4491c5639143" name="aaa390de4495e3c0ec93c4491c5639143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa390de4495e3c0ec93c4491c5639143">&#9670;&#160;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>- </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1b89ab01f9efe7650b6a97888f1e869" name="ac1b89ab01f9efe7650b6a97888f1e869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b89ab01f9efe7650b6a97888f1e869">&#9670;&#160;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafdc7ea9b09001e49518715162e70290" name="aafdc7ea9b09001e49518715162e70290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdc7ea9b09001e49518715162e70290">&#9670;&#160;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9660b9b2b46b561d976ffbf7dbde8d69" name="a9660b9b2b46b561d976ffbf7dbde8d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9660b9b2b46b561d976ffbf7dbde8d69">&#9670;&#160;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>/ </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1complex.html">complex</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c3293c8c6e37d2b24c05f95baa58aef" name="a2c3293c8c6e37d2b24c05f95baa58aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3293c8c6e37d2b24c05f95baa58aef">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af437446fcc1e53640c10980cfd99616e" name="af437446fcc1e53640c10980cfd99616e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af437446fcc1e53640c10980cfd99616e">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a571d0698767bc83dd12cd1d4d3dd9a9c" name="a571d0698767bc83dd12cd1d4d3dd9a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571d0698767bc83dd12cd1d4d3dd9a9c">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ae3409e7cab3e6c13e3d748566971e05e" name="ae3409e7cab3e6c13e3d748566971e05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3409e7cab3e6c13e3d748566971e05e">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6435b7c6bb6e776d7d7b22bc36f3a364" name="a6435b7c6bb6e776d7d7b22bc36f3a364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6435b7c6bb6e776d7d7b22bc36f3a364">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ab4cd653fa75caba7b24defbc611c6f71" name="ab4cd653fa75caba7b24defbc611c6f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cd653fa75caba7b24defbc611c6f71">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a86b87a87e119f906f153eb7a9dd4b27f" name="a86b87a87e119f906f153eb7a9dd4b27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b87a87e119f906f153eb7a9dd4b27f">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="acc3d8b9402fd47ee81c43ca9621035b7" name="acc3d8b9402fd47ee81c43ca9621035b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3d8b9402fd47ee81c43ca9621035b7">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e4f1579948c0050989b6bc4d56f0862" name="a1e4f1579948c0050989b6bc4d56f0862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4f1579948c0050989b6bc4d56f0862">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="ad49df96265d6364140d73a8656425763" name="ad49df96265d6364140d73a8656425763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49df96265d6364140d73a8656425763">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="ab892f9c1b557a16dd61daa9664feafda" name="ab892f9c1b557a16dd61daa9664feafda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab892f9c1b557a16dd61daa9664feafda">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a36eb9271474c81cef432c9a2b4afbee6" name="a36eb9271474c81cef432c9a2b4afbee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36eb9271474c81cef432c9a2b4afbee6">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift);</code> </p>

</div>
</div>
<a id="af1cb2843a224e246ba96818c029d3cbc" name="af1cb2843a224e246ba96818c029d3cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cb2843a224e246ba96818c029d3cbc">&#9670;&#160;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;

</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return b = b &lt;&lt; shift;</code> </p>

</div>
</div>
<a id="a4f2e96c99f7d8223e682d299d15a63a1" name="a4f2e96c99f7d8223e682d299d15a63a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2e96c99f7d8223e682d299d15a63a1">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6911622913c358aa6c9a69533740656e" name="a6911622913c358aa6c9a69533740656e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6911622913c358aa6c9a69533740656e">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a168c032d92366a1e3a01fd042f1bdd4b" name="a168c032d92366a1e3a01fd042f1bdd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168c032d92366a1e3a01fd042f1bdd4b">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a2166e999595123c9283e1d8b743f4d37" name="a2166e999595123c9283e1d8b743f4d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2166e999595123c9283e1d8b743f4d37">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c452fa081a792d415bada3098142f2c" name="a6c452fa081a792d415bada3098142f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c452fa081a792d415bada3098142f2c">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a40dafd7cae83ec90b947ed85149a4b38" name="a40dafd7cae83ec90b947ed85149a4b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40dafd7cae83ec90b947ed85149a4b38">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="ab26706133b16070592575cd905122691" name="ab26706133b16070592575cd905122691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26706133b16070592575cd905122691">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a4e8fec49a7e24b2cb1f6dc5b738b1daa" name="a4e8fec49a7e24b2cb1f6dc5b738b1daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8fec49a7e24b2cb1f6dc5b738b1daa">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a36c94057cb8199ed38d8d08fd67ef5" name="a5a36c94057cb8199ed38d8d08fd67ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a36c94057cb8199ed38d8d08fd67ef5">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="acf24c3b1cefb36e0c44f1cfaf6bf3f61" name="acf24c3b1cefb36e0c44f1cfaf6bf3f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf24c3b1cefb36e0c44f1cfaf6bf3f61">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="a894460b393d2ac20c8b8f033322ff230" name="a894460b393d2ac20c8b8f033322ff230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894460b393d2ac20c8b8f033322ff230">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf2918fec19c7ddaff292731a3c702c2" name="aaf2918fec19c7ddaff292731a3c702c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2918fec19c7ddaff292731a3c702c2">&#9670;&#160;</a></span>operator==() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__traits.html#gaca42c1976d1b12998afcabf8f39e8c23">type_identity_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a0713b9e434e4421d0130fc330118092d" name="a0713b9e434e4421d0130fc330118092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0713b9e434e4421d0130fc330118092d">&#9670;&#160;</a></span>operator==() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a27742612e6861226707341546907da1e" name="a27742612e6861226707341546907da1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27742612e6861226707341546907da1e">&#9670;&#160;</a></span>operator==() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af746cebe9104d4847df63754ab19eeb7" name="af746cebe9104d4847df63754ab19eeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af746cebe9104d4847df63754ab19eeb7">&#9670;&#160;</a></span>operator==() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab66a17a791126b7c9b34055551b46721" name="ab66a17a791126b7c9b34055551b46721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66a17a791126b7c9b34055551b46721">&#9670;&#160;</a></span>operator==() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a00f869738f3ebf43e3b752d084fe4abf" name="a00f869738f3ebf43e3b752d084fe4abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f869738f3ebf43e3b752d084fe4abf">&#9670;&#160;</a></span>operator==() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>Two strings are equal if both the size of lhs and rhs are equal and each character in lhs has equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a9ac9a7daa4f77fbf1aae7a1b941301cc" name="a9ac9a7daa4f77fbf1aae7a1b941301cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac9a7daa4f77fbf1aae7a1b941301cc">&#9670;&#160;</a></span>operator==() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a06cae3523aef79cbee6d0ad095484749" name="a06cae3523aef79cbee6d0ad095484749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cae3523aef79cbee6d0ad095484749">&#9670;&#160;</a></span>operator==() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a49d3cf9c4f58fa9982c28bfa20adb0cb" name="a49d3cf9c4f58fa9982c28bfa20adb0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d3cf9c4f58fa9982c28bfa20adb0cb">&#9670;&#160;</a></span>operator==() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Rhs</a> , <a class="el" href="structetl_1_1bitset.html">Rhs</a> R, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Lhs</a> , <a class="el" href="structetl_1_1bitset.html">Lhs</a> L&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Rhs</a>, <a class="el" href="structetl_1_1bitset.html">R</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">Lhs</a>, <a class="el" href="structetl_1_1bitset.html">L</a> &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">bool</a>, <a class="el" href="structetl_1_1bitset.html">L</a> == <a class="el" href="structetl_1_1bitset.html">R</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf1ef9857ea2d2e84bd3c311d0ccc92f" name="aaf1ef9857ea2d2e84bd3c311d0ccc92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1ef9857ea2d2e84bd3c311d0ccc92f">&#9670;&#160;</a></span>operator==() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares language_standards. </p>

</div>
</div>
<a id="a1d46beb3d8ffc0ea6e9f5157d7f1b299" name="a1d46beb3d8ffc0ea6e9f5157d7f1b299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d46beb3d8ffc0ea6e9f5157d7f1b299">&#9670;&#160;</a></span>operator==() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afb2c9350d32e78a0e4c960b9859ccb40">nullptr_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a> with a null pointer. Empty functions (that is, functions without a callable target) compare equal, non-empty functions compare non-equal. </p>

</div>
</div>
<a id="a4eb99a045aef160b997eab5178610a6a" name="a4eb99a045aef160b997eab5178610a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb99a045aef160b997eab5178610a6a">&#9670;&#160;</a></span>operator==() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second. </p>

</div>
</div>
<a id="ae066ee7e8566233be5ae1d96840d0c27" name="ae066ee7e8566233be5ae1d96840d0c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae066ee7e8566233be5ae1d96840d0c27">&#9670;&#160;</a></span>operator==() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="a287ee2e9239c563f862cb177ec7d5792" name="a287ee2e9239c563f862cb177ec7d5792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287ee2e9239c563f862cb177ec7d5792">&#9670;&#160;</a></span>operator==() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors. </p>
<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="a9a46d2610263aec2af4e9c49c94519ae" name="a9a46d2610263aec2af4e9c49c94519ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a46d2610263aec2af4e9c49c94519ae">&#9670;&#160;</a></span>operator==() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , CharT... Chars&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, Chars... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, Chars... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d9202f4500faf2a0dfeb6d39233517e" name="a2d9202f4500faf2a0dfeb6d39233517e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9202f4500faf2a0dfeb6d39233517e">&#9670;&#160;</a></span>operator==() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , CharT... CharsL, CharT... CharsR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, CharsL... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1string__constant.html">string_constant</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, CharsR... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32bab80e6235274bcc58d29d59d310a0" name="a32bab80e6235274bcc58d29d59d310a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bab80e6235274bcc58d29d59d310a0">&#9670;&#160;</a></span>operator==() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1complex.html">complex</a>&lt; T &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbffd4a8b5d0838ecc6a3f36cad3e3c6" name="abbffd4a8b5d0838ecc6a3f36cad3e3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbffd4a8b5d0838ecc6a3f36cad3e3c6">&#9670;&#160;</a></span>operator==() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Us&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1bitset.html">Ts</a>) == sizeof...(<a class="el" href="structetl_1_1bitset.html">Us</a>))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; Us... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77e34f2ca4ffdc8cf580ee55405dbd50" name="a77e34f2ca4ffdc8cf580ee55405dbd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e34f2ca4ffdc8cf580ee55405dbd50">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a282dab84234297d94efc2b6326190a55" name="a282dab84234297d94efc2b6326190a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282dab84234297d94efc2b6326190a55">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a19a02eaf1df39c8c9bf6616e9d9297c7" name="a19a02eaf1df39c8c9bf6616e9d9297c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a02eaf1df39c8c9bf6616e9d9297c7">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a767725b8e1034844aa4c3245f940832f" name="a767725b8e1034844aa4c3245f940832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767725b8e1034844aa4c3245f940832f">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad834ca81bce076e5e37bd38d124fbbda" name="ad834ca81bce076e5e37bd38d124fbbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad834ca81bce076e5e37bd38d124fbbda">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a874855bcecdef2ce1a2b18ee560f4875" name="a874855bcecdef2ce1a2b18ee560f4875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874855bcecdef2ce1a2b18ee560f4875">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="aca4156f3a7bdd78f42dba049d9cd2a7f" name="aca4156f3a7bdd78f42dba049d9cd2a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4156f3a7bdd78f42dba049d9cd2a7f">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a5f071a704146a7adbb1dc8186e6cd184" name="a5f071a704146a7adbb1dc8186e6cd184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f071a704146a7adbb1dc8186e6cd184">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba18e7582c10621006e4e0cbc7ad4e4a" name="aba18e7582c10621006e4e0cbc7ad4e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba18e7582c10621006e4e0cbc7ad4e4a">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a17ccbb17eca7af36ce1a29e8d176f165" name="a17ccbb17eca7af36ce1a29e8d176f165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ccbb17eca7af36ce1a29e8d176f165">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="ab897f8f3641b27de2e08d2d16563a2c2" name="ab897f8f3641b27de2e08d2d16563a2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab897f8f3641b27de2e08d2d16563a2c2">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7456ec6ff542660d9777cf19081a2cac" name="a7456ec6ff542660d9777cf19081a2cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7456ec6ff542660d9777cf19081a2cac">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06acbb7e9de53f5357b8a05ff2b81346" name="a06acbb7e9de53f5357b8a05ff2b81346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06acbb7e9de53f5357b8a05ff2b81346">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharType</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to lexicographical_compare. </p>

</div>
</div>
<a id="a926a024f13c49393549366cb074449cb" name="a926a024f13c49393549366cb074449cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926a024f13c49393549366cb074449cb">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="abbf977200588526eee94f7bfe90d02a9" name="abbf977200588526eee94f7bfe90d02a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf977200588526eee94f7bfe90d02a9">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="structetl_1_1bitset.html">int</a>  = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__string__view.html">basic_string_view</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add94f74715c924f9a96904acdea72bc9" name="add94f74715c924f9a96904acdea72bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add94f74715c924f9a96904acdea72bc9">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">CharT</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="a5d74379e90ba804afd1c2f9739b7d9d7" name="a5d74379e90ba804afd1c2f9739b7d9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d74379e90ba804afd1c2f9739b7d9d7">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity1, <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity1</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity2</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of a string with another string or a null-terminated array of CharT. </p>
<p>The ordering comparisons are done lexicographically. </p>

</div>
</div>
<a id="adada3b76df2e6fc502cf397340f36c22" name="adada3b76df2e6fc502cf397340f36c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adada3b76df2e6fc502cf397340f36c22">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter1</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1reverse__iterator.html">etl::reverse_iterator</a>&lt; <a class="el" href="structetl_1_1bitset.html">Iter2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the underlying iterators. Inverse comparisons are applied in order to take into account that the iterator order is reversed. </p>

</div>
</div>
<a id="a9a11fea942b05530889b9e1944f07147" name="a9a11fea942b05530889b9e1944f07147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a11fea942b05530889b9e1944f07147">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1de">language_standard</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f52394fdd7dcf3de62c6201ba727716" name="a8f52394fdd7dcf3de62c6201ba727716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f52394fdd7dcf3de62c6201ba727716">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="adb7a5ebdf6dec990fea752e60d99fc2c" name="adb7a5ebdf6dec990fea752e60d99fc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7a5ebdf6dec990fea752e60d99fc2c">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Comp</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two sets. </p>
<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to lexicographical_compare. This comparison ignores the set's ordering Compare. </p>

</div>
</div>
<a id="a5beff690dcaa87cb11a10e760c1d0211" name="a5beff690dcaa87cb11a10e760c1d0211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5beff690dcaa87cb11a10e760c1d0211">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51eea63a0ce9f777a6682aaf90f48696" name="a51eea63a0ce9f777a6682aaf90f48696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51eea63a0ce9f777a6682aaf90f48696">&#9670;&#160;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift);</code> </p>

</div>
</div>
<a id="a5ec81972434cf41e3465929f46a9d9e4" name="a5ec81972434cf41e3465929f46a9d9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec81972434cf41e3465929f46a9d9e4">&#9670;&#160;</a></span>operator&gt;&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Int</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return b = b &gt;&gt; shift;</code> </p>

</div>
</div>
<a id="a40a15b444153bb6f6f05086c199285cb" name="a40a15b444153bb6f6f05086c199285cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a15b444153bb6f6f05086c199285cb">&#9670;&#160;</a></span>operator^() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1bitset.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary XOR between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="a0f70d9e6f3612368a7a87afd88db9a49" name="a0f70d9e6f3612368a7a87afd88db9a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f70d9e6f3612368a7a87afd88db9a49">&#9670;&#160;</a></span>operator^() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) ^ static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a949f06ea9ccea69532ff49532f6cd7c7" name="a949f06ea9ccea69532ff49532f6cd7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949f06ea9ccea69532ff49532f6cd7c7">&#9670;&#160;</a></span>operator^() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>^ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71bdb2fbcbe02268c3ef208d91d5b702" name="a71bdb2fbcbe02268c3ef208d91d5b702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bdb2fbcbe02268c3ef208d91d5b702">&#9670;&#160;</a></span>operator^=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs ^ rhs;</code> </p>

</div>
</div>
<a id="acfa9d2eff6d0a0723cccce281bcf5619" name="acfa9d2eff6d0a0723cccce281bcf5619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa9d2eff6d0a0723cccce281bcf5619">&#9670;&#160;</a></span>operator^=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>^= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1bitset.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb6dd579fe662e47108bc466e6f4b94a" name="afb6dd579fe662e47108bc466e6f4b94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6dd579fe662e47108bc466e6f4b94a">&#9670;&#160;</a></span>operator|() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bitset</a>&lt; <a class="el" href="structetl_1_1bitset.html">N</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">bitset</a>&lt;<a class="el" href="structetl_1_1bitset.html">N</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs binary OR between two bitsets, lhs and rhs. </p>

</div>
</div>
<a id="ae524596905624f411ac531dd57bdc7db" name="ae524596905624f411ac531dd57bdc7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae524596905624f411ac531dd57bdc7db">&#9670;&#160;</a></span>operator|() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(static_cast&lt;unsigned int&gt;(lhs) | static_cast&lt;unsigned int&gt;(rhs));</code> </p>

</div>
</div>
<a id="a8dbe12aeee105b81dad6ee8d5bf70db5" name="a8dbe12aeee105b81dad6ee8d5bf70db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbe12aeee105b81dad6ee8d5bf70db5">&#9670;&#160;</a></span>operator|() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>| </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3816e8de39ecc8a024d86bd10a4f6f0" name="aa3816e8de39ecc8a024d86bd10a4f6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3816e8de39ecc8a024d86bd10a4f6f0">&#9670;&#160;</a></span>operator|=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return lhs = lhs | rhs;</code> </p>

</div>
</div>
<a id="afde4cd3357a82b4fb074755ab815223f" name="afde4cd3357a82b4fb074755ab815223f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde4cd3357a82b4fb074755ab815223f">&#9670;&#160;</a></span>operator|=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">operator</a>|= </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;) -&gt; T <a class="el" href="structetl_1_1bitset.html">const</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeea255f7742cda95d1dab63279b70687" name="aeea255f7742cda95d1dab63279b70687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea255f7742cda95d1dab63279b70687">&#9670;&#160;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#ac8b31cb9f07073943eca09b7e6030296">TETL_ALWAYS_INLINE</a> <a class="el" href="structetl_1_1bitset.html">constexpr</a> <a class="el" href="structetl_1_1bitset.html">auto</a> operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return byte(~static_cast&lt;unsigned int&gt;(b));</code> </p>

</div>
</div>
<a id="a8b2bdaacf0312586cd586bd854a7b35a" name="a8b2bdaacf0312586cd586bd854a7b35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2bdaacf0312586cd586bd854a7b35a">&#9670;&#160;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bitmask_type T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> operator~ </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabca2e2f91841c82fb5ef20995a618bb" name="aabca2e2f91841c82fb5ef20995a618bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabca2e2f91841c82fb5ef20995a618bb">&#9670;&#160;</a></span>overload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Functor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">overload </td>
          <td>(</td>
          <td class="paramtype">Functor...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  overload&lt; Functor... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1145f95a262f79865247b6744e474069" name="a1145f95a262f79865247b6744e474069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1145f95a262f79865247b6744e474069">&#9670;&#160;</a></span>pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">T1</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">T2</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  pair&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a3bdc4477493e7bc5c106a53a3a314" name="a88a3bdc4477493e7bc5c106a53a3a314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a3bdc4477493e7bc5c106a53a3a314">&#9670;&#160;</a></span>partial_sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">RandomIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> partial_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>middle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">RandomIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e19467104f59f0dafeaf2752b461a9e" name="a5e19467104f59f0dafeaf2752b461a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e19467104f59f0dafeaf2752b461a9e">&#9670;&#160;</a></span>raise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Exception</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8hpp.html#abb156b0e852ad82749ae42934d3b4dbf">TETL_NO_INLINE</a> <a class="el" href="attributes_8hpp.html#af0eb4be3e44a6a8a9235265e12ad89a7">TETL_COLD</a> <a class="el" href="structetl_1_1bitset.html">auto</a> raise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1source__location.html">etl::source_location</a> <a class="el" href="structetl_1_1bitset.html">const</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1source__location.html#a53acf372b311e213942517d71b4bf8b8">etl::source_location::current</a>()</span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adea72996d2287ae1be393a1827dfa5bf" name="adea72996d2287ae1be393a1827dfa5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea72996d2287ae1be393a1827dfa5bf">&#9670;&#160;</a></span>ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. </p>

</div>
</div>
<a id="a11516b369ddf80bc94d2f450200f5d11" name="a11516b369ddf80bc94d2f450200f5d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11516b369ddf80bc94d2f450200f5d11">&#9670;&#160;</a></span>ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> ref </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1reference__wrapper.html">reference_wrapper</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function templates ref and cref are helper functions that generate an object of type <a class="el" href="structetl_1_1reference__wrapper.html" title="reference_wrapper is a class template that wraps a reference in a copyable, assignable object....">reference_wrapper</a>, using template argument deduction to determine the template argument of the result. </p>

</div>
</div>
<a id="a1ffcd97e84a642fa9f9f3297692d128e" name="a1ffcd97e84a642fa9f9f3297692d128e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffcd97e84a642fa9f9f3297692d128e">&#9670;&#160;</a></span>reference_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference_wrapper </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  reference_wrapper&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e8ae9359da3a0a4cb0573e8cd219638" name="a0e8ae9359da3a0a4cb0573e8cd219638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8ae9359da3a0a4cb0573e8cd219638">&#9670;&#160;</a></span>scope_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">FuncT</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">scope_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">FuncT</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  scope_exit&lt; <a class="el" href="#a24f3c9ab2c53f9192c2899fc8efb263d">decay_t</a>&lt; <a class="el" href="structetl_1_1bitset.html">FuncT</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f4da52394b4be08dc83783c505ddc3a" name="a7f4da52394b4be08dc83783c505ddc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4da52394b4be08dc83783c505ddc3a">&#9670;&#160;</a></span>signbit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> signbit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1half.html">half</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f81df02edb24d409273f1a4f4ae1da7" name="a0f81df02edb24d409273f1a4f4ae1da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f81df02edb24d409273f1a4f4ae1da7">&#9670;&#160;</a></span>span() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Container</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1bitset.html">Element</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a929cb3ca520c09729a4166ed8244f76e" name="a929cb3ca520c09729a4166ed8244f76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929cb3ca520c09729a4166ed8244f76e">&#9670;&#160;</a></span>span() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Element</a>  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Container</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1bitset.html">Element</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a971583484d70115eb585a522b3d27c94" name="a971583484d70115eb585a522b3d27c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971583484d70115eb585a522b3d27c94">&#9670;&#160;</a></span>span() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Size</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26de73efb9b95ad5ed7a2efee4db36d1" name="a26de73efb9b95ad5ed7a2efee4db36d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26de73efb9b95ad5ed7a2efee4db36d1">&#9670;&#160;</a></span>span() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; <a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Size</a> &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1bitset.html">Type</a> <a class="el" href="structetl_1_1bitset.html">const</a>, <a class="el" href="structetl_1_1bitset.html">Size</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adeda768ae3894ba5ab71ab85c206b19d" name="adeda768ae3894ba5ab71ab85c206b19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeda768ae3894ba5ab71ab85c206b19d">&#9670;&#160;</a></span>span() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Extent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">span </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Type</a>(&amp;)</td>          <td class="paramname"><span class="paramname"><em></em></span>[Extent]</td><td>)</td>
          <td> -&gt;  span&lt; <a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Extent</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa1582db8c501fc2a0866681ff10eeef" name="aaa1582db8c501fc2a0866681ff10eeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1582db8c501fc2a0866681ff10eeef">&#9670;&#160;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Container</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Container</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  stack&lt; <a class="el" href="structetl_1_1bitset.html">typename</a> Container::value_type, <a class="el" href="structetl_1_1bitset.html">Container</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a292e75d88b4e3619e2654b8f6f8660" name="a1a292e75d88b4e3619e2654b8f6f8660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a292e75d88b4e3619e2654b8f6f8660">&#9670;&#160;</a></span>stoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> stoi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1bitset.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a634bfd356983e8d8a730538cd6b5f7cd" name="a634bfd356983e8d8a730538cd6b5f7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634bfd356983e8d8a730538cd6b5f7cd">&#9670;&#160;</a></span>stol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> stol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1bitset.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a8b844e6e1102e2efe7b9f7ad9ef4fff6" name="a8b844e6e1102e2efe7b9f7ad9ef4fff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b844e6e1102e2efe7b9f7ad9ef4fff6">&#9670;&#160;</a></span>stoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> stoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1bitset.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a0c74f60fe53545b60e1c1404719b84e6" name="a0c74f60fe53545b60e1c1404719b84e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c74f60fe53545b60e1c1404719b84e6">&#9670;&#160;</a></span>stoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> stoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1bitset.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="a3d870cb89861489715e34bf225feb213" name="a3d870cb89861489715e34bf225feb213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d870cb89861489715e34bf225feb213">&#9670;&#160;</a></span>stoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> stoull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">etl::string_view</a></td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> *</td>          <td class="paramname"><span class="paramname"><em>pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1bitset.html">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a signed integer value in the string str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">pos</td><td>Address of an integer to store the number of characters processed. </td></tr>
    <tr><td class="paramname">base</td><td>The number base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer value corresponding to the content of str. </dd></dl>

</div>
</div>
<a id="aa9406cef0552ac36f0ea11e670081897" name="aa9406cef0552ac36f0ea11e670081897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9406cef0552ac36f0ea11e670081897">&#9670;&#160;</a></span>strided_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OffsetType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ExtentType</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">StrideType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">strided_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">OffsetType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ExtentType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">StrideType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  strided_slice&lt; <a class="el" href="structetl_1_1bitset.html">OffsetType</a>, <a class="el" href="structetl_1_1bitset.html">ExtentType</a>, <a class="el" href="structetl_1_1bitset.html">StrideType</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a908461fb82d1921b7d9d47fefd69808f" name="a908461fb82d1921b7d9d47fefd69808f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908461fb82d1921b7d9d47fefd69808f">&#9670;&#160;</a></span>strtod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> strtod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1bitset.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a17ff85f301c7ae10d33eb06607976726" name="a17ff85f301c7ae10d33eb06607976726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ff85f301c7ae10d33eb06607976726">&#9670;&#160;</a></span>strtof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> strtof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1bitset.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">float</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="a1a70d2daad7d58df41e035dc7b7d6ee1" name="a1a70d2daad7d58df41e035dc7b7d6ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a70d2daad7d58df41e035dc7b7d6ee1">&#9670;&#160;</a></span>strtol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> strtol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtol">https://en.cppreference.com/w/cpp/string/byte/strtol</a> </p>

</div>
</div>
<a id="ac30cff1b320a5ca627023644ccb321ef" name="ac30cff1b320a5ca627023644ccb321ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30cff1b320a5ca627023644ccb321ef">&#9670;&#160;</a></span>strtold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> strtold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structetl_1_1bitset.html">nullptr</a></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">double</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets a floating point value in a byte string pointed to by str. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to the null-terminated byte string to be interpreted. </td></tr>
    <tr><td class="paramname">last</td><td>Pointer to a pointer to character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating point value corresponding to the contents of str on success. If the converted value falls out of range of corresponding return type, range error occurs and HUGE_VAL, HUGE_VALF or HUGE_VALL is returned. If no conversion can be performed, <code>0</code> is returned and *last is set to str. </dd></dl>

</div>
</div>
<a id="afe6baccbeb60e396a8222d877a5ef28f" name="afe6baccbeb60e396a8222d877a5ef28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6baccbeb60e396a8222d877a5ef28f">&#9670;&#160;</a></span>strtoll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> strtoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtol">https://en.cppreference.com/w/cpp/string/byte/strtol</a> </p>

</div>
</div>
<a id="a11d60e5943db8f44ee5c351c7744db66" name="a11d60e5943db8f44ee5c351c7744db66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d60e5943db8f44ee5c351c7744db66">&#9670;&#160;</a></span>strtoul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> strtoul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtoul">https://en.cppreference.com/w/cpp/string/byte/strtoul</a> </p>

</div>
</div>
<a id="a4ab96db1ba94415b0dce36ec1327f314" name="a4ab96db1ba94415b0dce36ec1327f314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab96db1ba94415b0dce36ec1327f314">&#9670;&#160;</a></span>strtoull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> strtoull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> <a class="el" href="structetl_1_1bitset.html">const</a> **</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interprets an integer value in a byte string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/byte/strtoul">https://en.cppreference.com/w/cpp/string/byte/strtoul</a> </p>

</div>
</div>
<a id="af804eb418abea75441ce277a3d8ac9a4" name="af804eb418abea75441ce277a3d8ac9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af804eb418abea75441ce277a3d8ac9a4">&#9670;&#160;</a></span>submdspan_extents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">IndexT</a> , etl::size_t... Extents, typename... SliceSpecifiers&gt; <br />
requires (sizeof...(<a class="el" href="structetl_1_1bitset.html">slices</a>) == <a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt;<a class="el" href="structetl_1_1bitset.html">IndexT</a>, Extents...&gt;::rank())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> submdspan_extents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1extents.html">etl::extents</a>&lt; <a class="el" href="structetl_1_1bitset.html">IndexT</a>, Extents... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceSpecifiers...</td>          <td class="paramname"><span class="paramname"><em>slices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a977829c40c43a6c097536fc959a86292" name="a977829c40c43a6c097536fc959a86292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977829c40c43a6c097536fc959a86292">&#9670;&#160;</a></span>swap() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">CharT</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Traits</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1basic__inplace__string.html">etl::basic_inplace_string</a>&lt; <a class="el" href="structetl_1_1bitset.html">CharT</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Traits</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1basic__inplace__string.html" title="basic_inplace_string class with fixed size capacity.">etl::basic_inplace_string</a>. Swaps the contents of lhs and rhs. Equivalent to lhs.swap(rhs). </p>

</div>
</div>
<a id="ac15165afbf59de637ccf27b635458ece" name="ac15165afbf59de637ccf27b635458ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15165afbf59de637ccf27b635458ece">&#9670;&#160;</a></span>swap() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , typename... Args, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Alignment&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1inplace__function.html">inplace_function</a>&lt; <a class="el" href="structetl_1_1bitset.html">R</a>(Args...), <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Alignment</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the <a class="el" href="#ac15165afbf59de637ccf27b635458ece" title="Overloads the etl::swap algorithm for etl::inplace_function. Exchanges the state of lhs with that of ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>. Exchanges the state of lhs with that of rhs. Effectively calls lhs.swap(rhs). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a0">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a74587901a0df261ba728e5fab73273de" name="a74587901a0df261ba728e5fab73273de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74587901a0df261ba728e5fab73273de">&#9670;&#160;</a></span>swap() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T1</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">pair</a>&lt; <a class="el" href="structetl_1_1bitset.html">T1</a>, <a class="el" href="structetl_1_1bitset.html">T2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of x and y. Equivalent to x.swap(y). </p>

</div>
</div>
<a id="a49bec9d408f2060c687550beff2bc22a" name="a49bec9d408f2060c687550beff2bc22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bec9d408f2060c687550beff2bc22a">&#9670;&#160;</a></span>swap() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">C</a> &gt; <br />
requires (<a class="el" href="#a6a08681ad0c17b00662bfd185a081335">is_swappable_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">C</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">C</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1stack.html">stack</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">C</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for stack. Swaps the contents of lhs and rhs. This overload only participates in overload resolution if is_swappable&lt;C&gt;::value is true. </p>

</div>
</div>
<a id="a10be93498b340088ebf6b854223c733f" name="a10be93498b340088ebf6b854223c733f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10be93498b340088ebf6b854223c733f">&#9670;&#160;</a></span>swap() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Key</a> , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity, <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__set.html">static_set</a>&lt; <a class="el" href="structetl_1_1bitset.html">Key</a>, <a class="el" href="structetl_1_1bitset.html">Capacity</a>, <a class="el" href="structetl_1_1bitset.html">Compare</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for set. Swaps the contents of lhs and rhs. Calls lhs.swap(rhs). </p>

</div>
</div>
<a id="a1059d0a7b563d13c9d599eea27ca489e" name="a1059d0a7b563d13c9d599eea27ca489e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1059d0a7b563d13c9d599eea27ca489e">&#9670;&#160;</a></span>swap() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="structetl_1_1bitset.html">Capacity</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the swap algorithm for <a class="el" href="structetl_1_1static__vector.html" title="Dynamically-resizable fixed-capacity vector.">static_vector</a>. Swaps the contents of lhs and rhs. </p>

</div>
</div>
<a id="a885a42e965c6251995730e67ba6d09eb" name="a885a42e965c6251995730e67ba6d09eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885a42e965c6251995730e67ba6d09eb">&#9670;&#160;</a></span>swap() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const -&gt;  <a class="el" href="structetl_1_1bitset.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="a9f797628671cf0d4b35a9858fd9a0455" name="a9f797628671cf0d4b35a9858fd9a0455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f797628671cf0d4b35a9858fd9a0455">&#9670;&#160;</a></span>swap() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v</a>&lt;T&gt; &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const -&gt;  <a class="el" href="structetl_1_1bitset.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="ad539af8c81b36e27d721d3df81ffe277" name="ad539af8c81b36e27d721d3df81ffe277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad539af8c81b36e27d721d3df81ffe277">&#9670;&#160;</a></span>swap() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v</a>&lt;T&gt; <a class="el" href="structetl_1_1bitset.html">and</a> <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="#a5181d927278f40a6a97e90944d673c0a">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="#afbf52ca54b0d508bfc6b9bbe916faf18">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap">https://en.cppreference.com/w/cpp/algorithm/swap</a> </p>

</div>
</div>
<a id="af5273f679984445be5233596370b7a15" name="af5273f679984445be5233596370b7a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5273f679984445be5233596370b7a15">&#9670;&#160;</a></span>swap() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="structetl_1_1is__swappable.html">etl::is_swappable</a>&lt;T&gt;::value)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>a</em></span>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>b</em></span>[N]&#160;) -&gt;  <a class="el" href="structetl_1_1bitset.html">void</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23ff5eb0624cb9e7995b622dc0c7e7c4" name="a23ff5eb0624cb9e7995b622dc0c7e7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ff5eb0624cb9e7995b622dc0c7e7c4">&#9670;&#160;</a></span>swap() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> N&gt; <br />
requires (<a class="el" href="#a6a08681ad0c17b00662bfd185a081335">etl::is_swappable_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> swap </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>a</em></span>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>b</em></span>[N]&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3408c1dae71c214e0b2b360f5fcba723" name="a3408c1dae71c214e0b2b360f5fcba723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3408c1dae71c214e0b2b360f5fcba723">&#9670;&#160;</a></span>test_implicit_default_constructible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">void</a> test_implicit_default_constructible </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d1ede89bcd679cdd58f45d98b785cd8" name="a0d1ede89bcd679cdd58f45d98b785cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1ede89bcd679cdd58f45d98b785cd8">&#9670;&#160;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> tie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Args</a> &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt;<a class="el" href="structetl_1_1bitset.html">Args</a>&amp;...&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa171f5d95623a8a1268dc9134a02f972" name="aa171f5d95623a8a1268dc9134a02f972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa171f5d95623a8a1268dc9134a02f972">&#9670;&#160;</a></span>to_address() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Ptr</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Ptr</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by p without forming a reference to the object pointed to by p. </p>
<p>Fancy pointer overload: If the expression pointer_traits&lt;Ptr&gt;::to_address(p) is well-formed, returns the result of that expression. Otherwise, returns to_address(p.operator-&gt;()). </p>

</div>
</div>
<a id="a9487e53c09efc9a8837a2d074e441b99" name="a9487e53c09efc9a8837a2d074e441b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9487e53c09efc9a8837a2d074e441b99">&#9670;&#160;</a></span>to_address() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; <br />
requires (<a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#abffc77cc5069dfe2c648737671e340d9">is_function_v</a>&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_address </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the address represented by p without forming a reference to the object pointed to by p. </p>
<p>Raw pointer overload: If T is a function type, the program is ill-formed. Otherwise, returns p unmodified. </p>

</div>
</div>
<a id="a76ada873a32749c139721424bd4a122d" name="a76ada873a32749c139721424bd4a122d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ada873a32749c139721424bd4a122d">&#9670;&#160;</a></span>to_chars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">bool</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt;  <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>=<a class="el" href="structetl_1_1bitset.html">delete</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d46a108541ea7e9e622ba37063518f9" name="a6d46a108541ea7e9e622ba37063518f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d46a108541ea7e9e622ba37063518f9">&#9670;&#160;</a></span>to_chars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;integral T&gt; <br />
requires (<a class="el" href="structetl_1_1bitset.html">not</a> same_as&lt;T, <a class="el" href="structetl_1_1bitset.html">bool</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">char</a> *</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>base</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;) -&gt; <a class="el" href="structetl_1_1to__chars__result.html">to_chars_result</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts value into a character string by successively filling the range [first, last), where [first, last) is required to be a valid range. </p>
<p>Integer formatters: value is converted to a string of digits in the given base (with no redundant leading zeroes). Digits in the range 10..35 (inclusive) are represented as lowercase characters a..z. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type char as the type of the parameter value. </p>

</div>
</div>
<a id="a02a64d34e50bd46ac7c48f9c3b20ecfe" name="a02a64d34e50bd46ac7c48f9c3b20ecfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a64d34e50bd46ac7c48f9c3b20ecfe">&#9670;&#160;</a></span>to_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptetl_1_1integral.html">etl::integral</a> Int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab">etl::byte</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">Int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: <code>return Int(b);</code> </p>

</div>
</div>
<a id="acabe21e30e1c4a3fe9d4b236c80b7bb1" name="acabe21e30e1c4a3fe9d4b236c80b7bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabe21e30e1c4a3fe9d4b236c80b7bb1">&#9670;&#160;</a></span>to_string() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>. </p>

</div>
</div>
<a id="a4058bf13763031d698e2360236eb1766" name="a4058bf13763031d698e2360236eb1766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4058bf13763031d698e2360236eb1766">&#9670;&#160;</a></span>to_string() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>. </p>

</div>
</div>
<a id="aab1cd63528320986c9785a5073bd9a5c" name="aab1cd63528320986c9785a5073bd9a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1cd63528320986c9785a5073bd9a5c">&#9670;&#160;</a></span>to_string() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>. </p>

</div>
</div>
<a id="a8117b4615a13419168ed037eaa6440d7" name="a8117b4615a13419168ed037eaa6440d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8117b4615a13419168ed037eaa6440d7">&#9670;&#160;</a></span>to_string() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>. </p>

</div>
</div>
<a id="a6d1309afc3747c07e3c2bee0669cf786" name="a6d1309afc3747c07e3c2bee0669cf786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1309afc3747c07e3c2bee0669cf786">&#9670;&#160;</a></span>to_string() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">unsigned</a> <a class="el" href="structetl_1_1bitset.html">long</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>. </p>

</div>
</div>
<a id="a5658429f25f4671a0e8a59cee2221895" name="a5658429f25f4671a0e8a59cee2221895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5658429f25f4671a0e8a59cee2221895">&#9670;&#160;</a></span>to_string() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c">etl::inplace_string</a>&lt;<a class="el" href="structetl_1_1bitset.html">Capacity</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric value to <a class="el" href="#ad8a7ab76e5b59bba68d1362a0cbff96c" title="Typedef for a basic_inplace_string using &#39;char&#39;.">etl::inplace_string</a>. </p>

</div>
</div>
<a id="abd4b8c890cb36df65940f4a0e4a65c11" name="abd4b8c890cb36df65940f4a0e4a65c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4b8c890cb36df65940f4a0e4a65c11">&#9670;&#160;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Enum</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> to_underlying </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Enum</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="group__type__traits.html#ga23e4463cad64a4fb5f8e4cf7acafec27">underlying_type_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">Enum</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an enumeration to its underlying type. </p>
<p><a href="https://en.cppreference.com/w/cpp/utility/to_underlying">https://en.cppreference.com/w/cpp/utility/to_underlying</a> </p>

</div>
</div>
<a id="a4c95e50e7b2dda0a7a7fd3b1b3a37dc9" name="a4c95e50e7b2dda0a7a7fd3b1b3a37dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c95e50e7b2dda0a7a7fd3b1b3a37dc9">&#9670;&#160;</a></span>tuple_cat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::tuple_like... Tuples&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> tuple_cat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">Tuples</a> &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4a93d951b4c9c54a4e94d4380874a4f" name="aa4a93d951b4c9c54a4e94d4380874a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a93d951b4c9c54a4e94d4380874a4f">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1bitset.html">auto</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9def1cedb7034b01e6cffb68531adbd3" name="a9def1cedb7034b01e6cffb68531adbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9def1cedb7034b01e6cffb68531adbd3">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1bitset.html">auto</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dcf60de77d9b1ad3d568505f3916fe2" name="a5dcf60de77d9b1ad3d568505f3916fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcf60de77d9b1ad3d568505f3916fe2">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac615a5375ea02af1dee73be6ba9c605c" name="ac615a5375ea02af1dee73be6ba9c605c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac615a5375ea02af1dee73be6ba9c605c">&#9670;&#160;</a></span>unchecked_get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> I, typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> unchecked_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1variant.html">variant</a>&lt; Ts... &gt; <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1bitset.html">auto</a> <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa14cd5bdeb510c30773c0a14b86d5f8e" name="aa14cd5bdeb510c30773c0a14b86d5f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14cd5bdeb510c30773c0a14b86d5f8e">&#9670;&#160;</a></span>unexpected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">E</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unexpected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">E</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  unexpected&lt; <a class="el" href="structetl_1_1bitset.html">E</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c3106ad57aa7a55b245407cb2b9d552" name="a3c3106ad57aa7a55b245407cb2b9d552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3106ad57aa7a55b245407cb2b9d552">&#9670;&#160;</a></span>uninitialized_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> uninitialized_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe4820f5ffdced8fbb8775a604cbcbc7" name="abe4820f5ffdced8fbb8775a604cbcbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4820f5ffdced8fbb8775a604cbcbc7">&#9670;&#160;</a></span>uninitialized_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">ForwardIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> uninitialized_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">ForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="structetl_1_1bitset.html">const</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af092ebf515a399cf1685d91ba2dbb6f7" name="af092ebf515a399cf1685d91ba2dbb6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af092ebf515a399cf1685d91ba2dbb6f7">&#9670;&#160;</a></span>uninitialized_move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">InputIt</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> uninitialized_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">InputIt</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a></td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">NoThrowForwardIt</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb16b244632f4ab5f6fd117e5a75473e" name="abb16b244632f4ab5f6fd117e5a75473e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb16b244632f4ab5f6fd117e5a75473e">&#9670;&#160;</a></span>unreachable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> unreachable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structetl_1_1bitset.html">void</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08c2340a69881856d04c55c19bb5c291" name="a08c2340a69881856d04c55c19bb5c291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c2340a69881856d04c55c19bb5c291">&#9670;&#160;</a></span>vformat_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">OutputIt</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> vformat_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">OutputIt</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6f7f02db9e66eaec8dccdca2f4e98a2f">string_view</a></td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abd8c737296655b44480da4fb422add24">format_args</a></td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">OutputIt</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95b81f8645cb1474f15eb0afc8297a82" name="a95b81f8645cb1474f15eb0afc8297a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b81f8645cb1474f15eb0afc8297a82">&#9670;&#160;</a></span>wcscat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcscat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the wide string pointed to by src to the end of the wide string pointed to by dest. The wide character src[0] replaces the null terminator at the end of dest. The resulting wide string is null-terminated. </p>
<p>The behavior is undefined if the destination array is not large enough for the contents of both src and dest and the terminating null character. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="a48742a27f06adaa943c923168958fffd" name="a48742a27f06adaa943c923168958fffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48742a27f06adaa943c923168958fffd">&#9670;&#160;</a></span>wcschr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcschr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>* </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcschr">https://en.cppreference.com/w/cpp/string/wide/wcschr</a> </p>

</div>
</div>
<a id="afa8528d93a4e282441b93ef41355de51" name="afa8528d93a4e282441b93ef41355de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8528d93a4e282441b93ef41355de51">&#9670;&#160;</a></span>wcschr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcschr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcschr">https://en.cppreference.com/w/cpp/string/wide/wcschr</a> </p>

</div>
</div>
<a id="a394989e435a3d8820b9887b0cb6f32d0" name="a394989e435a3d8820b9887b0cb6f32d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394989e435a3d8820b9887b0cb6f32d0">&#9670;&#160;</a></span>wcscmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcscmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two null-terminated wide strings lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</p>
<p>The behavior is undefined if lhs or rhs are not pointers to null-terminated wide strings. </p>

</div>
</div>
<a id="a9c6e17a8ddf3c4fbe89a15f971083a96" name="a9c6e17a8ddf3c4fbe89a15f971083a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6e17a8ddf3c4fbe89a15f971083a96">&#9670;&#160;</a></span>wcscpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcscpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest. </p>
<p>The behavior is undefined if the dest array is not large enough. The behavior is undefined if the strings overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="aa32c98dda497088d03d293fe8e7898f3" name="aa32c98dda497088d03d293fe8e7898f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32c98dda497088d03d293fe8e7898f3">&#9670;&#160;</a></span>wcscspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcscspn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters not found in wide string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcscspn">https://en.cppreference.com/w/cpp/string/wide/wcscspn</a> </p>

</div>
</div>
<a id="ae76640f48ef8b4a03e9b81fd5ca4209a" name="ae76640f48ef8b4a03e9b81fd5ca4209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76640f48ef8b4a03e9b81fd5ca4209a">&#9670;&#160;</a></span>wcslen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcslen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of a wide string, that is the number of non-null wide characters that precede the terminating null wide character. </p>

</div>
</div>
<a id="af7f1acddf72fe1e8ca96d2ba2ce4728a" name="af7f1acddf72fe1e8ca96d2ba2ce4728a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f1acddf72fe1e8ca96d2ba2ce4728a">&#9670;&#160;</a></span>wcsncat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcsncat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends at most count wide characters from the wide string pointed to by src to the end of the character string pointed to by dest, stopping if the null terminator is copied. The wide character src[0] replaces the null terminator at the end of dest. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is count+1). </p>
<p>The destination byte string must have enough space for the contents of both dest and src plus the terminating null character, except that the size of src is limited to count. The behavior is undefined if the strings overlap. </p>

</div>
</div>
<a id="aeab6f756717b07001aa0cc5ed00d89dd" name="aeab6f756717b07001aa0cc5ed00d89dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab6f756717b07001aa0cc5ed00d89dd">&#9670;&#160;</a></span>wcsncmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcsncmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares at most count wide characters of two null-terminated wide strings. The comparison is done lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</p>
<p>The behavior is undefined if lhs or rhs are not pointers to null-terminated strings. </p>

</div>
</div>
<a id="a075bf5df5b479586668e8dfe6a56d0b7" name="a075bf5df5b479586668e8dfe6a56d0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075bf5df5b479586668e8dfe6a56d0b7">&#9670;&#160;</a></span>wcsncpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcsncpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a> <a class="el" href="structetl_1_1bitset.html">const</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies at most count characters of the wide string pointed to by src (including the terminating null wide character) to wide character array pointed to by dest. </p>
<p>If count is reached before the entire string src was copied, the resulting character array is not null-terminated. If, after copying the terminating null character from src, count is not reached, additional null characters are written to dest until the total of count characters have been written. If the strings overlap, the behavior is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="a1dcddbba9daed153f19e883e9aea6f8d" name="a1dcddbba9daed153f19e883e9aea6f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcddbba9daed153f19e883e9aea6f8d">&#9670;&#160;</a></span>wcspbrk() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcspbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="afa424e61dbe13ba0fa30a5c09f2045ac" name="afa424e61dbe13ba0fa30a5c09f2045ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa424e61dbe13ba0fa30a5c09f2045ac">&#9670;&#160;</a></span>wcspbrk() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcspbrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>breakset</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first character in wide string pointed to by dest, that is also in wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="abb75f8bb32c928b359607a41c9f634e5" name="abb75f8bb32c928b359607a41c9f634e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75f8bb32c928b359607a41c9f634e5">&#9670;&#160;</a></span>wcsrchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcsrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsrchr">https://en.cppreference.com/w/cpp/string/wide/wcsrchr</a> </p>

</div>
</div>
<a id="a5ef301df65d76aedef7c3211e00900a2" name="a5ef301df65d76aedef7c3211e00900a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef301df65d76aedef7c3211e00900a2">&#9670;&#160;</a></span>wcsrchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcsrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">int</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the last occurrence of the wide character ch in the wide string pointed to by str. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsrchr">https://en.cppreference.com/w/cpp/string/wide/wcsrchr</a> </p>

</div>
</div>
<a id="a62a3a2cd36229b80bef3fcc819e45291" name="a62a3a2cd36229b80bef3fcc819e45291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a3a2cd36229b80bef3fcc819e45291">&#9670;&#160;</a></span>wcsspn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcsspn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;) -&gt; <a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the maximum initial segment of the wide string pointed to by dest, that consists of only the characters found in wide string pointed to by src. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcsspn">https://en.cppreference.com/w/cpp/string/wide/wcsspn</a> </p>

</div>
</div>
<a id="a74d69c1152ef7e628b1691179fc6f530" name="a74d69c1152ef7e628b1691179fc6f530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d69c1152ef7e628b1691179fc6f530">&#9670;&#160;</a></span>wcsstr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcsstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="ad67cab31ecf7c17b7ea41fbc4c1d0bd5" name="ad67cab31ecf7c17b7ea41fbc4c1d0bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67cab31ecf7c17b7ea41fbc4c1d0bd5">&#9670;&#160;</a></span>wcsstr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wcsstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first occurrence of the wide string needle in the wide string pointed to by haystack. The terminating null characters are not compared. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wcspbrk">https://en.cppreference.com/w/cpp/string/wide/wcspbrk</a> </p>

</div>
</div>
<a id="a5175847a36c688adb123a34e9780ab25" name="a5175847a36c688adb123a34e9780ab25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5175847a36c688adb123a34e9780ab25">&#9670;&#160;</a></span>wmemchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wmemchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr. </p>
<p>If count is zero, the function returns a null pointer.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemchr">https://en.cppreference.com/w/cpp/string/wide/wmemchr</a> </p>

</div>
</div>
<a id="a65747ecf11dff5d8f3be4a0f7793ca69" name="a65747ecf11dff5d8f3be4a0f7793ca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65747ecf11dff5d8f3be4a0f7793ca69">&#9670;&#160;</a></span>wmemchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wmemchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locates the first occurrence of wide character ch in the initial count wide characters of the wide character array pointed to by ptr. </p>
<p>If count is zero, the function returns a null pointer.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemchr">https://en.cppreference.com/w/cpp/string/wide/wmemchr</a> </p>

</div>
</div>
<a id="af171fdc02565644fe46f805df68af177" name="af171fdc02565644fe46f805df68af177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af171fdc02565644fe46f805df68af177">&#9670;&#160;</a></span>wmemcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wmemcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">int</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first count wide characters of the wide character arrays pointed to by lhs and rhs. The comparison is done lexicographically. </p>
<p>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared. If count is zero, the function does nothing.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemcmp">https://en.cppreference.com/w/cpp/string/wide/wmemcmp</a> </p>

</div>
</div>
<a id="af2ebfa659c54260fe5e6e06ee48a906b" name="af2ebfa659c54260fe5e6e06ee48a906b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ebfa659c54260fe5e6e06ee48a906b">&#9670;&#160;</a></span>wmemcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wmemcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. If the objects overlap, the behavior is undefined. If count is zero, the function does nothing. </p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemcpy">https://en.cppreference.com/w/cpp/string/wide/wmemcpy</a> </p>

</div>
</div>
<a id="a72695f43a1b04ada99db35bf2396de5a" name="a72695f43a1b04ada99db35bf2396de5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72695f43a1b04ada99db35bf2396de5a">&#9670;&#160;</a></span>wmemmove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wmemmove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> <a class="el" href="structetl_1_1bitset.html">const</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies exactly count successive wide characters from the wide character array pointed to by src to the wide character array pointed to by dest. </p>
<p>If count is zero, the function does nothing. The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to dest. This function is not locale-sensitive and pays no attention to the values of the wchar_t objects it copies: nulls as well as invalid characters are copied too.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemmove">https://en.cppreference.com/w/cpp/string/wide/wmemmove</a> </p>

</div>
</div>
<a id="a181b3459989bb776b4fde2be3f0ff339" name="a181b3459989bb776b4fde2be3f0ff339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181b3459989bb776b4fde2be3f0ff339">&#9670;&#160;</a></span>wmemset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> wmemset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1bitset.html">wchar_t</a></td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aee50235c04ef643cb7502785393220fe">etl::size_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) -&gt; <a class="el" href="structetl_1_1bitset.html">wchar_t</a>*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the wide character ch into each of the first count wide characters of the wide character array pointed to by dest. </p>
<p>If overflow occurs, the behavior is undefined. If count is zero, the function does nothing.</p>
<p><a href="https://en.cppreference.com/w/cpp/string/wide/wmemset">https://en.cppreference.com/w/cpp/string/wide/wmemset</a> </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae7fde4c1b709be147fc5d8f4efc0c605" name="ae7fde4c1b709be147fc5d8f4efc0c605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fde4c1b709be147fc5d8f4efc0c605">&#9670;&#160;</a></span>alignment_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> alignment_of_v = <a class="el" href="structetl_1_1alignment__of.html">alignment_of</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1903f5208bf0e496f112e85dd1915de8" name="a1903f5208bf0e496f112e85dd1915de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1903f5208bf0e496f112e85dd1915de8">&#9670;&#160;</a></span>allocator_arg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1allocator__arg__t.html">allocator_arg_t</a> allocator_arg {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocator_arg is a constant of type <a class="el" href="structetl_1_1allocator__arg__t.html" title="allocator_arg_t is an empty class type used to disambiguate the overloads of constructors and member ...">allocator_arg_t</a> used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects. </p>

</div>
</div>
<a id="a92b52772010dec87f8867320a8b03dfc" name="a92b52772010dec87f8867320a8b03dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b52772010dec87f8867320a8b03dfc">&#9670;&#160;</a></span>always_false</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> always_false = <a class="el" href="structetl_1_1bitset.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb794742f9815f88d6c2291181dc2501" name="abb794742f9815f88d6c2291181dc2501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb794742f9815f88d6c2291181dc2501">&#9670;&#160;</a></span>binary</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> binary = <a class="el" href="structetl_1_1binary__t.html">binary_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae88c83d30ae1d2a54dd8438da2038aab" name="ae88c83d30ae1d2a54dd8438da2038aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88c83d30ae1d2a54dd8438da2038aab">&#9670;&#160;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">enum</a> <a class="el" href="attributes_8hpp.html#a6cf990edeb7f9f6f1b5928471cef5e56">TETL_MAY_ALIAS</a> byte</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#ae88c83d30ae1d2a54dd8438da2038aab" title="etl::byte is a distinct type that implements the concept of byte as specified in the C++ language def...">etl::byte</a> is a distinct type that implements the concept of byte as specified in the C++ language definition. </p>
<p>Like char and unsigned char, it can be used to access raw memory occupied by other objects, but unlike those types, it is not a character type and is not an arithmetic type. A byte is only a collection of bits, and the only operators defined for it are the bitwise ones.</p>
<p><a href="https://en.cppreference.com/w/cpp/types/byte">https://en.cppreference.com/w/cpp/types/byte</a> </p>

</div>
</div>
<a id="a5672914b2f1f9c1c4c50ded53a8db2e3" name="a5672914b2f1f9c1c4c50ded53a8db2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5672914b2f1f9c1c4c50ded53a8db2e3">&#9670;&#160;</a></span>conjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> conjunction_v = <a class="el" href="structetl_1_1conjunction.html">conjunction</a>&lt;B...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9683edd538ff0cc668fb5a823604223" name="ac9683edd538ff0cc668fb5a823604223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9683edd538ff0cc668fb5a823604223">&#9670;&#160;</a></span>current_implementation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> current_implementation = <a class="el" href="#a6a5c92ae723acdba8ce0f48be8530154aed920a9dd5bae2e1c4f11aab8f5784e1">implementation::freestanding</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a32ab1ee4dc1bf7a3e86e713a4d6cbf" name="a6a32ab1ee4dc1bf7a3e86e713a4d6cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a32ab1ee4dc1bf7a3e86e713a4d6cbf">&#9670;&#160;</a></span>current_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> current_standard = <a class="el" href="#a72411d869deb28d3d6a0f7d0d77dd1deaf94629088b2e56f93753526b629a62ff">language_standard::cpp_26</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently configured C++ standard. </p>

</div>
</div>
<a id="ac49e3304c1cd20a376c9bd1758dd13bd" name="ac49e3304c1cd20a376c9bd1758dd13bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49e3304c1cd20a376c9bd1758dd13bd">&#9670;&#160;</a></span>destroying_delete</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> destroying_delete = <a class="el" href="structetl_1_1destroying__delete__t.html">destroying_delete_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag type used to identify the destroying delete form of operator delete. </p>

</div>
</div>
<a id="abb3abcd15bf9ea4a0629b7e03498e1e1" name="abb3abcd15bf9ea4a0629b7e03498e1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3abcd15bf9ea4a0629b7e03498e1e1">&#9670;&#160;</a></span>disjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> disjunction_v = <a class="el" href="structetl_1_1disjunction.html">disjunction</a>&lt;B...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06332dc22e85765f2c195c703cc49068" name="a06332dc22e85765f2c195c703cc49068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06332dc22e85765f2c195c703cc49068">&#9670;&#160;</a></span>extent_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">unsigned</a> N = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> extent_v = <a class="el" href="structetl_1_1bitset.html">static_cast</a>&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a>&gt;(<a class="el" href="structetl_1_1extent.html">extent</a>&lt;T, <a class="el" href="structetl_1_1bitset.html">N</a>&gt;::value)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a968338cd15fb1036406d2b3c8cb5b591" name="a968338cd15fb1036406d2b3c8cb5b591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968338cd15fb1036406d2b3c8cb5b591">&#9670;&#160;</a></span>hardware_constructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> hardware_constructive_interference_size = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum offset between two objects to avoid false sharing. Guaranteed to be at least alignof(max_align_t). </p>

</div>
</div>
<a id="acf9464e19a95c1baba9554e5ae2c2af6" name="acf9464e19a95c1baba9554e5ae2c2af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9464e19a95c1baba9554e5ae2c2af6">&#9670;&#160;</a></span>hardware_destructive_interference_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> hardware_destructive_interference_size = <a class="el" href="hardware__interference__size_8hpp.html#aa953892fe644febd033c1e533d29ac47">TETL_CACHELINE_SIZE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least alignof(max_align_t). </p>

</div>
</div>
<a id="a4c5a77036b20d94554de76a0879573e1" name="a4c5a77036b20d94554de76a0879573e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5a77036b20d94554de76a0879573e1">&#9670;&#160;</a></span>has_unique_object_representations_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> has_unique_object_representations_v = <a class="el" href="structetl_1_1has__unique__object__representations.html">has_unique_object_representations</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5895291aecd11c1e854ea1cdaac5d7c9" name="a5895291aecd11c1e854ea1cdaac5d7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5895291aecd11c1e854ea1cdaac5d7c9">&#9670;&#160;</a></span>ignore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">struct</a> etl::ignore ignore</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36d83619b037b662e5e0443f9d22fe3a" name="a36d83619b037b662e5e0443f9d22fe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d83619b037b662e5e0443f9d22fe3a">&#9670;&#160;</a></span>index_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> index_v = <a class="el" href="#a0fc29a848c78949599ea12f9b9827fd3">index_constant</a>&lt;<a class="el" href="structetl_1_1bitset.html">I</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10afef86eafa806bb7142657cfa37f79" name="a10afef86eafa806bb7142657cfa37f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10afef86eafa806bb7142657cfa37f79">&#9670;&#160;</a></span>is_abstract_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_abstract_v = <a class="el" href="structetl_1_1bitset.html">__is_abstract</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb0e64aa57f60e45754ac20ba126bbe3" name="adb0e64aa57f60e45754ac20ba126bbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0e64aa57f60e45754ac20ba126bbe3">&#9670;&#160;</a></span>is_aggregate_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_aggregate_v = <a class="el" href="structetl_1_1bitset.html">__is_aggregate</a>(<a class="el" href="#a57d58de8ee9130049557265efc11802c">remove_cv_t</a>&lt;T&gt;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf2224be65b8fb8794372d049a1d37d9" name="abf2224be65b8fb8794372d049a1d37d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2224be65b8fb8794372d049a1d37d9">&#9670;&#160;</a></span>is_arithmetic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_arithmetic_v = <a class="el" href="#a396e4b8c756441b942c1619de108e56a">is_integral_v</a>&lt;T&gt; <a class="el" href="structetl_1_1bitset.html">or</a> <a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b0e44222b6a1dc103286f3c5225ad93" name="a8b0e44222b6a1dc103286f3c5225ad93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0e44222b6a1dc103286f3c5225ad93">&#9670;&#160;</a></span>is_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_array_v = <a class="el" href="structetl_1_1is__array.html">is_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a762a8e8750c01c04403086076b7bab1e" name="a762a8e8750c01c04403086076b7bab1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762a8e8750c01c04403086076b7bab1e">&#9670;&#160;</a></span>is_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_assignable_v = <a class="el" href="structetl_1_1bitset.html">__is_assignable</a>(T, U)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a096bf5b121d9f427c8027f2949e8198e" name="a096bf5b121d9f427c8027f2949e8198e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096bf5b121d9f427c8027f2949e8198e">&#9670;&#160;</a></span>is_base_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Base</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Derived</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_base_of_v = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;<a class="el" href="structetl_1_1bitset.html">Base</a>, <a class="el" href="structetl_1_1bitset.html">Derived</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6cb779fe6050798f469e14a06f4412e" name="ad6cb779fe6050798f469e14a06f4412e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cb779fe6050798f469e14a06f4412e">&#9670;&#160;</a></span>is_bitmask_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_bitmask_type_v = <a class="el" href="structetl_1_1is__bitmask__type.html">is_bitmask_type</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a699f9a94f5d0c71c5e85e84f7baeb4" name="a7a699f9a94f5d0c71c5e85e84f7baeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a699f9a94f5d0c71c5e85e84f7baeb4">&#9670;&#160;</a></span>is_bounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_bounded_array_v = <a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca38abc104326427a46bccfd27cbfe28" name="aca38abc104326427a46bccfd27cbfe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca38abc104326427a46bccfd27cbfe28">&#9670;&#160;</a></span>is_class_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_class_v = <a class="el" href="structetl_1_1bitset.html">__is_class</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad2d62ca306fe828c5b72d7ebd4bf357" name="aad2d62ca306fe828c5b72d7ebd4bf357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2d62ca306fe828c5b72d7ebd4bf357">&#9670;&#160;</a></span>is_compound_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_compound_v = <a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="#aec01da22051322819e36fdfa6c5514a5">is_fundamental_v</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bf567b7866a96e4005d64743e0859b0" name="a0bf567b7866a96e4005d64743e0859b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf567b7866a96e4005d64743e0859b0">&#9670;&#160;</a></span>is_const_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_const_v = <a class="el" href="structetl_1_1is__const.html">is_const</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="utility_8cpp-example.html#a3">utility.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a123009e89543c37bab698abc5f4221a0" name="a123009e89543c37bab698abc5f4221a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123009e89543c37bab698abc5f4221a0">&#9670;&#160;</a></span>is_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_constructible_v = <a class="el" href="#aef5e3d94685880c2a0635ecd8f07b27f">is_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf5e75c4b12aa7982c5a97a14510ab35" name="adf5e75c4b12aa7982c5a97a14510ab35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5e75c4b12aa7982c5a97a14510ab35">&#9670;&#160;</a></span>is_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">From</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">To</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_convertible_v = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;<a class="el" href="structetl_1_1bitset.html">From</a>, <a class="el" href="structetl_1_1bitset.html">To</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe8a0fd8e07b2a2b0d62816c2958722a" name="afe8a0fd8e07b2a2b0d62816c2958722a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8a0fd8e07b2a2b0d62816c2958722a">&#9670;&#160;</a></span>is_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_copy_assignable_v = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f5da2852be4424089f4235ef44dec2" name="a03f5da2852be4424089f4235ef44dec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f5da2852be4424089f4235ef44dec2">&#9670;&#160;</a></span>is_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_copy_constructible_v = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1a93c5d7a09590573ceccfb239a590" name="a5d1a93c5d7a09590573ceccfb239a590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1a93c5d7a09590573ceccfb239a590">&#9670;&#160;</a></span>is_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_default_constructible_v = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9b3cd3fa2118be96d3b81105df490f8" name="ad9b3cd3fa2118be96d3b81105df490f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b3cd3fa2118be96d3b81105df490f8">&#9670;&#160;</a></span>is_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_destructible_v = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91bd4405b77f18a1a21a5b886c3e335d" name="a91bd4405b77f18a1a21a5b886c3e335d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bd4405b77f18a1a21a5b886c3e335d">&#9670;&#160;</a></span>is_empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_empty_v = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b43ce4d692cabf9e9e569bc813f910e" name="a4b43ce4d692cabf9e9e569bc813f910e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b43ce4d692cabf9e9e569bc813f910e">&#9670;&#160;</a></span>is_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_enum_v = <a class="el" href="structetl_1_1bitset.html">__is_enum</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98c97574ef59ab15ea9cff1856487d66" name="a98c97574ef59ab15ea9cff1856487d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c97574ef59ab15ea9cff1856487d66">&#9670;&#160;</a></span>is_final_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_final_v = <a class="el" href="structetl_1_1bitset.html">__is_final</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a70da46bf8635132fd3757deb2fff94" name="a8a70da46bf8635132fd3757deb2fff94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a70da46bf8635132fd3757deb2fff94">&#9670;&#160;</a></span>is_floating_point_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_floating_point_v = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abffc77cc5069dfe2c648737671e340d9" name="abffc77cc5069dfe2c648737671e340d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffc77cc5069dfe2c648737671e340d9">&#9670;&#160;</a></span>is_function_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_function_v = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether T is a function type. Types like <a class="el" href="structetl_1_1inplace__function.html">etl::inplace_function</a>, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false. </p>
<p>The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__function.html">is_function</a> or is_function_v is undefined. </p>

</div>
</div>
<a id="aec01da22051322819e36fdfa6c5514a5" name="aec01da22051322819e36fdfa6c5514a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec01da22051322819e36fdfa6c5514a5">&#9670;&#160;</a></span>is_fundamental_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_fundamental_v = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8014fcd9664b5608f77c514246ceafa8" name="a8014fcd9664b5608f77c514246ceafa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8014fcd9664b5608f77c514246ceafa8">&#9670;&#160;</a></span>is_implicit_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_implicit_default_constructible_v = <a class="el" href="structetl_1_1is__implicit__default__constructible.html">is_implicit_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a396e4b8c756441b942c1619de108e56a" name="a396e4b8c756441b942c1619de108e56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396e4b8c756441b942c1619de108e56a">&#9670;&#160;</a></span>is_integral_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_integral_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= meta::contains_v&lt;remove_cv_t&lt;T&gt;,</div>
<div class="line">    meta::list&lt;</div>
<div class="line">        bool,</div>
<div class="line">        char,</div>
<div class="line">        <span class="keywordtype">signed</span> char,</div>
<div class="line">        <span class="keywordtype">unsigned</span> char,</div>
<div class="line">        wchar_t,</div>
<div class="line">        char8_t,</div>
<div class="line">        char16_t,</div>
<div class="line">        char32_t,</div>
<div class="line">        short,</div>
<div class="line">        <span class="keywordtype">unsigned</span> short,</div>
<div class="line">        int,</div>
<div class="line">        <span class="keywordtype">unsigned</span> int,</div>
<div class="line">        long,</div>
<div class="line">        <span class="keywordtype">unsigned</span> long,</div>
<div class="line">        <span class="keywordtype">long</span> long,</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span></div>
<div class="line">    &gt;</div>
<div class="line">&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a79bb140a0b590bb8a6eadea52d880d17" name="a79bb140a0b590bb8a6eadea52d880d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bb140a0b590bb8a6eadea52d880d17">&#9670;&#160;</a></span>is_invocable_r_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">R</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Fn</a> , typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_invocable_r_v = <a class="el" href="structetl_1_1is__invocable__r.html">is_invocable_r</a>&lt;<a class="el" href="structetl_1_1bitset.html">R</a>, <a class="el" href="structetl_1_1bitset.html">Fn</a>, ArgTypes...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65073ba479a098a622312ecaaa89fa64" name="a65073ba479a098a622312ecaaa89fa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65073ba479a098a622312ecaaa89fa64">&#9670;&#160;</a></span>is_invocable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Fn</a> , typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_invocable_v = <a class="el" href="structetl_1_1is__invocable.html">is_invocable</a>&lt;<a class="el" href="structetl_1_1bitset.html">Fn</a>, ArgTypes...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a3172a26a55cf95dbe3c85e6611ebc0" name="a0a3172a26a55cf95dbe3c85e6611ebc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3172a26a55cf95dbe3c85e6611ebc0">&#9670;&#160;</a></span>is_lvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_lvalue_reference_v = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a241c086fc3e628de919419dd7772e345" name="a241c086fc3e628de919419dd7772e345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241c086fc3e628de919419dd7772e345">&#9670;&#160;</a></span>is_member_function_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_member_function_pointer_v = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a868fe6017d6496b38fe1f2a58a879f14" name="a868fe6017d6496b38fe1f2a58a879f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868fe6017d6496b38fe1f2a58a879f14">&#9670;&#160;</a></span>is_member_object_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_member_object_pointer_v = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f351ba579310d9228dc77b84bdf10b6" name="a8f351ba579310d9228dc77b84bdf10b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f351ba579310d9228dc77b84bdf10b6">&#9670;&#160;</a></span>is_member_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_member_pointer_v = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf52ca54b0d508bfc6b9bbe916faf18" name="afbf52ca54b0d508bfc6b9bbe916faf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf52ca54b0d508bfc6b9bbe916faf18">&#9670;&#160;</a></span>is_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_move_assignable_v = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5181d927278f40a6a97e90944d673c0a" name="a5181d927278f40a6a97e90944d673c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5181d927278f40a6a97e90944d673c0a">&#9670;&#160;</a></span>is_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_move_constructible_v = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0c249b3afd84019ec11170a1e06d267" name="ac0c249b3afd84019ec11170a1e06d267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c249b3afd84019ec11170a1e06d267">&#9670;&#160;</a></span>is_nothrow_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_assignable_v = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00c953e4e3f962b130f431bc25d6101" name="ac00c953e4e3f962b130f431bc25d6101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00c953e4e3f962b130f431bc25d6101">&#9670;&#160;</a></span>is_nothrow_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_constructible_v = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af70f6258c3e925eeb2d27b652374660d" name="af70f6258c3e925eeb2d27b652374660d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70f6258c3e925eeb2d27b652374660d">&#9670;&#160;</a></span>is_nothrow_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">From</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">To</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_convertible_v = <a class="el" href="structetl_1_1is__nothrow__convertible.html">is_nothrow_convertible</a>&lt;<a class="el" href="structetl_1_1bitset.html">From</a>, <a class="el" href="structetl_1_1bitset.html">To</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3322351bf5068346b84b6b19717f525c" name="a3322351bf5068346b84b6b19717f525c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3322351bf5068346b84b6b19717f525c">&#9670;&#160;</a></span>is_nothrow_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_copy_assignable_v = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a08255d43824dc23e14e09d4f9a3d22" name="a1a08255d43824dc23e14e09d4f9a3d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a08255d43824dc23e14e09d4f9a3d22">&#9670;&#160;</a></span>is_nothrow_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_copy_constructible_v = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d84124b3f5c4c4fab97253443d07a56" name="a2d84124b3f5c4c4fab97253443d07a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d84124b3f5c4c4fab97253443d07a56">&#9670;&#160;</a></span>is_nothrow_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_default_constructible_v = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf6b378d80292ae38acd1f467e10dd49" name="adf6b378d80292ae38acd1f467e10dd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6b378d80292ae38acd1f467e10dd49">&#9670;&#160;</a></span>is_nothrow_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_destructible_v = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad26f59ba1b8a873f9d8374f72a4002c4" name="ad26f59ba1b8a873f9d8374f72a4002c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26f59ba1b8a873f9d8374f72a4002c4">&#9670;&#160;</a></span>is_nothrow_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_move_assignable_v = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34e3584e54b63fd9e6a35fffd41080bd" name="a34e3584e54b63fd9e6a35fffd41080bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e3584e54b63fd9e6a35fffd41080bd">&#9670;&#160;</a></span>is_nothrow_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_move_constructible_v = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af740a9b650d7a3063e9414c3c50ffdb5" name="af740a9b650d7a3063e9414c3c50ffdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af740a9b650d7a3063e9414c3c50ffdb5">&#9670;&#160;</a></span>is_nothrow_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_nothrow_swappable_v = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a284cbaff17633b620e43bf4c4a5b9c66" name="a284cbaff17633b620e43bf4c4a5b9c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284cbaff17633b620e43bf4c4a5b9c66">&#9670;&#160;</a></span>is_null_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_null_pointer_v = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e0edf4d9cccfbffc3b8744b2c7bcfe9" name="a6e0edf4d9cccfbffc3b8744b2c7bcfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0edf4d9cccfbffc3b8744b2c7bcfe9">&#9670;&#160;</a></span>is_object_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_object_v = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6e287e878604ddef97548a69df3bb24" name="af6e287e878604ddef97548a69df3bb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e287e878604ddef97548a69df3bb24">&#9670;&#160;</a></span>is_placeholder_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">int</a> is_placeholder_v = <a class="el" href="structetl_1_1is__placeholder.html">is_placeholder</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d8a43ca3d5d473f1651ef5114c2628" name="a60d8a43ca3d5d473f1651ef5114c2628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d8a43ca3d5d473f1651ef5114c2628">&#9670;&#160;</a></span>is_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_pointer_v = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a143b8d7f44dff4fa25a08864799234" name="a7a143b8d7f44dff4fa25a08864799234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a143b8d7f44dff4fa25a08864799234">&#9670;&#160;</a></span>is_polymorphic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_polymorphic_v = <a class="el" href="structetl_1_1bitset.html">__is_polymorphic</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8301cd1745fa1701a4f9d6045f15a2e0" name="a8301cd1745fa1701a4f9d6045f15a2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8301cd1745fa1701a4f9d6045f15a2e0">&#9670;&#160;</a></span>is_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_reference_v = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e51e4e96e7f9909244d577e730f80cf" name="a0e51e4e96e7f9909244d577e730f80cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e51e4e96e7f9909244d577e730f80cf">&#9670;&#160;</a></span>is_reference_wrapper_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_reference_wrapper_v = <a class="el" href="structetl_1_1is__reference__wrapper.html">is_reference_wrapper</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae76f1e4408116211d60d33934f2241ec" name="ae76f1e4408116211d60d33934f2241ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76f1e4408116211d60d33934f2241ec">&#9670;&#160;</a></span>is_rvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_rvalue_reference_v = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6c6bde5fd020a928e6d7b5fe8db7bb0" name="aa6c6bde5fd020a928e6d7b5fe8db7bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">&#9670;&#160;</a></span>is_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_same_v = <a class="el" href="structetl_1_1bitset.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd4cca5d1a81afdeb0354d88b58554a1" name="abd4cca5d1a81afdeb0354d88b58554a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4cca5d1a81afdeb0354d88b58554a1">&#9670;&#160;</a></span>is_same_v&lt; T, T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a>&lt; T, T &gt; = <a class="el" href="structetl_1_1bitset.html">true</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a030808462771bbdd627d73c92a98565f" name="a030808462771bbdd627d73c92a98565f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030808462771bbdd627d73c92a98565f">&#9670;&#160;</a></span>is_scalar_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_scalar_v = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78db0060aa04a75ce5b8a07e7ece59de" name="a78db0060aa04a75ce5b8a07e7ece59de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78db0060aa04a75ce5b8a07e7ece59de">&#9670;&#160;</a></span>is_scoped_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_scoped_enum_v = <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether T is an scoped enumeration type. Provides the member constant value which is equal to true, if T is an scoped enumeration type. Otherwise, value is equal to false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__scoped__enum.html">is_scoped_enum</a> or is_scoped_enum_v is undefined. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_scoped_enum">https://en.cppreference.com/w/cpp/types/is_scoped_enum</a> </p>

</div>
</div>
<a id="a05c78609bb9e06b42e0a4c0c4409b0a1" name="a05c78609bb9e06b42e0a4c0c4409b0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c78609bb9e06b42e0a4c0c4409b0a1">&#9670;&#160;</a></span>is_signed_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_signed_v = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28194dad7a848538b478ff8c18abafed" name="a28194dad7a848538b478ff8c18abafed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28194dad7a848538b478ff8c18abafed">&#9670;&#160;</a></span>is_specialized_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">template</a>&lt; typename... &gt; <a class="el" href="structetl_1_1bitset.html">typename</a> Template, <a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Tag</a>  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_specialized_v = <a class="el" href="structetl_1_1is__specialized.html">is_specialized</a>&lt;<a class="el" href="structetl_1_1bitset.html">Template</a>, T, <a class="el" href="structetl_1_1bitset.html">Tag</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87eee4459ff69343253626fdfad870b1" name="a87eee4459ff69343253626fdfad870b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87eee4459ff69343253626fdfad870b1">&#9670;&#160;</a></span>is_standard_layout_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_standard_layout_v = <a class="el" href="structetl_1_1is__standard__layout.html">is_standard_layout</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a08681ad0c17b00662bfd185a081335" name="a6a08681ad0c17b00662bfd185a081335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a08681ad0c17b00662bfd185a081335">&#9670;&#160;</a></span>is_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_swappable_v = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1c3e504b08a7a017cf1fafdf4435eff" name="ac1c3e504b08a7a017cf1fafdf4435eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c3e504b08a7a017cf1fafdf4435eff">&#9670;&#160;</a></span>is_swappable_with_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_swappable_with_v = <a class="el" href="structetl_1_1is__swappable__with.html">is_swappable_with</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a328d1a7de791585957bddf38501d3965" name="a328d1a7de791585957bddf38501d3965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328d1a7de791585957bddf38501d3965">&#9670;&#160;</a></span>is_trivial_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivial_v = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e5575d88dd9e2ccdec94f3e0221bd93" name="a3e5575d88dd9e2ccdec94f3e0221bd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5575d88dd9e2ccdec94f3e0221bd93">&#9670;&#160;</a></span>is_trivially_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , <a class="el" href="structetl_1_1bitset.html">typename</a> U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivially_assignable_v = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a396c0b78998702552df9f3f40bc88982" name="a396c0b78998702552df9f3f40bc88982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396c0b78998702552df9f3f40bc88982">&#9670;&#160;</a></span>is_trivially_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivially_constructible_v = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57b0a04cc2a51f7a14f9c7a02c44aecc" name="a57b0a04cc2a51f7a14f9c7a02c44aecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b0a04cc2a51f7a14f9c7a02c44aecc">&#9670;&#160;</a></span>is_trivially_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivially_copy_assignable_v = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa380d2993e2d74ca6ec925404947169c" name="aa380d2993e2d74ca6ec925404947169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa380d2993e2d74ca6ec925404947169c">&#9670;&#160;</a></span>is_trivially_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivially_copy_constructible_v = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af94b442e8b9fb5a0de351b1b84d6f703" name="af94b442e8b9fb5a0de351b1b84d6f703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94b442e8b9fb5a0de351b1b84d6f703">&#9670;&#160;</a></span>is_trivially_copyable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivially_copyable_v = <a class="el" href="structetl_1_1bitset.html">__is_trivially_copyable</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadf6d7f246062eff8288873db7382e49" name="aadf6d7f246062eff8288873db7382e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf6d7f246062eff8288873db7382e49">&#9670;&#160;</a></span>is_trivially_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivially_default_constructible_v = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63c5a91c590beb77cbc056cb9327956f" name="a63c5a91c590beb77cbc056cb9327956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c5a91c590beb77cbc056cb9327956f">&#9670;&#160;</a></span>is_trivially_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivially_destructible_v = <a class="el" href="structetl_1_1bitset.html">__has_trivial_destructor</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57849835554ed7e24b739e5ad635cc5d" name="a57849835554ed7e24b739e5ad635cc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57849835554ed7e24b739e5ad635cc5d">&#9670;&#160;</a></span>is_trivially_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_trivially_move_assignable_v = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7d1caff81b5bd6a9266da221ee4a2f5" name="aa7d1caff81b5bd6a9266da221ee4a2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d1caff81b5bd6a9266da221ee4a2f5">&#9670;&#160;</a></span>is_trivially_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_trivially_move_constructible_v = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ad99d6adeb2c1d8530bf9204f34aab4" name="a5ad99d6adeb2c1d8530bf9204f34aab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad99d6adeb2c1d8530bf9204f34aab4">&#9670;&#160;</a></span>is_tuple_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> is_tuple_like&lt; <a class="el" href="structetl_1_1tuple.html">etl::tuple</a>&lt; Ts... &gt; &gt; = <a class="el" href="structetl_1_1bitset.html">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a687f368c330615460df7f61947e88279" name="a687f368c330615460df7f61947e88279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687f368c330615460df7f61947e88279">&#9670;&#160;</a></span>is_unbounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_unbounded_array_v = <a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39d7414e06afd624ccd66acee3873b11" name="a39d7414e06afd624ccd66acee3873b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d7414e06afd624ccd66acee3873b11">&#9670;&#160;</a></span>is_union_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_union_v = <a class="el" href="structetl_1_1bitset.html">__is_union</a>(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac22b0b8d8faeebf7b2eb8d80ccdb03ba" name="ac22b0b8d8faeebf7b2eb8d80ccdb03ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22b0b8d8faeebf7b2eb8d80ccdb03ba">&#9670;&#160;</a></span>is_unsigned_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_unsigned_v = <a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4414ccc8655262f0522dc640003d64b7" name="a4414ccc8655262f0522dc640003d64b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4414ccc8655262f0522dc640003d64b7">&#9670;&#160;</a></span>is_void_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_void_v = <a class="el" href="#aa6c6bde5fd020a928e6d7b5fe8db7bb0">is_same_v</a>&lt;<a class="el" href="structetl_1_1bitset.html">void</a>, <a class="el" href="#a57d58de8ee9130049557265efc11802c">remove_cv_t</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3fd8976091aa72c12d7a7e5ee986400" name="af3fd8976091aa72c12d7a7e5ee986400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fd8976091aa72c12d7a7e5ee986400">&#9670;&#160;</a></span>is_volatile_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> is_volatile_v = <a class="el" href="structetl_1_1is__volatile.html">is_volatile</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bef7b75bd1375e11a158bc94cbc4fa3" name="a3bef7b75bd1375e11a158bc94cbc4fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bef7b75bd1375e11a158bc94cbc4fa3">&#9670;&#160;</a></span>negation_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">B</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">bool</a> negation_v = <a class="el" href="structetl_1_1bitset.html">not</a> <a class="el" href="structetl_1_1bitset.html">static_cast</a>&lt;<a class="el" href="structetl_1_1bitset.html">bool</a>&gt;(B::value)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb090c3e2bd7b58f70ddb151d426d84c" name="afb090c3e2bd7b58f70ddb151d426d84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb090c3e2bd7b58f70ddb151d426d84c">&#9670;&#160;</a></span>nontype</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">auto</a> V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> nontype = <a class="el" href="structetl_1_1nontype__t.html">etl::nontype_t</a>&lt;<a class="el" href="structetl_1_1bitset.html">V</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9706e5f8dbc47772797c3f13cfd73517" name="a9706e5f8dbc47772797c3f13cfd73517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9706e5f8dbc47772797c3f13cfd73517">&#9670;&#160;</a></span>nothrow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> nothrow = <a class="el" href="structetl_1_1nothrow__t.html">etl::nothrow_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="#a9706e5f8dbc47772797c3f13cfd73517" title="etl::nothrow is a constant of type etl::nothrow_t used to disambiguate the overloads of throwing and ...">etl::nothrow</a> is a constant of type <a class="el" href="structetl_1_1nothrow__t.html" title="etl::nothrow_t is an empty class type used to disambiguate the overloads of throwing and non-throwing...">etl::nothrow_t</a> used to disambiguate the overloads of throwing and non-throwing allocation functions. </p>

</div>
</div>
<a id="a773a2a7547427bfc26b4ff3b8c2cebe3" name="a773a2a7547427bfc26b4ff3b8c2cebe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773a2a7547427bfc26b4ff3b8c2cebe3">&#9670;&#160;</a></span>piecewise_construct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> piecewise_construct = <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constant <a class="el" href="#a773a2a7547427bfc26b4ff3b8c2cebe3" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>. </p>

</div>
</div>
<a id="a3c66bceba9ac1596666a40596ddf9b62" name="a3c66bceba9ac1596666a40596ddf9b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c66bceba9ac1596666a40596ddf9b62">&#9670;&#160;</a></span>rank_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aee50235c04ef643cb7502785393220fe">size_t</a> rank_v = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;<a class="el" href="structetl_1_1bitset.html">Type</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba873a97be10ad8146b06a01a9694b9c" name="aba873a97be10ad8146b06a01a9694b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba873a97be10ad8146b06a01a9694b9c">&#9670;&#160;</a></span>sorted_unique</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> sorted_unique = <a class="el" href="structetl_1_1sorted__unique__t.html">sorted_unique_t</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bccb49e0b1f811bb51be4f782a5b6c6" name="a4bccb49e0b1f811bb51be4f782a5b6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bccb49e0b1f811bb51be4f782a5b6c6">&#9670;&#160;</a></span>tuple_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> tuple_size_v = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eb779f5e8046c7d141522c238bc2764" name="a2eb779f5e8046c7d141522c238bc2764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb779f5e8046c7d141522c238bc2764">&#9670;&#160;</a></span>uses_allocator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Type</a> , <a class="el" href="structetl_1_1bitset.html">typename</a> <a class="el" href="structetl_1_1bitset.html">Alloc</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> uses_allocator_v = <a class="el" href="structetl_1_1uses__allocator.html">uses_allocator</a>&lt;<a class="el" href="structetl_1_1bitset.html">Type</a>, <a class="el" href="structetl_1_1bitset.html">Alloc</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If T has a member typedef allocator_type which is convertible from Alloc, the member constant value is true. Otherwise value is false. </p>

</div>
</div>
<a id="a048867192f342c93436216b7b1ed601b" name="a048867192f342c93436216b7b1ed601b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048867192f342c93436216b7b1ed601b">&#9670;&#160;</a></span>variant_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structetl_1_1bitset.html">typename</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1bitset.html">auto</a> variant_size_v = <a class="el" href="structetl_1_1variant__size.html">variant_size</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li>
    <li class="footer">Generated on Wed Apr 10 2024 23:37:18 for tetl by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
